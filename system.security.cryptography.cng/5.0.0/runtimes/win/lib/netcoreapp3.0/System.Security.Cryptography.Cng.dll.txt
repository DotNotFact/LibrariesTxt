internal static class FxResources.System.Security.Cryptography.Cng.SR : object {
}
internal static class Internal.Cryptography.AesBCryptModes : object {
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCbc;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgEcb;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb128;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb8;
    private static AesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode, int feedback);
    internal static Lazy`1<SafeAlgorithmHandle> OpenAesAlgorithm(string cipherMode, int feedback);
}
internal abstract class Internal.Cryptography.BasicSymmetricCipher : object {
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaddingSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    public int BlockSizeInBytes { get; private set; }
    public int PaddingSizeInBytes { get; private set; }
    protected Byte[] IV { get; private set; }
    protected BasicSymmetricCipher(Byte[] iv, int blockSizeInBytes, int paddingSizeInBytes);
    public abstract virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public abstract virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    [CompilerGeneratedAttribute]
public int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_BlockSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PaddingSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_PaddingSizeInBytes(int value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
}
internal class Internal.Cryptography.BasicSymmetricCipherBCrypt : BasicSymmetricCipher {
    private bool _encrypting;
    private SafeKeyHandle _hKey;
    private Byte[] _currentIv;
    public BasicSymmetricCipherBCrypt(SafeAlgorithmHandle algorithm, CipherMode cipherMode, int blockSizeInBytes, int paddingSizeInBytes, Byte[] key, bool ownsParentHandle, Byte[] iv, bool encrypting);
    protected virtual void Dispose(bool disposing);
    public virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    private void Reset();
}
internal class Internal.Cryptography.BasicSymmetricCipherNCrypt : BasicSymmetricCipher {
    private CngKey _cngKey;
    private bool _encrypting;
    private static CngProperty s_ECBMode;
    private static CngProperty s_CBCMode;
    private static CngProperty s_CFBMode;
    public BasicSymmetricCipherNCrypt(Func`1<CngKey> cngKeyFactory, CipherMode cipherMode, int blockSizeInBytes, Byte[] iv, bool encrypting, int feedbackSizeInBytes, int paddingSize);
    private static BasicSymmetricCipherNCrypt();
    public sealed virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
}
internal class Internal.Cryptography.CngAlgorithmCore : ValueType {
    private string _disposedName;
    public CngAlgorithm DefaultKeyType;
    private CngKey _lazyKey;
    private bool _disposed;
    public CngAlgorithmCore(string disposedName);
    public static CngKey Duplicate(CngKey key);
    public bool IsKeyGeneratedNamedCurve();
    public void DisposeKey();
    public CngKey GetOrGenerateKey(int keySize, CngAlgorithm algorithm);
    public CngKey GetOrGenerateKey(Nullable`1<ECCurve> curve);
    public void SetKey(CngKey key);
    public void Dispose();
    internal void ThrowIfDisposed();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CngCommon : object {
    private static int StatusUnsuccessfulRetryCount;
    public static Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public static Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [ExtensionAttribute]
public static Byte[] SignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, int estimatedSize);
    [ExtensionAttribute]
public static bool TrySignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, Span`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, Int32& bytesWritten);
    [ExtensionAttribute]
public static bool VerifyHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo);
}
internal class Internal.Cryptography.CngSymmetricAlgorithmCore : ValueType {
    private ICngSymmetricAlgorithm _outer;
    private string _keyName;
    private CngProvider _provider;
    private CngKeyOpenOptions _optionOptions;
    private static int BitsPerByte;
    private bool KeyInPlainText { get; }
    public CngSymmetricAlgorithmCore(ICngSymmetricAlgorithm outer);
    public CngSymmetricAlgorithmCore(ICngSymmetricAlgorithm outer, string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public Byte[] GetKeyIfExportable();
    public void SetKey(Byte[] key);
    public void SetKeySize(int keySize, ICngSymmetricAlgorithm outer);
    public void GenerateKey();
    public void GenerateIV();
    public ICryptoTransform CreateEncryptor();
    public ICryptoTransform CreateDecryptor();
    public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    private ICryptoTransform CreateCryptoTransform(bool encrypting);
    private ICryptoTransform CreateCryptoTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private ICryptoTransform CreateEphemeralCryptoTransformCore(Byte[] key, Byte[] iv, bool encrypting);
    private ICryptoTransform CreatePersistedCryptoTransformCore(Func`1<CngKey> cngKeyFactory, Byte[] iv, bool encrypting);
    private CngKey ProduceCngKey();
    private bool get_KeyInPlainText();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.ErrorCodeHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(ErrorCode errorCode);
}
internal abstract class Internal.Cryptography.HashProvider : object {
    public int HashSizeInBytes { get; }
    public void AppendHashData(Byte[] data, int offset, int count);
    public abstract virtual void AppendHashData(ReadOnlySpan`1<byte> data);
    public abstract virtual int FinalizeHashAndReset(Span`1<byte> destination);
    public abstract virtual int GetCurrentHash(Span`1<byte> destination);
    public Byte[] FinalizeHashAndReset();
    public bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public abstract virtual int get_HashSizeInBytes();
    public sealed virtual void Dispose();
    public abstract virtual void Dispose(bool disposing);
}
internal class Internal.Cryptography.HashProviderCng : HashProvider {
    private SafeBCryptAlgorithmHandle _hAlgorithm;
    private SafeBCryptHashHandle _hHash;
    private Byte[] _key;
    private bool _reusable;
    private int _hashSize;
    public int HashSizeInBytes { get; }
    public HashProviderCng(string hashAlgId, Byte[] key);
    internal HashProviderCng(string hashAlgId, ReadOnlySpan`1<byte> key, bool isHmac);
    public sealed virtual void AppendHashData(ReadOnlySpan`1<byte> source);
    public virtual int FinalizeHashAndReset(Span`1<byte> destination);
    public virtual int GetCurrentHash(Span`1<byte> destination);
    public sealed virtual void Dispose(bool disposing);
    public sealed virtual int get_HashSizeInBytes();
    private void ResetHashObject();
    private void DestroyHash();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    [ExtensionAttribute]
public static Byte[] MapZeroLengthArrayToNonNullPointer(Byte[] src);
    [ExtensionAttribute]
public static SafeNCryptProviderHandle OpenStorageProvider(CngProvider provider);
    [ExtensionAttribute]
public static Byte[] GetProperty(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static string GetPropertyAsString(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static int GetPropertyAsDword(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static IntPtr GetPropertyAsIntPtr(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static void SetExportPolicy(SafeNCryptKeyHandle keyHandle, CngExportPolicies exportPolicy);
    [ExtensionAttribute]
public static int BitSizeToByteSize(int bits);
    public static Byte[] GenerateRandom(int count);
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static int GetPaddingSize(SymmetricAlgorithm algorithm);
    internal static bool TryCopyToDestination(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
}
internal interface Internal.Cryptography.ICngSymmetricAlgorithm {
    public int BlockSize { get; }
    public int FeedbackSize { get; }
    public CipherMode Mode { get; }
    public PaddingMode Padding { get; }
    public Byte[] IV { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public Byte[] BaseKey { get; public set; }
    public int BaseKeySize { get; public set; }
    public abstract virtual int get_BlockSize();
    public abstract virtual int get_FeedbackSize();
    public abstract virtual CipherMode get_Mode();
    public abstract virtual PaddingMode get_Padding();
    public abstract virtual Byte[] get_IV();
    public abstract virtual void set_IV(Byte[] value);
    public abstract virtual KeySizes[] get_LegalKeySizes();
    public abstract virtual Byte[] get_BaseKey();
    public abstract virtual void set_BaseKey(Byte[] value);
    public abstract virtual int get_BaseKeySize();
    public abstract virtual void set_BaseKeySize(int value);
    public abstract virtual bool IsWeakKey(Byte[] key);
    public abstract virtual SafeAlgorithmHandle GetEphemeralModeHandle();
    public abstract virtual string GetNCryptAlgorithmIdentifier();
    public abstract virtual Byte[] PreprocessKey(Byte[] key);
    public abstract virtual int GetPaddingSize();
}
internal static class Internal.Cryptography.KeyPropertyName : object {
    internal static string Algorithm;
    internal static string AlgorithmGroup;
    internal static string ECCCurveName;
    internal static string ECCParameters;
    internal static string ExportPolicy;
    internal static string KeyType;
    internal static string KeyUsage;
    internal static string Length;
    internal static string Name;
    internal static string ParentWindowHandle;
    internal static string PublicKeyLength;
    internal static string ProviderHandle;
    internal static string UIPolicy;
    internal static string UniqueName;
    internal static string UseContext;
    internal static string ClrIsEphemeral;
}
internal static class Internal.Cryptography.ProviderPropertyName : object {
    internal static string Name;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.SymmetricImportExportExtensions : object {
    private static int SizeOf_NCRYPT_KEY_BLOB_HEADER_SIZE;
    private static CngKeyBlobFormat s_cipherKeyBlobFormat;
    private static SymmetricImportExportExtensions();
    [ExtensionAttribute]
public static Byte[] GetSymmetricKeyDataIfExportable(CngKey cngKey, string algorithm);
}
internal static class Internal.Cryptography.TripleDesBCryptModes : object {
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCbc;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgEcb;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb8;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb64;
    private static TripleDesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode, int feedback);
    private static Lazy`1<SafeAlgorithmHandle> Open3DesAlgorithm(string cipherMode, int feedback);
}
internal class Internal.Cryptography.UniversalCryptoDecryptor : UniversalCryptoTransform {
    private Byte[] _heldoverCipher;
    private bool DepaddingRequired { get; }
    public UniversalCryptoDecryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
    private bool get_DepaddingRequired();
    private int GetPaddingLength(ReadOnlySpan`1<byte> block);
}
internal class Internal.Cryptography.UniversalCryptoEncryptor : UniversalCryptoTransform {
    public UniversalCryptoEncryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private int GetCiphertextLength(int plaintextLength);
    private int PadBlock(ReadOnlySpan`1<byte> block, Span`1<byte> destination);
}
internal abstract class Internal.Cryptography.UniversalCryptoTransform : object {
    [CompilerGeneratedAttribute]
private PaddingMode <PaddingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicSymmetricCipher <BasicSymmetricCipher>k__BackingField;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    protected int PaddingSizeBytes { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected PaddingMode PaddingMode { get; private set; }
    protected BasicSymmetricCipher BasicSymmetricCipher { get; private set; }
    protected UniversalCryptoTransform(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    public static ICryptoTransform Create(PaddingMode paddingMode, BasicSymmetricCipher cipher, bool encrypting);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    protected int get_PaddingSizeBytes();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual void Dispose();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual void Dispose(bool disposing);
    protected int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected abstract virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected abstract virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected abstract virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    [CompilerGeneratedAttribute]
protected PaddingMode get_PaddingMode();
    [CompilerGeneratedAttribute]
private void set_PaddingMode(PaddingMode value);
    [CompilerGeneratedAttribute]
protected BasicSymmetricCipher get_BasicSymmetricCipher();
    [CompilerGeneratedAttribute]
private void set_BasicSymmetricCipher(BasicSymmetricCipher value);
}
internal static class Internal.NativeCrypto.BCryptNative : object {
}
[ExtensionAttribute]
internal static class Internal.NativeCrypto.Cng : object {
    public static string BCRYPT_3DES_ALGORITHM;
    public static string BCRYPT_AES_ALGORITHM;
    public static string BCRYPT_DES_ALGORITHM;
    public static string BCRYPT_RC2_ALGORITHM;
    public static string BCRYPT_CHAIN_MODE_CBC;
    public static string BCRYPT_CHAIN_MODE_ECB;
    public static string BCRYPT_CHAIN_MODE_GCM;
    public static string BCRYPT_CHAIN_MODE_CFB;
    public static string BCRYPT_CHAIN_MODE_CCM;
    public static SafeAlgorithmHandle BCryptOpenAlgorithmProvider(string pszAlgId, string pszImplementation, OpenAlgorithmProviderFlags dwFlags);
    [ExtensionAttribute]
public static void SetFeedbackSize(SafeAlgorithmHandle hAlg, int dwFeedbackSize);
    [ExtensionAttribute]
public static void SetCipherMode(SafeAlgorithmHandle hAlg, string cipherMode);
    [ExtensionAttribute]
public static void SetEffectiveKeyLength(SafeAlgorithmHandle hAlg, int effectiveKeyLength);
    private static Exception CreateCryptographicException(NTSTATUS ntStatus);
}
internal class Internal.NativeCrypto.SafeAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int dwFlags);
}
internal class Internal.NativeCrypto.SafeKeyHandle : SafeBCryptHandle {
    private SafeAlgorithmHandle _parentHandle;
    public void SetParentHandle(SafeAlgorithmHandle parentHandle);
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptDestroyKey(IntPtr hKey);
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptHashHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private OwnershipState _ownershipState;
    private SafeNCryptHandle _holder;
    private SafeHandle _parentHandle;
    [NullableAttribute("2")]
private SafeNCryptHandle Holder { get; private set; }
    [NullableContextAttribute("1")]
protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle);
    private SafeNCryptHandle get_Holder();
    private void set_Holder(SafeNCryptHandle value);
    internal T Duplicate();
    private T DuplicateDuplicatedHandle();
    private T DuplicateOwnerHandle();
    protected virtual bool ReleaseHandle();
    protected abstract virtual bool ReleaseNativeHandle();
    internal bool ReleaseNativeWithNCryptFreeObject();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
    [NullableContextAttribute("1")]
public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle);
    internal SafeNCryptKeyHandle Duplicate();
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
    internal SafeNCryptProviderHandle Duplicate();
    internal void SetHandleValue(IntPtr newHandleValue);
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeUnicodeStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    public SafeUnicodeStringHandle(string s);
    public SafeUnicodeStringHandle(ReadOnlySpan`1<char> s);
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Formats.Asn1.AsnValueReader : ValueType {
    private static Byte[] s_singleByte;
    private ReadOnlySpan`1<byte> _span;
    private AsnEncodingRules _ruleSet;
    internal bool HasData { get; }
    internal AsnValueReader(ReadOnlySpan`1<byte> span, AsnEncodingRules ruleSet);
    private static AsnValueReader();
    internal bool get_HasData();
    internal void ThrowIfNotEmpty();
    internal Asn1Tag PeekTag();
    internal ReadOnlySpan`1<byte> PeekEncodedValue();
    internal ReadOnlySpan`1<byte> ReadEncodedValue();
    internal bool ReadBoolean(Nullable`1<Asn1Tag> expectedTag);
    internal BigInteger ReadInteger(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadInt32(Int32& value, Nullable`1<Asn1Tag> expectedTag);
    internal ReadOnlySpan`1<byte> ReadIntegerBytes(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveBitString(Int32& unusedBitCount, ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadBitString(Int32& unusedBitCount, Nullable`1<Asn1Tag> expectedTag);
    internal TFlagsEnum ReadNamedBitListValue(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveOctetString(ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadOctetString(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadObjectIdentifier(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSequence(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSetOf(Nullable`1<Asn1Tag> expectedTag);
    internal DateTimeOffset ReadUtcTime(Nullable`1<Asn1Tag> expectedTag);
    internal DateTimeOffset ReadGeneralizedTime(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadCharacterString(UniversalTagNumber encodingType, Nullable`1<Asn1Tag> expectedTag);
}
[ExtensionAttribute]
internal static class System.Formats.Asn1.AsnWriterExtensions : object {
    [ExtensionAttribute]
internal static void WriteEncodedValueForCrypto(AsnWriter writer, ReadOnlySpan`1<byte> value);
    [ExtensionAttribute]
internal static void WriteObjectIdentifierForCrypto(AsnWriter writer, string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    private protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[AttributeUsageAttribute("1023")]
internal class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    public SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("1")]
internal class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    public TargetPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("1023")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformAttribute(string platformName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AesCng : Aes {
    private CngSymmetricAlgorithmCore _core;
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    private Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.BaseKey { get; private set; }
    private int Internal.Cryptography.ICngSymmetricAlgorithm.BaseKeySize { get; private set; }
    public AesCng(string keyName);
    public AesCng(string keyName, CngProvider provider);
    public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKey();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKey(Byte[] value);
    private sealed virtual override int Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKeySize();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKeySize(int value);
    private sealed virtual override bool Internal.Cryptography.ICngSymmetricAlgorithm.IsWeakKey(Byte[] key);
    private sealed virtual override int Internal.Cryptography.ICngSymmetricAlgorithm.GetPaddingSize();
    private sealed virtual override SafeAlgorithmHandle Internal.Cryptography.ICngSymmetricAlgorithm.GetEphemeralModeHandle();
    private sealed virtual override string Internal.Cryptography.ICngSymmetricAlgorithm.GetNCryptAlgorithmIdentifier();
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.PreprocessKey(Byte[] key);
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal string Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AlgorithmIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AlgorithmIdentifierAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    internal bool Equals(AlgorithmIdentifierAsn& other);
    internal bool HasNullEquivalentParameters();
    internal static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Asn1.AttributeAsn : ValueType {
    internal string AttrType;
    internal ReadOnlyMemory`1[] AttrValues;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AttributeAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AttributeAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.CurveAsn : ValueType {
    internal ReadOnlyMemory`1<byte> A;
    internal ReadOnlyMemory`1<byte> B;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Seed;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CurveAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CurveAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.ECDomainParameters : ValueType {
    internal Nullable`1<SpecifiedECDomain> Specified;
    internal string Named;
    internal void Encode(AsnWriter writer);
    internal static ECDomainParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ECDomainParameters& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ECDomainParameters& decoded);
}
internal class System.Security.Cryptography.Asn1.ECPrivateKey : ValueType {
    internal int Version;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal Nullable`1<ECDomainParameters> Parameters;
    internal Nullable`1<ReadOnlyMemory`1<byte>> PublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static ECPrivateKey Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static ECPrivateKey Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ECPrivateKey& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ECPrivateKey& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ECPrivateKey& decoded);
}
internal class System.Security.Cryptography.Asn1.EncryptedPrivateKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn EncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedData;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncryptedPrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedPrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.FieldID : ValueType {
    internal string FieldType;
    internal ReadOnlyMemory`1<byte> Parameters;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static FieldID Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static FieldID Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
}
internal class System.Security.Cryptography.Asn1.PBEParameter : ValueType {
    internal ReadOnlyMemory`1<byte> Salt;
    internal int IterationCount;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PBEParameter Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBEParameter Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
}
internal class System.Security.Cryptography.Asn1.PBES2Params : ValueType {
    internal AlgorithmIdentifierAsn KeyDerivationFunc;
    internal AlgorithmIdentifierAsn EncryptionScheme;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PBES2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBES2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2Params : ValueType {
    internal Pbkdf2SaltChoice Salt;
    internal int IterationCount;
    internal Nullable`1<int> KeyLength;
    internal AlgorithmIdentifierAsn Prf;
    private static ReadOnlySpan`1<byte> DefaultPrf { get; }
    private static ReadOnlySpan`1<byte> get_DefaultPrf();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Pbkdf2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Pbkdf2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2SaltChoice : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Specified;
    internal Nullable`1<AlgorithmIdentifierAsn> OtherSource;
    internal void Encode(AsnWriter writer);
    internal static Pbkdf2SaltChoice Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
}
internal class System.Security.Cryptography.Asn1.PrivateKeyInfoAsn : ValueType {
    internal int Version;
    internal AlgorithmIdentifierAsn PrivateKeyAlgorithm;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal AttributeAsn[] Attributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Rc2CbcParameters : ValueType {
    internal int Rc2Version;
    internal ReadOnlyMemory`1<byte> Iv;
    private static Byte[] s_rc2EkbEncoding;
    internal Rc2CbcParameters(ReadOnlyMemory`1<byte> iv, int keySize);
    private static Rc2CbcParameters();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rc2CbcParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rc2CbcParameters Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    internal int GetEffectiveKeyBits();
}
internal class System.Security.Cryptography.Asn1.SpecifiedECDomain : ValueType {
    internal int Version;
    internal FieldID FieldID;
    internal CurveAsn Curve;
    internal ReadOnlyMemory`1<byte> Base;
    internal ReadOnlyMemory`1<byte> Order;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Cofactor;
    internal string Hash;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SpecifiedECDomain Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SpecifiedECDomain Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
}
internal class System.Security.Cryptography.Asn1.SubjectPublicKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> SubjectPublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SubjectPublicKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SubjectPublicKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithm : object {
    private static CngAlgorithm s_ecdh;
    private static CngAlgorithm s_ecdhp256;
    private static CngAlgorithm s_ecdhp384;
    private static CngAlgorithm s_ecdhp521;
    private static CngAlgorithm s_ecdsa;
    private static CngAlgorithm s_ecdsap256;
    private static CngAlgorithm s_ecdsap384;
    private static CngAlgorithm s_ecdsap521;
    private static CngAlgorithm s_md5;
    private static CngAlgorithm s_sha1;
    private static CngAlgorithm s_sha256;
    private static CngAlgorithm s_sha384;
    private static CngAlgorithm s_sha512;
    private static CngAlgorithm s_rsa;
    private string _algorithm;
    public string Algorithm { get; }
    public static CngAlgorithm Rsa { get; }
    public static CngAlgorithm ECDiffieHellman { get; }
    public static CngAlgorithm ECDiffieHellmanP256 { get; }
    public static CngAlgorithm ECDiffieHellmanP384 { get; }
    public static CngAlgorithm ECDiffieHellmanP521 { get; }
    public static CngAlgorithm ECDsa { get; }
    public static CngAlgorithm ECDsaP256 { get; }
    public static CngAlgorithm ECDsaP384 { get; }
    public static CngAlgorithm ECDsaP521 { get; }
    public static CngAlgorithm MD5 { get; }
    public static CngAlgorithm Sha1 { get; }
    public static CngAlgorithm Sha256 { get; }
    public static CngAlgorithm Sha384 { get; }
    public static CngAlgorithm Sha512 { get; }
    public CngAlgorithm(string algorithm);
    public string get_Algorithm();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithm left, CngAlgorithm right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithm left, CngAlgorithm right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithm other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithm get_Rsa();
    public static CngAlgorithm get_ECDiffieHellman();
    public static CngAlgorithm get_ECDiffieHellmanP256();
    public static CngAlgorithm get_ECDiffieHellmanP384();
    public static CngAlgorithm get_ECDiffieHellmanP521();
    public static CngAlgorithm get_ECDsa();
    public static CngAlgorithm get_ECDsaP256();
    public static CngAlgorithm get_ECDsaP384();
    public static CngAlgorithm get_ECDsaP521();
    public static CngAlgorithm get_MD5();
    public static CngAlgorithm get_Sha1();
    public static CngAlgorithm get_Sha256();
    public static CngAlgorithm get_Sha384();
    public static CngAlgorithm get_Sha512();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithmGroup : object {
    private static CngAlgorithmGroup s_dh;
    private static CngAlgorithmGroup s_dsa;
    private static CngAlgorithmGroup s_ecdh;
    private static CngAlgorithmGroup s_ecdsa;
    private static CngAlgorithmGroup s_rsa;
    private string _algorithmGroup;
    public string AlgorithmGroup { get; }
    public static CngAlgorithmGroup DiffieHellman { get; }
    public static CngAlgorithmGroup Dsa { get; }
    public static CngAlgorithmGroup ECDiffieHellman { get; }
    public static CngAlgorithmGroup ECDsa { get; }
    public static CngAlgorithmGroup Rsa { get; }
    public CngAlgorithmGroup(string algorithmGroup);
    public string get_AlgorithmGroup();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithmGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithmGroup get_DiffieHellman();
    public static CngAlgorithmGroup get_Dsa();
    public static CngAlgorithmGroup get_ECDiffieHellman();
    public static CngAlgorithmGroup get_ECDsa();
    public static CngAlgorithmGroup get_Rsa();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowExport;
    public static CngExportPolicies AllowPlaintextExport;
    public static CngExportPolicies AllowArchiving;
    public static CngExportPolicies AllowPlaintextArchiving;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKey : object {
    private SafeNCryptKeyHandle _keyHandle;
    private SafeNCryptProviderHandle _providerHandle;
    private static Byte[] s_pkcs12TripleDesOidBytes;
    public CngAlgorithm Algorithm { get; }
    [NullableAttribute("2")]
public CngAlgorithmGroup AlgorithmGroup { get; }
    public CngExportPolicies ExportPolicy { get; internal set; }
    public SafeNCryptKeyHandle Handle { get; }
    public bool IsEphemeral { get; private set; }
    public bool IsMachineKey { get; }
    [NullableAttribute("2")]
public string KeyName { get; }
    public int KeySize { get; }
    public CngKeyUsages KeyUsage { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    [NullableAttribute("2")]
public CngProvider Provider { get; }
    public SafeNCryptProviderHandle ProviderHandle { get; }
    public CngUIPolicy UIPolicy { get; }
    [NullableAttribute("2")]
public string UniqueName { get; }
    private CngKey(SafeNCryptProviderHandle providerHandle, SafeNCryptKeyHandle keyHandle);
    private static CngKey();
    public sealed virtual void Dispose();
    public CngProperty GetProperty(string name, CngPropertyOptions options);
    public bool HasProperty(string name, CngPropertyOptions options);
    public void SetProperty(CngProperty property);
    public CngAlgorithm get_Algorithm();
    [NullableContextAttribute("2")]
public CngAlgorithmGroup get_AlgorithmGroup();
    public CngExportPolicies get_ExportPolicy();
    internal void set_ExportPolicy(CngExportPolicies value);
    public SafeNCryptKeyHandle get_Handle();
    public bool get_IsEphemeral();
    private void set_IsEphemeral(bool value);
    public bool get_IsMachineKey();
    [NullableContextAttribute("2")]
public string get_KeyName();
    public int get_KeySize();
    public CngKeyUsages get_KeyUsage();
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
    [NullableContextAttribute("2")]
public CngProvider get_Provider();
    public SafeNCryptProviderHandle get_ProviderHandle();
    public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
public string get_UniqueName();
    public static CngKey Create(CngAlgorithm algorithm);
    public static CngKey Create(CngAlgorithm algorithm, string keyName);
    public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
    private static void InitializeKeyProperties(SafeNCryptKeyHandle keyHandle, CngKeyCreationParameters creationParameters);
    private static void InitializeKeyUiPolicyProperties(SafeNCryptKeyHandle keyHandle, CngUIPolicy uiPolicy);
    internal bool IsECNamedCurve();
    internal static bool IsECNamedCurve(string algorithm);
    internal string GetCurveName(String& oidValue);
    private string GetECSpecificCurveName(String& oidValue);
    internal static CngProperty GetPropertyFromNamedCurve(ECCurve curve);
    internal static CngAlgorithm EcdsaCurveNameToAlgorithm(string name);
    internal static CngAlgorithm EcdhCurveNameToAlgorithm(string name);
    internal static CngKey Create(ECCurve curve, Func`2<string, CngAlgorithm> algorithmResolver);
    internal static CngKey Import(ReadOnlySpan`1<byte> keyBlob, CngKeyBlobFormat format);
    public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format);
    internal static CngKey Import(Byte[] keyBlob, string curveName, CngKeyBlobFormat format);
    public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
    internal static CngKey ImportEncryptedPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password);
    internal static CngKey ImportEncryptedPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password, CngProvider provider);
    internal static CngKey Import(Byte[] keyBlob, string curveName, CngKeyBlobFormat format, CngProvider provider);
    internal static CngKey Import(ReadOnlySpan`1<byte> keyBlob, string curveName, CngKeyBlobFormat format, CngProvider provider);
    public Byte[] Export(CngKeyBlobFormat format);
    internal bool TryExportKeyBlob(string blobType, Span`1<byte> destination, Int32& bytesWritten);
    internal Byte[] ExportPkcs8KeyBlob(ReadOnlySpan`1<char> password, int kdfCount);
    internal bool TryExportPkcs8KeyBlob(ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    internal static bool ExportPkcs8KeyBlob(bool allocate, SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten, Byte[]& allocated);
    public void Delete();
    public static bool Exists(string keyName);
    public static bool Exists(string keyName, CngProvider provider);
    public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
    public static CngKey Open(string keyName);
    public static CngKey Open(string keyName, CngProvider provider);
    public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyBlobFormat : object {
    private static CngKeyBlobFormat s_eccPrivate;
    private static CngKeyBlobFormat s_eccPublic;
    private static CngKeyBlobFormat s_eccFullPrivate;
    private static CngKeyBlobFormat s_eccFullPublic;
    private static CngKeyBlobFormat s_genericPrivate;
    private static CngKeyBlobFormat s_genericPublic;
    private static CngKeyBlobFormat s_opaqueTransport;
    private static CngKeyBlobFormat s_pkcs8Private;
    private string _format;
    public string Format { get; }
    public static CngKeyBlobFormat EccPrivateBlob { get; }
    public static CngKeyBlobFormat EccPublicBlob { get; }
    public static CngKeyBlobFormat EccFullPrivateBlob { get; }
    public static CngKeyBlobFormat EccFullPublicBlob { get; }
    public static CngKeyBlobFormat GenericPrivateBlob { get; }
    public static CngKeyBlobFormat GenericPublicBlob { get; }
    public static CngKeyBlobFormat OpaqueTransportBlob { get; }
    public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
    public CngKeyBlobFormat(string format);
    public string get_Format();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngKeyBlobFormat other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngKeyBlobFormat get_EccPrivateBlob();
    public static CngKeyBlobFormat get_EccPublicBlob();
    public static CngKeyBlobFormat get_EccFullPrivateBlob();
    public static CngKeyBlobFormat get_EccFullPublicBlob();
    public static CngKeyBlobFormat get_GenericPrivateBlob();
    public static CngKeyBlobFormat get_GenericPublicBlob();
    public static CngKeyBlobFormat get_OpaqueTransportBlob();
    public static CngKeyBlobFormat get_Pkcs8PrivateBlob();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
    public static CngKeyCreationOptions MachineKey;
    public static CngKeyCreationOptions OverwriteExistingKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyCreationParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<CngExportPolicies> <ExportPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKeyCreationOptions <KeyCreationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CngKeyUsages> <KeyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyCollection <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <ParentWindowHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private CngUIPolicy <UIPolicy>k__BackingField;
    private CngProvider _provider;
    public Nullable`1<CngExportPolicies> ExportPolicy { get; public set; }
    public CngKeyCreationOptions KeyCreationOptions { get; public set; }
    public Nullable`1<CngKeyUsages> KeyUsage { get; public set; }
    public CngPropertyCollection Parameters { get; private set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; public set; }
    [NullableAttribute("2")]
public CngUIPolicy UIPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<CngExportPolicies> get_ExportPolicy();
    [CompilerGeneratedAttribute]
public void set_ExportPolicy(Nullable`1<CngExportPolicies> value);
    [CompilerGeneratedAttribute]
public CngKeyCreationOptions get_KeyCreationOptions();
    [CompilerGeneratedAttribute]
public void set_KeyCreationOptions(CngKeyCreationOptions value);
    [CompilerGeneratedAttribute]
public Nullable`1<CngKeyUsages> get_KeyUsage();
    [CompilerGeneratedAttribute]
public void set_KeyUsage(Nullable`1<CngKeyUsages> value);
    [CompilerGeneratedAttribute]
public CngPropertyCollection get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(CngPropertyCollection value);
    [CompilerGeneratedAttribute]
public IntPtr get_ParentWindowHandle();
    [CompilerGeneratedAttribute]
public void set_ParentWindowHandle(IntPtr value);
    public CngProvider get_Provider();
    public void set_Provider(CngProvider value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UIPolicy(CngUIPolicy value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
    public int value__;
    public static CngKeyHandleOpenOptions None;
    public static CngKeyHandleOpenOptions EphemeralKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyOpenOptions : Enum {
    public int value__;
    public static CngKeyOpenOptions None;
    public static CngKeyOpenOptions UserKey;
    public static CngKeyOpenOptions MachineKey;
    public static CngKeyOpenOptions Silent;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyUsages : Enum {
    public int value__;
    public static CngKeyUsages None;
    public static CngKeyUsages Decryption;
    public static CngKeyUsages Signing;
    public static CngKeyUsages KeyAgreement;
    public static CngKeyUsages AllUsages;
}
internal static class System.Security.Cryptography.CngPkcs8 : object {
    private static PbeParameters s_platformParameters;
    private static CngPkcs8();
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob);
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password);
    internal static bool IsPlatformScheme(PbeParameters pbeParameters);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Pkcs8Response ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static Pkcs8Response ImportPkcs8(AsnWriter pkcs8Writer);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    private static AsnWriter RewritePkcs8ECPrivateKeyWithZeroPublicKey(ReadOnlySpan`1<byte> source);
    private static void FillRandomAsciiString(Span`1<char> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProperty : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyOptions <Options>k__BackingField;
    private Byte[] _value;
    private Nullable`1<int> _lazyHashCode;
    public string Name { get; private set; }
    public CngPropertyOptions Options { get; private set; }
    public CngProperty(string name, Byte[] value, CngPropertyOptions options);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [NullableContextAttribute("2")]
public Byte[] GetValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CngPropertyOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(CngPropertyOptions value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProperty other);
    public virtual int GetHashCode();
    public static bool op_Equality(CngProperty left, CngProperty right);
    public static bool op_Inequality(CngProperty left, CngProperty right);
    internal Byte[] GetValueWithoutCopying();
}
public class System.Security.Cryptography.CngPropertyCollection : Collection`1<CngProperty> {
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions None;
    public static CngPropertyOptions CustomProperty;
    public static CngPropertyOptions Persist;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProvider : object {
    private static CngProvider s_msSmartCardKsp;
    private static CngProvider s_msSoftwareKsp;
    private string _provider;
    public string Provider { get; }
    public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
    public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
    public CngProvider(string provider);
    public string get_Provider();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngProvider left, CngProvider right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngProvider left, CngProvider right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngProvider other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngProvider get_MicrosoftSmartCardKeyStorageProvider();
    public static CngProvider get_MicrosoftSoftwareKeyStorageProvider();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngUIPolicy : object {
    [CompilerGeneratedAttribute]
private CngUIProtectionLevels <ProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreationTitle>k__BackingField;
    public CngUIProtectionLevels ProtectionLevel { get; private set; }
    public string FriendlyName { get; private set; }
    public string Description { get; private set; }
    public string UseContext { get; private set; }
    public string CreationTitle { get; private set; }
    public CngUIPolicy(CngUIProtectionLevels protectionLevel);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
    [CompilerGeneratedAttribute]
public CngUIProtectionLevels get_ProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_ProtectionLevel(CngUIProtectionLevels value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_UseContext();
    [CompilerGeneratedAttribute]
private void set_UseContext(string value);
    [CompilerGeneratedAttribute]
public string get_CreationTitle();
    [CompilerGeneratedAttribute]
private void set_CreationTitle(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngUIProtectionLevels : Enum {
    public int value__;
    public static CngUIProtectionLevels None;
    public static CngUIProtectionLevels ProtectKey;
    public static CngUIProtectionLevels ForceHighProtection;
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static int ClearAll;
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(ArraySegment`1<byte> arraySegment);
    internal static void Return(Byte[] array, int clearSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSACng : DSA {
    private CngAlgorithmCore _core;
    private static string BCRYPT_DSA_ALGORITHM;
    private CngAlgorithm _dsnCng;
    private static KeySizes[] s_legalKeySizes;
    private static int s_defaultKeySize;
    private static int MaxV1KeySize;
    private static int Sha1HashOutputSize;
    private static int Sha256HashOutputSize;
    private static int Sha512HashOutputSize;
    private static int WindowsMaxQSize;
    public CngKey Key { get; private set; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public DSACng(CngKey key);
    public DSACng(int keySize);
    private static DSACng();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] dsaBlob, bool includePrivate);
    private void AcceptImport(Pkcs8Response response);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    private void ForceSetKeySize(int newKeySize);
    private static bool Supports2048KeySize();
    public virtual void ImportParameters(DSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    private static void GenerateV1DsaBlob(Byte[]& blob, DSAParameters parameters, int cbKey, bool includePrivate);
    private static void GenerateV2DsaBlob(Byte[]& blob, DSAParameters parameters, int cbKey, bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    [NullableContextAttribute("0")]
public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [NullableContextAttribute("0")]
public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    private ReadOnlySpan`1<byte> AdjustHashSizeIfNecessary(ReadOnlySpan`1<byte> hash, Span`1<byte> stackBuf);
    private int ComputeQLength();
}
internal static class System.Security.Cryptography.EccKeyFormatHelper : object {
    private static int MaxFieldBitSize;
    private static String[] s_validOids;
    private static EccKeyFormatHelper();
    internal static void ReadSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead, ECParameters& key);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, Int32& bytesRead, ECParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, Int32& bytesRead, ECParameters& key);
    internal static ECParameters FromECPrivateKey(ReadOnlySpan`1<byte> key, Int32& bytesRead);
    internal static void FromECPrivateKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    internal static void FromECPrivateKey(ECPrivateKey key, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    internal static void FromECPublicKey(ReadOnlyMemory`1<byte> key, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    private static void ValidateParameters(Nullable`1<ECDomainParameters> keyParameters, AlgorithmIdentifierAsn& algId);
    private static ECCurve GetCurve(ECDomainParameters domainParameters);
    private static ECCurve GetSpecifiedECCurve(SpecifiedECDomain specifiedParameters);
    private static ECCurve GetSpecifiedECCurveCore(SpecifiedECDomain specifiedParameters);
    internal static AsnWriter WriteSubjectPublicKeyInfo(ECParameters ecParameters);
    private static AsnWriter WriteAlgorithmIdentifier(ECParameters& ecParameters);
    private static void WriteAlgorithmIdentifier(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WritePkcs8PrivateKey(ECParameters ecParameters, AttributeAsn[] attributes);
    private static AsnWriter WritePrivateKeyInfoAttributes(AttributeAsn[] attributes);
    private static void WriteEcParameters(ECParameters ecParameters, AsnWriter writer);
    private static void WriteSpecifiedECDomain(ECParameters ecParameters, AsnWriter writer);
    private static void DetermineChar2Parameters(ECParameters& ecParameters, Int32& m, Int32& k1, Int32& k2, Int32& k3);
    private static void WriteCurve(ECCurve& curve, AsnWriter writer);
    private static void WriteFieldElement(Byte[] fieldElement, AsnWriter writer);
    private static void WriteUncompressedBasePoint(ECParameters& ecParameters, AsnWriter writer);
    private static void WriteUncompressedPublicKey(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WriteECPrivateKey(ECParameters& ecParameters);
    private static AsnWriter WriteEcPrivateKey(ECParameters& ecParameters, bool includeDomainParameters);
}
internal static class System.Security.Cryptography.ECCng : object {
    internal static CngKey ImportKeyBlob(Byte[] ecBlob, string curveName, bool includePrivateParameters);
    internal static CngKey ImportFullKeyBlob(Byte[] ecBlob, bool includePrivateParameters);
    internal static Byte[] ExportKeyBlob(CngKey key, bool includePrivateParameters);
    internal static Byte[] ExportFullKeyBlob(CngKey key, bool includePrivateParameters);
    internal static Byte[] ExportKeyBlob(CngKey key, bool includePrivateParameters, CngKeyBlobFormat& format, String& curveName);
    private static void FixupGenericBlob(Byte[] blob);
    internal static Byte[] GetNamedCurveBlob(ECParameters& parameters, bool ecdh);
    internal static Byte[] GetPrimeCurveBlob(ECParameters& parameters, bool ecdh);
    internal static void ExportNamedCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static void ExportPrimeCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static Byte[] GetPrimeCurveParameterBlob(ECCurve& curve);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    private static bool IsMagicValueOfKeyPrivate(KeyBlobMagicNumber magic);
    private static bool IsMagicValueOfKeyPublic(KeyBlobMagicNumber magic);
    private static KeyBlobMagicNumber EcdsaCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static KeyBlobMagicNumber EcdhCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static ECC_CURVE_TYPE_ENUM ConvertToCurveTypeEnum(ECCurveType value);
    private static ECCurveType ConvertToCurveTypeEnum(ECC_CURVE_TYPE_ENUM value);
    internal static SafeNCryptKeyHandle ImportKeyBlob(string blobType, ReadOnlySpan`1<byte> keyBlob, string curveName, SafeNCryptProviderHandle provider);
    internal static string EcdsaCurveNameToAlgorithm(string algorithm);
    internal static string EcdhCurveNameToAlgorithm(string algorithm);
    internal static ECC_CURVE_ALG_ID_ENUM GetHashAlgorithmId(Nullable`1<HashAlgorithmName> name);
    internal static Nullable`1<HashAlgorithmName> GetHashAlgorithmName(ECC_CURVE_ALG_ID_ENUM hashId);
    internal static bool IsECNamedCurve(string algorithm);
    internal static string SpecialNistAlgorithmToCurveName(string algorithm, String& oidValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
    private CngAlgorithmCore _core;
    private CngAlgorithm _hashAlgorithm;
    private ECDiffieHellmanKeyDerivationFunction _kdf;
    private Byte[] _hmacKey;
    private Byte[] _label;
    private Byte[] _secretAppend;
    private Byte[] _secretPrepend;
    private Byte[] _seed;
    public CngAlgorithm HashAlgorithm { get; public set; }
    public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; public set; }
    [NullableAttribute("2")]
public Byte[] HmacKey { get; public set; }
    [NullableAttribute("2")]
public Byte[] Label { get; public set; }
    [NullableAttribute("2")]
public Byte[] SecretAppend { get; public set; }
    [NullableAttribute("2")]
public Byte[] SecretPrepend { get; public set; }
    [NullableAttribute("2")]
public Byte[] Seed { get; public set; }
    public bool UseSecretAgreementAsHmacKey { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public CngKey Key { get; private set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public ECDiffieHellmanCng(CngKey key);
    public ECDiffieHellmanCng(int keySize);
    public ECDiffieHellmanCng(ECCurve curve);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction();
    public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value);
    [NullableContextAttribute("2")]
public Byte[] get_HmacKey();
    [NullableContextAttribute("2")]
public void set_HmacKey(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_Label();
    [NullableContextAttribute("2")]
public void set_Label(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_SecretAppend();
    [NullableContextAttribute("2")]
public void set_SecretAppend(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_SecretPrepend();
    [NullableContextAttribute("2")]
public void set_SecretPrepend(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_Seed();
    [NullableContextAttribute("2")]
public void set_Seed(Byte[] value);
    public bool get_UseSecretAgreementAsHmacKey();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void DisposeKey();
    internal string GetCurveName(String& oidValue);
    private void ImportFullKeyBlob(Byte[] ecfullKeyBlob, bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] ecfullKeyBlob, string curveName, bool includePrivateParameters);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private Byte[] ExportFullKeyBlob(bool includePrivateParameters);
    private void AcceptImport(Pkcs8Response response);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual void GenerateKey(ECCurve curve);
    private CngKey GetKey();
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public string ToXmlString(ECKeyXmlFormat format);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    private void ForceSetKeySize(int newKeySize);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    [NullableContextAttribute("2")]
public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
    private CngKeyBlobFormat _format;
    private string _curveName;
    private bool _disposed;
    public CngKeyBlobFormat BlobFormat { get; }
    internal ECDiffieHellmanCngPublicKey(Byte[] keyBlob, string curveName, CngKeyBlobFormat format);
    protected virtual void Dispose(bool disposing);
    public virtual string ToXmlString();
    public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
    public CngKeyBlobFormat get_BlobFormat();
    public static ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format);
    internal static ECDiffieHellmanCngPublicKey FromKey(CngKey key);
    public CngKey Import();
    public virtual ECParameters ExportExplicitParameters();
    public virtual ECParameters ExportParameters();
}
public enum System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
    public int value__;
    public static ECDiffieHellmanKeyDerivationFunction Hash;
    public static ECDiffieHellmanKeyDerivationFunction Hmac;
    public static ECDiffieHellmanKeyDerivationFunction Tls;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDsaCng : ECDsa {
    private CngAlgorithmCore _core;
    private CngAlgorithm _hashAlgorithm;
    public CngAlgorithm HashAlgorithm { get; public set; }
    public CngKey Key { get; private set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public ECDsaCng(CngKey key);
    public ECDsaCng(ECCurve curve);
    public ECDsaCng(int keySize);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void DisposeKey();
    private static bool IsEccAlgorithmGroup(CngAlgorithmGroup algorithmGroup);
    internal string GetCurveName(String& oidValue);
    private void ImportFullKeyBlob(Byte[] ecfullKeyBlob, bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] ecfullKeyBlob, string curveName, bool includePrivateParameters);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private Byte[] ExportFullKeyBlob(bool includePrivateParameters);
    private void AcceptImport(Pkcs8Response response);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public Byte[] SignData(Byte[] data);
    public Byte[] SignData(Byte[] data, int offset, int count);
    public Byte[] SignData(Stream data);
    public string ToXmlString(ECKeyXmlFormat format);
    public bool VerifyData(Byte[] data, Byte[] signature);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature);
    public bool VerifyData(Stream data, Byte[] signature);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual void GenerateKey(ECCurve curve);
    private CngKey GetKey();
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
    public virtual void ImportParameters(ECParameters parameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    private void ForceSetKeySize(int newKeySize);
    public virtual KeySizes[] get_LegalKeySizes();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual Byte[] SignHash(Byte[] hash);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
}
public enum System.Security.Cryptography.ECKeyXmlFormat : Enum {
    public int value__;
    public static ECKeyXmlFormat Rfc4050;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeyBlobHelpers : object {
    [ExtensionAttribute]
internal static Byte[] ToUnsignedIntegerBytes(ReadOnlyMemory`1<byte> memory, int length);
    [ExtensionAttribute]
internal static Byte[] ToUnsignedIntegerBytes(ReadOnlyMemory`1<byte> memory);
    [ExtensionAttribute]
internal static Byte[] ExportKeyParameter(BigInteger value, int length);
    [ExtensionAttribute]
internal static void WriteKeyParameterInteger(AsnWriter writer, ReadOnlySpan`1<byte> integer);
}
internal static class System.Security.Cryptography.KeyFormatHelper : object {
    internal static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WritePkcs8(AsnWriter algorithmIdentifierWriter, AsnWriter privateKeyWriter, AsnWriter attributesWriter);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    private static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<char> newPassword, PbeParameters pbeParameters);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<byte> newPasswordBytes, PbeParameters pbeParameters);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeySizeHelpers : object {
    [ExtensionAttribute]
public static KeySizes[] CloneKeySizesArray(KeySizes[] src);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
}
internal static class System.Security.Cryptography.Oids : object {
    internal static string Rc2Cbc;
    internal static string Rc4;
    internal static string TripleDesCbc;
    internal static string DesCbc;
    internal static string Aes128Cbc;
    internal static string Aes192Cbc;
    internal static string Aes256Cbc;
    internal static string Dsa;
    internal static string Rsa;
    internal static string RsaOaep;
    internal static string RsaPss;
    internal static string RsaPkcs1Md5;
    internal static string RsaPkcs1Sha1;
    internal static string RsaPkcs1Sha256;
    internal static string RsaPkcs1Sha384;
    internal static string RsaPkcs1Sha512;
    internal static string Esdh;
    internal static string EcDiffieHellman;
    internal static string DiffieHellman;
    internal static string DiffieHellmanPkcs3;
    internal static string SigningTime;
    internal static string ContentType;
    internal static string DocumentDescription;
    internal static string MessageDigest;
    internal static string CounterSigner;
    internal static string SigningCertificate;
    internal static string SigningCertificateV2;
    internal static string DocumentName;
    internal static string LocalKeyId;
    internal static string EnrollCertTypeExtension;
    internal static string UserPrincipalName;
    internal static string CertificateTemplate;
    internal static string ApplicationCertPolicies;
    internal static string AuthorityInformationAccess;
    internal static string OcspEndpoint;
    internal static string CertificateAuthorityIssuers;
    internal static string Pkcs9ExtensionRequest;
    internal static string CmsRc2Wrap;
    internal static string Cms3DesWrap;
    internal static string Pkcs7Data;
    internal static string Pkcs7Signed;
    internal static string Pkcs7Enveloped;
    internal static string Pkcs7SignedEnveloped;
    internal static string Pkcs7Hashed;
    internal static string Pkcs7Encrypted;
    internal static string Md5;
    internal static string Sha1;
    internal static string Sha256;
    internal static string Sha384;
    internal static string Sha512;
    internal static string DsaWithSha1;
    internal static string DsaWithSha256;
    internal static string DsaWithSha384;
    internal static string DsaWithSha512;
    internal static string EcPrimeField;
    internal static string EcChar2Field;
    internal static string EcChar2TrinomialBasis;
    internal static string EcChar2PentanomialBasis;
    internal static string EcPublicKey;
    internal static string ECDsaWithSha1;
    internal static string ECDsaWithSha256;
    internal static string ECDsaWithSha384;
    internal static string ECDsaWithSha512;
    internal static string Mgf1;
    internal static string PSpecified;
    internal static string NoSignature;
    internal static string CommonName;
    internal static string Organization;
    internal static string OrganizationalUnit;
    internal static string EmailAddress;
    internal static string BasicConstraints;
    internal static string SubjectKeyIdentifier;
    internal static string KeyUsage;
    internal static string SubjectAltName;
    internal static string IssuerAltName;
    internal static string BasicConstraints2;
    internal static string CrlDistributionPoints;
    internal static string CertPolicies;
    internal static string AnyCertPolicy;
    internal static string CertPolicyMappings;
    internal static string CertPolicyConstraints;
    internal static string EnhancedKeyUsage;
    internal static string InhibitAnyPolicyExtension;
    internal static string TstInfo;
    internal static string TimeStampingPurpose;
    private static string Pkcs12Prefix;
    private static string Pkcs12PbePrefix;
    internal static string Pkcs12PbeWithShaAnd3Key3Des;
    internal static string Pkcs12PbeWithShaAnd2Key3Des;
    internal static string Pkcs12PbeWithShaAnd128BitRC2;
    internal static string Pkcs12PbeWithShaAnd40BitRC2;
    private static string Pkcs12BagTypesPrefix;
    internal static string Pkcs12KeyBag;
    internal static string Pkcs12ShroudedKeyBag;
    internal static string Pkcs12CertBag;
    internal static string Pkcs12CrlBag;
    internal static string Pkcs12SecretBag;
    internal static string Pkcs12SafeContentsBag;
    internal static string Pkcs12X509CertBagType;
    internal static string Pkcs12SdsiCertBagType;
    private static string Pkcs5Prefix;
    internal static string PbeWithMD5AndDESCBC;
    internal static string PbeWithMD5AndRC2CBC;
    internal static string PbeWithSha1AndDESCBC;
    internal static string PbeWithSha1AndRC2CBC;
    internal static string Pbkdf2;
    internal static string PasswordBasedEncryptionScheme2;
    private static string RsaDsiDigestAlgorithmPrefix;
    internal static string HmacWithSha1;
    internal static string HmacWithSha256;
    internal static string HmacWithSha384;
    internal static string HmacWithSha512;
    internal static string secp256r1;
    internal static string secp384r1;
    internal static string secp521r1;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _rsaOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _ecPublicKeyOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _tripleDesCbcOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _aes256CbcOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _secp256r1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _secp384r1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _secp521r1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _sha256Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _pkcs7DataOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _contentTypeOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _documentDescriptionOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _documentNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _localKeyIdOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _messageDigestOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _signingTimeOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _pkcs9ExtensionRequestOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _basicConstraints2Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _enhancedKeyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _keyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) _subjectKeyIdentifierOid;
    internal static Oid RsaOid { get; }
    internal static Oid EcPublicKeyOid { get; }
    internal static Oid TripleDesCbcOid { get; }
    internal static Oid Aes256CbcOid { get; }
    internal static Oid secp256r1Oid { get; }
    internal static Oid secp384r1Oid { get; }
    internal static Oid secp521r1Oid { get; }
    internal static Oid Sha256Oid { get; }
    internal static Oid Pkcs7DataOid { get; }
    internal static Oid ContentTypeOid { get; }
    internal static Oid DocumentDescriptionOid { get; }
    internal static Oid DocumentNameOid { get; }
    internal static Oid LocalKeyIdOid { get; }
    internal static Oid MessageDigestOid { get; }
    internal static Oid SigningTimeOid { get; }
    internal static Oid Pkcs9ExtensionRequestOid { get; }
    internal static Oid BasicConstraints2Oid { get; }
    internal static Oid EnhancedKeyUsageOid { get; }
    internal static Oid KeyUsageOid { get; }
    internal static Oid SubjectKeyIdentifierOid { get; }
    internal static Oid get_RsaOid();
    internal static Oid get_EcPublicKeyOid();
    internal static Oid get_TripleDesCbcOid();
    internal static Oid get_Aes256CbcOid();
    internal static Oid get_secp256r1Oid();
    internal static Oid get_secp384r1Oid();
    internal static Oid get_secp521r1Oid();
    internal static Oid get_Sha256Oid();
    internal static Oid get_Pkcs7DataOid();
    internal static Oid get_ContentTypeOid();
    internal static Oid get_DocumentDescriptionOid();
    internal static Oid get_DocumentNameOid();
    internal static Oid get_LocalKeyIdOid();
    internal static Oid get_MessageDigestOid();
    internal static Oid get_SigningTimeOid();
    internal static Oid get_Pkcs9ExtensionRequestOid();
    internal static Oid get_BasicConstraints2Oid();
    internal static Oid get_EnhancedKeyUsageOid();
    internal static Oid get_KeyUsageOid();
    internal static Oid get_SubjectKeyIdentifierOid();
    private static Oid InitializeOid(string oidValue);
}
internal static class System.Security.Cryptography.PasswordBasedEncryption : object {
    internal static int IterationLimit;
    private static CryptographicException AlgorithmKdfRequiresChars(string algId);
    internal static void ValidatePbeParameters(PbeParameters pbeParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    internal static int Decrypt(AlgorithmIdentifierAsn& algorithmIdentifier, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    internal static void InitiateEncryption(PbeParameters pbeParameters, SymmetricAlgorithm& cipher, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    internal static int Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, SymmetricAlgorithm cipher, bool isPkcs12, AsnWriter source, PbeParameters pbeParameters, ReadOnlySpan`1<byte> salt, Byte[] destination, Span`1<byte> ivDest);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static SymmetricAlgorithm OpenCipher(AlgorithmIdentifierAsn encryptionScheme, Nullable`1<int> requestedKeyLength, Span`1& iv);
    private static void ReadIvParameter(Nullable`1<ReadOnlyMemory`1<byte>> encryptionSchemeParameters, int length, Span`1& iv);
    private static Rfc2898DeriveBytes OpenPbkdf2(ReadOnlySpan`1<byte> password, Nullable`1<ReadOnlyMemory`1<byte>> parameters, Nullable`1& requestedKeyLength);
    private static int Pbes1Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, IncrementalHash hasher, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pkcs12PbeDecrypt(AlgorithmIdentifierAsn algorithmIdentifier, ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Decrypt(SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static void Pbkdf1(IncrementalHash hasher, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterationCount, Span`1<byte> dk);
    internal static void WritePbeAlgorithmIdentifier(AsnWriter writer, bool isPkcs12, string encryptionAlgorithmOid, Span`1<byte> salt, int iterationCount, string hmacOid, Span`1<byte> iv);
    internal static int NormalizeIterationCount(int iterationCount, Nullable`1<int> iterationLimit);
}
internal static class System.Security.Cryptography.Pkcs.Pkcs12Kdf : object {
    private static byte CipherKeyId;
    private static byte IvId;
    private static byte MacKeyId;
    private static Dictionary`2<HashAlgorithmName, Tuple`2<int, int>> s_uvLookup;
    private static Pkcs12Kdf();
    internal static void DeriveCipherKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveIV(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveMacKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void Derive(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, byte id, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void AddPlusOne(Span`1<byte> into, Span`1<byte> addend);
    private static void CircularCopy(ReadOnlySpan`1<byte> bytes, Span`1<byte> destination);
    private static void CircularCopyUtf16BE(ReadOnlySpan`1<char> password, Span`1<byte> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSACng : RSA {
    private CngAlgorithmCore _core;
    private static CngKeyBlobFormat s_rsaFullPrivateBlob;
    private static CngKeyBlobFormat s_rsaPrivateBlob;
    private static CngKeyBlobFormat s_rsaPublicBlob;
    private static int Pkcs1PaddingOverhead;
    private static int StatusUnsuccessfulRetryCount;
    private static ConcurrentDictionary`2<HashAlgorithmName, int> s_hashSizes;
    public CngKey Key { get; private set; }
    public KeySizes[] LegalKeySizes { get; }
    public RSACng(CngKey key);
    public RSACng(int keySize);
    private static RSACng();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void ImportKeyBlob(Byte[] rsaBlob, bool includePrivate);
    private void AcceptImport(Pkcs8Response response);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
    public virtual KeySizes[] get_LegalKeySizes();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    private void ForceSetKeySize(int newKeySize);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    private Byte[] EncryptOrDecrypt(Byte[] data, RSAEncryptionPadding padding, bool encrypt);
    private bool TryEncryptOrDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, bool encrypt, Int32& bytesWritten);
    private Byte[] EncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt);
    private bool TryEncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, Span`1<byte> output, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt, Int32& bytesWritten);
    private static ErrorCode EncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, Span`1<byte> output, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt, Int32& bytesNeeded);
    public virtual void ImportParameters(RSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    private static void ExportParameters(RSAParameters& rsaParams, Byte[] rsaBlob, bool includePrivateParameters);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    private static int GetHashSizeInBytes(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
}
internal class System.Security.Cryptography.RsaPaddingProcessor : object {
    private static ConcurrentDictionary`2<HashAlgorithmName, RsaPaddingProcessor> s_lookup;
    private HashAlgorithmName _hashAlgorithmName;
    private int _hLen;
    private static ReadOnlySpan`1<byte> EightZeros { get; }
    internal int HashLength { get; }
    private RsaPaddingProcessor(HashAlgorithmName hashAlgorithmName, int hLen);
    private static RsaPaddingProcessor();
    internal static int BytesRequiredForBitCount(int keySizeInBits);
    private static ReadOnlySpan`1<byte> get_EightZeros();
    internal int get_HashLength();
    internal static RsaPaddingProcessor OpenProcessor(HashAlgorithmName hashAlgorithmName);
    internal static void PadPkcs1Encryption(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal void PadOaep(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal bool DepadOaep(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    internal void EncodePss(ReadOnlySpan`1<byte> mHash, Span`1<byte> destination, int keySize);
    internal bool VerifyPss(ReadOnlySpan`1<byte> mHash, ReadOnlySpan`1<byte> em, int keySize);
    private void Mgf1(IncrementalHash hasher, ReadOnlySpan`1<byte> mgfSeed, Span`1<byte> mask);
    private static void FillNonZeroBytes(Span`1<byte> data);
    private static void Xor(Span`1<byte> a, ReadOnlySpan`1<byte> b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.TripleDESCng : TripleDES {
    private CngSymmetricAlgorithmCore _core;
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    private Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.BaseKey { get; private set; }
    private int Internal.Cryptography.ICngSymmetricAlgorithm.BaseKeySize { get; private set; }
    public TripleDESCng(string keyName);
    public TripleDESCng(string keyName, CngProvider provider);
    public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKey();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKey(Byte[] value);
    private sealed virtual override int Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKeySize();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKeySize(int value);
    private sealed virtual override bool Internal.Cryptography.ICngSymmetricAlgorithm.IsWeakKey(Byte[] key);
    private sealed virtual override int Internal.Cryptography.ICngSymmetricAlgorithm.GetPaddingSize();
    private sealed virtual override SafeAlgorithmHandle Internal.Cryptography.ICngSymmetricAlgorithm.GetEphemeralModeHandle();
    private sealed virtual override string Internal.Cryptography.ICngSymmetricAlgorithm.GetNCryptAlgorithmIdentifier();
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.PreprocessKey(Byte[] key);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Argument_EncodeDestinationTooSmall { get; }
    internal static string Argument_Invalid_SafeHandleInvalidOrClosed { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string Cryptography_AlgKdfRequiresChars { get; }
    internal static string Cryptography_ArgECDHKeySizeMismatch { get; }
    internal static string Cryptography_ArgECDHRequiresECDHKey { get; }
    internal static string Cryptography_ArgExpectedECDiffieHellmanCngPublicKey { get; }
    internal static string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListRequiresFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListValueTooBig { get; }
    internal static string Cryptography_Asn_UniversalValueIsFixed { get; }
    internal static string Cryptography_Asn_UnusedBitCountRange { get; }
    internal static string Cryptography_AsnWriter_EncodeUnbalancedStack { get; }
    internal static string Cryptography_AsnWriter_PopWrongTag { get; }
    internal static string Cryptography_TlsRequiresLabelAndSeed { get; }
    internal static string Cryptography_ArgDSARequiresDSAKey { get; }
    internal static string Cryptography_ArgECDsaRequiresECDsaKey { get; }
    internal static string Cryptography_ArgRSARequiresRSAKey { get; }
    internal static string Cryptography_CngKeyWrongAlgorithm { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Encryption_MessageTooLong { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_InvalidAlgorithmGroup { get; }
    internal static string Cryptography_InvalidAlgorithmName { get; }
    internal static string Cryptography_InvalidCipherMode { get; }
    internal static string Cryptography_InvalidDsaParameters_MissingFields { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPGY { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedQX { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPJ { get; }
    internal static string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_LargeKey { get; }
    internal static string Cryptography_CurveNotSupported { get; }
    internal static string Cryptography_InvalidCurveOid { get; }
    internal static string Cryptography_InvalidIVSize { get; }
    internal static string Cryptography_InvalidKeyBlobFormat { get; }
    internal static string Cryptography_InvalidKeySize { get; }
    internal static string Cryptography_InvalidPadding { get; }
    internal static string Cryptography_InvalidProviderName { get; }
    internal static string Cryptography_InvalidRsaParameters { get; }
    internal static string Cryptography_KeyBlobParsingError { get; }
    internal static string Cryptography_KeyTooSmall { get; }
    internal static string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag { get; }
    internal static string Cryptography_OpenInvalidHandle { get; }
    internal static string Cryptography_MissingIV { get; }
    internal static string Cryptography_MustTransformWholeBlock { get; }
    internal static string Cryptography_NotValidPrivateKey { get; }
    internal static string Cryptography_NotValidPublicOrPrivateKey { get; }
    internal static string Cryptography_OAEP_Decryption_Failed { get; }
    internal static string Cryptography_PartialBlock { get; }
    internal static string Cryptography_RSA_DecryptWrongSize { get; }
    internal static string Cryptography_Pkcs8_EncryptedReadFailed { get; }
    internal static string Cryptography_SignHash_WrongSize { get; }
    internal static string Cryptography_UnsupportedPaddingMode { get; }
    internal static string Cryptography_TransformBeyondEndOfBuffer { get; }
    internal static string Cryptography_UnexpectedTransformTruncation { get; }
    internal static string Cryptography_UnknownAlgorithmIdentifier { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownPaddingMode { get; }
    internal static string Cryptography_WeakKey { get; }
    internal static string Cryptography_WriteEncodedValue_OneValueAtATime { get; }
    internal static string PlatformNotSupported_CryptographyCng { get; }
    internal static string Cryptography_ECC_NamedCurvesOnly { get; }
    internal static string Cryptography_CSP_NoPrivateKey { get; }
    internal static string Cryptography_InvalidECCharacteristic2Curve { get; }
    internal static string Argument_DestinationTooShort { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Argument_EncodeDestinationTooSmall();
    internal static string get_Argument_Invalid_SafeHandleInvalidOrClosed();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Argument_InvalidValue();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_Cryptography_AlgKdfRequiresChars();
    internal static string get_Cryptography_ArgECDHKeySizeMismatch();
    internal static string get_Cryptography_ArgECDHRequiresECDHKey();
    internal static string get_Cryptography_ArgExpectedECDiffieHellmanCngPublicKey();
    internal static string get_Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListRequiresFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListValueTooBig();
    internal static string get_Cryptography_Asn_UniversalValueIsFixed();
    internal static string get_Cryptography_Asn_UnusedBitCountRange();
    internal static string get_Cryptography_AsnWriter_EncodeUnbalancedStack();
    internal static string get_Cryptography_AsnWriter_PopWrongTag();
    internal static string get_Cryptography_TlsRequiresLabelAndSeed();
    internal static string get_Cryptography_ArgDSARequiresDSAKey();
    internal static string get_Cryptography_ArgECDsaRequiresECDsaKey();
    internal static string get_Cryptography_ArgRSARequiresRSAKey();
    internal static string get_Cryptography_CngKeyWrongAlgorithm();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Encryption_MessageTooLong();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_InvalidAlgorithmGroup();
    internal static string get_Cryptography_InvalidAlgorithmName();
    internal static string get_Cryptography_InvalidCipherMode();
    internal static string get_Cryptography_InvalidDsaParameters_MissingFields();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPGY();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedQX();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPJ();
    internal static string get_Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_LargeKey();
    internal static string get_Cryptography_CurveNotSupported();
    internal static string get_Cryptography_InvalidCurveOid();
    internal static string get_Cryptography_InvalidIVSize();
    internal static string get_Cryptography_InvalidKeyBlobFormat();
    internal static string get_Cryptography_InvalidKeySize();
    internal static string get_Cryptography_InvalidPadding();
    internal static string get_Cryptography_InvalidProviderName();
    internal static string get_Cryptography_InvalidRsaParameters();
    internal static string get_Cryptography_KeyBlobParsingError();
    internal static string get_Cryptography_KeyTooSmall();
    internal static string get_Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag();
    internal static string get_Cryptography_OpenInvalidHandle();
    internal static string get_Cryptography_MissingIV();
    internal static string get_Cryptography_MustTransformWholeBlock();
    internal static string get_Cryptography_NotValidPrivateKey();
    internal static string get_Cryptography_NotValidPublicOrPrivateKey();
    internal static string get_Cryptography_OAEP_Decryption_Failed();
    internal static string get_Cryptography_PartialBlock();
    internal static string get_Cryptography_RSA_DecryptWrongSize();
    internal static string get_Cryptography_Pkcs8_EncryptedReadFailed();
    internal static string get_Cryptography_SignHash_WrongSize();
    internal static string get_Cryptography_UnsupportedPaddingMode();
    internal static string get_Cryptography_TransformBeyondEndOfBuffer();
    internal static string get_Cryptography_UnexpectedTransformTruncation();
    internal static string get_Cryptography_UnknownAlgorithmIdentifier();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownPaddingMode();
    internal static string get_Cryptography_WeakKey();
    internal static string get_Cryptography_WriteEncodedValue_OneValueAtATime();
    internal static string get_PlatformNotSupported_CryptographyCng();
    internal static string get_Cryptography_ECC_NamedCurvesOnly();
    internal static string get_Cryptography_CSP_NoPrivateKey();
    internal static string get_Cryptography_InvalidECCharacteristic2Curve();
    internal static string get_Argument_DestinationTooShort();
}
