[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.Auxiliary : object {
    [NullableAttribute("2")]
private static string _libraryName;
    private static bool _setInfo;
    private static Auxiliary();
    public static void ResetInfoDefaults();
    public static List`1<object> MergeArgs(RedisKey key, RedisValue[] items);
    public static Object[] AssembleNonNullArguments(Object[] arguments);
    [ExtensionAttribute]
public static IDatabase GetDatabase(ConnectionMultiplexer redis, string LibraryName);
    [ExtensionAttribute]
private static void SetInfoInPipeline(IDatabase db);
    [ExtensionAttribute]
public static RedisResult Execute(IDatabase db, SerializedCommand command);
    [AsyncStateMachineAttribute("NRedisStack.Auxiliary/<ExecuteAsync>d__8")]
[ExtensionAttribute]
public static Task`1<RedisResult> ExecuteAsync(IDatabaseAsync db, SerializedCommand command);
    [ExtensionAttribute]
public static List`1<RedisResult> ExecuteBroadcast(IDatabase db, string command);
    [ExtensionAttribute]
public static List`1<RedisResult> ExecuteBroadcast(IDatabase db, SerializedCommand command);
    [AsyncStateMachineAttribute("NRedisStack.Auxiliary/<ExecuteBroadcastAsync>d__11")]
[ExtensionAttribute]
public static Task`1<List`1<RedisResult>> ExecuteBroadcastAsync(IDatabaseAsync db, string command);
    [AsyncStateMachineAttribute("NRedisStack.Auxiliary/<ExecuteBroadcastAsync>d__12")]
[ExtensionAttribute]
public static Task`1<List`1<RedisResult>> ExecuteBroadcastAsync(IDatabaseAsync db, SerializedCommand command);
    public static string GetNRedisStackVersion();
}
public class NRedisStack.Bloom.DataTypes.BloomInformation : object {
    [CompilerGeneratedAttribute]
private long <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfItemsInserted>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpansionRate>k__BackingField;
    public long Capacity { get; private set; }
    public long Size { get; private set; }
    public long NumberOfFilters { get; private set; }
    public long NumberOfItemsInserted { get; private set; }
    public long ExpansionRate { get; private set; }
    internal BloomInformation(long capacity, long size, long numberOfFilters, long numberOfItemsInserted, long expansionRate);
    [CompilerGeneratedAttribute]
public long get_Capacity();
    [CompilerGeneratedAttribute]
private void set_Capacity(long value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfFilters();
    [CompilerGeneratedAttribute]
private void set_NumberOfFilters(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfItemsInserted();
    [CompilerGeneratedAttribute]
private void set_NumberOfItemsInserted(long value);
    [CompilerGeneratedAttribute]
public long get_ExpansionRate();
    [CompilerGeneratedAttribute]
private void set_ExpansionRate(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Bloom.Literals.BF : object {
    public static string ADD;
    public static string CARD;
    public static string EXISTS;
    public static string INFO;
    public static string INSERT;
    public static string LOADCHUNK;
    public static string MADD;
    public static string MEXISTS;
    public static string RESERVE;
    public static string SCANDUMP;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Bloom.Literals.BloomArgs : object {
    public static string CAPACITY;
    public static string ERROR;
    public static string EXPANSION;
    public static string NOCREATE;
    public static string NONSCALING;
    public static string ITEMS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.BloomAux : object {
    public static List`1<object> BuildInsertArgs(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, Nullable`1<double> error, Nullable`1<int> expansion, bool nocreate, bool nonscaling);
    [ExtensionAttribute]
private static void AddItems(List`1<object> args, RedisValue[] items);
    [ExtensionAttribute]
private static void AddNoScaling(List`1<object> args, bool nonscaling);
    [ExtensionAttribute]
private static void AddNoCreate(List`1<object> args, bool nocreate);
    [ExtensionAttribute]
private static void AddExpansion(List`1<object> args, Nullable`1<int> expansion);
    [ExtensionAttribute]
private static void AddError(List`1<object> args, Nullable`1<double> error);
    [ExtensionAttribute]
private static void AddCapacity(List`1<object> args, Nullable`1<int> capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.BloomCommandBuilder : object {
    public static SerializedCommand Add(RedisKey key, RedisValue item);
    public static SerializedCommand Card(RedisKey key);
    public static SerializedCommand Exists(RedisKey key, RedisValue item);
    public static SerializedCommand Info(RedisKey key);
    public static SerializedCommand Insert(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, Nullable`1<double> error, Nullable`1<int> expansion, bool nocreate, bool nonscaling);
    public static SerializedCommand LoadChunk(RedisKey key, long iterator, Byte[] data);
    public static SerializedCommand MAdd(RedisKey key, RedisValue[] items);
    public static SerializedCommand MExists(RedisKey key, RedisValue[] items);
    public static SerializedCommand Reserve(RedisKey key, double errorRate, long capacity, Nullable`1<int> expansion, bool nonscaling);
    public static SerializedCommand ScanDump(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.BloomCommands : BloomCommandsAsync {
    private IDatabase _db;
    public BloomCommands(IDatabase db);
    public sealed virtual bool Add(RedisKey key, RedisValue item);
    public sealed virtual long Card(RedisKey key);
    public sealed virtual bool Exists(RedisKey key, RedisValue item);
    public sealed virtual BloomInformation Info(RedisKey key);
    public sealed virtual Boolean[] Insert(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, Nullable`1<double> error, Nullable`1<int> expansion, bool nocreate, bool nonscaling);
    public sealed virtual bool LoadChunk(RedisKey key, long iterator, Byte[] data);
    public sealed virtual Boolean[] MAdd(RedisKey key, RedisValue[] items);
    public sealed virtual Boolean[] MExists(RedisKey key, RedisValue[] items);
    public sealed virtual bool Reserve(RedisKey key, double errorRate, long capacity, Nullable`1<int> expansion, bool nonscaling);
    public sealed virtual Tuple`2<long, Byte[]> ScanDump(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.BloomCommandsAsync : object {
    private IDatabaseAsync _db;
    public BloomCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<AddAsync>d__2")]
public sealed virtual Task`1<bool> AddAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<CardAsync>d__3")]
public sealed virtual Task`1<long> CardAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<ExistsAsync>d__4")]
public sealed virtual Task`1<bool> ExistsAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<InfoAsync>d__5")]
public sealed virtual Task`1<BloomInformation> InfoAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<InsertAsync>d__6")]
public sealed virtual Task`1<Boolean[]> InsertAsync(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, Nullable`1<double> error, Nullable`1<int> expansion, bool nocreate, bool nonscaling);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<LoadChunkAsync>d__7")]
public sealed virtual Task`1<bool> LoadChunkAsync(RedisKey key, long iterator, Byte[] data);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<MAddAsync>d__8")]
public sealed virtual Task`1<Boolean[]> MAddAsync(RedisKey key, RedisValue[] items);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<MExistsAsync>d__9")]
public sealed virtual Task`1<Boolean[]> MExistsAsync(RedisKey key, RedisValue[] items);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<ReserveAsync>d__10")]
public sealed virtual Task`1<bool> ReserveAsync(RedisKey key, double errorRate, long capacity, Nullable`1<int> expansion, bool nonscaling);
    [AsyncStateMachineAttribute("NRedisStack.BloomCommandsAsync/<ScanDumpAsync>d__11")]
public sealed virtual Task`1<Tuple`2<long, Byte[]>> ScanDumpAsync(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.CmsCommandBuilder : object {
    public static SerializedCommand IncrBy(RedisKey key, RedisValue item, long increment);
    public static SerializedCommand IncrBy(RedisKey key, Tuple`2[] itemIncrements);
    public static SerializedCommand Info(RedisKey key);
    public static SerializedCommand InitByDim(RedisKey key, long width, long depth);
    public static SerializedCommand InitByProb(RedisKey key, double error, double probability);
    public static SerializedCommand Merge(RedisValue destination, long numKeys, RedisValue[] source, Int64[] weight);
    public static SerializedCommand Query(RedisKey key, RedisValue[] items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.CmsCommands : CmsCommandsAsync {
    private IDatabase _db;
    public CmsCommands(IDatabase db);
    public sealed virtual long IncrBy(RedisKey key, RedisValue item, long increment);
    public sealed virtual Int64[] IncrBy(RedisKey key, Tuple`2[] itemIncrements);
    public sealed virtual CmsInformation Info(RedisKey key);
    public sealed virtual bool InitByDim(RedisKey key, long width, long depth);
    public sealed virtual bool InitByProb(RedisKey key, double error, double probability);
    public sealed virtual bool Merge(RedisValue destination, long numKeys, RedisValue[] source, Int64[] weight);
    public sealed virtual Int64[] Query(RedisKey key, RedisValue[] items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.CmsCommandsAsync : object {
    private IDatabaseAsync _db;
    public CmsCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.CmsCommandsAsync/<IncrByAsync>d__2")]
public sealed virtual Task`1<long> IncrByAsync(RedisKey key, RedisValue item, long increment);
    [AsyncStateMachineAttribute("NRedisStack.CmsCommandsAsync/<IncrByAsync>d__3")]
public sealed virtual Task`1<Int64[]> IncrByAsync(RedisKey key, Tuple`2[] itemIncrements);
    [AsyncStateMachineAttribute("NRedisStack.CmsCommandsAsync/<InfoAsync>d__4")]
public sealed virtual Task`1<CmsInformation> InfoAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.CmsCommandsAsync/<InitByDimAsync>d__5")]
public sealed virtual Task`1<bool> InitByDimAsync(RedisKey key, long width, long depth);
    [AsyncStateMachineAttribute("NRedisStack.CmsCommandsAsync/<InitByProbAsync>d__6")]
public sealed virtual Task`1<bool> InitByProbAsync(RedisKey key, double error, double probability);
    [AsyncStateMachineAttribute("NRedisStack.CmsCommandsAsync/<MergeAsync>d__7")]
public sealed virtual Task`1<bool> MergeAsync(RedisValue destination, long numKeys, RedisValue[] source, Int64[] weight);
    [AsyncStateMachineAttribute("NRedisStack.CmsCommandsAsync/<QueryAsync>d__8")]
public sealed virtual Task`1<Int64[]> QueryAsync(RedisKey key, RedisValue[] items);
}
public enum NRedisStack.Core.DataTypes.MinMaxModifier : Enum {
    public int value__;
    public static MinMaxModifier Min;
    public static MinMaxModifier Max;
}
[ExtensionAttribute]
public static class NRedisStack.Core.DataTypes.MinMaxModifierExtensions : object {
    [ExtensionAttribute]
public static MinMaxModifier ToMinMax(Order order);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class NRedisStack.Core.DataTypes.RedisStreamEntries : ValueType {
    [CompilerGeneratedAttribute]
private RedisKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamEntry[] <Entries>k__BackingField;
    public RedisKey Key { get; }
    public StreamEntry[] Entries { get; }
    internal RedisStreamEntries(RedisKey key, StreamEntry[] entries);
    [CompilerGeneratedAttribute]
public RedisKey get_Key();
    [CompilerGeneratedAttribute]
public StreamEntry[] get_Entries();
}
public class NRedisStack.Core.DataTypes.RedisValueWithScore : ValueType {
    [CompilerGeneratedAttribute]
private RedisValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Score>k__BackingField;
    public RedisValue Value { get; }
    public double Score { get; }
    public RedisValueWithScore(RedisValue value, double score);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RedisValue get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Score();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Core.DataTypes.StreamSpecialIds : object {
    public static string AllMessagesId;
    public static string NewMessagesId;
    public static string UndeliveredMessagesId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NRedisStack.Core.Literals.CoreArgs : object {
    public static string BLOCK;
    public static string COUNT;
    public static string GROUP;
    public static string LEFT;
    public static string MAX;
    public static string MIN;
    public static string NOACK;
    public static string RIGHT;
    public static string STREAMS;
    public static string lib_name;
    public static string lib_ver;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NRedisStack.Core.Literals.RedisCoreCommands : object {
    public static string BLMOVE;
    public static string BLMPOP;
    public static string BLPOP;
    public static string BRPOP;
    public static string BRPOPLPUSH;
    public static string BZMPOP;
    public static string BZPOPMAX;
    public static string BZPOPMIN;
    public static string CLIENT;
    public static string SETINFO;
    public static string XREAD;
    public static string XREADGROUP;
}
public enum NRedisStack.Core.SetInfoAttr : Enum {
    public int value__;
    public static SetInfoAttr LibraryName;
    public static SetInfoAttr LibraryVersion;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.CoreCommandBuilder : object {
    public static SerializedCommand ClientSetInfo(SetInfoAttr attr, string value);
    public static SerializedCommand BZMPop(double timeout, RedisKey[] keys, MinMaxModifier minMaxModifier, Nullable`1<long> count);
    public static SerializedCommand BZPopMin(RedisKey[] keys, double timeout);
    public static SerializedCommand BZPopMax(RedisKey[] keys, double timeout);
    public static SerializedCommand BLMPop(double timeout, RedisKey[] keys, ListSide listSide, Nullable`1<long> count);
    public static SerializedCommand BLPop(RedisKey[] keys, double timeout);
    public static SerializedCommand BRPop(RedisKey[] keys, double timeout);
    public static SerializedCommand BLMove(RedisKey source, RedisKey destination, ListSide sourceSide, ListSide destinationSide, double timeout);
    public static SerializedCommand BRPopLPush(RedisKey source, RedisKey destination, double timeout);
    public static SerializedCommand XRead(RedisKey[] keys, RedisValue[] positions, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds);
    public static SerializedCommand XReadGroup(RedisValue groupName, RedisValue consumerName, RedisKey[] keys, RedisValue[] positions, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds, Nullable`1<bool> noAcknowledge);
    private static SerializedCommand BlockingCommandWithKeysAndTimeout(string command, RedisKey[] keys, double timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.CoreCommands : object {
    [ExtensionAttribute]
public static bool ClientSetInfo(IDatabase db, SetInfoAttr attr, string value);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, List`1<RedisValueWithScore>> BZMPop(IDatabase db, double timeout, RedisKey[] keys, MinMaxModifier minMaxModifier, Nullable`1<long> count);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, List`1<RedisValueWithScore>> BZMPop(IDatabase db, double timeout, RedisKey key, MinMaxModifier minMaxModifier, Nullable`1<long> count);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValueWithScore> BZPopMin(IDatabase db, RedisKey[] keys, double timeout);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValueWithScore> BZPopMin(IDatabase db, RedisKey key, double timeout);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValueWithScore> BZPopMax(IDatabase db, RedisKey[] keys, double timeout);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValueWithScore> BZPopMax(IDatabase db, RedisKey key, double timeout);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, List`1<RedisValue>> BLMPop(IDatabase db, double timeout, RedisKey[] keys, ListSide listSide, Nullable`1<long> count);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, List`1<RedisValue>> BLMPop(IDatabase db, double timeout, RedisKey key, ListSide listSide, Nullable`1<long> count);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValue> BLPop(IDatabase db, RedisKey[] keys, double timeout);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValue> BLPop(IDatabase db, RedisKey key, double timeout);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValue> BRPop(IDatabase db, RedisKey[] keys, double timeout);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValue> BRPop(IDatabase db, RedisKey key, double timeout);
    [ExtensionAttribute]
public static Nullable`1<RedisValue> BLMove(IDatabase db, RedisKey source, RedisKey destination, ListSide sourceSide, ListSide destinationSide, double timeout);
    [ExtensionAttribute]
public static Nullable`1<RedisValue> BRPopLPush(IDatabase db, RedisKey source, RedisKey destination, double timeout);
    [ExtensionAttribute]
public static RedisStreamEntries[] XRead(IDatabase db, RedisKey[] keys, RedisValue[] positions, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds);
    [ExtensionAttribute]
public static StreamEntry[] XRead(IDatabase db, RedisKey key, RedisValue position, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds);
    [ExtensionAttribute]
public static RedisStreamEntries[] XReadGroup(IDatabase db, RedisValue groupName, RedisValue consumerName, RedisKey[] keys, RedisValue[] positions, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds, Nullable`1<bool> noAck);
    [ExtensionAttribute]
public static StreamEntry[] XReadGroup(IDatabase db, RedisValue groupName, RedisValue consumerName, RedisKey key, RedisValue position, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds, Nullable`1<bool> noAck);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.CoreCommandsAsync : object {
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<ClientSetInfoAsync>d__0")]
[ExtensionAttribute]
public static Task`1<bool> ClientSetInfoAsync(IDatabaseAsync db, SetInfoAttr attr, string value);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BZMPopAsync>d__1")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, List`1<RedisValueWithScore>>> BZMPopAsync(IDatabase db, double timeout, RedisKey[] keys, MinMaxModifier minMaxModifier, Nullable`1<long> count);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BZMPopAsync>d__2")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, List`1<RedisValueWithScore>>> BZMPopAsync(IDatabase db, double timeout, RedisKey key, MinMaxModifier minMaxModifier, Nullable`1<long> count);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BZPopMinAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValueWithScore>> BZPopMinAsync(IDatabase db, RedisKey[] keys, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BZPopMinAsync>d__4")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValueWithScore>> BZPopMinAsync(IDatabase db, RedisKey key, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BZPopMaxAsync>d__5")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValueWithScore>> BZPopMaxAsync(IDatabase db, RedisKey[] keys, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BZPopMaxAsync>d__6")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValueWithScore>> BZPopMaxAsync(IDatabase db, RedisKey key, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BLMPopAsync>d__7")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, List`1<RedisValue>>> BLMPopAsync(IDatabase db, double timeout, RedisKey[] keys, ListSide listSide, Nullable`1<long> count);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BLMPopAsync>d__8")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, List`1<RedisValue>>> BLMPopAsync(IDatabase db, double timeout, RedisKey key, ListSide listSide, Nullable`1<long> count);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BLPopAsync>d__9")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValue>> BLPopAsync(IDatabase db, RedisKey[] keys, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BLPopAsync>d__10")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValue>> BLPopAsync(IDatabase db, RedisKey key, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BRPopAsync>d__11")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValue>> BRPopAsync(IDatabase db, RedisKey[] keys, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BRPopAsync>d__12")]
[ExtensionAttribute]
public static Task`1<Tuple`2<RedisKey, RedisValue>> BRPopAsync(IDatabase db, RedisKey key, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BLMoveAsync>d__13")]
[ExtensionAttribute]
public static Task`1<Nullable`1<RedisValue>> BLMoveAsync(IDatabase db, RedisKey source, RedisKey destination, ListSide sourceSide, ListSide destinationSide, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<BRPopLPushAsync>d__14")]
[ExtensionAttribute]
public static Task`1<Nullable`1<RedisValue>> BRPopLPushAsync(IDatabase db, RedisKey source, RedisKey destination, double timeout);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<XReadAsync>d__15")]
[ExtensionAttribute]
public static Task`1<RedisStreamEntries[]> XReadAsync(IDatabase db, RedisKey[] keys, RedisValue[] positions, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<XReadAsync>d__16")]
[ExtensionAttribute]
public static Task`1<StreamEntry[]> XReadAsync(IDatabase db, RedisKey key, RedisValue position, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<XReadGroupAsync>d__17")]
[ExtensionAttribute]
public static Task`1<RedisStreamEntries[]> XReadGroupAsync(IDatabase db, RedisValue groupName, RedisValue consumerName, RedisKey[] keys, RedisValue[] positions, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds, Nullable`1<bool> noAck);
    [AsyncStateMachineAttribute("NRedisStack.CoreCommandsAsync/<XReadGroupAsync>d__18")]
[ExtensionAttribute]
public static Task`1<StreamEntry[]> XReadGroupAsync(IDatabase db, RedisValue groupName, RedisValue consumerName, RedisKey key, RedisValue position, Nullable`1<int> count, Nullable`1<int> timeoutMilliseconds, Nullable`1<bool> noAck);
}
public class NRedisStack.CountMinSketch.DataTypes.CmsInformation : object {
    [CompilerGeneratedAttribute]
private long <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Width { get; private set; }
    public long Depth { get; private set; }
    public long Count { get; private set; }
    internal CmsInformation(long width, long depth, long count);
    [CompilerGeneratedAttribute]
public long get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(long value);
    [CompilerGeneratedAttribute]
public long get_Depth();
    [CompilerGeneratedAttribute]
private void set_Depth(long value);
    [CompilerGeneratedAttribute]
public long get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.CountMinSketch.Literals.CMS : object {
    public static string INITBYDIM;
    public static string INITBYPROB;
    public static string INCRBY;
    public static string QUERY;
    public static string MERGE;
    public static string INFO;
}
internal class NRedisStack.CountMinSketch.Literals.CmsArgs : object {
    [NullableAttribute("1")]
public static string WEIGHTS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.CuckooCommandBuilder : object {
    public static SerializedCommand Add(RedisKey key, RedisValue item);
    public static SerializedCommand AddNX(RedisKey key, RedisValue item);
    public static SerializedCommand Count(RedisKey key, RedisValue item);
    public static SerializedCommand Del(RedisKey key, RedisValue item);
    public static SerializedCommand Exists(RedisKey key, RedisValue item);
    public static SerializedCommand Info(RedisKey key);
    public static SerializedCommand Insert(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public static SerializedCommand InsertNX(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public static SerializedCommand LoadChunk(RedisKey key, long iterator, Byte[] data);
    public static SerializedCommand MExists(RedisKey key, RedisValue[] items);
    public static SerializedCommand Reserve(RedisKey key, long capacity, Nullable`1<long> bucketSize, Nullable`1<int> maxIterations, Nullable`1<int> expansion);
    public static SerializedCommand ScanDump(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.CuckooCommands : CuckooCommandsAsync {
    private IDatabase _db;
    public CuckooCommands(IDatabase db);
    public sealed virtual bool Add(RedisKey key, RedisValue item);
    public sealed virtual bool AddNX(RedisKey key, RedisValue item);
    public sealed virtual long Count(RedisKey key, RedisValue item);
    public sealed virtual bool Del(RedisKey key, RedisValue item);
    public sealed virtual bool Exists(RedisKey key, RedisValue item);
    public sealed virtual CuckooInformation Info(RedisKey key);
    public sealed virtual Boolean[] Insert(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public sealed virtual Boolean[] InsertNX(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public sealed virtual bool LoadChunk(RedisKey key, long iterator, Byte[] data);
    public sealed virtual Boolean[] MExists(RedisKey key, RedisValue[] items);
    public sealed virtual bool Reserve(RedisKey key, long capacity, Nullable`1<long> bucketSize, Nullable`1<int> maxIterations, Nullable`1<int> expansion);
    public sealed virtual Tuple`2<long, Byte[]> ScanDump(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.CuckooCommandsAsync : object {
    private IDatabaseAsync _db;
    public CuckooCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<AddAsync>d__2")]
public sealed virtual Task`1<bool> AddAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<AddNXAsync>d__3")]
public sealed virtual Task`1<bool> AddNXAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<CountAsync>d__4")]
public sealed virtual Task`1<long> CountAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<DelAsync>d__5")]
public sealed virtual Task`1<bool> DelAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<ExistsAsync>d__6")]
public sealed virtual Task`1<bool> ExistsAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<InfoAsync>d__7")]
public sealed virtual Task`1<CuckooInformation> InfoAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<InsertAsync>d__8")]
public sealed virtual Task`1<Boolean[]> InsertAsync(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<InsertNXAsync>d__9")]
public sealed virtual Task`1<Boolean[]> InsertNXAsync(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<LoadChunkAsync>d__10")]
public sealed virtual Task`1<bool> LoadChunkAsync(RedisKey key, long iterator, Byte[] data);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<MExistsAsync>d__11")]
public sealed virtual Task`1<Boolean[]> MExistsAsync(RedisKey key, RedisValue[] items);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<ReserveAsync>d__12")]
public sealed virtual Task`1<bool> ReserveAsync(RedisKey key, long capacity, Nullable`1<long> bucketSize, Nullable`1<int> maxIterations, Nullable`1<int> expansion);
    [AsyncStateMachineAttribute("NRedisStack.CuckooCommandsAsync/<ScanDumpAsync>d__13")]
public sealed virtual Task`1<Tuple`2<long, Byte[]>> ScanDumpAsync(RedisKey key, long iterator);
}
public class NRedisStack.CuckooFilter.DataTypes.CuckooInformation : object {
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfBuckets>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfItemsInserted>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumberOfItemsDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BucketSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpansionRate>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxIterations>k__BackingField;
    public long Size { get; private set; }
    public long NumberOfBuckets { get; private set; }
    public long NumberOfFilters { get; private set; }
    public long NumberOfItemsInserted { get; private set; }
    public long NumberOfItemsDeleted { get; private set; }
    public long BucketSize { get; private set; }
    public long ExpansionRate { get; private set; }
    public long MaxIterations { get; private set; }
    internal CuckooInformation(long size, long numberOfBuckets, long numberOfFilter, long numberOfItemsInserted, long numberOfItemsDeleted, long bucketSize, long expansionRate, long maxIteration);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfBuckets();
    [CompilerGeneratedAttribute]
private void set_NumberOfBuckets(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfFilters();
    [CompilerGeneratedAttribute]
private void set_NumberOfFilters(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfItemsInserted();
    [CompilerGeneratedAttribute]
private void set_NumberOfItemsInserted(long value);
    [CompilerGeneratedAttribute]
public long get_NumberOfItemsDeleted();
    [CompilerGeneratedAttribute]
private void set_NumberOfItemsDeleted(long value);
    [CompilerGeneratedAttribute]
public long get_BucketSize();
    [CompilerGeneratedAttribute]
private void set_BucketSize(long value);
    [CompilerGeneratedAttribute]
public long get_ExpansionRate();
    [CompilerGeneratedAttribute]
private void set_ExpansionRate(long value);
    [CompilerGeneratedAttribute]
public long get_MaxIterations();
    [CompilerGeneratedAttribute]
private void set_MaxIterations(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.CuckooFilter.Literals.CF : object {
    public static string RESERVE;
    public static string ADD;
    public static string ADDNX;
    public static string INSERT;
    public static string INSERTNX;
    public static string EXISTS;
    public static string MEXISTS;
    public static string DEL;
    public static string COUNT;
    public static string SCANDUMP;
    public static string LOADCHUNK;
    public static string INFO;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.CuckooFilter.Literals.CuckooArgs : object {
    public static string CAPACITY;
    public static string EXPANSION;
    public static string NOCREATE;
    public static string ITEMS;
    public static string BUCKETSIZE;
    public static string MAXITERATIONS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.DataTypes.TimeSeriesChunck : object {
    [CompilerGeneratedAttribute]
private long <StartTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Samples>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BytesPerSample>k__BackingField;
    public long StartTimestamp { get; }
    public long EndTimestamp { get; }
    public long Samples { get; }
    public long Size { get; }
    public string BytesPerSample { get; }
    public TimeSeriesChunck(long startTimestamp, long endTimestamp, long samples, long size, string bytesPerSample);
    [CompilerGeneratedAttribute]
public long get_StartTimestamp();
    [CompilerGeneratedAttribute]
public long get_EndTimestamp();
    [CompilerGeneratedAttribute]
public long get_Samples();
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public string get_BytesPerSample();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NRedisStack.DataTypes.TimeSeriesInformation : object {
    [CompilerGeneratedAttribute]
private long <TotalSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeStamp> <FirstTimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeStamp> <LastTimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RetentionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ChunkCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxSamplesPerChunk>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ChunkSize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<TimeSeriesLabel> <Labels>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceKey>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<TimeSeriesRule> <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TsDuplicatePolicy> <DuplicatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeySelfName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<TimeSeriesChunck> <Chunks>k__BackingField;
    public long TotalSamples { get; private set; }
    public long MemoryUsage { get; private set; }
    public Nullable`1<TimeStamp> FirstTimeStamp { get; private set; }
    public Nullable`1<TimeStamp> LastTimeStamp { get; private set; }
    public long RetentionTime { get; private set; }
    public long ChunkCount { get; private set; }
    [ObsoleteAttribute("This method has been deprecated. Use ChunkSize instead.")]
public long MaxSamplesPerChunk { get; private set; }
    public long ChunkSize { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<TimeSeriesLabel> Labels { get; private set; }
    public string SourceKey { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<TimeSeriesRule> Rules { get; private set; }
    public Nullable`1<TsDuplicatePolicy> DuplicatePolicy { get; private set; }
    public string KeySelfName { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<TimeSeriesChunck> Chunks { get; private set; }
    [ObsoleteAttribute]
internal TimeSeriesInformation(long totalSamples, long memoryUsage, Nullable`1<TimeStamp> firstTimeStamp, Nullable`1<TimeStamp> lastTimeStamp, long retentionTime, long chunkCount, long chunkSize, IReadOnlyList`1<TimeSeriesLabel> labels, string sourceKey, IReadOnlyList`1<TimeSeriesRule> rules, Nullable`1<TsDuplicatePolicy> policy, string keySelfName, IReadOnlyList`1<TimeSeriesChunck> chunks);
    [CompilerGeneratedAttribute]
public long get_TotalSamples();
    [CompilerGeneratedAttribute]
private void set_TotalSamples(long value);
    [CompilerGeneratedAttribute]
public long get_MemoryUsage();
    [CompilerGeneratedAttribute]
private void set_MemoryUsage(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeStamp> get_FirstTimeStamp();
    [CompilerGeneratedAttribute]
private void set_FirstTimeStamp(Nullable`1<TimeStamp> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeStamp> get_LastTimeStamp();
    [CompilerGeneratedAttribute]
private void set_LastTimeStamp(Nullable`1<TimeStamp> value);
    [CompilerGeneratedAttribute]
public long get_RetentionTime();
    [CompilerGeneratedAttribute]
private void set_RetentionTime(long value);
    [CompilerGeneratedAttribute]
public long get_ChunkCount();
    [CompilerGeneratedAttribute]
private void set_ChunkCount(long value);
    [CompilerGeneratedAttribute]
public long get_MaxSamplesPerChunk();
    [CompilerGeneratedAttribute]
private void set_MaxSamplesPerChunk(long value);
    [CompilerGeneratedAttribute]
public long get_ChunkSize();
    [CompilerGeneratedAttribute]
private void set_ChunkSize(long value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TimeSeriesLabel> get_Labels();
    [CompilerGeneratedAttribute]
private void set_Labels(IReadOnlyList`1<TimeSeriesLabel> value);
    [CompilerGeneratedAttribute]
public string get_SourceKey();
    [CompilerGeneratedAttribute]
private void set_SourceKey(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TimeSeriesRule> get_Rules();
    [CompilerGeneratedAttribute]
private void set_Rules(IReadOnlyList`1<TimeSeriesRule> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TsDuplicatePolicy> get_DuplicatePolicy();
    [CompilerGeneratedAttribute]
private void set_DuplicatePolicy(Nullable`1<TsDuplicatePolicy> value);
    [CompilerGeneratedAttribute]
public string get_KeySelfName();
    [CompilerGeneratedAttribute]
private void set_KeySelfName(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TimeSeriesChunck> get_Chunks();
    [CompilerGeneratedAttribute]
private void set_Chunks(IReadOnlyList`1<TimeSeriesChunck> value);
    [NullableContextAttribute("1")]
public static string op_Implicit(TimeSeriesInformation info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.DataTypes.TimeSeriesLabel : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public TimeSeriesLabel(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static string op_Implicit(TimeSeriesLabel tsl);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.DataTypes.TimeSeriesRule : object {
    [CompilerGeneratedAttribute]
private string <DestKey>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeBucket>k__BackingField;
    [CompilerGeneratedAttribute]
private TsAggregation <Aggregation>k__BackingField;
    public string DestKey { get; private set; }
    public long TimeBucket { get; private set; }
    public TsAggregation Aggregation { get; private set; }
    public TimeSeriesRule(string destKey, long timeBucket, TsAggregation aggregation);
    [CompilerGeneratedAttribute]
public string get_DestKey();
    [CompilerGeneratedAttribute]
private void set_DestKey(string value);
    [CompilerGeneratedAttribute]
public long get_TimeBucket();
    [CompilerGeneratedAttribute]
private void set_TimeBucket(long value);
    [CompilerGeneratedAttribute]
public TsAggregation get_Aggregation();
    [CompilerGeneratedAttribute]
private void set_Aggregation(TsAggregation value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static string op_Implicit(TimeSeriesRule tsr);
    public virtual int GetHashCode();
}
public class NRedisStack.DataTypes.TimeSeriesTuple : object {
    [CompilerGeneratedAttribute]
private TimeStamp <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Val>k__BackingField;
    public TimeStamp Time { get; }
    public double Val { get; }
    public TimeSeriesTuple(TimeStamp time, double val);
    [CompilerGeneratedAttribute]
public TimeStamp get_Time();
    [CompilerGeneratedAttribute]
public double get_Val();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public static string op_Implicit(TimeSeriesTuple tst);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class NRedisStack.DataTypes.TimeStamp : ValueType {
    private static String[] constants;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public TimeStamp(long timestamp);
    public TimeStamp(DateTime dateTime);
    public TimeStamp(string timestamp);
    private static TimeStamp();
    [CompilerGeneratedAttribute]
public object get_Value();
    public static TimeStamp op_Implicit(long l);
    public static long op_Implicit(TimeStamp ts);
    public static TimeStamp op_Implicit(string s);
    [NullableContextAttribute("2")]
public static string op_Implicit(TimeStamp ts);
    public static TimeStamp op_Implicit(DateTime dateTime);
    public static DateTime op_Implicit(TimeStamp timeStamp);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TimeStamp left, TimeStamp right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TimeStamp left, TimeStamp right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TimeStamp other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NRedisStack.Extensions.AggregationExtensions : object {
    [ExtensionAttribute]
public static string AsArg(TsAggregation aggregation);
    public static TsAggregation AsAggregation(string aggregation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NRedisStack.Extensions.DuplicatePolicyExtensions : object {
    [ExtensionAttribute]
public static string AsArg(TsDuplicatePolicy policy);
    public static TsDuplicatePolicy AsPolicy(string policy);
}
[ExtensionAttribute]
internal static class NRedisStack.Extensions.ReduceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string AsArg(TsReduce reduce);
}
[ExtensionAttribute]
internal static class NRedisStack.Extensions.TsBucketTimestampsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string AsArg(TsBucketTimestamps bt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Gears.Literals.GearsArgs : object {
    public static string CONFIG;
    public static string REPLACE;
    public static string LOAD;
    public static string DELETE;
    public static string LIST;
    public static string WITHCODE;
    public static string LIBRARY;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Gears.Literals.RG : object {
    public static string TFUNCTION;
    public static string TFCALL;
    public static string TFCALLASYNC;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.GearsCommandBuilder : object {
    public static SerializedCommand TFunctionLoad(string libraryCode, bool replace, string config);
    public static SerializedCommand TFunctionDelete(string libraryName);
    public static SerializedCommand TFunctionList(bool withCode, int verbose, string libraryName);
    public static SerializedCommand TFCall(string libraryName, string functionName, String[] keys, String[] args, bool async);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.GearsCommands : object {
    [ExtensionAttribute]
public static bool TFunctionLoad(IDatabase db, string libraryCode, bool replace, string config);
    [ExtensionAttribute]
public static bool TFunctionDelete(IDatabase db, string libraryName);
    [ExtensionAttribute]
public static Dictionary`2[] TFunctionList(IDatabase db, bool withCode, int verbose, string libraryName);
    [ExtensionAttribute]
public static RedisResult TFCall_(IDatabase db, string libraryName, string functionName, String[] keys, String[] args);
    [ExtensionAttribute]
public static RedisResult TFCallAsync_(IDatabase db, string libraryName, string functionName, String[] keys, String[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.GearsCommandsAsync : object {
    [AsyncStateMachineAttribute("NRedisStack.GearsCommandsAsync/<TFunctionLoadAsync>d__0")]
[ExtensionAttribute]
public static Task`1<bool> TFunctionLoadAsync(IDatabase db, string libraryCode, string config, bool replace);
    [AsyncStateMachineAttribute("NRedisStack.GearsCommandsAsync/<TFunctionDeleteAsync>d__1")]
[ExtensionAttribute]
public static Task`1<bool> TFunctionDeleteAsync(IDatabase db, string libraryName);
    [AsyncStateMachineAttribute("NRedisStack.GearsCommandsAsync/<TFunctionListAsync>d__2")]
[ExtensionAttribute]
public static Task`1<Dictionary`2[]> TFunctionListAsync(IDatabase db, bool withCode, int verbose, string libraryName);
    [AsyncStateMachineAttribute("NRedisStack.GearsCommandsAsync/<TFCall_Async>d__3")]
[ExtensionAttribute]
public static Task`1<RedisResult> TFCall_Async(IDatabase db, string libraryName, string functionName, String[] keys, String[] args);
    [AsyncStateMachineAttribute("NRedisStack.GearsCommandsAsync/<TFCallAsync_Async>d__4")]
[ExtensionAttribute]
public static Task`1<RedisResult> TFCallAsync_Async(IDatabase db, string libraryName, string functionName, String[] keys, String[] args);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NRedisStack.Graph.DataTypes.Edge : GraphEntity {
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Destination>k__BackingField;
    public string RelationshipType { get; public set; }
    public long Source { get; public set; }
    public long Destination { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RelationshipType();
    [CompilerGeneratedAttribute]
public void set_RelationshipType(string value);
    [CompilerGeneratedAttribute]
public long get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(long value);
    [CompilerGeneratedAttribute]
public long get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(long value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NRedisStack.Graph.DataTypes.GraphEntity : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public IDictionary`2<string, object> PropertyMap;
    public long Id { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(long value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string PropertyMapToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Graph.DataTypes.Node : GraphEntity {
    [CompilerGeneratedAttribute]
private List`1<string> <Labels>k__BackingField;
    public List`1<string> Labels { get; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Labels();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Graph.DataTypes.Path : object {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Node> <Nodes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Edge> <Edges>k__BackingField;
    public ReadOnlyCollection`1<Node> Nodes { get; }
    public ReadOnlyCollection`1<Edge> Edges { get; }
    public Path(IList`1<Node> nodes, IList`1<Edge> edges);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Node> get_Nodes();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Edge> get_Edges();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Graph.GraphCache : object {
    [CompilerGeneratedAttribute]
private GraphCacheList <Labels>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphCacheList <PropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphCacheList <RelationshipTypes>k__BackingField;
    public GraphCacheList Labels { get; public set; }
    public GraphCacheList PropertyNames { get; public set; }
    public GraphCacheList RelationshipTypes { get; public set; }
    [ObsoleteAttribute]
public GraphCache(string graphName, GraphCommands redisGraph);
    [ObsoleteAttribute]
public GraphCache(string graphName, GraphCommandsAsync redisGraph);
    [CompilerGeneratedAttribute]
public GraphCacheList get_Labels();
    [CompilerGeneratedAttribute]
public void set_Labels(GraphCacheList value);
    [CompilerGeneratedAttribute]
public GraphCacheList get_PropertyNames();
    [CompilerGeneratedAttribute]
public void set_PropertyNames(GraphCacheList value);
    [CompilerGeneratedAttribute]
public GraphCacheList get_RelationshipTypes();
    [CompilerGeneratedAttribute]
public void set_RelationshipTypes(GraphCacheList value);
    [ObsoleteAttribute]
public string GetLabel(int index);
    [ObsoleteAttribute]
public string GetRelationshipType(int index);
    [ObsoleteAttribute]
public string GetPropertyName(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Graph.GraphCacheList : object {
    private string _graphName;
    private string _procedure;
    private String[] _data;
    [ObsoleteAttribute]
private GraphCommandsAsync _redisGraph;
    private object _locker;
    [ObsoleteAttribute]
internal GraphCacheList(string graphName, string procedure, GraphCommands redisGraph);
    [ObsoleteAttribute]
internal GraphCacheList(string graphName, string procedure, GraphCommandsAsync redisGraphAsync);
    [NullableContextAttribute("2")]
[ObsoleteAttribute]
internal string GetCachedData(int index);
    [ObsoleteAttribute]
private String[] GetProcedureInfo();
    [ObsoleteAttribute]
private ResultSet CallProcedure();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Graph.Header : object {
    [CompilerGeneratedAttribute]
private List`1<ResultSetColumnTypes> <SchemaTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SchemaNames>k__BackingField;
    [ObsoleteAttribute("SchemaType is no longer supported after RedisGraph 2.1 and will always return COLUMN_SCALAR")]
public List`1<ResultSetColumnTypes> SchemaTypes { get; }
    public List`1<string> SchemaNames { get; }
    [ObsoleteAttribute]
internal Header(RedisResult result);
    [CompilerGeneratedAttribute]
public List`1<ResultSetColumnTypes> get_SchemaTypes();
    [CompilerGeneratedAttribute]
public List`1<string> get_SchemaNames();
    [NullableContextAttribute("2")]
[ObsoleteAttribute]
public virtual bool Equals(object obj);
    [ObsoleteAttribute]
public virtual int GetHashCode();
    [ObsoleteAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Graph.Literals.GRAPH : object {
    public static string QUERY;
    public static string RO_QUERY;
    public static string DELETE;
    public static string EXPLAIN;
    public static string PROFILE;
    public static string SLOWLOG;
    public static string CONFIG;
    public static string CONFIG_SET;
    public static string CONFIG_GET;
    public static string LIST;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Graph.Literals.GraphArgs : object {
    public static string TIMEOUT;
    public static string SET;
    public static string GET;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Graph.Point : object {
    private static double EPSILON;
    [CompilerGeneratedAttribute]
private double <latitude>k__BackingField;
    [CompilerGeneratedAttribute]
private double <longitude>k__BackingField;
    private double latitude { get; }
    private double longitude { get; }
    public Point(double latitude, double longitude);
    public Point(List`1<double> values);
    private static Point();
    [CompilerGeneratedAttribute]
private double get_latitude();
    [CompilerGeneratedAttribute]
private double get_longitude();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum NRedisStack.Graph.ProcedureMode : Enum {
    public int value__;
    public static ProcedureMode Read;
    public static ProcedureMode Write;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Graph.Record : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<object> <Values>k__BackingField;
    public List`1<string> Header { get; }
    public List`1<object> Values { get; }
    public int Size { get; }
    internal Record(List`1<string> header, List`1<object> values);
    [CompilerGeneratedAttribute]
public List`1<string> get_Header();
    [CompilerGeneratedAttribute]
public List`1<object> get_Values();
    public T GetValue(int index);
    public T GetValue(string key);
    public string GetString(int index);
    public string GetString(string key);
    public bool ContainsKey(string key);
    public int get_Size();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NRedisStack.Graph.RedisGraphUtilities : object {
    internal static string PrepareQuery(string query, IDictionary`2<string, object> parms);
    public static string ValueToString(object value);
    private static string ConvertibleToString(IConvertible floatValue);
    private static string ArrayToString(Object[] array);
    internal static string QuoteCharacter(char character);
    internal static string QuoteString(string unquotedString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Graph.ResultSet : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RedisResult[] _rawResults;
    [NullableAttribute("2")]
private GraphCache _graphCache;
    [CompilerGeneratedAttribute]
private Statistics <Statistics>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public Statistics Statistics { get; }
    [NullableAttribute("2")]
public Header Header { get; }
    public int Count { get; }
    [ObsoleteAttribute]
internal ResultSet(RedisResult result, GraphCache graphCache);
    [CompilerGeneratedAttribute]
public Statistics get_Statistics();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Header get_Header();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [ObsoleteAttribute]
public sealed virtual IEnumerator`1<Record> GetEnumerator();
    [ObsoleteAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("NRedisStack.Graph.ResultSet/<RecordIterator>d__15")]
[ObsoleteAttribute]
private IEnumerable`1<Record> RecordIterator();
    [ObsoleteAttribute]
private Node DeserializeNode(RedisResult[] rawNodeData);
    [ObsoleteAttribute]
private Edge DeserializeEdge(RedisResult[] rawEdgeData);
    [ObsoleteAttribute]
private object DeserializeScalar(RedisResult[] rawScalarData);
    private static void DeserializeGraphEntityId(GraphEntity graphEntity, RedisResult rawEntityId);
    [ObsoleteAttribute]
private void DeserializeGraphEntityProperties(GraphEntity graphEntity, RedisResult[] rawProperties);
    [ObsoleteAttribute]
private Object[] DeserializeArray(RedisResult[] serializedArray);
    [ObsoleteAttribute]
private Path DeserializePath(RedisResult[] rawPath);
    private object DeserializePoint(RedisResult[] rawPath);
    [ObsoleteAttribute]
private Dictionary`2<string, object> DeserializeDictionary(RedisResult rawPath);
    private static ResultSetScalarType GetValueTypeFromObject(RedisResult rawScalarType);
    private static void ScanForErrors(RedisResult[] results);
    private Statistics ParseStatistics(RedisResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Graph.Statistics : object {
    private IDictionary`2<string, string> _statistics;
    [CompilerGeneratedAttribute]
private int <NodesCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodesDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndicesAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndicesCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndicesDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LabelsAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RelationshipsDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RelationshipsCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PropertiesSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryInternalExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GraphRemovedInternalExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CachedExecution>k__BackingField;
    public int NodesCreated { get; }
    public int NodesDeleted { get; }
    public int IndicesAdded { get; }
    public int IndicesCreated { get; }
    public int IndicesDeleted { get; }
    public int LabelsAdded { get; }
    public int RelationshipsDeleted { get; }
    public int RelationshipsCreated { get; }
    public int PropertiesSet { get; }
    public string QueryInternalExecutionTime { get; }
    public string GraphRemovedInternalExecutionTime { get; }
    public bool CachedExecution { get; }
    internal Statistics(Dictionary`2<string, string> statistics);
    public string GetStringValue(string label);
    private int GetIntValue(string label);
    [CompilerGeneratedAttribute]
public int get_NodesCreated();
    [CompilerGeneratedAttribute]
public int get_NodesDeleted();
    [CompilerGeneratedAttribute]
public int get_IndicesAdded();
    [CompilerGeneratedAttribute]
public int get_IndicesCreated();
    [CompilerGeneratedAttribute]
public int get_IndicesDeleted();
    [CompilerGeneratedAttribute]
public int get_LabelsAdded();
    [CompilerGeneratedAttribute]
public int get_RelationshipsDeleted();
    [CompilerGeneratedAttribute]
public int get_RelationshipsCreated();
    [CompilerGeneratedAttribute]
public int get_PropertiesSet();
    [CompilerGeneratedAttribute]
public string get_QueryInternalExecutionTime();
    [CompilerGeneratedAttribute]
public string get_GraphRemovedInternalExecutionTime();
    [CompilerGeneratedAttribute]
public bool get_CachedExecution();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.GraphCommandBuilder : object {
    internal static object CompactQueryFlag;
    internal static Dictionary`2<string, List`1<string>> EmptyKwargsDictionary;
    private static GraphCommandBuilder();
    public static SerializedCommand Query(string graphName, string query, Dictionary`2<string, object> parameters, Nullable`1<long> timeout);
    public static SerializedCommand Query(string graphName, string query, Nullable`1<long> timeout);
    public static SerializedCommand RO_Query(string graphName, string query, Nullable`1<long> timeout);
    public static SerializedCommand Delete(string graphName);
    public static SerializedCommand Explain(string graphName, string query);
    public static SerializedCommand Profile(string graphName, string query, Nullable`1<long> timeout);
    public static SerializedCommand List();
    public static SerializedCommand ConfigSet(string configName, object value);
    public static SerializedCommand ConfigGet(string configName);
    public static SerializedCommand Slowlog(string graphName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute]
public class NRedisStack.GraphCommands : GraphCommandsAsync {
    private IDatabase _db;
    private IDictionary`2<string, GraphCache> _graphCaches;
    private static Dictionary`2<string, List`1<string>> EmptyKwargsDictionary;
    public GraphCommands(IDatabase db);
    private static GraphCommands();
    public sealed virtual ResultSet Query(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    public sealed virtual ResultSet Query(string graphName, string query, Nullable`1<long> timeout);
    public sealed virtual ResultSet RO_Query(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    public sealed virtual ResultSet RO_Query(string graphName, string query, Nullable`1<long> timeout);
    public sealed virtual ResultSet CallProcedure(string graphName, string procedure, ProcedureMode procedureMode);
    public sealed virtual ResultSet CallProcedure(string graphName, string procedure, IEnumerable`1<string> args, ProcedureMode procedureMode);
    public sealed virtual ResultSet CallProcedure(string graphName, string procedure, IEnumerable`1<string> args, Dictionary`2<string, List`1<string>> kwargs, ProcedureMode procedureMode);
    public sealed virtual bool Delete(string graphName);
    public sealed virtual IReadOnlyList`1<string> Explain(string graphName, string query);
    public sealed virtual IReadOnlyList`1<string> Profile(string graphName, string query, Nullable`1<long> timeout);
    public sealed virtual IReadOnlyList`1<string> List();
    public sealed virtual bool ConfigSet(string configName, object value);
    public sealed virtual Dictionary`2<string, RedisResult> ConfigGet(string configName);
    public sealed virtual List`1<List`1<string>> Slowlog(string graphName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute]
public class NRedisStack.GraphCommandsAsync : object {
    private IDatabaseAsync _db;
    private IDictionary`2<string, GraphCache> _graphCaches;
    private static Dictionary`2<string, List`1<string>> EmptyKwargsDictionary;
    public GraphCommandsAsync(IDatabaseAsync db);
    private static GraphCommandsAsync();
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<QueryAsync>d__3")]
public sealed virtual Task`1<ResultSet> QueryAsync(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<QueryAsync>d__4")]
public sealed virtual Task`1<ResultSet> QueryAsync(string graphName, string query, Nullable`1<long> timeout);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<RO_QueryAsync>d__5")]
public sealed virtual Task`1<ResultSet> RO_QueryAsync(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<RO_QueryAsync>d__6")]
public sealed virtual Task`1<ResultSet> RO_QueryAsync(string graphName, string query, Nullable`1<long> timeout);
    public sealed virtual Task`1<ResultSet> CallProcedureAsync(string graphName, string procedure, ProcedureMode procedureMode);
    public sealed virtual Task`1<ResultSet> CallProcedureAsync(string graphName, string procedure, IEnumerable`1<string> args, ProcedureMode procedureMode);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<CallProcedureAsync>d__10")]
public sealed virtual Task`1<ResultSet> CallProcedureAsync(string graphName, string procedure, IEnumerable`1<string> args, Dictionary`2<string, List`1<string>> kwargs, ProcedureMode procedureMode);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<DeleteAsync>d__11")]
public sealed virtual Task`1<bool> DeleteAsync(string graphName);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<ExplainAsync>d__12")]
public sealed virtual Task`1<IReadOnlyList`1<string>> ExplainAsync(string graphName, string query);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<ProfileAsync>d__13")]
public sealed virtual Task`1<IReadOnlyList`1<string>> ProfileAsync(string graphName, string query, Nullable`1<long> timeout);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<ListAsync>d__14")]
public sealed virtual Task`1<IReadOnlyList`1<string>> ListAsync();
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<ConfigSetAsync>d__15")]
public sealed virtual Task`1<bool> ConfigSetAsync(string configName, object value);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<ConfigGetAsync>d__16")]
public sealed virtual Task`1<Dictionary`2<string, RedisResult>> ConfigGetAsync(string configName);
    [AsyncStateMachineAttribute("NRedisStack.GraphCommandsAsync/<SlowlogAsync>d__17")]
public sealed virtual Task`1<List`1<List`1<string>>> SlowlogAsync(string graphName);
}
[NullableContextAttribute("1")]
public interface NRedisStack.IBloomCommands {
    public abstract virtual bool Add(RedisKey key, RedisValue item);
    public abstract virtual long Card(RedisKey key);
    public abstract virtual bool Exists(RedisKey key, RedisValue item);
    public abstract virtual BloomInformation Info(RedisKey key);
    public abstract virtual Boolean[] Insert(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, Nullable`1<double> error, Nullable`1<int> expansion, bool nocreate, bool nonscaling);
    public abstract virtual bool LoadChunk(RedisKey key, long iterator, Byte[] data);
    public abstract virtual Boolean[] MAdd(RedisKey key, RedisValue[] items);
    public abstract virtual Boolean[] MExists(RedisKey key, RedisValue[] items);
    public abstract virtual bool Reserve(RedisKey key, double errorRate, long capacity, Nullable`1<int> expansion, bool nonscaling);
    public abstract virtual Tuple`2<long, Byte[]> ScanDump(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
public interface NRedisStack.IBloomCommandsAsync {
    public abstract virtual Task`1<bool> AddAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<long> CardAsync(RedisKey key);
    public abstract virtual Task`1<bool> ExistsAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<BloomInformation> InfoAsync(RedisKey key);
    public abstract virtual Task`1<Boolean[]> InsertAsync(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, Nullable`1<double> error, Nullable`1<int> expansion, bool nocreate, bool nonscaling);
    public abstract virtual Task`1<bool> LoadChunkAsync(RedisKey key, long iterator, Byte[] data);
    public abstract virtual Task`1<Boolean[]> MAddAsync(RedisKey key, RedisValue[] items);
    public abstract virtual Task`1<Boolean[]> MExistsAsync(RedisKey key, RedisValue[] items);
    public abstract virtual Task`1<bool> ReserveAsync(RedisKey key, double errorRate, long capacity, Nullable`1<int> expansion, bool nonscaling);
    public abstract virtual Task`1<Tuple`2<long, Byte[]>> ScanDumpAsync(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ICmsCommands {
    public abstract virtual long IncrBy(RedisKey key, RedisValue item, long increment);
    public abstract virtual Int64[] IncrBy(RedisKey key, Tuple`2[] itemIncrements);
    public abstract virtual CmsInformation Info(RedisKey key);
    public abstract virtual bool InitByDim(RedisKey key, long width, long depth);
    public abstract virtual bool InitByProb(RedisKey key, double error, double probability);
    public abstract virtual bool Merge(RedisValue destination, long numKeys, RedisValue[] source, Int64[] weight);
    public abstract virtual Int64[] Query(RedisKey key, RedisValue[] items);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ICmsCommandsAsync {
    public abstract virtual Task`1<long> IncrByAsync(RedisKey key, RedisValue item, long increment);
    public abstract virtual Task`1<Int64[]> IncrByAsync(RedisKey key, Tuple`2[] itemIncrements);
    public abstract virtual Task`1<CmsInformation> InfoAsync(RedisKey key);
    public abstract virtual Task`1<bool> InitByDimAsync(RedisKey key, long width, long depth);
    public abstract virtual Task`1<bool> InitByProbAsync(RedisKey key, double error, double probability);
    public abstract virtual Task`1<bool> MergeAsync(RedisValue destination, long numKeys, RedisValue[] source, Int64[] weight);
    public abstract virtual Task`1<Int64[]> QueryAsync(RedisKey key, RedisValue[] items);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ICuckooCommands {
    public abstract virtual bool Add(RedisKey key, RedisValue item);
    public abstract virtual bool AddNX(RedisKey key, RedisValue item);
    public abstract virtual long Count(RedisKey key, RedisValue item);
    public abstract virtual bool Del(RedisKey key, RedisValue item);
    public abstract virtual bool Exists(RedisKey key, RedisValue item);
    public abstract virtual CuckooInformation Info(RedisKey key);
    public abstract virtual Boolean[] Insert(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public abstract virtual Boolean[] InsertNX(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public abstract virtual bool LoadChunk(RedisKey key, long iterator, Byte[] data);
    public abstract virtual Boolean[] MExists(RedisKey key, RedisValue[] items);
    public abstract virtual bool Reserve(RedisKey key, long capacity, Nullable`1<long> bucketSize, Nullable`1<int> maxIterations, Nullable`1<int> expansion);
    public abstract virtual Tuple`2<long, Byte[]> ScanDump(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ICuckooCommandsAsync {
    public abstract virtual Task`1<bool> AddAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<bool> AddNXAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<long> CountAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<bool> DelAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<bool> ExistsAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<CuckooInformation> InfoAsync(RedisKey key);
    public abstract virtual Task`1<Boolean[]> InsertAsync(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public abstract virtual Task`1<Boolean[]> InsertNXAsync(RedisKey key, RedisValue[] items, Nullable`1<int> capacity, bool nocreate);
    public abstract virtual Task`1<bool> LoadChunkAsync(RedisKey key, long iterator, Byte[] data);
    public abstract virtual Task`1<Boolean[]> MExistsAsync(RedisKey key, RedisValue[] items);
    public abstract virtual Task`1<bool> ReserveAsync(RedisKey key, long capacity, Nullable`1<long> bucketSize, Nullable`1<int> maxIterations, Nullable`1<int> expansion);
    public abstract virtual Task`1<Tuple`2<long, Byte[]>> ScanDumpAsync(RedisKey key, long iterator);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("RedisGraph support is deprecated as of Redis Stack 7.2 (https://redis.com/blog/redisgraph-eol/)")]
public interface NRedisStack.IGraphCommands {
    public abstract virtual ResultSet Query(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    public abstract virtual ResultSet Query(string graphName, string query, Nullable`1<long> timeout);
    public abstract virtual ResultSet RO_Query(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    public abstract virtual ResultSet RO_Query(string graphName, string query, Nullable`1<long> timeout);
    public abstract virtual ResultSet CallProcedure(string graphName, string procedure, ProcedureMode procedureMode);
    public abstract virtual ResultSet CallProcedure(string graphName, string procedure, IEnumerable`1<string> args, ProcedureMode procedureMode);
    public abstract virtual ResultSet CallProcedure(string graphName, string procedure, IEnumerable`1<string> args, Dictionary`2<string, List`1<string>> kwargs, ProcedureMode procedureMode);
    public abstract virtual bool Delete(string graphName);
    public abstract virtual IReadOnlyList`1<string> Explain(string graphName, string query);
    public abstract virtual IReadOnlyList`1<string> Profile(string graphName, string query, Nullable`1<long> timeout);
    public abstract virtual IReadOnlyList`1<string> List();
    public abstract virtual bool ConfigSet(string configName, object value);
    public abstract virtual Dictionary`2<string, RedisResult> ConfigGet(string configName);
    public abstract virtual List`1<List`1<string>> Slowlog(string graphName);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("RedisGraph support is deprecated as of Redis Stack 7.2 (https://redis.com/blog/redisgraph-eol/)")]
public interface NRedisStack.IGraphCommandsAsync {
    public abstract virtual Task`1<ResultSet> QueryAsync(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    public abstract virtual Task`1<ResultSet> QueryAsync(string graphName, string query, Nullable`1<long> timeout);
    public abstract virtual Task`1<ResultSet> RO_QueryAsync(string graphName, string query, IDictionary`2<string, object> parameters, Nullable`1<long> timeout);
    public abstract virtual Task`1<ResultSet> RO_QueryAsync(string graphName, string query, Nullable`1<long> timeout);
    public abstract virtual Task`1<ResultSet> CallProcedureAsync(string graphName, string procedure, ProcedureMode procedureMode);
    public abstract virtual Task`1<ResultSet> CallProcedureAsync(string graphName, string procedure, IEnumerable`1<string> args, ProcedureMode procedureMode);
    public abstract virtual Task`1<ResultSet> CallProcedureAsync(string graphName, string procedure, IEnumerable`1<string> args, Dictionary`2<string, List`1<string>> kwargs, ProcedureMode procedureMode);
    public abstract virtual Task`1<bool> DeleteAsync(string graphName);
    public abstract virtual Task`1<IReadOnlyList`1<string>> ExplainAsync(string graphName, string query);
    public abstract virtual Task`1<IReadOnlyList`1<string>> ProfileAsync(string graphName, string query, Nullable`1<long> timeout);
    public abstract virtual Task`1<IReadOnlyList`1<string>> ListAsync();
    public abstract virtual Task`1<bool> ConfigSetAsync(string configName, object value);
    public abstract virtual Task`1<Dictionary`2<string, RedisResult>> ConfigGetAsync(string configName);
    public abstract virtual Task`1<List`1<List`1<string>>> SlowlogAsync(string graphName);
}
[NullableContextAttribute("1")]
public interface NRedisStack.IJsonCommands {
    public abstract virtual Nullable`1[] ArrAppend(RedisKey key, string path, Object[] values);
    public abstract virtual Nullable`1[] ArrIndex(RedisKey key, string path, object value, Nullable`1<long> start, Nullable`1<long> stop);
    public abstract virtual Nullable`1[] ArrInsert(RedisKey key, string path, long index, Object[] values);
    public abstract virtual Nullable`1[] ArrLen(RedisKey key, string path);
    public abstract virtual RedisResult[] ArrPop(RedisKey key, string path, Nullable`1<long> index);
    public abstract virtual Nullable`1[] ArrTrim(RedisKey key, string path, long start, long stop);
    [NullableContextAttribute("2")]
public abstract virtual long Clear(RedisKey key, string path);
    [NullableContextAttribute("2")]
public abstract virtual long Del(RedisKey key, string path);
    [NullableContextAttribute("2")]
public abstract virtual long Forget(RedisKey key, string path);
    public abstract virtual RedisResult Get(RedisKey key, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space, Nullable`1<RedisValue> path);
    public abstract virtual RedisResult Get(RedisKey key, String[] paths, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space);
    [NullableContextAttribute("2")]
public abstract virtual T Get(RedisKey key, string path, JsonSerializerOptions serializerOptions);
    public abstract virtual IEnumerable`1<T> GetEnumerable(RedisKey key, string path);
    public abstract virtual RedisResult[] MGet(RedisKey[] keys, string path);
    public abstract virtual Nullable`1[] NumIncrby(RedisKey key, string path, double value);
    public abstract virtual IEnumerable`1<HashSet`1<string>> ObjKeys(RedisKey key, string path);
    public abstract virtual Nullable`1[] ObjLen(RedisKey key, string path);
    public abstract virtual RedisResult[] Resp(RedisKey key, string path);
    public abstract virtual bool Set(RedisKey key, RedisValue path, object obj, When when, JsonSerializerOptions serializerOptions);
    public abstract virtual bool Set(RedisKey key, RedisValue path, RedisValue json, When when);
    public abstract virtual bool MSet(KeyPathValue[] KeyPathValueList);
    public abstract virtual bool Merge(RedisKey key, RedisValue path, RedisValue json);
    public abstract virtual bool Merge(RedisKey key, RedisValue path, object obj, JsonSerializerOptions serializerOptions);
    public abstract virtual bool SetFromFile(RedisKey key, RedisValue path, string filePath, When when);
    public abstract virtual int SetFromDirectory(RedisValue path, string filesPath, When when);
    public abstract virtual Nullable`1[] StrAppend(RedisKey key, string value, string path);
    public abstract virtual Nullable`1[] StrLen(RedisKey key, string path);
    public abstract virtual Nullable`1[] Toggle(RedisKey key, string path);
    public abstract virtual JsonType[] Type(RedisKey key, string path);
    public abstract virtual long DebugMemory(string key, string path);
}
[NullableContextAttribute("1")]
public interface NRedisStack.IJsonCommandsAsync {
    public abstract virtual Task`1<Nullable`1[]> ArrAppendAsync(RedisKey key, string path, Object[] values);
    public abstract virtual Task`1<Nullable`1[]> ArrIndexAsync(RedisKey key, string path, object value, Nullable`1<long> start, Nullable`1<long> stop);
    public abstract virtual Task`1<Nullable`1[]> ArrInsertAsync(RedisKey key, string path, long index, Object[] values);
    public abstract virtual Task`1<Nullable`1[]> ArrLenAsync(RedisKey key, string path);
    public abstract virtual Task`1<RedisResult[]> ArrPopAsync(RedisKey key, string path, Nullable`1<long> index);
    public abstract virtual Task`1<Nullable`1[]> ArrTrimAsync(RedisKey key, string path, long start, long stop);
    public abstract virtual Task`1<long> ClearAsync(RedisKey key, string path);
    public abstract virtual Task`1<long> DelAsync(RedisKey key, string path);
    public abstract virtual Task`1<long> ForgetAsync(RedisKey key, string path);
    public abstract virtual Task`1<RedisResult> GetAsync(RedisKey key, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space, Nullable`1<RedisValue> path);
    public abstract virtual Task`1<RedisResult> GetAsync(RedisKey key, String[] paths, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space);
    [NullableContextAttribute("2")]
public abstract virtual Task`1<T> GetAsync(RedisKey key, string path, JsonSerializerOptions serializerOptions);
    public abstract virtual Task`1<IEnumerable`1<T>> GetEnumerableAsync(RedisKey key, string path);
    public abstract virtual Task`1<RedisResult[]> MGetAsync(RedisKey[] keys, string path);
    public abstract virtual Task`1<Nullable`1[]> NumIncrbyAsync(RedisKey key, string path, double value);
    public abstract virtual Task`1<IEnumerable`1<HashSet`1<string>>> ObjKeysAsync(RedisKey key, string path);
    public abstract virtual Task`1<Nullable`1[]> ObjLenAsync(RedisKey key, string path);
    public abstract virtual Task`1<RedisResult[]> RespAsync(RedisKey key, string path);
    public abstract virtual Task`1<bool> SetAsync(RedisKey key, RedisValue path, object obj, When when, JsonSerializerOptions serializerOptions);
    public abstract virtual Task`1<bool> SetAsync(RedisKey key, RedisValue path, RedisValue json, When when);
    public abstract virtual Task`1<bool> MSetAsync(KeyPathValue[] KeyPathValueList);
    public abstract virtual Task`1<bool> MergeAsync(RedisKey key, RedisValue path, RedisValue json);
    public abstract virtual Task`1<bool> MergeAsync(RedisKey key, RedisValue path, object obj, JsonSerializerOptions serializerOptions);
    public abstract virtual Task`1<bool> SetFromFileAsync(RedisKey key, RedisValue path, string filePath, When when);
    public abstract virtual Task`1<int> SetFromDirectoryAsync(RedisValue path, string filesPath, When when);
    public abstract virtual Task`1<Nullable`1[]> StrAppendAsync(RedisKey key, string value, string path);
    public abstract virtual Task`1<Nullable`1[]> StrLenAsync(RedisKey key, string path);
    public abstract virtual Task`1<Nullable`1[]> ToggleAsync(RedisKey key, string path);
    public abstract virtual Task`1<JsonType[]> TypeAsync(RedisKey key, string path);
    public abstract virtual Task`1<long> DebugMemoryAsync(string key, string path);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ISearchCommands {
    public abstract virtual RedisResult[] _List();
    public abstract virtual AggregationResult Aggregate(string index, AggregationRequest query);
    public abstract virtual bool AliasAdd(string alias, string index);
    public abstract virtual bool AliasDel(string alias);
    public abstract virtual bool AliasUpdate(string alias, string index);
    public abstract virtual bool Alter(string index, Schema schema, bool skipInitialScan);
    public abstract virtual Dictionary`2<string, string> ConfigGet(string option);
    public abstract virtual bool ConfigSet(string option, string value);
    public abstract virtual bool Create(string indexName, FTCreateParams parameters, Schema schema);
    public abstract virtual bool CursorDel(string indexName, long cursorId);
    public abstract virtual AggregationResult CursorRead(string indexName, long cursorId, Nullable`1<int> count);
    public abstract virtual long DictAdd(string dict, String[] terms);
    public abstract virtual long DictDel(string dict, String[] terms);
    public abstract virtual RedisResult[] DictDump(string dict);
    public abstract virtual bool DropIndex(string indexName, bool dd);
    public abstract virtual string Explain(string indexName, string query, Nullable`1<int> dialect);
    public abstract virtual RedisResult[] ExplainCli(string indexName, string query, Nullable`1<int> dialect);
    public abstract virtual InfoResult Info(RedisValue index);
    public abstract virtual Tuple`2<SearchResult, Dictionary`2<string, RedisResult>> ProfileSearch(string indexName, Query q, bool limited);
    public abstract virtual Tuple`2<AggregationResult, Dictionary`2<string, RedisResult>> ProfileAggregate(string indexName, AggregationRequest query, bool limited);
    public abstract virtual SearchResult Search(string indexName, Query q);
    public abstract virtual Dictionary`2<string, List`1<string>> SynDump(string indexName);
    public abstract virtual Dictionary`2<string, Dictionary`2<string, double>> SpellCheck(string indexName, string query, FTSpellCheckParams spellCheckParams);
    public abstract virtual long SugAdd(string key, string str, double score, bool increment, string payload);
    public abstract virtual bool SugDel(string key, string str);
    public abstract virtual List`1<string> SugGet(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    public abstract virtual List`1<Tuple`2<string, double>> SugGetWithScores(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    public abstract virtual long SugLen(string key);
    public abstract virtual bool SynUpdate(string indexName, string synonymGroupId, bool skipInitialScan, String[] terms);
    public abstract virtual RedisResult[] TagVals(string indexName, string fieldName);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ISearchCommandsAsync {
    public abstract virtual Task`1<RedisResult[]> _ListAsync();
    public abstract virtual Task`1<AggregationResult> AggregateAsync(string index, AggregationRequest query);
    public abstract virtual Task`1<bool> AliasAddAsync(string alias, string index);
    public abstract virtual Task`1<bool> AliasDelAsync(string alias);
    public abstract virtual Task`1<bool> AliasUpdateAsync(string alias, string index);
    public abstract virtual Task`1<bool> AlterAsync(string index, Schema schema, bool skipInitialScan);
    public abstract virtual Task`1<Dictionary`2<string, string>> ConfigGetAsync(string option);
    public abstract virtual Task`1<bool> ConfigSetAsync(string option, string value);
    public abstract virtual Task`1<bool> CreateAsync(string indexName, FTCreateParams parameters, Schema schema);
    public abstract virtual Task`1<bool> CursorDelAsync(string indexName, long cursorId);
    public abstract virtual Task`1<AggregationResult> CursorReadAsync(string indexName, long cursorId, Nullable`1<int> count);
    public abstract virtual Task`1<long> DictAddAsync(string dict, String[] terms);
    public abstract virtual Task`1<long> DictDelAsync(string dict, String[] terms);
    public abstract virtual Task`1<RedisResult[]> DictDumpAsync(string dict);
    public abstract virtual Task`1<bool> DropIndexAsync(string indexName, bool dd);
    public abstract virtual Task`1<string> ExplainAsync(string indexName, string query, Nullable`1<int> dialect);
    public abstract virtual Task`1<RedisResult[]> ExplainCliAsync(string indexName, string query, Nullable`1<int> dialect);
    public abstract virtual Task`1<InfoResult> InfoAsync(RedisValue index);
    public abstract virtual Task`1<Tuple`2<SearchResult, Dictionary`2<string, RedisResult>>> ProfileSearchAsync(string indexName, Query q, bool limited);
    public abstract virtual Task`1<Tuple`2<AggregationResult, Dictionary`2<string, RedisResult>>> ProfileAggregateAsync(string indexName, AggregationRequest query, bool limited);
    public abstract virtual Task`1<SearchResult> SearchAsync(string indexName, Query q);
    public abstract virtual Task`1<Dictionary`2<string, Dictionary`2<string, double>>> SpellCheckAsync(string indexName, string query, FTSpellCheckParams spellCheckParams);
    public abstract virtual Task`1<long> SugAddAsync(string key, string str, double score, bool increment, string payload);
    public abstract virtual Task`1<bool> SugDelAsync(string key, string str);
    public abstract virtual Task`1<List`1<string>> SugGetAsync(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    public abstract virtual Task`1<List`1<Tuple`2<string, double>>> SugGetWithScoresAsync(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    public abstract virtual Task`1<long> SugLenAsync(string key);
    public abstract virtual Task`1<Dictionary`2<string, List`1<string>>> SynDumpAsync(string indexName);
    public abstract virtual Task`1<bool> SynUpdateAsync(string indexName, string synonymGroupId, bool skipInitialScan, String[] terms);
    public abstract virtual Task`1<RedisResult[]> TagValsAsync(string indexName, string fieldName);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ITdigestCommands {
    public abstract virtual bool Add(RedisKey key, Double[] values);
    public abstract virtual Double[] CDF(RedisKey key, Double[] values);
    public abstract virtual bool Create(RedisKey key, long compression);
    public abstract virtual TdigestInformation Info(RedisKey key);
    public abstract virtual double Max(RedisKey key);
    public abstract virtual double Min(RedisKey key);
    public abstract virtual bool Merge(RedisKey destinationKey, long compression, bool overide, RedisKey[] sourceKeys);
    public abstract virtual Double[] Quantile(RedisKey key, Double[] quantile);
    public abstract virtual Int64[] Rank(RedisKey key, Int64[] values);
    public abstract virtual Int64[] RevRank(RedisKey key, Int64[] values);
    public abstract virtual Double[] ByRank(RedisKey key, Int64[] ranks);
    public abstract virtual Double[] ByRevRank(RedisKey key, Int64[] ranks);
    public abstract virtual bool Reset(RedisKey key);
    public abstract virtual double TrimmedMean(RedisKey key, double lowCutQuantile, double highCutQuantile);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ITdigestCommandsAsync {
    public abstract virtual Task`1<bool> AddAsync(RedisKey key, Double[] values);
    public abstract virtual Task`1<Double[]> CDFAsync(RedisKey key, Double[] values);
    public abstract virtual Task`1<bool> CreateAsync(RedisKey key, long compression);
    public abstract virtual Task`1<TdigestInformation> InfoAsync(RedisKey key);
    public abstract virtual Task`1<double> MaxAsync(RedisKey key);
    public abstract virtual Task`1<double> MinAsync(RedisKey key);
    public abstract virtual Task`1<bool> MergeAsync(RedisKey destinationKey, long compression, bool overide, RedisKey[] sourceKeys);
    public abstract virtual Task`1<Double[]> QuantileAsync(RedisKey key, Double[] quantile);
    public abstract virtual Task`1<Int64[]> RankAsync(RedisKey key, Int64[] values);
    public abstract virtual Task`1<Int64[]> RevRankAsync(RedisKey key, Int64[] values);
    public abstract virtual Task`1<Double[]> ByRankAsync(RedisKey key, Int64[] ranks);
    public abstract virtual Task`1<Double[]> ByRevRankAsync(RedisKey key, Int64[] ranks);
    public abstract virtual Task`1<bool> ResetAsync(RedisKey key);
    public abstract virtual Task`1<double> TrimmedMeanAsync(RedisKey key, double lowCutQuantile, double highCutQuantile);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ITimeSeriesCommands {
    public abstract virtual bool Create(string key, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public abstract virtual bool Alter(string key, Nullable`1<long> retentionTime, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy, IReadOnlyCollection`1<TimeSeriesLabel> labels);
    public abstract virtual TimeStamp Add(string key, TimeStamp timestamp, double value, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public abstract virtual IReadOnlyList`1<TimeStamp> MAdd(IReadOnlyCollection`1<ValueTuple`3<string, TimeStamp, double>> sequence);
    public abstract virtual TimeStamp IncrBy(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public abstract virtual TimeStamp DecrBy(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public abstract virtual long Del(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp);
    public abstract virtual bool CreateRule(string sourceKey, TimeSeriesRule rule, long alignTimestamp);
    public abstract virtual bool DeleteRule(string sourceKey, string destKey);
    public abstract virtual TimeSeriesTuple Get(string key, bool latest);
    public abstract virtual IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, TimeSeriesTuple>> MGet(IReadOnlyCollection`1<string> filter, bool latest, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectedLabels);
    public abstract virtual IReadOnlyList`1<TimeSeriesTuple> Range(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    public abstract virtual IReadOnlyList`1<TimeSeriesTuple> RevRange(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    [NullableContextAttribute("0")]
public abstract virtual IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>> MRange(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    [NullableContextAttribute("0")]
public abstract virtual IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>> MRevRange(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    public abstract virtual TimeSeriesInformation Info(string key, bool debug);
    public abstract virtual IReadOnlyList`1<string> QueryIndex(IReadOnlyCollection`1<string> filter);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ITimeSeriesCommandsAsync {
    public abstract virtual Task`1<bool> CreateAsync(string key, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public abstract virtual Task`1<bool> AlterAsync(string key, Nullable`1<long> retentionTime, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy, IReadOnlyCollection`1<TimeSeriesLabel> labels);
    public abstract virtual Task`1<TimeStamp> AddAsync(string key, TimeStamp timestamp, double value, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public abstract virtual Task`1<IReadOnlyList`1<TimeStamp>> MAddAsync(IReadOnlyCollection`1<ValueTuple`3<string, TimeStamp, double>> sequence);
    public abstract virtual Task`1<TimeStamp> IncrByAsync(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public abstract virtual Task`1<TimeStamp> DecrByAsync(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public abstract virtual Task`1<long> DelAsync(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp);
    public abstract virtual Task`1<bool> CreateRuleAsync(string sourceKey, TimeSeriesRule rule, long alignTimestamp);
    public abstract virtual Task`1<bool> DeleteRuleAsync(string sourceKey, string destKey);
    public abstract virtual Task`1<TimeSeriesTuple> GetAsync(string key, bool latest);
    public abstract virtual Task`1<IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, TimeSeriesTuple>>> MGetAsync(IReadOnlyCollection`1<string> filter, bool latest, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectedLabels);
    public abstract virtual Task`1<IReadOnlyList`1<TimeSeriesTuple>> RangeAsync(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    public abstract virtual Task`1<IReadOnlyList`1<TimeSeriesTuple>> RevRangeAsync(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    [NullableContextAttribute("0")]
public abstract virtual Task`1<IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>>> MRangeAsync(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    [NullableContextAttribute("0")]
public abstract virtual Task`1<IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>>> MRevRangeAsync(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    public abstract virtual Task`1<TimeSeriesInformation> InfoAsync(string key, bool debug);
    public abstract virtual Task`1<IReadOnlyList`1<string>> QueryIndexAsync(IReadOnlyCollection`1<string> filter);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ITopKCommands {
    public abstract virtual RedisResult[] Add(RedisKey key, RedisValue[] items);
    [ObsoleteAttribute("TOPK.COUNT is deprecated as of Bloom 2.4.0")]
public abstract virtual Int64[] Count(RedisKey key, RedisValue[] items);
    public abstract virtual RedisResult[] IncrBy(RedisKey key, Tuple`2[] itemIncrements);
    public abstract virtual TopKInformation Info(RedisKey key);
    public abstract virtual RedisResult[] List(RedisKey key, bool withcount);
    public abstract virtual bool Query(RedisKey key, RedisValue item);
    public abstract virtual Boolean[] Query(RedisKey key, RedisValue[] items);
    public abstract virtual bool Reserve(RedisKey key, long topk, long width, long depth, double decay);
}
[NullableContextAttribute("1")]
public interface NRedisStack.ITopKCommandsAsync {
    public abstract virtual Task`1<RedisResult[]> AddAsync(RedisKey key, RedisValue[] items);
    [ObsoleteAttribute("TOPK.COUNT is deprecated as of Bloom 2.4.0")]
public abstract virtual Task`1<Int64[]> CountAsync(RedisKey key, RedisValue[] items);
    public abstract virtual Task`1<RedisResult[]> IncrByAsync(RedisKey key, Tuple`2[] itemIncrements);
    public abstract virtual Task`1<TopKInformation> InfoAsync(RedisKey key);
    public abstract virtual Task`1<RedisResult[]> ListAsync(RedisKey key, bool withcount);
    public abstract virtual Task`1<bool> QueryAsync(RedisKey key, RedisValue item);
    public abstract virtual Task`1<Boolean[]> QueryAsync(RedisKey key, RedisValue[] items);
    public abstract virtual Task`1<bool> ReserveAsync(RedisKey key, long topk, long width, long depth, double decay);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Json.DataTypes.KeyPathValue : ValueType {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Key { get; public set; }
    public string Path { get; public set; }
    public object Value { get; public set; }
    public KeyPathValue(string key, string path, object value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public String[] ToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Json.Literals.JSON : object {
    public static string ARRAPPEND;
    public static string ARRINDEX;
    public static string ARRINSERT;
    public static string ARRLEN;
    public static string ARRPOP;
    public static string ARRTRIM;
    public static string CLEAR;
    public static string DEBUG;
    public static string DEBUG_HELP;
    public static string DEL;
    public static string FORGET;
    public static string GET;
    public static string MEMORY;
    public static string MERGE;
    public static string MSET;
    public static string MGET;
    public static string NUMINCRBY;
    public static string NUMMULTBY;
    public static string OBJKEYS;
    public static string OBJLEN;
    public static string RESP;
    public static string SET;
    public static string STRAPPEND;
    public static string STRLEN;
    public static string TOGGLE;
    public static string TYPE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Json.Literals.JsonArgs : object {
    public static string INDENT;
    public static string NEWLINE;
    public static string SPACE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.JsonCommandBuilder : object {
    public static SerializedCommand Resp(RedisKey key, string path);
    public static SerializedCommand Set(RedisKey key, RedisValue path, RedisValue json, When when);
    public static SerializedCommand MSet(KeyPathValue[] KeyPathValueList);
    public static SerializedCommand Merge(RedisKey key, RedisValue path, RedisValue json);
    public static SerializedCommand StrAppend(RedisKey key, string value, string path);
    public static SerializedCommand StrLen(RedisKey key, string path);
    public static SerializedCommand Toggle(RedisKey key, string path);
    public static SerializedCommand Type(RedisKey key, string path);
    public static SerializedCommand DebugMemory(string key, string path);
    public static SerializedCommand ArrAppend(RedisKey key, string path, Object[] values);
    public static SerializedCommand ArrIndex(RedisKey key, string path, object value, Nullable`1<long> start, Nullable`1<long> stop);
    public static SerializedCommand ArrInsert(RedisKey key, string path, long index, Object[] values);
    public static SerializedCommand ArrLen(RedisKey key, string path);
    public static SerializedCommand ArrPop(RedisKey key, string path, Nullable`1<long> index);
    public static SerializedCommand ArrTrim(RedisKey key, string path, long start, long stop);
    public static SerializedCommand Clear(RedisKey key, string path);
    public static SerializedCommand Del(RedisKey key, string path);
    public static SerializedCommand Get(RedisKey key, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space, Nullable`1<RedisValue> path);
    public static SerializedCommand Get(RedisKey key, String[] paths, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space);
    public static SerializedCommand Get(RedisKey key, string path);
    public static SerializedCommand MGet(RedisKey[] keys, string path);
    public static SerializedCommand NumIncrby(RedisKey key, string path, double value);
    public static SerializedCommand ObjKeys(RedisKey key, string path);
    public static SerializedCommand ObjLen(RedisKey key, string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.JsonCommands : JsonCommandsAsync {
    private IDatabase _db;
    public JsonCommands(IDatabase db);
    public sealed virtual RedisResult[] Resp(RedisKey key, string path);
    public sealed virtual bool Set(RedisKey key, RedisValue path, object obj, When when, JsonSerializerOptions serializerOptions);
    public sealed virtual bool Set(RedisKey key, RedisValue path, RedisValue json, When when);
    public sealed virtual bool MSet(KeyPathValue[] KeyPathValueList);
    public sealed virtual bool Merge(RedisKey key, RedisValue path, RedisValue json);
    public sealed virtual bool Merge(RedisKey key, RedisValue path, object obj, JsonSerializerOptions serializerOptions);
    public sealed virtual bool SetFromFile(RedisKey key, RedisValue path, string filePath, When when);
    public sealed virtual int SetFromDirectory(RedisValue path, string filesPath, When when);
    public sealed virtual Nullable`1[] StrAppend(RedisKey key, string value, string path);
    public sealed virtual Nullable`1[] StrLen(RedisKey key, string path);
    public sealed virtual Nullable`1[] Toggle(RedisKey key, string path);
    public sealed virtual JsonType[] Type(RedisKey key, string path);
    public sealed virtual long DebugMemory(string key, string path);
    public sealed virtual Nullable`1[] ArrAppend(RedisKey key, string path, Object[] values);
    public sealed virtual Nullable`1[] ArrIndex(RedisKey key, string path, object value, Nullable`1<long> start, Nullable`1<long> stop);
    public sealed virtual Nullable`1[] ArrInsert(RedisKey key, string path, long index, Object[] values);
    public sealed virtual Nullable`1[] ArrLen(RedisKey key, string path);
    public sealed virtual RedisResult[] ArrPop(RedisKey key, string path, Nullable`1<long> index);
    public sealed virtual Nullable`1[] ArrTrim(RedisKey key, string path, long start, long stop);
    [NullableContextAttribute("2")]
public sealed virtual long Clear(RedisKey key, string path);
    [NullableContextAttribute("2")]
public sealed virtual long Del(RedisKey key, string path);
    [NullableContextAttribute("2")]
public sealed virtual long Forget(RedisKey key, string path);
    public sealed virtual RedisResult Get(RedisKey key, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space, Nullable`1<RedisValue> path);
    public sealed virtual RedisResult Get(RedisKey key, String[] paths, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space);
    [NullableContextAttribute("2")]
public sealed virtual T Get(RedisKey key, string path, JsonSerializerOptions serializerOptions);
    public sealed virtual IEnumerable`1<T> GetEnumerable(RedisKey key, string path);
    public sealed virtual RedisResult[] MGet(RedisKey[] keys, string path);
    public sealed virtual Nullable`1[] NumIncrby(RedisKey key, string path, double value);
    public sealed virtual IEnumerable`1<HashSet`1<string>> ObjKeys(RedisKey key, string path);
    public sealed virtual Nullable`1[] ObjLen(RedisKey key, string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.JsonCommandsAsync : object {
    private IDatabaseAsync _db;
    public JsonCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ArrAppendAsync>d__2")]
public sealed virtual Task`1<Nullable`1[]> ArrAppendAsync(RedisKey key, string path, Object[] values);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ArrIndexAsync>d__3")]
public sealed virtual Task`1<Nullable`1[]> ArrIndexAsync(RedisKey key, string path, object value, Nullable`1<long> start, Nullable`1<long> stop);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ArrInsertAsync>d__4")]
public sealed virtual Task`1<Nullable`1[]> ArrInsertAsync(RedisKey key, string path, long index, Object[] values);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ArrLenAsync>d__5")]
public sealed virtual Task`1<Nullable`1[]> ArrLenAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ArrPopAsync>d__6")]
public sealed virtual Task`1<RedisResult[]> ArrPopAsync(RedisKey key, string path, Nullable`1<long> index);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ArrTrimAsync>d__7")]
public sealed virtual Task`1<Nullable`1[]> ArrTrimAsync(RedisKey key, string path, long start, long stop);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ClearAsync>d__8")]
public sealed virtual Task`1<long> ClearAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<DelAsync>d__9")]
public sealed virtual Task`1<long> DelAsync(RedisKey key, string path);
    public sealed virtual Task`1<long> ForgetAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<GetAsync>d__11")]
public sealed virtual Task`1<RedisResult> GetAsync(RedisKey key, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space, Nullable`1<RedisValue> path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<GetAsync>d__12")]
public sealed virtual Task`1<RedisResult> GetAsync(RedisKey key, String[] paths, Nullable`1<RedisValue> indent, Nullable`1<RedisValue> newLine, Nullable`1<RedisValue> space);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<GetAsync>d__13`1")]
public sealed virtual Task`1<T> GetAsync(RedisKey key, string path, JsonSerializerOptions serializerOptions);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<GetEnumerableAsync>d__14`1")]
public sealed virtual Task`1<IEnumerable`1<T>> GetEnumerableAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<MGetAsync>d__15")]
public sealed virtual Task`1<RedisResult[]> MGetAsync(RedisKey[] keys, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<NumIncrbyAsync>d__16")]
public sealed virtual Task`1<Nullable`1[]> NumIncrbyAsync(RedisKey key, string path, double value);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ObjKeysAsync>d__17")]
public sealed virtual Task`1<IEnumerable`1<HashSet`1<string>>> ObjKeysAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ObjLenAsync>d__18")]
public sealed virtual Task`1<Nullable`1[]> ObjLenAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<RespAsync>d__19")]
public sealed virtual Task`1<RedisResult[]> RespAsync(RedisKey key, string path);
    public sealed virtual Task`1<bool> SetAsync(RedisKey key, RedisValue path, object obj, When when, JsonSerializerOptions serializerOptions);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<SetAsync>d__21")]
public sealed virtual Task`1<bool> SetAsync(RedisKey key, RedisValue path, RedisValue json, When when);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<MSetAsync>d__22")]
public sealed virtual Task`1<bool> MSetAsync(KeyPathValue[] KeyPathValueList);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<MergeAsync>d__23")]
public sealed virtual Task`1<bool> MergeAsync(RedisKey key, RedisValue path, RedisValue json);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<MergeAsync>d__24")]
public sealed virtual Task`1<bool> MergeAsync(RedisKey key, RedisValue path, object obj, JsonSerializerOptions serializerOptions);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<SetFromFileAsync>d__25")]
public sealed virtual Task`1<bool> SetFromFileAsync(RedisKey key, RedisValue path, string filePath, When when);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<SetFromDirectoryAsync>d__26")]
public sealed virtual Task`1<int> SetFromDirectoryAsync(RedisValue path, string filesPath, When when);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<StrAppendAsync>d__27")]
public sealed virtual Task`1<Nullable`1[]> StrAppendAsync(RedisKey key, string value, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<StrLenAsync>d__28")]
public sealed virtual Task`1<Nullable`1[]> StrLenAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<ToggleAsync>d__29")]
public sealed virtual Task`1<Nullable`1[]> ToggleAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<TypeAsync>d__30")]
public sealed virtual Task`1<JsonType[]> TypeAsync(RedisKey key, string path);
    [AsyncStateMachineAttribute("NRedisStack.JsonCommandsAsync/<DebugMemoryAsync>d__31")]
public sealed virtual Task`1<long> DebugMemoryAsync(string key, string path);
}
public enum NRedisStack.JsonType : Enum {
    public int value__;
    public static JsonType UNKNOWN;
    public static JsonType NULL;
    public static JsonType BOOLEAN;
    public static JsonType INTEGER;
    public static JsonType NUMBER;
    public static JsonType STRING;
    public static JsonType ARRAY;
    public static JsonType OBJECT;
}
public enum NRedisStack.Literals.Enums.TsAggregation : Enum {
    public int value__;
    public static TsAggregation Avg;
    public static TsAggregation Sum;
    public static TsAggregation Min;
    public static TsAggregation Max;
    public static TsAggregation Range;
    public static TsAggregation Count;
    public static TsAggregation First;
    public static TsAggregation Last;
    public static TsAggregation StdP;
    public static TsAggregation StdS;
    public static TsAggregation VarP;
    public static TsAggregation VarS;
    public static TsAggregation Twa;
}
public enum NRedisStack.Literals.Enums.TsBucketTimestamps : Enum {
    public int value__;
    public static TsBucketTimestamps low;
    public static TsBucketTimestamps mid;
    public static TsBucketTimestamps high;
}
public enum NRedisStack.Literals.Enums.TsDuplicatePolicy : Enum {
    public int value__;
    public static TsDuplicatePolicy BLOCK;
    public static TsDuplicatePolicy FIRST;
    public static TsDuplicatePolicy LAST;
    public static TsDuplicatePolicy MIN;
    public static TsDuplicatePolicy MAX;
    public static TsDuplicatePolicy SUM;
}
public enum NRedisStack.Literals.Enums.TsReduce : Enum {
    public int value__;
    public static TsReduce Sum;
    public static TsReduce Min;
    public static TsReduce Max;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Literals.TDIGEST : object {
    public static string CREATE;
    public static string RESET;
    public static string ADD;
    public static string MERGE;
    public static string MERGESTORE;
    public static string MIN;
    public static string MAX;
    public static string QUANTILE;
    public static string CDF;
    public static string TRIMMED_MEAN;
    public static string INFO;
    public static string RANK;
    public static string REVRANK;
    public static string BYRANK;
    public static string BYREVRANK;
}
internal class NRedisStack.Literals.TdigestArgs : object {
    [NullableAttribute("1")]
public static string COMPRESSION;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Literals.TimeSeriesArgs : object {
    public static string RETENTION;
    public static string LABELS;
    public static string UNCOMPRESSED;
    public static string COUNT;
    public static string AGGREGATION;
    public static string ALIGN;
    public static string FILTER;
    public static string WITHLABELS;
    public static string SELECTEDLABELS;
    public static string TIMESTAMP;
    public static string CHUNK_SIZE;
    public static string DUPLICATE_POLICY;
    public static string ON_DUPLICATE;
    public static string GROPUBY;
    public static string REDUCE;
    public static string FILTER_BY_TS;
    public static string FILTER_BY_VALUE;
    public static string LATEST;
    public static string DEBUG;
    public static string BUCKETTIMESTAMP;
    public static string EMPTY;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Literals.TS : object {
    public static string CREATE;
    public static string ALTER;
    public static string ADD;
    public static string MADD;
    public static string INCRBY;
    public static string DECRBY;
    public static string DEL;
    public static string CREATERULE;
    public static string DELETERULE;
    public static string RANGE;
    public static string REVRANGE;
    public static string MRANGE;
    public static string MREVRANGE;
    public static string GET;
    public static string MGET;
    public static string INFO;
    public static string QUERYINDEX;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Pipeline : object {
    private IBatch _batch;
    public BloomCommandsAsync Bf { get; }
    public CmsCommandsAsync Cms { get; }
    public CuckooCommandsAsync Cf { get; }
    [ObsoleteAttribute]
public GraphCommandsAsync Graph { get; }
    public JsonCommandsAsync Json { get; }
    public SearchCommandsAsync Ft { get; }
    public TdigestCommandsAsync Tdigest { get; }
    public TimeSeriesCommandsAsync Ts { get; }
    public TopKCommandsAsync TopK { get; }
    public IDatabaseAsync Db { get; }
    public Pipeline(IDatabase db);
    public void Execute();
    public BloomCommandsAsync get_Bf();
    public CmsCommandsAsync get_Cms();
    public CuckooCommandsAsync get_Cf();
    public GraphCommandsAsync get_Graph();
    public JsonCommandsAsync get_Json();
    public SearchCommandsAsync get_Ft();
    public TdigestCommandsAsync get_Tdigest();
    public TimeSeriesCommandsAsync get_Ts();
    public TopKCommandsAsync get_TopK();
    public IDatabaseAsync get_Db();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.RedisStackCommands.ModulePrefixes : object {
    [ExtensionAttribute]
public static BloomCommands BF(IDatabase db);
    [ExtensionAttribute]
public static CuckooCommands CF(IDatabase db);
    [ExtensionAttribute]
public static CmsCommands CMS(IDatabase db);
    [ExtensionAttribute]
[ObsoleteAttribute]
public static GraphCommands GRAPH(IDatabase db);
    [ExtensionAttribute]
public static TopKCommands TOPK(IDatabase db);
    [ExtensionAttribute]
public static TdigestCommands TDIGEST(IDatabase db);
    [ExtensionAttribute]
public static SearchCommands FT(IDatabase db, Nullable`1<int> searchDialect);
    [ExtensionAttribute]
public static JsonCommands JSON(IDatabase db);
    [ExtensionAttribute]
public static TimeSeriesCommands TS(IDatabase db);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.RedisStackCommands.SerializedCommand : object {
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public string Command { get; }
    public Object[] Args { get; }
    public SerializedCommand(string command, Object[] args);
    public SerializedCommand(string command, ICollection`1<object> args);
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public Object[] get_Args();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NRedisStack.ResponseParser : object {
    [ExtensionAttribute]
public static bool OKtoBoolean(RedisResult result);
    [ExtensionAttribute]
public static Boolean[] ToBooleanArray(RedisResult result);
    [ExtensionAttribute]
public static RedisResult[] ToArray(RedisResult result);
    [ExtensionAttribute]
public static long ToLong(RedisResult result);
    [ExtensionAttribute]
public static double ToDouble(RedisResult result);
    [ExtensionAttribute]
public static Double[] ToDoubleArray(RedisResult result);
    [ExtensionAttribute]
public static Int64[] ToLongArray(RedisResult result);
    [ExtensionAttribute]
public static TimeStamp ToTimeStamp(RedisResult result);
    [ExtensionAttribute]
public static RedisKey ToRedisKey(RedisResult result);
    [ExtensionAttribute]
public static RedisValue ToRedisValue(RedisResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<TimeStamp> ToTimeStampArray(RedisResult result);
    [ExtensionAttribute]
public static TimeSeriesTuple ToTimeSeriesTuple(RedisResult result);
    [ExtensionAttribute]
public static Tuple`2<long, Byte[]> ToScanDumpTuple(RedisResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<TimeSeriesTuple> ToTimeSeriesTupleArray(RedisResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<TimeSeriesLabel> ToLabelArray(RedisResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, TimeSeriesTuple>> ParseMGetResponse(RedisResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>> ParseMRangeResponse(RedisResult result);
    [ExtensionAttribute]
public static TimeSeriesRule ToRule(RedisResult result);
    [ExtensionAttribute]
public static IReadOnlyList`1<TimeSeriesRule> ToRuleArray(RedisResult result);
    [ExtensionAttribute]
public static Nullable`1<TsDuplicatePolicy> ToPolicy(RedisResult result);
    [ExtensionAttribute]
public static BloomInformation ToBloomInfo(RedisResult result);
    [ExtensionAttribute]
public static CuckooInformation ToCuckooInfo(RedisResult result);
    [ExtensionAttribute]
public static CmsInformation ToCmsInfo(RedisResult result);
    [ExtensionAttribute]
public static TopKInformation ToTopKInfo(RedisResult result);
    [ExtensionAttribute]
public static TdigestInformation ToTdigestInfo(RedisResult result);
    [ExtensionAttribute]
[ObsoleteAttribute]
public static TimeSeriesInformation ToTimeSeriesInfo(RedisResult result);
    [ExtensionAttribute]
public static Dictionary`2<string, string> ToConfigDictionary(RedisResult value);
    [ExtensionAttribute]
public static IReadOnlyList`1<TimeSeriesChunck> ToTimeSeriesChunkArray(RedisResult result);
    [ExtensionAttribute]
public static TimeSeriesChunck ToTimeSeriesChunk(RedisResult result);
    [ExtensionAttribute]
public static List`1<string> ToStringList(RedisResult result);
    [ExtensionAttribute]
public static Nullable`1[] ToNullableLongArray(RedisResult result);
    [ExtensionAttribute]
public static IEnumerable`1<HashSet`1<string>> ToHashSets(RedisResult result);
    [ExtensionAttribute]
public static Dictionary`2<string, Dictionary`2<string, double>> ToFtSpellCheckResult(RedisResult result);
    [ExtensionAttribute]
public static List`1<Tuple`2<string, double>> ToStringDoubleTupleList(RedisResult result);
    [ExtensionAttribute]
public static Dictionary`2<string, RedisResult> ToStringRedisResultDictionary(RedisResult value);
    [ExtensionAttribute]
public static Tuple`2<SearchResult, Dictionary`2<string, RedisResult>> ToProfileSearchResult(RedisResult result, Query q);
    [ExtensionAttribute]
public static SearchResult ToSearchResult(RedisResult result, Query q);
    [ExtensionAttribute]
public static Tuple`2<AggregationResult, Dictionary`2<string, RedisResult>> ToProfileAggregateResult(RedisResult result, AggregationRequest q);
    [ExtensionAttribute]
public static AggregationResult ToAggregationResult(RedisResult result, AggregationRequest query);
    [ExtensionAttribute]
public static Dictionary`2[] ToDictionarys(RedisResult result);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValueWithScore> ToSortedSetPopResult(RedisResult result);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, List`1<RedisValueWithScore>> ToSortedSetPopResults(RedisResult result);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, RedisValue> ToListPopResult(RedisResult result);
    [ExtensionAttribute]
public static Tuple`2<RedisKey, List`1<RedisValue>> ToListPopResults(RedisResult result);
    [ExtensionAttribute]
public static RedisStreamEntries[] ToRedisStreamEntries(RedisResult result);
    private static StreamEntry[] ParseStreamEntries(IReadOnlyList`1<RedisResult> results);
    private static NameValueEntry[] ParseNameValueEntries(IReadOnlyList`1<RedisResult> redisResults);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.Aggregation.AggregationRequest : object {
    private List`1<object> args;
    private bool isWithCursor;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <dialect>k__BackingField;
    public Nullable`1<int> dialect { get; private set; }
    public AggregationRequest(string query, Nullable`1<int> defaultDialect);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_dialect();
    [CompilerGeneratedAttribute]
private void set_dialect(Nullable`1<int> value);
    public AggregationRequest Verbatim();
    public AggregationRequest Load(FieldName[] fields);
    public AggregationRequest LoadAll();
    public AggregationRequest Timeout(long timeout);
    public AggregationRequest GroupBy(string field, Reducer[] reducers);
    public AggregationRequest GroupBy(IList`1<string> fields, IList`1<Reducer> reducers);
    public AggregationRequest GroupBy(Group group);
    public AggregationRequest SortBy(string property);
    public AggregationRequest SortBy(SortedField[] fields);
    public AggregationRequest SortBy(int max, SortedField[] fields);
    public AggregationRequest Apply(string projection, string alias);
    public AggregationRequest Limit(int count);
    public AggregationRequest Limit(int offset, int count);
    public AggregationRequest Filter(string filter);
    public AggregationRequest Cursor(Nullable`1<int> count, Nullable`1<long> maxIdle);
    public AggregationRequest Params(Dictionary`2<string, object> nameValue);
    public AggregationRequest Dialect(int dialect);
    private void Dialect();
    public List`1<object> GetArgs();
    public void SerializeRedisArgs();
    public bool IsWithCursor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NRedisStack.Search.Aggregation.AggregationResult : object {
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    private Dictionary`2[] _results;
    [CompilerGeneratedAttribute]
private long <CursorId>k__BackingField;
    public long TotalResults { get; }
    public long CursorId { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, RedisValue> Item { get; }
    internal AggregationResult(RedisResult result, long cursorId);
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public long get_CursorId();
    public IReadOnlyList`1<Dictionary`2<string, RedisValue>> GetResults();
    public Dictionary`2<string, RedisValue> get_Item(int index);
    public Row GetRow(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.Aggregation.Group : object {
    private IList`1<Reducer> _reducers;
    private IList`1<string> _fields;
    private Limit _limit;
    public Group(String[] fields);
    public Group(IList`1<string> fields);
    internal Group Limit(Limit limit);
    internal Group Reduce(Reducer r);
    internal void SerializeRedisArgs(List`1<object> args);
}
[IsReadOnlyAttribute]
internal class NRedisStack.Search.Aggregation.Limit : ValueType {
    public static Limit NO_LIMIT;
    private int _offset;
    private int _count;
    public Limit(int offset, int count);
    private static Limit();
    [NullableContextAttribute("1")]
internal void SerializeRedisArgs(List`1<object> args);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class NRedisStack.Search.Aggregation.Reducer : object {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    private string _field;
    [NullableAttribute("1")]
public string Name { get; }
    public string Alias { get; public set; }
    protected Reducer(string field);
    [NullableContextAttribute("1")]
public abstract virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    protected virtual int GetOwnArgsCount();
    [NullableContextAttribute("1")]
protected virtual void AddOwnArgs(List`1<object> args);
    [NullableContextAttribute("1")]
public Reducer As(string alias);
    [NullableContextAttribute("1")]
internal void SerializeRedisArgs(List`1<object> args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.Search.Aggregation.Reducers : object {
    public static Reducer Count();
    public static Reducer CountDistinct(string field);
    public static Reducer CountDistinctish(string field);
    public static Reducer Sum(string field);
    public static Reducer Min(string field);
    public static Reducer Max(string field);
    public static Reducer Avg(string field);
    public static Reducer StdDev(string field);
    public static Reducer Quantile(string field, double percentile);
    public static Reducer FirstValue(string field, SortedField sortBy);
    public static Reducer FirstValue(string field);
    public static Reducer ToList(string field);
    public static Reducer RandomSample(string field, int size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class NRedisStack.Search.Aggregation.Row : ValueType {
    private Dictionary`2<string, RedisValue> _fields;
    public RedisValue Item { get; }
    internal Row(Dictionary`2<string, RedisValue> fields);
    public bool ContainsKey(string key);
    public RedisValue get_Item(string key);
    public string GetString(string key);
    public long GetLong(string key);
    public double GetDouble(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.Aggregation.SortedField : object {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private SortOrder <Order>k__BackingField;
    public string FieldName { get; }
    public SortOrder Order { get; }
    public SortedField(string fieldName, SortOrder order);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public SortOrder get_Order();
    public static SortedField Asc(string field);
    public static SortedField Desc(string field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.DataTypes.InfoResult : object {
    private Dictionary`2<string, RedisResult> _all;
    public string IndexName { get; }
    public Dictionary`2<string, RedisResult> IndexOption { get; }
    public Dictionary`2[] Attributes { get; }
    public long NumDocs { get; }
    public string MaxDocId { get; }
    public long NumTerms { get; }
    public long NumRecords { get; }
    public double InvertedSzMebibytes { get; }
    public double VectorIndexSzMebibytes { get; }
    public double TotalInvertedIndexBlocks { get; }
    public double OffsetVectorsSzMebibytes { get; }
    public double DocTableSizeMebibytes { get; }
    public double SortableValueSizeMebibytes { get; }
    public double KeyTableSizeMebibytes { get; }
    public double RecordsPerDocAvg { get; }
    public double BytesPerRecordAvg { get; }
    public double OffsetsPerTermAvg { get; }
    public double OffsetBitsPerRecordAvg { get; }
    public long HashIndexingFailures { get; }
    public double TotalIndexingTime { get; }
    public long Indexing { get; }
    public double PercentIndexed { get; }
    public long NumberOfUses { get; }
    public Dictionary`2<string, RedisResult> GcStats { get; }
    public Dictionary`2<string, RedisResult> CursorStats { get; }
    public InfoResult(RedisResult result);
    public string get_IndexName();
    public Dictionary`2<string, RedisResult> get_IndexOption();
    public Dictionary`2[] get_Attributes();
    public long get_NumDocs();
    public string get_MaxDocId();
    public long get_NumTerms();
    public long get_NumRecords();
    public double get_InvertedSzMebibytes();
    public double get_VectorIndexSzMebibytes();
    public double get_TotalInvertedIndexBlocks();
    public double get_OffsetVectorsSzMebibytes();
    public double get_DocTableSizeMebibytes();
    public double get_SortableValueSizeMebibytes();
    public double get_KeyTableSizeMebibytes();
    public double get_RecordsPerDocAvg();
    public double get_BytesPerRecordAvg();
    public double get_OffsetsPerTermAvg();
    public double get_OffsetBitsPerRecordAvg();
    public long get_HashIndexingFailures();
    public double get_TotalIndexingTime();
    public long get_Indexing();
    public double get_PercentIndexed();
    public long get_NumberOfUses();
    public Dictionary`2<string, RedisResult> get_GcStats();
    public Dictionary`2<string, RedisResult> get_CursorStats();
    private string GetString(string key);
    private long GetLong(string key);
    private double GetDouble(string key);
    private Dictionary`2<string, RedisResult> GetRedisResultDictionary(string key);
    private Dictionary`2[] GetRedisResultDictionaryArray(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NRedisStack.Search.Document : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Score>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <Payload>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <ScoreExplained>k__BackingField;
    internal Dictionary`2<string, RedisValue> _properties;
    public string Id { get; }
    public double Score { get; public set; }
    [NullableAttribute("2")]
public Byte[] Payload { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ScoreExplained { get; private set; }
    public RedisValue Item { get; internal set; }
    public Document(string id, double score, Byte[] payload);
    public Document(string id);
    public Document(string id, Dictionary`2<string, RedisValue> fields, double score);
    public Document(string id, Dictionary`2<string, RedisValue> fields, double score, Byte[] payload);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public double get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(double value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_Payload();
    [CompilerGeneratedAttribute]
public String[] get_ScoreExplained();
    [CompilerGeneratedAttribute]
private void set_ScoreExplained(String[] value);
    public IEnumerable`1<KeyValuePair`2<string, RedisValue>> GetProperties();
    public static Document Load(string id, double score, Byte[] payload, RedisValue[] fields);
    public static Document Load(string id, double score, Byte[] payload, RedisValue[] fields, String[] scoreExplained);
    public RedisValue get_Item(string key);
    internal void set_Item(string key, RedisValue value);
    public Document Set(string field, RedisValue value);
    public Document SetScore(double score);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.FieldName : object {
    private string fieldName;
    [NullableAttribute("2")]
private string alias;
    public FieldName(string name);
    public FieldName(string name, string attribute);
    public int AddCommandArguments(List`1<object> args);
    public static FieldName Of(string name);
    public FieldName As(string attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.FTCreateParams : object {
    private IndexDataType dataType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> prefixes;
    [NullableAttribute("2")]
private string filter;
    [NullableAttribute("2")]
private string language;
    [NullableAttribute("2")]
private string languageField;
    private double score;
    [NullableAttribute("2")]
private string scoreField;
    [NullableAttribute("2")]
private string payloadField;
    private bool maxTextFields;
    private bool noOffsets;
    private long temporary;
    private bool noHL;
    private bool noFields;
    private bool noFreqs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> stopwords;
    private bool skipInitialScan;
    public static FTCreateParams CreateParams();
    public FTCreateParams On(IndexDataType dataType);
    public FTCreateParams Prefix(String[] prefixes);
    public FTCreateParams AddPrefix(string prefix);
    public FTCreateParams Filter(string filter);
    public FTCreateParams Language(string defaultLanguage);
    public FTCreateParams LanguageField(string languageAttribute);
    public FTCreateParams Score(double defaultScore);
    public FTCreateParams ScoreField(string scoreField);
    public FTCreateParams PayloadField(string payloadAttribute);
    public FTCreateParams MaxTextFields();
    public FTCreateParams NoOffsets();
    public FTCreateParams Temporary(long seconds);
    public FTCreateParams NoHL();
    public FTCreateParams NoHighlights();
    public FTCreateParams NoFields();
    public FTCreateParams NoFreqs();
    public FTCreateParams Stopwords(String[] stopwords);
    public FTCreateParams NoStopwords();
    public FTCreateParams SkipInitialScan();
    public void AddParams(List`1<object> args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.FTSpellCheckParams : object {
    private List`1<object> args;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<string, string>> terms;
    private Nullable`1<int> distance;
    private Nullable`1<int> dialect;
    public FTSpellCheckParams IncludeTerm(string dict);
    public FTSpellCheckParams ExcludeTerm(string dict);
    private FTSpellCheckParams AddTerm(string dict, string type);
    public FTSpellCheckParams Distance(int distance);
    public FTSpellCheckParams Dialect(int dialect);
    public List`1<object> GetArgs();
    public void SerializeRedisArgs();
    private void Dialect();
    private void Terms();
    private void Distance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Search.Literals.AttributeOptions : object {
    public static string SORTABLE;
    public static string UNF;
    public static string NOSTEM;
    public static string NOINDEX;
}
public enum NRedisStack.Search.Literals.Enums.IndexDataType : Enum {
    public int value__;
    public static IndexDataType HASH;
    public static IndexDataType JSON;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Search.Literals.FT : object {
    public static string _LIST;
    public static string AGGREGATE;
    public static string ALIASADD;
    public static string ALIASDEL;
    public static string ALIASUPDATE;
    public static string ALTER;
    public static string CONFIG;
    public static string CREATE;
    public static string CURSOR;
    public static string DICTADD;
    public static string DICTDEL;
    public static string DICTDUMP;
    public static string DROPINDEX;
    public static string EXPLAIN;
    public static string EXPLAINCLI;
    public static string INFO;
    public static string PROFILE;
    public static string SEARCH;
    public static string SPELLCHECK;
    public static string SUGADD;
    public static string SUGDEL;
    public static string SUGGET;
    public static string SUGLEN;
    public static string SYNDUMP;
    public static string SYNUPDATE;
    public static string TAGVALS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.Search.Literals.SearchArgs : object {
    public static string AGGREGATE;
    public static string APPLY;
    public static string AS;
    public static string ASC;
    public static string CASESENSITIVE;
    public static string COUNT;
    public static string DESC;
    public static string DIALECT;
    public static string DISTANCE;
    public static string EXCLUDE;
    public static string EXPANDER;
    public static string FIELDS;
    public static string FILTER;
    public static string FRAGS;
    public static string FUZZY;
    public static string GROUPBY;
    public static string HIGHLIGHT;
    public static string INCLUDE;
    public static string INCR;
    public static string INFIELDS;
    public static string INKEYS;
    public static string INORDER;
    public static string JSON;
    public static string LANGUAGE;
    public static string LANGUAGE_FIELD;
    public static string LEN;
    public static string LIMIT;
    public static string LIMITED;
    public static string LOAD;
    public static string MAX;
    public static string MAXIDLE;
    public static string MAXTEXTFIELDS;
    public static string NOCONTENT;
    public static string NOFIELDS;
    public static string NOFREQS;
    public static string NOHL;
    public static string NOINDEX;
    public static string NOOFFSETS;
    public static string NOSTEM;
    public static string NOSTOPWORDS;
    public static string ON_HASH;
    public static string PARAMS;
    public static string PAYLOAD;
    public static string PAYLOAD_FIELD;
    public static string PHONETIC;
    public static string PREFIX;
    public static string QUERY;
    public static string RETURN;
    public static string SCORE;
    public static string SCORE_FIELD;
    public static string SCORER;
    public static string SEARCH;
    public static string SEPARATOR;
    public static string SKIPINITIALSCAN;
    public static string SLOP;
    public static string SORTBY;
    public static string STOPWORDS;
    public static string SUMMARIZE;
    public static string TAGS;
    public static string TEMPORARY;
    public static string TERMS;
    public static string TIMEOUT;
    public static string UNF;
    public static string VERBATIM;
    public static string WEIGHT;
    public static string WITHCURSOR;
    public static string WITHPAYLOADS;
    public static string WITHSCORES;
    public static string WITHSUFFIXTRIE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.Query : object {
    internal List`1<Filter> _filters;
    [CompilerGeneratedAttribute]
private string <QueryString>k__BackingField;
    internal Paging _paging;
    [CompilerGeneratedAttribute]
private bool <Verbatim>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoStopwords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithScores>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithPayloads>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _fields;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _returnFields;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal FieldName[] _returnFieldsNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _highlightFields;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _summarizeFields;
    internal Nullable`1<HighlightTags> _highlightTags;
    [NullableAttribute("2")]
internal string _summarizeSeparator;
    internal int _summarizeNumFragments;
    internal int _summarizeFragmentLen;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Payload>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SortBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SortAscending>k__BackingField;
    internal bool _wantsHighlight;
    internal bool _wantsSummarize;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Scorer>k__BackingField;
    private Dictionary`2<string, object> _params;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <dialect>k__BackingField;
    private int _slop;
    private long _timeout;
    private bool _inOrder;
    [NullableAttribute("2")]
private string _expander;
    public string QueryString { get; }
    public bool Verbatim { get; public set; }
    public bool NoContent { get; public set; }
    public bool NoStopwords { get; public set; }
    public bool WithScores { get; public set; }
    public bool WithPayloads { get; public set; }
    [NullableAttribute("2")]
public string Language { get; public set; }
    [NullableAttribute("2")]
public string Payload { get; public set; }
    [NullableAttribute("2")]
public string SortBy { get; public set; }
    public Nullable`1<bool> SortAscending { get; public set; }
    [NullableAttribute("2")]
public string Scorer { get; public set; }
    public Nullable`1<int> dialect { get; private set; }
    public Query(string queryString);
    [CompilerGeneratedAttribute]
public string get_QueryString();
    [CompilerGeneratedAttribute]
public bool get_Verbatim();
    [CompilerGeneratedAttribute]
public void set_Verbatim(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoContent();
    [CompilerGeneratedAttribute]
public void set_NoContent(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoStopwords();
    [CompilerGeneratedAttribute]
public void set_NoStopwords(bool value);
    [CompilerGeneratedAttribute]
public bool get_WithScores();
    [CompilerGeneratedAttribute]
public void set_WithScores(bool value);
    [CompilerGeneratedAttribute]
public bool get_WithPayloads();
    [CompilerGeneratedAttribute]
public void set_WithPayloads(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Language();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Language(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Payload();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Payload(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SortBy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_SortBy(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SortAscending();
    [CompilerGeneratedAttribute]
public void set_SortAscending(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Scorer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Scorer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_dialect();
    [CompilerGeneratedAttribute]
private void set_dialect(Nullable`1<int> value);
    internal void SerializeRedisArgs(List`1<object> args);
    public Query Limit(int offset, int count);
    public Query AddFilter(Filter f);
    public Query SetPayload(string payload);
    public Query SetVerbatim(bool value);
    public Query SetNoContent(bool value);
    public Query SetNoStopwords(bool value);
    public Query SetWithScores(bool value);
    public Query SetWithPayloads();
    public Query SetLanguage(string language);
    public Query SetScorer(string scorer);
    public Query LimitFields(String[] fields);
    public Query LimitKeys(String[] keys);
    public Query ReturnFields(String[] fields);
    public Query ReturnFields(FieldName[] fields);
    public Query HighlightFields(HighlightTags tags, String[] fields);
    public Query HighlightFields(String[] fields);
    private Query HighlightFieldsImpl(Nullable`1<HighlightTags> tags, String[] fields);
    public Query SummarizeFields(int contextLen, int fragmentCount, string separator, String[] fields);
    public Query SummarizeFields(String[] fields);
    public Query SetSortBy(string field, Nullable`1<bool> ascending);
    public Query AddParam(string name, object value);
    public Query Params(Dictionary`2<string, object> nameValue);
    public Query Dialect(int dialect);
    public Query Slop(int slop);
    public Query Timeout(long timeout);
    public Query SetInOrder();
    public Query SetExpander(string field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.Schema : object {
    [CompilerGeneratedAttribute]
private List`1<Field> <Fields>k__BackingField;
    public List`1<Field> Fields { get; }
    [CompilerGeneratedAttribute]
public List`1<Field> get_Fields();
    public Schema AddField(Field field);
    public Schema AddTextField(string name, double weight, bool sortable, bool unf, bool noStem, string phonetic, bool noIndex, bool withSuffixTrie);
    public Schema AddTextField(FieldName name, double weight, bool sortable, bool unf, bool noStem, string phonetic, bool noIndex, bool withSuffixTrie);
    public Schema AddGeoShapeField(string name, CoordinateSystem system);
    public Schema AddGeoShapeField(FieldName name, CoordinateSystem system);
    public Schema AddGeoField(FieldName name, bool sortable, bool noIndex);
    public Schema AddGeoField(string name, bool sortable, bool noIndex);
    public Schema AddNumericField(FieldName name, bool sortable, bool noIndex);
    public Schema AddNumericField(string name, bool sortable, bool noIndex);
    public Schema AddTagField(FieldName name, bool sortable, bool unf, bool noIndex, string separator, bool caseSensitive, bool withSuffixTrie);
    public Schema AddTagField(string name, bool sortable, bool unf, bool noIndex, string separator, bool caseSensitive, bool withSuffixTrie);
    public Schema AddVectorField(FieldName name, VectorAlgo algorithm, Dictionary`2<string, object> attributes);
    public Schema AddVectorField(string name, VectorAlgo algorithm, Dictionary`2<string, object> attributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Search.SearchResult : object {
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Document> <Documents>k__BackingField;
    public long TotalResults { get; }
    public List`1<Document> Documents { get; }
    internal SearchResult(RedisResult[] resp, bool hasContent, bool hasScores, bool hasPayloads);
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public List`1<Document> get_Documents();
    public List`1<string> ToJson();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.SearchCommandBuilder : object {
    public static SerializedCommand _List();
    public static SerializedCommand Aggregate(string index, AggregationRequest query);
    public static SerializedCommand AliasAdd(string alias, string index);
    public static SerializedCommand AliasDel(string alias);
    public static SerializedCommand AliasUpdate(string alias, string index);
    public static SerializedCommand Alter(string index, Schema schema, bool skipInitialScan);
    public static SerializedCommand ConfigGet(string option);
    public static SerializedCommand ConfigSet(string option, string value);
    public static SerializedCommand Create(string indexName, FTCreateParams parameters, Schema schema);
    public static SerializedCommand CursorDel(string indexName, long cursorId);
    public static SerializedCommand CursorRead(string indexName, long cursorId, Nullable`1<int> count);
    public static SerializedCommand DictAdd(string dict, String[] terms);
    public static SerializedCommand DictDel(string dict, String[] terms);
    public static SerializedCommand DictDump(string dict);
    public static SerializedCommand DropIndex(string indexName, bool dd);
    public static SerializedCommand Explain(string indexName, string query, Nullable`1<int> dialect);
    public static SerializedCommand ExplainCli(string indexName, string query, Nullable`1<int> dialect);
    public static SerializedCommand Info(RedisValue index);
    public static SerializedCommand Search(string indexName, Query q);
    public static SerializedCommand ProfileSearch(string IndexName, Query q, bool limited);
    public static SerializedCommand ProfileAggregate(string IndexName, AggregationRequest query, bool limited);
    public static SerializedCommand SpellCheck(string indexName, string query, FTSpellCheckParams spellCheckParams);
    public static SerializedCommand SugAdd(string key, string str, double score, bool increment, string payload);
    public static SerializedCommand SugDel(string key, string str);
    public static SerializedCommand SugGet(string key, string prefix, bool fuzzy, bool withScores, bool withPayloads, Nullable`1<int> max);
    public static SerializedCommand SugLen(string key);
    public static SerializedCommand SynDump(string indexName);
    public static SerializedCommand SynUpdate(string indexName, string synonymGroupId, bool skipInitialScan, String[] terms);
    public static SerializedCommand TagVals(string indexName, string fieldName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.SearchCommands : SearchCommandsAsync {
    private IDatabase _db;
    public SearchCommands(IDatabase db, Nullable`1<int> defaultDialect);
    public void SetDefaultDialect(Nullable`1<int> defaultDialect);
    public sealed virtual RedisResult[] _List();
    public sealed virtual AggregationResult Aggregate(string index, AggregationRequest query);
    public sealed virtual bool AliasAdd(string alias, string index);
    public sealed virtual bool AliasDel(string alias);
    public sealed virtual bool AliasUpdate(string alias, string index);
    public sealed virtual bool Alter(string index, Schema schema, bool skipInitialScan);
    public sealed virtual Dictionary`2<string, string> ConfigGet(string option);
    public sealed virtual bool ConfigSet(string option, string value);
    public sealed virtual bool Create(string indexName, FTCreateParams parameters, Schema schema);
    public bool Create(string indexName, Schema schema);
    public sealed virtual bool CursorDel(string indexName, long cursorId);
    public sealed virtual AggregationResult CursorRead(string indexName, long cursorId, Nullable`1<int> count);
    public sealed virtual long DictAdd(string dict, String[] terms);
    public sealed virtual long DictDel(string dict, String[] terms);
    public sealed virtual RedisResult[] DictDump(string dict);
    public sealed virtual bool DropIndex(string indexName, bool dd);
    public sealed virtual string Explain(string indexName, string query, Nullable`1<int> dialect);
    public sealed virtual RedisResult[] ExplainCli(string indexName, string query, Nullable`1<int> dialect);
    public sealed virtual InfoResult Info(RedisValue index);
    public sealed virtual Tuple`2<SearchResult, Dictionary`2<string, RedisResult>> ProfileSearch(string indexName, Query q, bool limited);
    public sealed virtual Tuple`2<AggregationResult, Dictionary`2<string, RedisResult>> ProfileAggregate(string indexName, AggregationRequest query, bool limited);
    public sealed virtual SearchResult Search(string indexName, Query q);
    public sealed virtual Dictionary`2<string, Dictionary`2<string, double>> SpellCheck(string indexName, string query, FTSpellCheckParams spellCheckParams);
    public sealed virtual long SugAdd(string key, string str, double score, bool increment, string payload);
    public sealed virtual bool SugDel(string key, string str);
    public sealed virtual List`1<string> SugGet(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    public sealed virtual List`1<Tuple`2<string, double>> SugGetWithScores(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    public sealed virtual long SugLen(string key);
    public sealed virtual Dictionary`2<string, List`1<string>> SynDump(string indexName);
    public sealed virtual bool SynUpdate(string indexName, string synonymGroupId, bool skipInitialScan, String[] terms);
    public sealed virtual RedisResult[] TagVals(string indexName, string fieldName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.SearchCommandsAsync : object {
    private IDatabaseAsync _db;
    protected Nullable`1<int> defaultDialect;
    public SearchCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<_ListAsync>d__3")]
public sealed virtual Task`1<RedisResult[]> _ListAsync();
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<AggregateAsync>d__4")]
public sealed virtual Task`1<AggregationResult> AggregateAsync(string index, AggregationRequest query);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<AliasAddAsync>d__5")]
public sealed virtual Task`1<bool> AliasAddAsync(string alias, string index);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<AliasDelAsync>d__6")]
public sealed virtual Task`1<bool> AliasDelAsync(string alias);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<AliasUpdateAsync>d__7")]
public sealed virtual Task`1<bool> AliasUpdateAsync(string alias, string index);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<AlterAsync>d__8")]
public sealed virtual Task`1<bool> AlterAsync(string index, Schema schema, bool skipInitialScan);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<ConfigGetAsync>d__9")]
public sealed virtual Task`1<Dictionary`2<string, string>> ConfigGetAsync(string option);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<ConfigSetAsync>d__10")]
public sealed virtual Task`1<bool> ConfigSetAsync(string option, string value);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<CreateAsync>d__11")]
public sealed virtual Task`1<bool> CreateAsync(string indexName, FTCreateParams parameters, Schema schema);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<CreateAsync>d__12")]
public Task`1<bool> CreateAsync(string indexName, Schema schema);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<CursorDelAsync>d__13")]
public sealed virtual Task`1<bool> CursorDelAsync(string indexName, long cursorId);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<CursorReadAsync>d__14")]
public sealed virtual Task`1<AggregationResult> CursorReadAsync(string indexName, long cursorId, Nullable`1<int> count);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<DictAddAsync>d__15")]
public sealed virtual Task`1<long> DictAddAsync(string dict, String[] terms);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<DictDelAsync>d__16")]
public sealed virtual Task`1<long> DictDelAsync(string dict, String[] terms);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<DictDumpAsync>d__17")]
public sealed virtual Task`1<RedisResult[]> DictDumpAsync(string dict);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<DropIndexAsync>d__18")]
public sealed virtual Task`1<bool> DropIndexAsync(string indexName, bool dd);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<ExplainAsync>d__19")]
public sealed virtual Task`1<string> ExplainAsync(string indexName, string query, Nullable`1<int> dialect);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<ExplainCliAsync>d__20")]
public sealed virtual Task`1<RedisResult[]> ExplainCliAsync(string indexName, string query, Nullable`1<int> dialect);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<InfoAsync>d__21")]
public sealed virtual Task`1<InfoResult> InfoAsync(RedisValue index);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<ProfileSearchAsync>d__22")]
public sealed virtual Task`1<Tuple`2<SearchResult, Dictionary`2<string, RedisResult>>> ProfileSearchAsync(string indexName, Query q, bool limited);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<ProfileAggregateAsync>d__23")]
public sealed virtual Task`1<Tuple`2<AggregationResult, Dictionary`2<string, RedisResult>>> ProfileAggregateAsync(string indexName, AggregationRequest query, bool limited);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SearchAsync>d__24")]
public sealed virtual Task`1<SearchResult> SearchAsync(string indexName, Query q);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SpellCheckAsync>d__25")]
public sealed virtual Task`1<Dictionary`2<string, Dictionary`2<string, double>>> SpellCheckAsync(string indexName, string query, FTSpellCheckParams spellCheckParams);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SugAddAsync>d__26")]
public sealed virtual Task`1<long> SugAddAsync(string key, string str, double score, bool increment, string payload);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SugDelAsync>d__27")]
public sealed virtual Task`1<bool> SugDelAsync(string key, string str);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SugGetAsync>d__28")]
public sealed virtual Task`1<List`1<string>> SugGetAsync(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SugGetWithScoresAsync>d__29")]
public sealed virtual Task`1<List`1<Tuple`2<string, double>>> SugGetWithScoresAsync(string key, string prefix, bool fuzzy, bool withPayloads, Nullable`1<int> max);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SugLenAsync>d__30")]
public sealed virtual Task`1<long> SugLenAsync(string key);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SynDumpAsync>d__31")]
public sealed virtual Task`1<Dictionary`2<string, List`1<string>>> SynDumpAsync(string indexName);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<SynUpdateAsync>d__32")]
public sealed virtual Task`1<bool> SynUpdateAsync(string indexName, string synonymGroupId, bool skipInitialScan, String[] terms);
    [AsyncStateMachineAttribute("NRedisStack.SearchCommandsAsync/<TagValsAsync>d__33")]
public sealed virtual Task`1<RedisResult[]> TagValsAsync(string indexName, string fieldName);
}
public class NRedisStack.Tdigest.DataTypes.TdigestInformation : object {
    [CompilerGeneratedAttribute]
private long <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Capacity>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MergedNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UnmergedNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MergedWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <UnmergedWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Observations>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalCompressions>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryUsage>k__BackingField;
    public long Compression { get; private set; }
    public long Capacity { get; private set; }
    public long MergedNodes { get; private set; }
    public long UnmergedNodes { get; private set; }
    public double MergedWeight { get; private set; }
    public double UnmergedWeight { get; private set; }
    public double Observations { get; private set; }
    public long TotalCompressions { get; private set; }
    public long MemoryUsage { get; private set; }
    internal TdigestInformation(long compression, long capacity, long mergedNodes, long unmergedNodes, double mergedWeight, double unmergedWeight, double observations, long totalCompressions, long memoryUsage);
    [CompilerGeneratedAttribute]
public long get_Compression();
    [CompilerGeneratedAttribute]
private void set_Compression(long value);
    [CompilerGeneratedAttribute]
public long get_Capacity();
    [CompilerGeneratedAttribute]
private void set_Capacity(long value);
    [CompilerGeneratedAttribute]
public long get_MergedNodes();
    [CompilerGeneratedAttribute]
private void set_MergedNodes(long value);
    [CompilerGeneratedAttribute]
public long get_UnmergedNodes();
    [CompilerGeneratedAttribute]
private void set_UnmergedNodes(long value);
    [CompilerGeneratedAttribute]
public double get_MergedWeight();
    [CompilerGeneratedAttribute]
private void set_MergedWeight(double value);
    [CompilerGeneratedAttribute]
public double get_UnmergedWeight();
    [CompilerGeneratedAttribute]
private void set_UnmergedWeight(double value);
    [CompilerGeneratedAttribute]
public double get_Observations();
    [CompilerGeneratedAttribute]
private void set_Observations(double value);
    [CompilerGeneratedAttribute]
public long get_TotalCompressions();
    [CompilerGeneratedAttribute]
private void set_TotalCompressions(long value);
    [CompilerGeneratedAttribute]
public long get_MemoryUsage();
    [CompilerGeneratedAttribute]
private void set_MemoryUsage(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.TdigestCommandBuilder : object {
    public static SerializedCommand Add(RedisKey key, Double[] values);
    public static SerializedCommand CDF(RedisKey key, Double[] values);
    public static SerializedCommand Create(RedisKey key, long compression);
    public static SerializedCommand Info(RedisKey key);
    public static SerializedCommand Max(RedisKey key);
    public static SerializedCommand Min(RedisKey key);
    public static SerializedCommand Merge(RedisKey destinationKey, long compression, bool overide, RedisKey[] sourceKeys);
    public static SerializedCommand Quantile(RedisKey key, Double[] quantile);
    public static SerializedCommand Rank(RedisKey key, Int64[] values);
    public static SerializedCommand RevRank(RedisKey key, Int64[] values);
    public static SerializedCommand ByRank(RedisKey key, Int64[] ranks);
    public static SerializedCommand ByRevRank(RedisKey key, Int64[] ranks);
    public static SerializedCommand Reset(RedisKey key);
    public static SerializedCommand TrimmedMean(RedisKey key, double lowCutQuantile, double highCutQuantile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.TdigestCommands : TdigestCommandsAsync {
    private IDatabase _db;
    public TdigestCommands(IDatabase db);
    public sealed virtual bool Add(RedisKey key, Double[] values);
    public sealed virtual Double[] CDF(RedisKey key, Double[] values);
    public sealed virtual bool Create(RedisKey key, long compression);
    public sealed virtual TdigestInformation Info(RedisKey key);
    public sealed virtual double Max(RedisKey key);
    public sealed virtual double Min(RedisKey key);
    public sealed virtual bool Merge(RedisKey destinationKey, long compression, bool overide, RedisKey[] sourceKeys);
    public sealed virtual Double[] Quantile(RedisKey key, Double[] quantile);
    public sealed virtual Int64[] Rank(RedisKey key, Int64[] values);
    public sealed virtual Int64[] RevRank(RedisKey key, Int64[] values);
    public sealed virtual Double[] ByRank(RedisKey key, Int64[] ranks);
    public sealed virtual Double[] ByRevRank(RedisKey key, Int64[] ranks);
    public sealed virtual bool Reset(RedisKey key);
    public sealed virtual double TrimmedMean(RedisKey key, double lowCutQuantile, double highCutQuantile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.TdigestCommandsAsync : object {
    private IDatabaseAsync _db;
    public TdigestCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<AddAsync>d__2")]
public sealed virtual Task`1<bool> AddAsync(RedisKey key, Double[] values);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<CDFAsync>d__3")]
public sealed virtual Task`1<Double[]> CDFAsync(RedisKey key, Double[] values);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<CreateAsync>d__4")]
public sealed virtual Task`1<bool> CreateAsync(RedisKey key, long compression);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<InfoAsync>d__5")]
public sealed virtual Task`1<TdigestInformation> InfoAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<MaxAsync>d__6")]
public sealed virtual Task`1<double> MaxAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<MinAsync>d__7")]
public sealed virtual Task`1<double> MinAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<MergeAsync>d__8")]
public sealed virtual Task`1<bool> MergeAsync(RedisKey destinationKey, long compression, bool overide, RedisKey[] sourceKeys);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<QuantileAsync>d__9")]
public sealed virtual Task`1<Double[]> QuantileAsync(RedisKey key, Double[] quantile);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<RankAsync>d__10")]
public sealed virtual Task`1<Int64[]> RankAsync(RedisKey key, Int64[] values);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<RevRankAsync>d__11")]
public sealed virtual Task`1<Int64[]> RevRankAsync(RedisKey key, Int64[] values);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<ByRankAsync>d__12")]
public sealed virtual Task`1<Double[]> ByRankAsync(RedisKey key, Int64[] ranks);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<ByRevRankAsync>d__13")]
public sealed virtual Task`1<Double[]> ByRevRankAsync(RedisKey key, Int64[] ranks);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<ResetAsync>d__14")]
public sealed virtual Task`1<bool> ResetAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.TdigestCommandsAsync/<TrimmedMeanAsync>d__15")]
public sealed virtual Task`1<double> TrimmedMeanAsync(RedisKey key, double lowCutQuantile, double highCutQuantile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NRedisStack.TimeSeriesAux : object {
    [ExtensionAttribute]
public static void AddLatest(IList`1<object> args, bool latest);
    [ExtensionAttribute]
public static void AddRetentionTime(IList`1<object> args, Nullable`1<long> retentionTime);
    [ExtensionAttribute]
public static void AddChunkSize(IList`1<object> args, Nullable`1<long> chunkSize);
    [ExtensionAttribute]
public static void AddLabels(IList`1<object> args, IReadOnlyCollection`1<TimeSeriesLabel> labels);
    [ExtensionAttribute]
public static void AddUncompressed(IList`1<object> args, Nullable`1<bool> uncompressed);
    [ExtensionAttribute]
public static void AddCount(IList`1<object> args, Nullable`1<long> count);
    [ExtensionAttribute]
public static void AddDuplicatePolicy(IList`1<object> args, Nullable`1<TsDuplicatePolicy> policy);
    [ExtensionAttribute]
public static void AddOnDuplicate(IList`1<object> args, Nullable`1<TsDuplicatePolicy> policy);
    [ExtensionAttribute]
public static void AddAlign(IList`1<object> args, Nullable`1<TimeStamp> alignMaybe);
    [ExtensionAttribute]
public static void AddBucketTimestamp(IList`1<object> args, Nullable`1<TsBucketTimestamps> bt);
    [ExtensionAttribute]
public static void AddAggregation(IList`1<object> args, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    [ExtensionAttribute]
public static void AddAggregation(IList`1<object> args, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket);
    [ExtensionAttribute]
public static void AddFilters(List`1<object> args, IReadOnlyCollection`1<string> filter);
    [ExtensionAttribute]
public static void AddFilterByTs(List`1<object> args, IReadOnlyCollection`1<TimeStamp> filter);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddFilterByValue(List`1<object> args, Nullable`1<ValueTuple`2<long, long>> filter);
    [ExtensionAttribute]
public static void AddWithLabels(IList`1<object> args, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels);
    [ExtensionAttribute]
public static void AddGroupby(IList`1<object> args, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    [ExtensionAttribute]
public static void AddTimeStamp(IList`1<object> args, TimeStamp timeStamp);
    [ExtensionAttribute]
public static void AddRule(IList`1<object> args, TimeSeriesRule rule);
    public static List`1<object> BuildTsCreateArgs(string key, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> policy);
    public static List`1<object> BuildTsAlterArgs(string key, Nullable`1<long> retentionTime, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> policy, IReadOnlyCollection`1<TimeSeriesLabel> labels);
    public static List`1<object> BuildTsAddArgs(string key, TimeStamp timestamp, double value, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> policy);
    public static List`1<object> BuildTsIncrDecrByArgs(string key, double value, Nullable`1<TimeStamp> timestampMaybe, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public static List`1<object> BuildTsDelArgs(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp);
    public static List`1<object> BuildTsMaddArgs(IReadOnlyCollection`1<ValueTuple`3<string, TimeStamp, double>> sequence);
    public static List`1<object> BuildTsMgetArgs(bool latest, IReadOnlyCollection`1<string> filter, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectedLabels);
    public static List`1<object> BuildRangeArgs(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    public static List`1<object> BuildMultiRangeArgs(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.TimeSeriesCommands : TimeSeriesCommandsAsync {
    private IDatabase _db;
    public TimeSeriesCommands(IDatabase db);
    public sealed virtual bool Create(string key, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public sealed virtual bool Alter(string key, Nullable`1<long> retentionTime, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy, IReadOnlyCollection`1<TimeSeriesLabel> labels);
    public sealed virtual TimeStamp Add(string key, TimeStamp timestamp, double value, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public sealed virtual IReadOnlyList`1<TimeStamp> MAdd(IReadOnlyCollection`1<ValueTuple`3<string, TimeStamp, double>> sequence);
    public sealed virtual TimeStamp IncrBy(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public sealed virtual TimeStamp DecrBy(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public sealed virtual long Del(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp);
    public sealed virtual bool CreateRule(string sourceKey, TimeSeriesRule rule, long alignTimestamp);
    public sealed virtual bool DeleteRule(string sourceKey, string destKey);
    public sealed virtual TimeSeriesTuple Get(string key, bool latest);
    public sealed virtual IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, TimeSeriesTuple>> MGet(IReadOnlyCollection`1<string> filter, bool latest, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectedLabels);
    public sealed virtual IReadOnlyList`1<TimeSeriesTuple> Range(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    public sealed virtual IReadOnlyList`1<TimeSeriesTuple> RevRange(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    [NullableContextAttribute("0")]
public sealed virtual IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>> MRange(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    [NullableContextAttribute("0")]
public sealed virtual IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>> MRevRange(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    [ObsoleteAttribute]
public sealed virtual TimeSeriesInformation Info(string key, bool debug);
    public sealed virtual IReadOnlyList`1<string> QueryIndex(IReadOnlyCollection`1<string> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.TimeSeriesCommandsAsync : object {
    private IDatabaseAsync _db;
    public TimeSeriesCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<CreateAsync>d__2")]
public sealed virtual Task`1<bool> CreateAsync(string key, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<AlterAsync>d__3")]
public sealed virtual Task`1<bool> AlterAsync(string key, Nullable`1<long> retentionTime, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy, IReadOnlyCollection`1<TimeSeriesLabel> labels);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<AddAsync>d__4")]
public sealed virtual Task`1<TimeStamp> AddAsync(string key, TimeStamp timestamp, double value, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<MAddAsync>d__5")]
public sealed virtual Task`1<IReadOnlyList`1<TimeStamp>> MAddAsync(IReadOnlyCollection`1<ValueTuple`3<string, TimeStamp, double>> sequence);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<IncrByAsync>d__6")]
public sealed virtual Task`1<TimeStamp> IncrByAsync(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<DecrByAsync>d__7")]
public sealed virtual Task`1<TimeStamp> DecrByAsync(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<DelAsync>d__8")]
public sealed virtual Task`1<long> DelAsync(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<CreateRuleAsync>d__9")]
public sealed virtual Task`1<bool> CreateRuleAsync(string sourceKey, TimeSeriesRule rule, long alignTimestamp);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<DeleteRuleAsync>d__10")]
public sealed virtual Task`1<bool> DeleteRuleAsync(string sourceKey, string destKey);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<GetAsync>d__11")]
public sealed virtual Task`1<TimeSeriesTuple> GetAsync(string key, bool latest);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<MGetAsync>d__12")]
public sealed virtual Task`1<IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, TimeSeriesTuple>>> MGetAsync(IReadOnlyCollection`1<string> filter, bool latest, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectedLabels);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<RangeAsync>d__13")]
public sealed virtual Task`1<IReadOnlyList`1<TimeSeriesTuple>> RangeAsync(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<RevRangeAsync>d__14")]
public sealed virtual Task`1<IReadOnlyList`1<TimeSeriesTuple>> RevRangeAsync(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<MRangeAsync>d__15")]
public sealed virtual Task`1<IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>>> MRangeAsync(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<MRevRangeAsync>d__16")]
public sealed virtual Task`1<IReadOnlyList`1<ValueTuple`3<string, IReadOnlyList`1<TimeSeriesLabel>, IReadOnlyList`1<TimeSeriesTuple>>>> MRevRangeAsync(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<InfoAsync>d__17")]
[ObsoleteAttribute]
public sealed virtual Task`1<TimeSeriesInformation> InfoAsync(string key, bool debug);
    [AsyncStateMachineAttribute("NRedisStack.TimeSeriesCommandsAsync/<QueryIndexAsync>d__18")]
public sealed virtual Task`1<IReadOnlyList`1<string>> QueryIndexAsync(IReadOnlyCollection`1<string> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.TimeSeriesCommandsBuilder : object {
    public static SerializedCommand Create(string key, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public static SerializedCommand Alter(string key, Nullable`1<long> retentionTime, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy, IReadOnlyCollection`1<TimeSeriesLabel> labels);
    public static SerializedCommand Add(string key, TimeStamp timestamp, double value, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes, Nullable`1<TsDuplicatePolicy> duplicatePolicy);
    public static SerializedCommand MAdd(IReadOnlyCollection`1<ValueTuple`3<string, TimeStamp, double>> sequence);
    public static SerializedCommand IncrBy(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public static SerializedCommand DecrBy(string key, double value, Nullable`1<TimeStamp> timestamp, Nullable`1<long> retentionTime, IReadOnlyCollection`1<TimeSeriesLabel> labels, Nullable`1<bool> uncompressed, Nullable`1<long> chunkSizeBytes);
    public static SerializedCommand Del(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp);
    public static SerializedCommand CreateRule(string sourceKey, TimeSeriesRule rule, long alignTimestamp);
    public static SerializedCommand DeleteRule(string sourceKey, string destKey);
    public static SerializedCommand Get(string key, bool latest);
    public static SerializedCommand MGet(IReadOnlyCollection`1<string> filter, bool latest, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectedLabels);
    public static SerializedCommand Range(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    public static SerializedCommand RevRange(string key, TimeStamp fromTimeStamp, TimeStamp toTimeStamp, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty);
    public static SerializedCommand MRange(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    public static SerializedCommand MRevRange(TimeStamp fromTimeStamp, TimeStamp toTimeStamp, IReadOnlyCollection`1<string> filter, bool latest, IReadOnlyCollection`1<TimeStamp> filterByTs, Nullable`1<ValueTuple`2<long, long>> filterByValue, Nullable`1<bool> withLabels, IReadOnlyCollection`1<string> selectLabels, Nullable`1<long> count, Nullable`1<TimeStamp> align, Nullable`1<TsAggregation> aggregation, Nullable`1<long> timeBucket, Nullable`1<TsBucketTimestamps> bt, bool empty, Nullable`1<ValueTuple`2<string, TsReduce>> groupbyTuple);
    public static SerializedCommand Info(string key, bool debug);
    public static SerializedCommand QueryIndex(IReadOnlyCollection`1<string> filter);
}
public class NRedisStack.TopK.DataTypes.TopKInformation : object {
    [CompilerGeneratedAttribute]
private long <K>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Decay>k__BackingField;
    public long K { get; private set; }
    public long Width { get; private set; }
    public long Depth { get; private set; }
    public double Decay { get; private set; }
    internal TopKInformation(long k, long width, long depth, double decay);
    [CompilerGeneratedAttribute]
public long get_K();
    [CompilerGeneratedAttribute]
private void set_K(long value);
    [CompilerGeneratedAttribute]
public long get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(long value);
    [CompilerGeneratedAttribute]
public long get_Depth();
    [CompilerGeneratedAttribute]
private void set_Depth(long value);
    [CompilerGeneratedAttribute]
public double get_Decay();
    [CompilerGeneratedAttribute]
private void set_Decay(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NRedisStack.TopK.Literals.TOPK : object {
    public static string RESERVE;
    public static string ADD;
    public static string INCRBY;
    public static string QUERY;
    public static string COUNT;
    public static string LIST;
    public static string INFO;
}
internal class NRedisStack.TopK.Literals.TopKArgs : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NRedisStack.TopKCommandBuilder : object {
    public static SerializedCommand Add(RedisKey key, RedisValue[] items);
    public static SerializedCommand Count(RedisKey key, RedisValue[] items);
    public static SerializedCommand IncrBy(RedisKey key, Tuple`2[] itemIncrements);
    public static SerializedCommand Info(RedisKey key);
    public static SerializedCommand List(RedisKey key, bool withcount);
    public static SerializedCommand Query(RedisKey key, RedisValue[] items);
    public static SerializedCommand Reserve(RedisKey key, long topk, long width, long depth, double decay);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.TopKCommands : TopKCommandsAsync {
    private IDatabase _db;
    public TopKCommands(IDatabase db);
    public sealed virtual RedisResult[] Add(RedisKey key, RedisValue[] items);
    public sealed virtual Int64[] Count(RedisKey key, RedisValue[] items);
    public sealed virtual RedisResult[] IncrBy(RedisKey key, Tuple`2[] itemIncrements);
    public sealed virtual TopKInformation Info(RedisKey key);
    public sealed virtual RedisResult[] List(RedisKey key, bool withcount);
    public sealed virtual bool Query(RedisKey key, RedisValue item);
    public sealed virtual Boolean[] Query(RedisKey key, RedisValue[] items);
    public sealed virtual bool Reserve(RedisKey key, long topk, long width, long depth, double decay);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.TopKCommandsAsync : object {
    private IDatabaseAsync _db;
    public TopKCommandsAsync(IDatabaseAsync db);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<AddAsync>d__2")]
public sealed virtual Task`1<RedisResult[]> AddAsync(RedisKey key, RedisValue[] items);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<CountAsync>d__3")]
public sealed virtual Task`1<Int64[]> CountAsync(RedisKey key, RedisValue[] items);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<IncrByAsync>d__4")]
public sealed virtual Task`1<RedisResult[]> IncrByAsync(RedisKey key, Tuple`2[] itemIncrements);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<InfoAsync>d__5")]
public sealed virtual Task`1<TopKInformation> InfoAsync(RedisKey key);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<ListAsync>d__6")]
public sealed virtual Task`1<RedisResult[]> ListAsync(RedisKey key, bool withcount);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<QueryAsync>d__7")]
public sealed virtual Task`1<bool> QueryAsync(RedisKey key, RedisValue item);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<QueryAsync>d__8")]
public sealed virtual Task`1<Boolean[]> QueryAsync(RedisKey key, RedisValue[] items);
    [AsyncStateMachineAttribute("NRedisStack.TopKCommandsAsync/<ReserveAsync>d__9")]
public sealed virtual Task`1<bool> ReserveAsync(RedisKey key, long topk, long width, long depth, double decay);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NRedisStack.Transaction : object {
    private ITransaction _transaction;
    public IDatabaseAsync Db { get; }
    public BloomCommandsAsync Bf { get; }
    public CmsCommandsAsync Cms { get; }
    public CuckooCommandsAsync Cf { get; }
    [ObsoleteAttribute]
public GraphCommandsAsync Graph { get; }
    public JsonCommandsAsync Json { get; }
    public SearchCommandsAsync Ft { get; }
    public TdigestCommandsAsync Tdigest { get; }
    public TimeSeriesCommandsAsync Ts { get; }
    public TopKCommandsAsync TopK { get; }
    public Transaction(IDatabase db);
    public IDatabaseAsync get_Db();
    public ConditionResult AddCondition(Condition condition);
    public bool Execute(CommandFlags flags);
    public Task`1<bool> ExecuteAsync(CommandFlags flags);
    public BloomCommandsAsync get_Bf();
    public CmsCommandsAsync get_Cms();
    public CuckooCommandsAsync get_Cf();
    public GraphCommandsAsync get_Graph();
    public JsonCommandsAsync get_Json();
    public SearchCommandsAsync get_Ft();
    public TdigestCommandsAsync get_Tdigest();
    public TimeSeriesCommandsAsync get_Ts();
    public TopKCommandsAsync get_TopK();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
