[ExtensionAttribute]
internal static class AssemblyExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetLocalCodeBase(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DictionaryExtensions : object {
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TValue> inputValues, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TInput> inputValues, Func`2<TInput, TKey> keySelector, Func`2<TInput, TValue> valueSelector, IEqualityComparer`1<TKey> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class ExceptionExtensions : object {
    [ExtensionAttribute]
[DoesNotReturnAttribute]
public static void Rethrow(Exception ex);
    [ExtensionAttribute]
public static Exception Unwrap(Exception ex);
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.ApplicationEnvironment : object {
    [CompilerGeneratedAttribute]
private static string <ApplicationBasePath>k__BackingField;
    public static string ApplicationBasePath { get; }
    private static ApplicationEnvironment();
    [CompilerGeneratedAttribute]
public static string get_ApplicationBasePath();
    private static string GetApplicationBasePath();
}
internal class Internal.Microsoft.DotNet.PlatformAbstractions.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.NativeMethods : object {
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.PlatformApis : object {
    private static Lazy`1<Platform> _platform;
    private static Lazy`1<DistroInfo> _distroInfo;
    private static PlatformApis();
    public static string GetOSName();
    public static string GetOSVersion();
    private static string GetDarwinVersion();
    public static Platform GetOSPlatform();
    private static string GetDistroId();
    private static string GetDistroVersionId();
    private static DistroInfo LoadDistroInfo();
    private static DistroInfo NormalizeDistroInfo(DistroInfo distroInfo);
    private static Platform DetermineOSPlatform();
}
internal enum Internal.Microsoft.DotNet.PlatformAbstractions.Platform : Enum {
    public int value__;
    public static Platform Unknown;
    public static Platform Windows;
    public static Platform Linux;
    public static Platform Darwin;
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment : object {
    private static string OverrideEnvironmentVariableName;
    [CompilerGeneratedAttribute]
private static Platform <OperatingSystemPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RuntimeArchitecture>k__BackingField;
    public static Platform OperatingSystemPlatform { get; }
    public static string OperatingSystemVersion { get; }
    public static string OperatingSystem { get; }
    public static string RuntimeArchitecture { get; }
    private static RuntimeEnvironment();
    [CompilerGeneratedAttribute]
public static Platform get_OperatingSystemPlatform();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystemVersion();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystem();
    [CompilerGeneratedAttribute]
public static string get_RuntimeArchitecture();
    private static string GetArch();
    public static string GetRuntimeIdentifier();
    private static string GetRIDArch();
    private static string GetRIDVersion();
    private static string GetWindowsProductVersion();
    private static string GetRIDOS();
}
internal class Internal.Microsoft.Extensions.DependencyModel.CompilationLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private static ICompilationAssemblyResolver <DefaultResolver>k__BackingField;
    public IReadOnlyList`1<string> Assemblies { get; }
    internal static ICompilationAssemblyResolver DefaultResolver { get; }
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    private static CompilationLibrary();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Assemblies();
    [CompilerGeneratedAttribute]
internal static ICompilationAssemblyResolver get_DefaultResolver();
    public IEnumerable`1<string> ResolveReferencePaths();
    public IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver[] customResolvers);
    private IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver resolver, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.CompilationOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Defines>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PublicSign>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DebugType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EmitEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GenerateXmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompilationOptions <Default>k__BackingField;
    public IReadOnlyList`1<string> Defines { get; }
    public string LanguageVersion { get; }
    public string Platform { get; }
    public Nullable`1<bool> AllowUnsafe { get; }
    public Nullable`1<bool> WarningsAsErrors { get; }
    public Nullable`1<bool> Optimize { get; }
    public string KeyFile { get; }
    public Nullable`1<bool> DelaySign { get; }
    public Nullable`1<bool> PublicSign { get; }
    public string DebugType { get; }
    public Nullable`1<bool> EmitEntryPoint { get; }
    public Nullable`1<bool> GenerateXmlDocumentation { get; }
    public static CompilationOptions Default { get; }
    public CompilationOptions(IEnumerable`1<string> defines, string languageVersion, string platform, Nullable`1<bool> allowUnsafe, Nullable`1<bool> warningsAsErrors, Nullable`1<bool> optimize, string keyFile, Nullable`1<bool> delaySign, Nullable`1<bool> publicSign, string debugType, Nullable`1<bool> emitEntryPoint, Nullable`1<bool> generateXmlDocumentation);
    private static CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Defines();
    [CompilerGeneratedAttribute]
public string get_LanguageVersion();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnsafe();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DelaySign();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PublicSign();
    [CompilerGeneratedAttribute]
public string get_DebugType();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EmitEntryPoint();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_GenerateXmlDocumentation();
    [CompilerGeneratedAttribute]
public static CompilationOptions get_Default();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Dependency : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; }
    public string Version { get; }
    public Dependency(string name, string version);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Version();
    public bool Equals(Dependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContext : object {
    private static Lazy`1<DependencyContext> _defaultContext;
    [CompilerGeneratedAttribute]
private TargetInfo <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CompilationLibrary> <CompileLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeLibrary> <RuntimeLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeFallbacks> <RuntimeGraph>k__BackingField;
    public static DependencyContext Default { get; }
    public TargetInfo Target { get; }
    public CompilationOptions CompilationOptions { get; }
    public IReadOnlyList`1<CompilationLibrary> CompileLibraries { get; }
    public IReadOnlyList`1<RuntimeLibrary> RuntimeLibraries { get; }
    public IReadOnlyList`1<RuntimeFallbacks> RuntimeGraph { get; }
    public DependencyContext(TargetInfo target, CompilationOptions compilationOptions, IEnumerable`1<CompilationLibrary> compileLibraries, IEnumerable`1<RuntimeLibrary> runtimeLibraries, IEnumerable`1<RuntimeFallbacks> runtimeGraph);
    private static DependencyContext();
    public static DependencyContext get_Default();
    [CompilerGeneratedAttribute]
public TargetInfo get_Target();
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CompilationLibrary> get_CompileLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeLibrary> get_RuntimeLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeFallbacks> get_RuntimeGraph();
    public DependencyContext Merge(DependencyContext other);
    private static DependencyContext LoadDefault();
    public static DependencyContext Load(Assembly assembly);
}
[ExtensionAttribute]
internal static class Internal.Microsoft.Extensions.DependencyModel.DependencyContextExtensions : object {
    private static string NativeImageSufix;
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    private static AssemblyName GetAssemblyName(string assetPath);
    private static IEnumerable`1<string> ResolveAssets(DependencyContext context, string runtimeIdentifier, IEnumerable`1<RuntimeAssetGroup> assets);
    private static IEnumerable`1<string> SelectAssets(IEnumerable`1<string> rids, IEnumerable`1<RuntimeAssetGroup> groups);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextJsonReader : object {
    private static String[] EmptyStringArray;
    private IDictionary`2<string, string> _stringPool;
    private static DependencyContextJsonReader();
    public sealed virtual DependencyContext Read(Stream stream);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private DependencyContext Read(TextReader reader);
    private Target SelectRuntimeTarget(List`1<Target> targets, string runtimeTargetName);
    private bool IsRuntimeTarget(string name);
    private void ReadRuntimeTarget(JsonObject runtimeTargetJson, String& runtimeTargetName, String& runtimeSignature);
    private CompilationOptions ReadCompilationOptions(JsonObject compilationOptionsJson);
    private List`1<Target> ReadTargets(JsonObject targetsJson);
    private Target ReadTarget(string targetName, JsonObject targetJson);
    private TargetLibrary ReadTargetLibrary(string targetLibraryName, JsonObject targetLibraryJson);
    public IEnumerable`1<Dependency> ReadTargetLibraryDependencies(JsonObject targetLibraryDependenciesJson);
    private List`1<RuntimeTargetEntryStub> ReadTargetLibraryRuntimeTargets(JsonObject targetLibraryRuntimeTargetsJson);
    private List`1<ResourceAssembly> ReadTargetLibraryResources(JsonObject targetLibraryResourcesJson);
    private Dictionary`2<string, LibraryStub> ReadLibraries(JsonObject librariesJson);
    private LibraryStub ReadLibrary(JsonObject libraryJson);
    private List`1<RuntimeFallbacks> ReadRuntimes(JsonObject runtimesJson);
    private IEnumerable`1<Library> CreateLibraries(IEnumerable`1<TargetLibrary> libraries, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private Library CreateLibrary(TargetLibrary targetLibrary, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private string Pool(string s);
    [CompilerGeneratedAttribute]
private bool <Read>b__5_0(Target t);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextLoader : object {
    private static string DepsJsonExtension;
    private string _entryPointDepsLocation;
    private IEnumerable`1<string> _nonEntryPointDepsPaths;
    private IFileSystem _fileSystem;
    private Func`1<IDependencyContextReader> _jsonReaderFactory;
    [CompilerGeneratedAttribute]
private static DependencyContextLoader <Default>k__BackingField;
    public static DependencyContextLoader Default { get; }
    internal DependencyContextLoader(string entryPointDepsLocation, IEnumerable`1<string> nonEntryPointDepsPaths, IFileSystem fileSystem, Func`1<IDependencyContextReader> jsonReaderFactory);
    private static DependencyContextLoader();
    [CompilerGeneratedAttribute]
public static DependencyContextLoader get_Default();
    private static bool IsEntryAssembly(Assembly assembly);
    private static Stream GetResourceStream(Assembly assembly, string name);
    public DependencyContext Load(Assembly assembly);
    private DependencyContext LoadEntryAssemblyContext(IDependencyContextReader reader);
    private DependencyContext LoadContext(IDependencyContextReader reader, string location);
    private DependencyContext LoadAssemblyContext(Assembly assembly, IDependencyContextReader reader);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextPaths : object {
    private static string DepsFilesProperty;
    private static string FxDepsFileProperty;
    [CompilerGeneratedAttribute]
private static DependencyContextPaths <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <NonApplicationPaths>k__BackingField;
    public static DependencyContextPaths Current { get; }
    public string Application { get; }
    public string SharedRuntime { get; }
    public IEnumerable`1<string> NonApplicationPaths { get; }
    public DependencyContextPaths(string application, string sharedRuntime, IEnumerable`1<string> nonApplicationPaths);
    private static DependencyContextPaths();
    [CompilerGeneratedAttribute]
public static DependencyContextPaths get_Current();
    [CompilerGeneratedAttribute]
public string get_Application();
    [CompilerGeneratedAttribute]
public string get_SharedRuntime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_NonApplicationPaths();
    private static DependencyContextPaths GetCurrent();
    internal static DependencyContextPaths Create(string depsFiles, string sharedRuntime);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextStrings : object {
    internal static char VersionSeperator;
    internal static string CompileTimeAssembliesKey;
    internal static string RuntimeAssembliesKey;
    internal static string NativeLibrariesKey;
    internal static string RuntimeTargetPropertyName;
    internal static string LibrariesPropertyName;
    internal static string TargetsPropertyName;
    internal static string DependenciesPropertyName;
    internal static string Sha512PropertyName;
    internal static string PathPropertyName;
    internal static string HashPathPropertyName;
    internal static string RuntimeStoreManifestPropertyName;
    internal static string TypePropertyName;
    internal static string ServiceablePropertyName;
    internal static string CompilationOptionsPropertName;
    internal static string DefinesPropertyName;
    internal static string LanguageVersionPropertyName;
    internal static string PlatformPropertyName;
    internal static string AllowUnsafePropertyName;
    internal static string WarningsAsErrorsPropertyName;
    internal static string OptimizePropertyName;
    internal static string KeyFilePropertyName;
    internal static string DelaySignPropertyName;
    internal static string PublicSignPropertyName;
    internal static string DebugTypePropertyName;
    internal static string EmitEntryPointPropertyName;
    internal static string GenerateXmlDocumentationPropertyName;
    internal static string PortablePropertyName;
    internal static string RuntimeTargetNamePropertyName;
    internal static string RuntimeTargetSignaturePropertyName;
    internal static string RuntimesPropertyName;
    internal static string RuntimeTargetsPropertyName;
    internal static string RidPropertyName;
    internal static string AssetTypePropertyName;
    internal static string RuntimeAssetType;
    internal static string NativeAssetType;
    internal static string ResourceAssembliesPropertyName;
    internal static string LocalePropertyName;
    internal static string CompilationOnlyPropertyName;
}
internal class Internal.Microsoft.Extensions.DependencyModel.DirectoryWrapper : object {
    public sealed virtual bool Exists(string path);
}
internal class Internal.Microsoft.Extensions.DependencyModel.EnvironmentWrapper : object {
    public static IEnvironment Default;
    private static EnvironmentWrapper();
    public sealed virtual string GetEnvironmentVariable(string name);
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileSystemWrapper : object {
    [CompilerGeneratedAttribute]
private static IFileSystem <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectory <Directory>k__BackingField;
    public static IFileSystem Default { get; }
    public IFile File { get; }
    public IDirectory Directory { get; }
    private static FileSystemWrapper();
    [CompilerGeneratedAttribute]
public static IFileSystem get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_File();
    [CompilerGeneratedAttribute]
public sealed virtual IDirectory get_Directory();
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileWrapper : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual Stream OpenRead(string path);
    public sealed virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public sealed virtual void CreateEmptyFile(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IDependencyContextReader {
    public abstract virtual DependencyContext Read(Stream stream);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IDirectory {
    public abstract virtual bool Exists(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IEnvironment {
    public abstract virtual string GetEnvironmentVariable(string name);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFile {
    public abstract virtual bool Exists(string path);
    public abstract virtual string ReadAllText(string path);
    public abstract virtual Stream OpenRead(string path);
    public abstract virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public abstract virtual void CreateEmptyFile(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFileSystem {
    public IFile File { get; }
    public IDirectory Directory { get; }
    public abstract virtual IFile get_File();
    public abstract virtual IDirectory get_Directory();
}
[DefaultMemberAttribute("Item")]
internal class Internal.Microsoft.Extensions.DependencyModel.JsonArray : JsonValue {
    private JsonValue[] _array;
    public int Length { get; }
    public JsonValue Item { get; }
    public JsonArray(JsonValue[] array, int line, int column);
    public int get_Length();
    public JsonValue get_Item(int index);
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonBoolean : JsonValue {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; private set; }
    public JsonBoolean(JsonToken token);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(bool value);
    public static bool op_Implicit(JsonBoolean jsonBoolean);
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonBuffer : object {
    public static string ValueNull;
    public static string ValueTrue;
    public static string ValueFalse;
    private StringBuilder _buffer;
    private StringBuilder _codePointBuffer;
    private TextReader _reader;
    private JsonToken _token;
    private int _line;
    private int _column;
    public JsonBuffer(TextReader reader);
    public JsonToken Read();
    private int ReadNextChar();
    private string ReadNumber(int firstRead);
    private void ReadLiteral(string literal);
    private string ReadString();
    private static bool IsWhitespace(int value);
}
internal static class Internal.Microsoft.Extensions.DependencyModel.JsonDeserializer : object {
    public static JsonValue Deserialize(TextReader reader);
    private static JsonValue DeserializeInternal(JsonToken next, JsonBuffer buffer);
    private static JsonArray DeserializeArray(JsonToken head, JsonBuffer buffer);
    private static JsonObject DeserializeObject(JsonToken head, JsonBuffer buffer);
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonDeserializerException : Exception {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonDeserializerException(string message, Exception innerException, int line, int column);
    public JsonDeserializerException(string message, int line, int column);
    public JsonDeserializerException(string message, JsonToken nextToken);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
internal static class Internal.Microsoft.Extensions.DependencyModel.JsonDeserializerResource : object {
    internal static string JSON_OpenString { get; }
    internal static string JSON_InvalidEnd { get; }
    internal static string Format_IllegalCharacter(int value);
    internal static string Format_IllegalTrailingCharacterAfterLiteral(int value, string literal);
    internal static string Format_UnrecognizedLiteral(string literal);
    internal static string Format_DuplicateObjectMemberName(string memberName);
    internal static string Format_InvalidFloatNumberFormat(string raw);
    internal static string Format_FloatNumberOverflow(string raw);
    internal static string Format_InvalidSyntax(string syntaxName, string issue);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, char unexpected);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, string unexpected);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, string expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation1, char expectation2);
    internal static string Format_InvalidTokenExpectation(string tokenValue, string expectation);
    internal static string Format_InvalidUnicode(string unicode);
    internal static string Format_UnfinishedJSON(string nextTokenValue);
    internal static string get_JSON_OpenString();
    internal static string get_JSON_InvalidEnd();
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonNull : JsonValue {
    public JsonNull(int line, int column);
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonNumber : JsonValue {
    private string _raw;
    private double _double;
    public double Double { get; }
    public string Raw { get; }
    public JsonNumber(JsonToken token);
    public double get_Double();
    public string get_Raw();
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonObject : JsonValue {
    private IDictionary`2<string, JsonValue> _data;
    public ICollection`1<string> Keys { get; }
    public JsonObject(IDictionary`2<string, JsonValue> data, int line, int column);
    public ICollection`1<string> get_Keys();
    public JsonValue Value(string key);
    public JsonObject ValueAsJsonObject(string key);
    public JsonString ValueAsString(string key);
    public int ValueAsInt(string key);
    public bool ValueAsBoolean(string key, bool defaultValue);
    public Nullable`1<bool> ValueAsNullableBoolean(string key);
    public String[] ValueAsStringArray(string key);
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonString : JsonValue {
    private string _value;
    public string Value { get; }
    public JsonString(string value, int line, int column);
    public string get_Value();
    public virtual string ToString();
    public static string op_Implicit(JsonString instance);
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonToken : ValueType {
    public JsonTokenType Type;
    public string Value;
    public int Line;
    public int Column;
}
internal enum Internal.Microsoft.Extensions.DependencyModel.JsonTokenType : Enum {
    public int value__;
    public static JsonTokenType LeftCurlyBracket;
    public static JsonTokenType LeftSquareBracket;
    public static JsonTokenType RightCurlyBracket;
    public static JsonTokenType RightSquareBracket;
    public static JsonTokenType Colon;
    public static JsonTokenType Comma;
    public static JsonTokenType Null;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Number;
    public static JsonTokenType String;
    public static JsonTokenType EOF;
}
internal class Internal.Microsoft.Extensions.DependencyModel.JsonValue : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonValue(int line, int column);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Library : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Dependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeStoreManifestName>k__BackingField;
    public string Type { get; }
    public string Name { get; }
    public string Version { get; }
    public string Hash { get; }
    public IReadOnlyList`1<Dependency> Dependencies { get; }
    public bool Serviceable { get; }
    public string Path { get; }
    public string HashPath { get; }
    public string RuntimeStoreManifestName { get; }
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Dependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_HashPath();
    [CompilerGeneratedAttribute]
public string get_RuntimeStoreManifestName();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.AppBaseCompilationAssemblyResolver : object {
    private static string RefsDirectoryName;
    private IFileSystem _fileSystem;
    private string _basePath;
    private DependencyContextPaths _dependencyContextPaths;
    public AppBaseCompilationAssemblyResolver(string basePath);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem, string basePath, DependencyContextPaths dependencyContextPaths);
    private static AppBaseCompilationAssemblyResolver();
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.CompositeCompilationAssemblyResolver : object {
    private ICompilationAssemblyResolver[] _resolvers;
    public CompositeCompilationAssemblyResolver(ICompilationAssemblyResolver[] resolvers);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.DotNetReferenceAssembliesPathResolver : object {
    public static string DotNetReferenceAssembliesPathEnv;
    private static DotNetReferenceAssembliesPathResolver();
    internal static string Resolve(IEnvironment envirnment, IFileSystem fileSystem);
    public static string Resolve();
    private static string GetDefaultDotNetReferenceAssembliesPath(IFileSystem fileSystem);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.Resolution.ICompilationAssemblyResolver {
    public abstract virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.PackageCompilationAssemblyResolver : object {
    private IFileSystem _fileSystem;
    private String[] _nugetPackageDirectories;
    public PackageCompilationAssemblyResolver(string nugetPackageDirectory);
    internal PackageCompilationAssemblyResolver(IEnvironment environment, IFileSystem fileSystem);
    internal PackageCompilationAssemblyResolver(IFileSystem fileSystem, String[] nugetPackageDirectories);
    private static String[] GetDefaultProbeDirectories(IEnvironment environment);
    internal static String[] GetDefaultProbeDirectories(Platform osPlatform, IEnvironment environment);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private static bool TryResolveFromPackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, IEnumerable`1& results);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.ReferenceAssemblyPathResolver : object {
    private IFileSystem _fileSystem;
    private string _defaultReferenceAssembliesPath;
    private String[] _fallbackSearchPaths;
    public ReferenceAssemblyPathResolver(string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, IEnvironment environment);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveReferenceAssembly(string path, String& fullPath);
    internal static String[] GetFallbackSearchPaths(IFileSystem fileSystem, Platform platform, IEnvironment environment);
    internal static string GetDefaultReferenceAssembliesPath(IFileSystem fileSystem, Platform platform, IEnvironment environment);
}
internal static class Internal.Microsoft.Extensions.DependencyModel.Resolution.ResolverUtils : object {
    internal static bool TryResolvePackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, String& packagePath);
    internal static bool TryResolveAssemblyFile(IFileSystem fileSystem, string basePath, string assemblyPath, String& fullName);
}
internal class Internal.Microsoft.Extensions.DependencyModel.ResourceAssembly : object {
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Locale { get; public set; }
    public string Path { get; public set; }
    public ResourceAssembly(string path, string locale);
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssembly : object {
    private static string NativeImageSufix;
    private string _assemblyName;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public AssemblyName Name { get; }
    public string Path { get; }
    public RuntimeAssembly(string assemblyName, string path);
    public AssemblyName get_Name();
    [CompilerGeneratedAttribute]
public string get_Path();
    public static RuntimeAssembly Create(string path);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssetGroup : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AssetPaths>k__BackingField;
    public string Runtime { get; }
    public IReadOnlyList`1<string> AssetPaths { get; }
    public RuntimeAssetGroup(string runtime, String[] assetPaths);
    public RuntimeAssetGroup(string runtime, IEnumerable`1<string> assetPaths);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AssetPaths();
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeFallbacks : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Fallbacks>k__BackingField;
    public string Runtime { get; public set; }
    public IReadOnlyList`1<string> Fallbacks { get; public set; }
    public RuntimeFallbacks(string runtime, String[] fallbacks);
    public RuntimeFallbacks(string runtime, IEnumerable`1<string> fallbacks);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public void set_Runtime(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Fallbacks();
    [CompilerGeneratedAttribute]
public void set_Fallbacks(IReadOnlyList`1<string> value);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <RuntimeAssemblyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <NativeLibraryGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ResourceAssembly> <ResourceAssemblies>k__BackingField;
    public IReadOnlyList`1<RuntimeAssetGroup> RuntimeAssemblyGroups { get; }
    public IReadOnlyList`1<RuntimeAssetGroup> NativeLibraryGroups { get; }
    public IReadOnlyList`1<ResourceAssembly> ResourceAssemblies { get; }
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_RuntimeAssemblyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_NativeLibraryGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ResourceAssembly> get_ResourceAssemblies();
}
internal class Internal.Microsoft.Extensions.DependencyModel.TargetInfo : object {
    [CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortable>k__BackingField;
    public string Framework { get; }
    public string Runtime { get; }
    public string RuntimeSignature { get; }
    public bool IsPortable { get; }
    public TargetInfo(string framework, string runtime, string runtimeSignature, bool isPortable);
    [CompilerGeneratedAttribute]
public string get_Framework();
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public string get_RuntimeSignature();
    [CompilerGeneratedAttribute]
public bool get_IsPortable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LoggerHelper : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IMessageLogger <InnerLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Stopwatch>k__BackingField;
    [NullableAttribute("2")]
public IMessageLogger InnerLogger { get; private set; }
    public Stopwatch Stopwatch { get; private set; }
    public LoggerHelper(IMessageLogger logger, Stopwatch stopwatch);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IMessageLogger get_InnerLogger();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_InnerLogger(IMessageLogger value);
    [CompilerGeneratedAttribute]
public Stopwatch get_Stopwatch();
    [CompilerGeneratedAttribute]
private void set_Stopwatch(Stopwatch value);
    public void Log(string format, Object[] args);
    public void Log(ITestCase testCase, string format, Object[] args);
    public void LogWithSource(string source, string format, Object[] args);
    public void LogError(string format, Object[] args);
    public void LogError(ITestCase testCase, string format, Object[] args);
    public void LogErrorWithSource(string source, string format, Object[] args);
    public void LogWarning(string format, Object[] args);
    public void LogWarning(ITestCase testCase, string format, Object[] args);
    public void LogWarningWithSource(string source, string format, Object[] args);
    private void SendMessage(IMessageLogger logger, TestMessageLevel level, string assemblyName, string message);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static RuntimeAssetGroup GetDefaultGroup(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static RuntimeAssetGroup GetRuntimeGroup(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static RuntimeAssetGroup GetGroup(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultAssets(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeAssets(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static IEnumerable`1<string> GetAssets(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Generic.EnumerableExtensions : object {
    private static Func`2<object, bool> notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> This, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Xunit._DiagnosticMessage : LongLivedMarshalByRefObject {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; public set; }
    public _DiagnosticMessage(string message);
    public _DiagnosticMessage(string format, Object[] args);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Xunit.AssemblyHelper : AssemblyLoadContext {
    [NullableAttribute("2")]
private DependencyContextAssemblyCache assemblyCache;
    public AssemblyHelper(string assemblyFileName, IMessageSink internalDiagnosticsMessageSink);
    public sealed virtual void Dispose();
    protected virtual Assembly Load(AssemblyName assemblyName);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
    private Assembly OnResolving(AssemblyLoadContext context, AssemblyName name);
    public static IDisposable SubscribeResolveForAssembly(string assemblyFileName, IMessageSink internalDiagnosticsMessageSink);
    public static IDisposable SubscribeResolveForAssembly(Type typeInAssembly, IMessageSink internalDiagnosticsMessageSink);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Xunit.ConsoleHelper : object {
    [CompilerGeneratedAttribute]
private static Action <ResetColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<ConsoleColor> <SetBackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<ConsoleColor> <SetForegroundColor>k__BackingField;
    public static Action ResetColor { get; }
    public static Action`1<ConsoleColor> SetBackgroundColor { get; }
    public static Action`1<ConsoleColor> SetForegroundColor { get; }
    private static ConsoleHelper();
    [CompilerGeneratedAttribute]
public static Action get_ResetColor();
    [CompilerGeneratedAttribute]
public static Action`1<ConsoleColor> get_SetBackgroundColor();
    [CompilerGeneratedAttribute]
public static Action`1<ConsoleColor> get_SetForegroundColor();
    private static void SetBackgroundColorANSI(ConsoleColor c);
    private static void SetBackgroundColorConsole(ConsoleColor c);
    private static void SetForegroundColorANSI(ConsoleColor c);
    private static void SetForegroundColorConsole(ConsoleColor c);
    private static void ResetColorANSI();
    private static void ResetColorConsole();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Xunit.DependencyContextAssemblyCache : object {
    private static RuntimeFallbacks AnyAndBase;
    private static String[] ManagedAssemblyExtensions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Tuple`2<string, Assembly> ManagedAssemblyNotFound;
    private static Regex RuntimeIdRegex;
    private string assemblyFolder;
    private XunitPackageCompilationAssemblyResolver assemblyResolver;
    private string currentRuntimeIdentifier;
    private Lazy`1<string> fallbackRuntimeIdentifier;
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private IMessageSink internalDiagnosticsMessageSink;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, Assembly> managedAssemblyCache;
    private Dictionary`2<string, Tuple`2<RuntimeLibrary, RuntimeAssetGroup>> managedAssemblyMap;
    private Platform operatingSystemPlatform;
    private String[] unmanagedDllFormats;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> unmanagedAssemblyCache;
    private Dictionary`2<string, Tuple`2<RuntimeLibrary, RuntimeAssetGroup>> unmanagedAssemblyMap;
    [NullableContextAttribute("2")]
public DependencyContextAssemblyCache(string assemblyFolder, DependencyContext dependencyContext, IMessageSink internalDiagnosticsMessageSink, Nullable`1<Platform> operatingSystemPlatform, string currentRuntimeIdentifier, IFileSystem fileSystem);
    private static DependencyContextAssemblyCache();
    private List`1<string> GetCompatibleRuntimes(DependencyContext dependencyContext);
    private RuntimeFallbacks GetFallbacks(IReadOnlyList`1<RuntimeFallbacks> runtimeGraph);
    private string GetFallbackRuntime(string runtime);
    [IteratorStateMachineAttribute("Xunit.DependencyContextAssemblyCache/<GetUnmanagedDllFormats>d__20")]
private IEnumerable`1<string> GetUnmanagedDllFormats();
    public Assembly LoadManagedDll(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    public IntPtr LoadUnmanagedLibrary(string unmanagedLibraryName, Func`2<string, IntPtr> unmanagedAssemblyLoader);
    private Tuple`2<string, Assembly> ResolveManagedAssembly(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    public string ResolveUnmanagedLibrary(string unmanagedLibraryName);
    [CompilerGeneratedAttribute]
private string <.ctor>b__16_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetFallbacks>b__18_0(RuntimeFallbacks x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetFallbacks>b__18_1(RuntimeFallbacks x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Xunit.Internal.Guard : object {
    public static T ArgumentNotNull(T argValue, string argName);
    public static T ArgumentNotNullOrEmpty(T argValue, string argName);
    public static void ArgumentValid(string message, bool test, string argName);
    [NullableContextAttribute("2")]
public static string FileExists(string fileName, string argName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.AssemblyRunInfo : object {
    [CompilerGeneratedAttribute]
private XunitProjectAssembly <Assembly>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<TestCase> <TestCases>k__BackingField;
    public XunitProjectAssembly Assembly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<TestCase> TestCases { get; }
    public AssemblyRunInfo(RunSettings runSettings, string assemblyFileName, IList`1<TestCase> testCases);
    [CompilerGeneratedAttribute]
public XunitProjectAssembly get_Assembly();
    [CompilerGeneratedAttribute]
public IList`1<TestCase> get_TestCases();
}
public static class Xunit.Runner.VisualStudio.Constants : object {
    [NullableAttribute("1")]
public static string ExecutorUri;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.DiagnosticMessageSink : DiagnosticEventSink {
    public static DiagnosticMessageSink ForDiagnostics(LoggerHelper log, string assemblyDisplayName, bool showDiagnostics);
    public static DiagnosticMessageSink ForInternalDiagnostics(LoggerHelper log, bool showDiagnostics);
}
internal interface Xunit.Runner.VisualStudio.IVsDiscoverySink {
    public abstract virtual int Finish();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.RunSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<AppDomainSupport> <AppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectSourceInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DiagnosticMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FailSkips>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <InternalDiagnosticMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LongRunningTestSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxParallelThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TestMethodDisplay> <MethodDisplay>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TestMethodDisplayOptions> <MethodDisplayOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoAutoReporters>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ParallelizeAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ParallelizeTestCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PreEnumerateTheories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReporterSwitch>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShadowCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <StopOnFail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkVersion>k__BackingField;
    [NullableAttribute("1")]
private static Regex regexNet5Plus;
    public Nullable`1<AppDomainSupport> AppDomain { get; public set; }
    public bool CollectSourceInformation { get; public set; }
    public Nullable`1<bool> DiagnosticMessages { get; public set; }
    public bool DisableSerialization { get; public set; }
    public Nullable`1<bool> FailSkips { get; public set; }
    public Nullable`1<bool> InternalDiagnosticMessages { get; public set; }
    public Nullable`1<int> LongRunningTestSeconds { get; public set; }
    public Nullable`1<int> MaxParallelThreads { get; public set; }
    public Nullable`1<TestMethodDisplay> MethodDisplay { get; public set; }
    public Nullable`1<TestMethodDisplayOptions> MethodDisplayOptions { get; public set; }
    public Nullable`1<bool> NoAutoReporters { get; public set; }
    public Nullable`1<bool> ParallelizeAssembly { get; public set; }
    public Nullable`1<bool> ParallelizeTestCollections { get; public set; }
    public Nullable`1<bool> PreEnumerateTheories { get; public set; }
    public string ReporterSwitch { get; public set; }
    public Nullable`1<bool> ShadowCopy { get; public set; }
    public Nullable`1<bool> StopOnFail { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    private static RunSettings();
    [CompilerGeneratedAttribute]
public Nullable`1<AppDomainSupport> get_AppDomain();
    [CompilerGeneratedAttribute]
public void set_AppDomain(Nullable`1<AppDomainSupport> value);
    [CompilerGeneratedAttribute]
public bool get_CollectSourceInformation();
    [CompilerGeneratedAttribute]
public void set_CollectSourceInformation(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DiagnosticMessages();
    [CompilerGeneratedAttribute]
public void set_DiagnosticMessages(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_DisableSerialization();
    [CompilerGeneratedAttribute]
public void set_DisableSerialization(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_FailSkips();
    [CompilerGeneratedAttribute]
public void set_FailSkips(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_InternalDiagnosticMessages();
    [CompilerGeneratedAttribute]
public void set_InternalDiagnosticMessages(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LongRunningTestSeconds();
    [CompilerGeneratedAttribute]
public void set_LongRunningTestSeconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxParallelThreads();
    [CompilerGeneratedAttribute]
public void set_MaxParallelThreads(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TestMethodDisplay> get_MethodDisplay();
    [CompilerGeneratedAttribute]
public void set_MethodDisplay(Nullable`1<TestMethodDisplay> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TestMethodDisplayOptions> get_MethodDisplayOptions();
    [CompilerGeneratedAttribute]
public void set_MethodDisplayOptions(Nullable`1<TestMethodDisplayOptions> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoAutoReporters();
    [CompilerGeneratedAttribute]
public void set_NoAutoReporters(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ParallelizeAssembly();
    [CompilerGeneratedAttribute]
public void set_ParallelizeAssembly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ParallelizeTestCollections();
    [CompilerGeneratedAttribute]
public void set_ParallelizeTestCollections(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PreEnumerateTheories();
    [CompilerGeneratedAttribute]
public void set_PreEnumerateTheories(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_ReporterSwitch();
    [CompilerGeneratedAttribute]
public void set_ReporterSwitch(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ShadowCopy();
    [CompilerGeneratedAttribute]
public void set_ShadowCopy(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_StopOnFail();
    [CompilerGeneratedAttribute]
public void set_StopOnFail(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkVersion(string value);
    [NullableContextAttribute("1")]
public void CopyTo(TestAssemblyConfiguration configuration);
    [NullableContextAttribute("1")]
public static RunSettings Parse(string settingsXml);
    public bool IsMatchingTargetFramework();
    [NullableContextAttribute("1")]
private static bool IsNetCore(string targetFrameworkVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.TestCaseFilter : object {
    private static string DisplayNameString;
    private static string FullyQualifiedNameString;
    private HashSet`1<string> knownTraits;
    private List`1<string> supportedPropertyNames;
    [NullableAttribute("2")]
private ITestCaseFilterExpression filterExpression;
    private bool successfullyGotFilter;
    private bool isDiscovery;
    public TestCaseFilter(IRunContext runContext, LoggerHelper logger, string assemblyFileName, HashSet`1<string> knownTraits);
    public TestCaseFilter(IDiscoveryContext discoveryContext, LoggerHelper logger);
    public bool MatchTestCase(TestCase testCase);
    public object PropertyProvider(TestCase testCase, string name);
    private bool GetTestCaseFilterExpression(IRunContext runContext, LoggerHelper logger, string assemblyFileName, ITestCaseFilterExpression& filter);
    private bool GetTestCaseFilterExpressionFromDiscoveryContext(IDiscoveryContext discoveryContext, LoggerHelper logger, ITestCaseFilterExpression& filter);
    private List`1<string> GetSupportedPropertyNames();
    private static IEnumerable`1<KeyValuePair`2<string, string>> GetTraits(TestCase testCase);
    [CompilerGeneratedAttribute]
internal static TestProperty <GetTestCaseFilterExpressionFromDiscoveryContext>g__noop|12_1(string name);
}
public class Xunit.Runner.VisualStudio.TestPlatformContext : ValueType {
    [CompilerGeneratedAttribute]
private bool <RequireSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireSourceInformation>k__BackingField;
    public bool RequireSerialization { get; public set; }
    public bool RequireSourceInformation { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_RequireSerialization();
    [CompilerGeneratedAttribute]
public void set_RequireSerialization(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_RequireSourceInformation();
    [CompilerGeneratedAttribute]
public void set_RequireSourceInformation(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Xunit.Runner.VisualStudio.Utility.DiaSessionWrapper : object {
    [NullableAttribute("2")]
private DiaSessionWrapperHelper helper;
    [NullableAttribute("2")]
private DiaSession session;
    private DiagnosticMessageSink internalDiagnosticMessageSink;
    public DiaSessionWrapper(string assemblyFileName, DiagnosticMessageSink internalDiagnosticMessageSink);
    public INavigationData GetNavigationData(string typeName, string methodName);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Xunit.Runner.VisualStudio.Utility.DiaSessionWrapperHelper : LongLivedMarshalByRefObject {
    [NullableAttribute("2")]
private Assembly assembly;
    private Dictionary`2<string, Type> typeNameMap;
    public DiaSessionWrapperHelper(string assemblyFileName);
    public void Normalize(String& typeName, String& methodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.VisualStudioRunnerLogger : object {
    private static object lockObject;
    private LoggerHelper loggerHelper;
    public object LockObject { get; }
    public VisualStudioRunnerLogger(LoggerHelper loggerHelper);
    private static VisualStudioRunnerLogger();
    public sealed virtual object get_LockObject();
    public sealed virtual void LogError(StackFrameInfo stackFrame, string message);
    public sealed virtual void LogImportantMessage(StackFrameInfo stackFrame, string message);
    public sealed virtual void LogMessage(StackFrameInfo stackFrame, string message);
    public sealed virtual void LogRaw(string message);
    public sealed virtual void LogWarning(StackFrameInfo stackFrame, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.VisualStudioSourceInformationProvider : LongLivedMarshalByRefObject {
    private static SourceInformation EmptySourceInformation;
    private DiaSessionWrapper session;
    public VisualStudioSourceInformationProvider(string assemblyFileName, DiagnosticMessageSink internalDiagnosticMessageSink);
    private static VisualStudioSourceInformationProvider();
    public sealed virtual ISourceInformation GetSourceInformation(ITestCase testCase);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.VsDiscoverySink : object {
    private static string Ellipsis;
    private static int MaximumDisplayNameLength;
    private static int TestCaseDescriptorBatchSize;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`3<TestCase, string, string> addTraitThunk;
    private static Uri uri;
    private Func`1<bool> cancelThunk;
    private ITestCaseDescriptorProvider descriptorProvider;
    private ITestFrameworkDiscoveryOptions discoveryOptions;
    private ITestCaseDiscoverySink discoverySink;
    private DiscoveryEventSink discoveryEventSink;
    private LoggerHelper logger;
    private string source;
    private List`1<ITestCase> testCaseBatch;
    private TestPlatformContext testPlatformContext;
    private TestCaseFilter testCaseFilter;
    [CompilerGeneratedAttribute]
private ManualResetEvent <Finished>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalTests>k__BackingField;
    private static HashAlgorithm Hasher;
    public ManualResetEvent Finished { get; }
    public int TotalTests { get; private set; }
    public VsDiscoverySink(string source, ITestFrameworkDiscoverer discoverer, LoggerHelper logger, ITestCaseDiscoverySink discoverySink, ITestFrameworkDiscoveryOptions discoveryOptions, TestPlatformContext testPlatformContext, TestCaseFilter testCaseFilter, Func`1<bool> cancelThunk);
    private static VsDiscoverySink();
    [CompilerGeneratedAttribute]
public ManualResetEvent get_Finished();
    [CompilerGeneratedAttribute]
public int get_TotalTests();
    [CompilerGeneratedAttribute]
private void set_TotalTests(int value);
    public sealed virtual void Dispose();
    public static TestCase CreateVsTestCase(string source, TestCaseDescriptor descriptor, LoggerHelper logger, TestPlatformContext testPlatformContext);
    private static string Escape(string value);
    private static string Truncate(string value);
    public sealed virtual int Finish();
    private static Action`3<TestCase, string, string> GetAddTraitThunk();
    private void HandleCancellation(MessageHandlerArgs args);
    private void HandleTestCaseDiscoveryMessage(MessageHandlerArgs`1<ITestCaseDiscoveryMessage> args);
    private void HandleDiscoveryCompleteMessage(MessageHandlerArgs`1<IDiscoveryCompleteMessage> args);
    private sealed virtual override bool Xunit.IMessageSinkWithTypes.OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
    private void SendExistingTestCases();
    private static Guid GuidFromString(string data);
}
internal class Xunit.Runner.VisualStudio.VsExecutionDiscoverySink : TestDiscoverySink {
    [NullableContextAttribute("1")]
public VsExecutionDiscoverySink(Func`1<bool> cancelThunk);
    public sealed virtual int Finish();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Runner.VisualStudio.VsExecutionSink : TestMessageSink {
    private Func`1<bool> cancelledThunk;
    private LoggerHelper logger;
    private IMessageSinkWithTypes innerSink;
    private ITestExecutionRecorder recorder;
    private Dictionary`2<string, TestCase> testCasesMap;
    [CompilerGeneratedAttribute]
private ExecutionSummary <ExecutionSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEvent <Finished>k__BackingField;
    public ExecutionSummary ExecutionSummary { get; private set; }
    public ManualResetEvent Finished { get; }
    public VsExecutionSink(IMessageSinkWithTypes innerSink, ITestExecutionRecorder recorder, LoggerHelper logger, Dictionary`2<string, TestCase> testCasesMap, Func`1<bool> cancelledThunk);
    [CompilerGeneratedAttribute]
public sealed virtual ExecutionSummary get_ExecutionSummary();
    [CompilerGeneratedAttribute]
private void set_ExecutionSummary(ExecutionSummary value);
    [CompilerGeneratedAttribute]
public sealed virtual ManualResetEvent get_Finished();
    public virtual void Dispose();
    private TestCase FindTestCase(ITestCase testCase);
    private void TryAndReport(string actionDescription, ITestCase testCase, Action action);
    private void HandleCancellation(MessageHandlerArgs args);
    private void HandleErrorMessage(MessageHandlerArgs`1<IErrorMessage> args);
    private void HandleTestAssemblyFinished(MessageHandlerArgs`1<ITestAssemblyFinished> args);
    private void HandleTestFailed(MessageHandlerArgs`1<ITestFailed> args);
    private void HandleTestPassed(MessageHandlerArgs`1<ITestPassed> args);
    private void HandleTestSkipped(MessageHandlerArgs`1<ITestSkipped> args);
    private void HandleTestCaseStarting(MessageHandlerArgs`1<ITestCaseStarting> args);
    private void HandleTestCaseFinished(MessageHandlerArgs`1<ITestCaseFinished> args);
    private void HandleTestAssemblyCleanupFailure(MessageHandlerArgs`1<ITestAssemblyCleanupFailure> args);
    private void HandleTestCaseCleanupFailure(MessageHandlerArgs`1<ITestCaseCleanupFailure> args);
    private void HandleTestClassCleanupFailure(MessageHandlerArgs`1<ITestClassCleanupFailure> args);
    private void HandleTestCollectionCleanupFailure(MessageHandlerArgs`1<ITestCollectionCleanupFailure> args);
    private void HandleTestCleanupFailure(MessageHandlerArgs`1<ITestCleanupFailure> args);
    private void HandleTestMethodCleanupFailure(MessageHandlerArgs`1<ITestMethodCleanupFailure> args);
    private void WriteError(string failureName, IFailureInformation failureInfo, IEnumerable`1<ITestCase> testCases);
    private TestResult MakeVsTestResult(TestOutcome outcome, ITestResultMessage testResult);
    private TestResult MakeVsTestResult(TestOutcome outcome, ITestSkipped skippedResult);
    [NullableContextAttribute("2")]
private TestResult MakeVsTestResult(TestOutcome outcome, ITestCase testCase, string displayName, double executionTime, string output, string errorMessage);
    private static TestOutcome GetAggregatedTestOutcome(ITestCaseFinished testCaseFinished);
    public virtual bool OnMessageWithTypes(IMessageSinkMessage message, HashSet`1<string> messageTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[FileExtensionAttribute(".dll")]
[FileExtensionAttribute(".exe")]
[DefaultExecutorUriAttribute("executor://xunit/VsTestRunner2/netcoreapp")]
[ExtensionUriAttribute("executor://xunit/VsTestRunner2/netcoreapp")]
[CategoryAttribute("managed")]
public class Xunit.Runner.VisualStudio.VsTestRunner : object {
    private static int printedHeader;
    private static AppDomainSupport AppDomainDefaultBehavior;
    private static HashSet`1<string> PlatformAssemblies;
    [CompilerGeneratedAttribute]
private static TestProperty <SerializedTestCaseProperty>k__BackingField;
    private bool cancelled;
    public static TestProperty SerializedTestCaseProperty { get; }
    private static VsTestRunner();
    [CompilerGeneratedAttribute]
public static TestProperty get_SerializedTestCaseProperty();
    public sealed virtual void Cancel();
    private sealed virtual override void Microsoft.VisualStudio.TestPlatform.ObjectModel.Adapter.ITestDiscoverer.DiscoverTests(IEnumerable`1<string> sources, IDiscoveryContext discoveryContext, IMessageLogger logger, ITestCaseDiscoverySink discoverySink);
    private static void PrintHeader(LoggerHelper loggerHelper);
    [NullableContextAttribute("2")]
private sealed virtual override void Microsoft.VisualStudio.TestPlatform.ObjectModel.Adapter.ITestExecutor.RunTests(IEnumerable`1<string> sources, IRunContext runContext, IFrameworkHandle frameworkHandle);
    [NullableContextAttribute("2")]
private sealed virtual override void Microsoft.VisualStudio.TestPlatform.ObjectModel.Adapter.ITestExecutor.RunTests(IEnumerable`1<TestCase> tests, IRunContext runContext, IFrameworkHandle frameworkHandle);
    private void DiscoverTests(IEnumerable`1<string> sources, LoggerHelper logger, TestPlatformContext testPlatformContext, RunSettings runSettings, Func`4<string, ITestFrameworkDiscoverer, ITestFrameworkDiscoveryOptions, TVisitor> visitorFactory, Action`4<string, ITestFrameworkDiscoverer, ITestFrameworkDiscoveryOptions, TVisitor> visitComplete);
    private bool DiscoverTestsInSource(XunitFrontController controller, LoggerHelper logger, TestPlatformContext testPlatformContext, RunSettings runSettings, Func`4<string, ITestFrameworkDiscoverer, ITestFrameworkDiscoveryOptions, TVisitor> visitorFactory, Action`4<string, ITestFrameworkDiscoverer, ITestFrameworkDiscoveryOptions, TVisitor> visitComplete, XunitProjectAssembly assembly);
    private static TestProperty GetTestProperty();
    private static bool IsXunitTestAssembly(string assemblyFileName);
    private static bool IsXunitPackageReferenced(string assemblyFileName);
    private static string GetAssemblyFileName(string source);
    private void RunTests(IRunContext runContext, IFrameworkHandle frameworkHandle, LoggerHelper logger, TestPlatformContext testPlatformContext, RunSettings runSettings, Func`1<List`1<AssemblyRunInfo>> getRunInfos);
    private void RunTestsInAssembly(IRunContext runContext, IFrameworkHandle frameworkHandle, LoggerHelper logger, TestPlatformContext testPlatformContext, RunSettings runSettings, IMessageSinkWithTypes reporterMessageHandler, AssemblyRunInfo runInfo);
    private ManualResetEvent RunTestsInAssemblyAsync(IRunContext runContext, IFrameworkHandle frameworkHandle, LoggerHelper logger, TestPlatformContext testPlatformContext, RunSettings runSettings, IMessageSinkWithTypes reporterMessageHandler, AssemblyRunInfo runInfo);
    public static IRunnerReporter GetRunnerReporter(LoggerHelper logger, RunSettings runSettings, IReadOnlyList`1<string> assemblyFileNames);
    public static IReadOnlyList`1<IRunnerReporter> GetAvailableRunnerReporters(LoggerHelper logger, IReadOnlyList`1<string> sources);
    private static IList`1<DiscoveredTestCase> GetVsTestCases(string source, ITestFrameworkDiscoverer discoverer, VsExecutionDiscoverySink visitor, LoggerHelper logger, TestPlatformContext testPlatformContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Xunit.XunitPackageCompilationAssemblyResolver : object {
    private IFileSystem fileSystem;
    private List`1<string> nugetPackageDirectories;
    [NullableContextAttribute("2")]
public XunitPackageCompilationAssemblyResolver(IMessageSink internalDiagnosticsMessageSink, IFileSystem fileSystem);
    private static List`1<string> GetDefaultProbeDirectories(IMessageSink internalDiagnosticsMessageSink);
    private static List`1<string> GetDefaultProbeDirectories(Platform osPlatform, IMessageSink internalDiagnosticsMessageSink);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveFromPackagePath(CompilationLibrary library, string basePath, IEnumerable`1& results);
}
