[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[IsReadOnlyAttribute]
internal class ProtoBuf.Compiler.CodeLabel : ValueType {
    public Label Value;
    public int Index;
    public CodeLabel(Label value, int index);
}
internal class ProtoBuf.Compiler.CompilerContext : object {
    [CompilerGeneratedAttribute]
private TypeModel <Model>k__BackingField;
    private DynamicMethod method;
    private static int next;
    private static MethodInfo s_CreateInstance;
    [CompilerGeneratedAttribute]
private bool <NonPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private Local <InputValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    private string _traceName;
    private OpCode _state;
    private byte _inputArg;
    private SignatureType _signature;
    [CompilerGeneratedAttribute]
private CompilerContextScope <Scope>k__BackingField;
    private static MethodInfo s_GetInbuiltSerializer;
    private ILGenerator il;
    private List`1<LocalBuilder> locals;
    private int nextLabel;
    private List`1<Assembly> knownTrustedAssemblies;
    private List`1<Assembly> knownUntrustedAssemblies;
    public TypeModel Model { get; }
    internal bool NonPublic { get; }
    public Local InputValue { get; }
    public bool IsStatic { get; }
    internal CompilerContextScope Scope { get; }
    public bool IsService { get; }
    internal ILGenerator IL { get; }
    internal CompilerContext(CompilerContext parent, ILGenerator il, bool isStatic, SignatureType signature, Type inputType, string traceName);
    internal CompilerContext(CompilerContextScope scope, ILGenerator il, bool isStatic, SignatureType signature, TypeModel model, Type inputType, string traceName);
    private CompilerContext(CompilerContextScope scope, Type associatedType, SignatureType signature, bool isStatic, TypeModel model, Type inputType, Type returnType);
    private static CompilerContext();
    [CompilerGeneratedAttribute]
public TypeModel get_Model();
    internal CodeLabel DefineLabel();
    [ConditionalAttribute("DEBUG_COMPILE")]
private void TraceCompile(string value);
    internal void MarkLabel(CodeLabel label);
    public static ProtoSerializer`1<TActual> BuildSerializer(CompilerContextScope scope, IRuntimeProtoSerializerNode head, TypeModel model);
    public static ProtoSubTypeDeserializer`1<T> BuildSubTypeDeserializer(CompilerContextScope scope, IRuntimeProtoSerializerNode head, TypeModel model);
    public static ProtoDeserializer`1<T> BuildDeserializer(CompilerContextScope scope, IRuntimeProtoSerializerNode head, TypeModel model, bool isScalar);
    public static Func`2<ISerializationContext, T> BuildFactory(CompilerContextScope scope, IRuntimeProtoSerializerNode head, TypeModel model);
    internal void CreateInstance();
    internal void Return();
    private static bool IsObject(Type type);
    internal void CastToObject(Type type);
    internal void CastFromObject(Type type);
    [CompilerGeneratedAttribute]
internal bool get_NonPublic();
    [CompilerGeneratedAttribute]
public Local get_InputValue();
    internal void ThrowException(Type exceptionType);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    public virtual string ToString();
    private static void GetOpCodes(SignatureType signature, bool isStatic, OpCode& state, Byte& inputArg);
    [CompilerGeneratedAttribute]
internal CompilerContextScope get_Scope();
    public bool get_IsService();
    public void LoadSelfAsService(CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
    internal void Emit(OpCode opcode);
    public void LoadValue(string value);
    public void LoadValue(float value);
    public void LoadValue(double value);
    public void LoadValue(ulong value);
    public void LoadValue(long value);
    public void LoadValue(bool value);
    public void LoadValue(int value);
    private sealed virtual override void System.IDisposable.Dispose();
    internal LocalBuilder GetFromPool(Type type);
    internal void ReleaseToPool(LocalBuilder value);
    public void LoadState();
    public void StoreValue(Local local);
    public void LoadValue(Local local);
    public Local GetLocalWithValue(Type type, Local fromValue);
    internal void EmitStateBasedRead(string methodName, Type expectedType);
    internal void EmitStateBasedRead(Type ownerType, string methodName, Type expectedType);
    internal void EmitStateBasedWrite(string methodName, Local fromValue, Type type, Type argType);
    public void EmitCall(MethodInfo method);
    public void EmitCall(MethodInfo method, Type targetType);
    public void LoadNullRef();
    internal void WriteNullCheckedTail(Type type, IRuntimeProtoSerializerNode tail, Local valueFrom);
    internal void ReadNullCheckedTail(Type type, IRuntimeProtoSerializerNode tail, Local valueFrom);
    public void EmitCtor(Type type);
    public void EmitCtor(ConstructorInfo ctor);
    public void InitLocal(Type type, Local target);
    internal ILGenerator get_IL();
    public void EmitCtor(Type type, Type[] parameterTypes);
    private bool InternalsVisible(Assembly assembly);
    internal void CheckAccessibility(MemberInfo& member);
    public void LoadValue(FieldInfo field, bool checkAccessibility);
    public void StoreValue(FieldInfo field);
    public void LoadValue(PropertyInfo property);
    public void StoreValue(PropertyInfo property);
    internal static void LoadValue(ILGenerator il, int value);
    private static bool UseShortForm(Local local);
    internal void LoadAddress(Local local, Type type, bool evenIfClass);
    internal void Branch(CodeLabel label, bool short);
    internal void BranchIfFalse(CodeLabel label, bool short);
    internal void BranchIfTrue(CodeLabel label, bool short);
    internal void BranchIfEqual(CodeLabel label, bool short);
    internal void CopyValue();
    internal void BranchIfGreater(CodeLabel label, bool short);
    internal void BranchIfLess(CodeLabel label, bool short);
    internal void DiscardValue();
    public void Subtract();
    public void Switch(CodeLabel[] jumpTable);
    internal void EndFinally();
    internal void BeginFinally();
    internal void EndTry(CodeLabel label, bool short);
    internal CodeLabel BeginTry();
    internal void Constrain(Type type);
    internal void TryCast(Type type);
    internal void Cast(Type type);
    public IDisposable Using(Local local);
    internal void Add();
    internal void LoadLength(Local arr, bool zeroIfNull);
    internal void CreateArray(Type elementType, Local length);
    internal void LoadArrayValue(Local arr, Local i);
    internal static void LoadValue(ILGenerator il, Type type);
    internal void LoadValue(Type type);
    internal void ConvertToInt32(ProtoTypeCode typeCode, bool uint32Overflow);
    internal void ConvertFromInt32(ProtoTypeCode typeCode, bool uint32Overflow);
    internal void LoadValue(decimal value);
    internal void LoadValue(Guid value);
    internal void LoadSerializationContext(Type asType);
    internal bool AllowInternal(PropertyInfo property);
}
internal class ProtoBuf.Compiler.CompilerContextScope : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullEmit>k__BackingField;
    private ModuleBuilder _module;
    private RuntimeTypeModel _model;
    private int _localUniqueId;
    private static int s_globalUniqueId;
    internal string AssemblyName { get; }
    public bool IsFullEmit { get; }
    private CompilerContextScope(RuntimeTypeModel model, ModuleBuilder module, bool isFullEmit, string assemblyName);
    internal static CompilerContextScope CreateInProcess();
    internal static CompilerContextScope CreateForModule(RuntimeTypeModel model, ModuleBuilder module, bool isFullEmit, string assemblyName);
    [CompilerGeneratedAttribute]
internal string get_AssemblyName();
    [CompilerGeneratedAttribute]
public bool get_IsFullEmit();
    private ModuleBuilder GetModule();
    private static ModuleBuilder GetSharedModule();
    internal static ILGenerator Implement(TypeBuilder type, Type interfaceType, string name, bool explicit);
    private int Uniquify();
    internal FieldInfo DefineSubTypeStateCallbackField(MethodInfo callback);
    internal bool ImplementsServiceFor(CompatibilityLevel ambient);
    [CompilerGeneratedAttribute]
internal static void <DefineSubTypeStateCallbackField>g__WriteCall|18_0(ILGenerator il, MethodInfo callback);
}
internal class ProtoBuf.Compiler.Local : object {
    private LocalBuilder value;
    private Type type;
    private CompilerContext ctx;
    internal LocalBuilder Value { get; }
    public Type Type { get; }
    private Local(LocalBuilder value, Type type);
    internal Local(CompilerContext ctx, Type type);
    internal LocalBuilder get_Value();
    public Type get_Type();
    public Local AsCopy();
    public sealed virtual void Dispose();
    internal bool IsSame(Local other);
}
internal class ProtoBuf.Compiler.ProtoDeserializer`1 : MulticastDelegate {
    public ProtoDeserializer`1(object object, IntPtr method);
    public virtual T Invoke(State& state, T value);
    public virtual IAsyncResult BeginInvoke(State& state, T value, AsyncCallback callback, object object);
    public virtual T EndInvoke(State& state, IAsyncResult result);
}
internal class ProtoBuf.Compiler.ProtoSerializer`1 : MulticastDelegate {
    public ProtoSerializer`1(object object, IntPtr method);
    public virtual void Invoke(State& state, T value);
    public virtual IAsyncResult BeginInvoke(State& state, T value, AsyncCallback callback, object object);
    public virtual void EndInvoke(State& state, IAsyncResult result);
}
internal class ProtoBuf.Compiler.ProtoSubTypeDeserializer`1 : MulticastDelegate {
    public ProtoSubTypeDeserializer`1(object object, IntPtr method);
    public virtual T Invoke(State& state, SubTypeState`1<T> value);
    public virtual IAsyncResult BeginInvoke(State& state, SubTypeState`1<T> value, AsyncCallback callback, object object);
    public virtual T EndInvoke(State& state, IAsyncResult result);
}
internal static class ProtoBuf.Compiler.WriterUtil : object {
    internal static Type ByRefStateType;
    private static WriterUtil();
}
[ExtensionAttribute]
internal static class ProtoBuf.Extensions.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder NewLine(StringBuilder builder, Int32& pos, int indent);
    [ExtensionAttribute]
public static StringBuilder Insert(StringBuilder builder, string value, Int32& pos, Func`1<bool> condition, int count);
    [ExtensionAttribute]
public static StringBuilder Insert(StringBuilder builder, string value, Int32& pos, int count);
}
[DefaultMemberAttribute("Item")]
internal class ProtoBuf.Internal.BasicList : object {
    private static Node nil;
    private Node head;
    public object Item { get; }
    public int Count { get; }
    private static BasicList();
    public int Add(object value);
    public object get_Item(int index);
    public int get_Count();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public NodeEnumerator GetEnumerator();
    internal int IndexOf(MatchPredicate predicate, object ctx);
    internal bool Contains(object value);
    internal static List`1<Group`1<T>> GetContiguousGroups(Int32[] keys, T[] values);
    internal bool Any();
}
internal static class ProtoBuf.Internal.Serializers.AnyTypeSerializer : object {
    internal static MethodInfo ReadAnyT;
    internal static MethodInfo WriteAnyT;
    private static AnyTypeSerializer();
    private static bool FindSerializerFeaturesMethodFilter(MemberInfo member, object state);
    private static MethodInfo FindSerializerFeaturesMethod(Type type, string name);
    internal static IRuntimeProtoSerializerNode Create(Type memberType, SerializerFeatures features, CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
}
internal class ProtoBuf.Internal.Serializers.AnyTypeSerializer`1 : object {
    private SerializerFeatures _features;
    private CompatibilityLevel _compatibilityLevel;
    private DataFormat _dataFormat;
    private static MethodInfo ReadAnyT;
    private static MethodInfo WriteAnyT;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    public AnyTypeSerializer`1(SerializerFeatures features, CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
    private static AnyTypeSerializer`1();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IDirectRuntimeWriteNode.DirectWrite(int fieldNumber, WireType wireType, State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IDirectWriteNode.CanEmitDirectWrite(WireType wireType);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IDirectRuntimeWriteNode.CanDirectWrite(WireType wireType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IDirectWriteNode.EmitDirectWrite(int fieldNumber, WireType wireType, CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.BlobSerializer`1 : object {
    private static Type expectedType;
    private bool overwriteList;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    public BlobSerializer`1(bool overwriteList);
    private static BlobSerializer`1();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.BooleanSerializer : object {
    internal static BooleanSerializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static BooleanSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual void Write(State& state, object value);
    public sealed virtual object Read(State& state, object value);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.ByteSerializer : object {
    internal static ByteSerializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static ByteSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual void Write(State& state, object value);
    public sealed virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.CharSerializer : UInt16Serializer {
    internal static CharSerializer Instance;
    private static Type expectedType;
    public Type ExpectedType { get; }
    private static CharSerializer();
    public virtual Type get_ExpectedType();
    public virtual void Write(State& state, object value);
    public virtual object Read(State& state, object value);
}
internal abstract class ProtoBuf.Internal.Serializers.CompiledSerializer : object {
    protected IProtoTypeSerializer head;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public SerializerFeatures Features { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.IsSubType { get; }
    private Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.BaseType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasInheritance { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.ShouldEmitCreateInstance { get; }
    protected CompiledSerializer(IProtoTypeSerializer head);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual SerializerFeatures get_Features();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_IsSubType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CreateInstance(ISerializationContext context);
    public sealed virtual void Callback(object value, CallbackType callbackType, ISerializationContext context);
    public static ICompiledSerializer Wrap(IProtoTypeSerializer head, RuntimeTypeModel model);
    private sealed virtual override Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_BaseType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual Type get_ExpectedType();
    public abstract virtual void Write(State& state, object value);
    public abstract virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitWriteRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitReadRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_HasInheritance();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_ShouldEmitCreateInstance();
}
internal class ProtoBuf.Internal.Serializers.DateTimeSerializer : object {
    private static Type expectedType;
    private static DateTimeSerializer s_Timestamp;
    private bool _includeKind;
    private bool _useTimestamp;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private DateTimeSerializer(bool useTimestamp, bool includeKind);
    private static DateTimeSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public static DateTimeSerializer Create(CompatibilityLevel compatibilityLevel, TypeModel model);
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.DecimalSerializer : object {
    private static DecimalSerializer s_BclDecimal;
    private static DecimalSerializer s_String;
    private Variant _variant;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private DecimalSerializer(Variant variant);
    private static DecimalSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public static DecimalSerializer Create(CompatibilityLevel compatibilityLevel);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.DefaultValueDecorator : ProtoDecoratorBase {
    private object defaultValue;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public DefaultValueDecorator(object defaultValue, IRuntimeProtoSerializerNode tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(State& state, object value);
    public virtual object Read(State& state, object value);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private static void EmitBeq(CompilerContext ctx, CodeLabel label, Type type);
    private void EmitBranchIfDefaultValue(CompilerContext ctx, CodeLabel label);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.DoubleSerializer : object {
    internal static DoubleSerializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static DoubleSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.EnumMemberSerializer : object {
    private IRuntimeProtoSerializerNode _tail;
    [CompilerGeneratedAttribute]
private Type <ExpectedType>k__BackingField;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    public EnumMemberSerializer(Type enumType);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    internal static object EnumToWire(object value, Type type);
    private object EnumToWire(object value);
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IDirectWriteNode.CanEmitDirectWrite(WireType wireType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IDirectWriteNode.EmitDirectWrite(int fieldNumber, WireType wireType, CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.ExternalSerializer : object {
    internal static IProtoTypeSerializer Create(Type target, Type serializer);
}
internal class ProtoBuf.Internal.Serializers.ExternalSerializer`2 : object {
    private object ProtoBuf.Internal.Serializers.IExternalSerializer.Service { get; }
    private static ISerializer`1<T> Serializer { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private SerializerFeatures ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Features { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    private Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.BaseType { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.ShouldEmitCreateInstance { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasInheritance { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.IsSubType { get; }
    private sealed virtual override object ProtoBuf.Internal.Serializers.IExternalSerializer.get_Service();
    private static ISerializer`1<T> get_Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Write(State& state, object value);
    private sealed virtual override object ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Read(State& state, object value);
    private sealed virtual override SerializerFeatures ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_Features();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    private sealed virtual override Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_BaseType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CreateInstance(ISerializationContext context);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, ISerializationContext context);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_ShouldEmitCreateInstance();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_HasInheritance();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_IsSubType();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitReadRoot(CompilerContext ctx, Local entity);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitWriteRoot(CompilerContext ctx, Local entity);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.FieldDecorator : ProtoDecoratorBase {
    [CompilerGeneratedAttribute]
private Type <ExpectedType>k__BackingField;
    private FieldInfo field;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public FieldDecorator(Type forType, FieldInfo field, IRuntimeProtoSerializerNode tail);
    [CompilerGeneratedAttribute]
public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(State& state, object value);
    public virtual object Read(State& state, object value);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.GuidSerializer : object {
    private Variant _variant;
    private static GuidSerializer s_Legacy;
    private static GuidSerializer s_String;
    private static GuidSerializer s_Bytes;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private GuidSerializer(Variant variant);
    private static GuidSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    internal static GuidSerializer Create(CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual void Write(State& state, object value);
    public sealed virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal interface ProtoBuf.Internal.Serializers.ICompiledSerializer {
    public Type ExpectedType { get; }
    public abstract virtual Type get_ExpectedType();
}
internal interface ProtoBuf.Internal.Serializers.IDirectRuntimeWriteNode {
    public abstract virtual bool CanDirectWrite(WireType wireType);
    public abstract virtual void DirectWrite(int fieldNumber, WireType wireType, State& state, object value);
}
internal interface ProtoBuf.Internal.Serializers.IDirectWriteNode {
    public abstract virtual bool CanEmitDirectWrite(WireType wireType);
    public abstract virtual void EmitDirectWrite(int fieldNumber, WireType wireType, CompilerContext ctx, Local valueFrom);
}
internal interface ProtoBuf.Internal.Serializers.IExternalSerializer {
    public object Service { get; }
    public abstract virtual object get_Service();
}
internal class ProtoBuf.Internal.Serializers.InheritanceCompiledSerializer`2 : CompiledSerializer {
    private ProtoSerializer`1<T> subTypeSerializer;
    private ProtoSubTypeDeserializer`1<T> subTypeDeserializer;
    private Func`2<ISerializationContext, T> factory;
    public InheritanceCompiledSerializer`2(IProtoTypeSerializer head, RuntimeTypeModel model);
    private sealed virtual override T ProtoBuf.Serializers.ISerializer<T>.Read(State& state, T value);
    private sealed virtual override T ProtoBuf.Serializers.IFactory<T>.Create(ISerializationContext context);
    public virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Serializers.ISerializer<T>.Write(State& state, T value);
    public virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Serializers.ISubTypeSerializer<T>.WriteSubType(State& state, T value);
    private sealed virtual override T ProtoBuf.Serializers.ISubTypeSerializer<T>.ReadSubType(State& state, SubTypeState`1<T> value);
}
internal class ProtoBuf.Internal.Serializers.InheritanceTypeSerializer`2 : TypeSerializer`1<T> {
    public bool HasInheritance { get; }
    internal Type BaseType { get; }
    public bool IsSubType { get; }
    public virtual bool get_HasInheritance();
    internal virtual Type get_BaseType();
    public virtual void Write(State& state, T value);
    public virtual T Read(State& state, T value);
    private sealed virtual override T ProtoBuf.Serializers.ISubTypeSerializer<T>.ReadSubType(State& state, SubTypeState`1<T> value);
    private sealed virtual override void ProtoBuf.Serializers.ISubTypeSerializer<T>.WriteSubType(State& state, T value);
    public virtual void EmitReadRoot(CompilerContext context, Local valueFrom);
    public virtual void EmitWriteRoot(CompilerContext context, Local valueFrom);
    public virtual bool get_IsSubType();
}
internal class ProtoBuf.Internal.Serializers.Int16Serializer : object {
    internal static Int16Serializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static Int16Serializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.Int32Serializer : object {
    internal static Int32Serializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static Int32Serializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IDirectWriteNode.CanEmitDirectWrite(WireType wireType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IDirectWriteNode.EmitDirectWrite(int fieldNumber, WireType wireType, CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.Int64Serializer : object {
    internal static Int64Serializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static Int64Serializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.IntPtrSerializer : object {
    internal static IntPtrSerializer Instance;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static IntPtrSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual void Write(State& state, object value);
    public sealed virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal interface ProtoBuf.Internal.Serializers.IProtoTypeSerializer {
    public Type BaseType { get; }
    public bool ShouldEmitCreateInstance { get; }
    public bool HasInheritance { get; }
    public bool IsSubType { get; }
    public SerializerFeatures Features { get; }
    public abstract virtual Type get_BaseType();
    public abstract virtual bool HasCallbacks(CallbackType callbackType);
    public abstract virtual bool CanCreateInstance();
    public abstract virtual object CreateInstance(ISerializationContext context);
    public abstract virtual void Callback(object value, CallbackType callbackType, ISerializationContext context);
    public abstract virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public abstract virtual void EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    public abstract virtual bool get_ShouldEmitCreateInstance();
    public abstract virtual void EmitReadRoot(CompilerContext ctx, Local entity);
    public abstract virtual void EmitWriteRoot(CompilerContext ctx, Local entity);
    public abstract virtual bool get_HasInheritance();
    public abstract virtual bool get_IsSubType();
    public abstract virtual SerializerFeatures get_Features();
}
internal interface ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode {
    public bool IsScalar { get; }
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public abstract virtual bool get_IsScalar();
    public abstract virtual Type get_ExpectedType();
    public abstract virtual void Write(State& state, object value);
    public abstract virtual object Read(State& state, object value);
    public abstract virtual bool get_RequiresOldValue();
    public abstract virtual bool get_ReturnsValue();
    public abstract virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public abstract virtual void EmitRead(CompilerContext ctx, Local entity);
}
internal interface ProtoBuf.Internal.Serializers.ISerializerProxy {
    public IRuntimeProtoSerializerNode Serializer { get; }
    public abstract virtual IRuntimeProtoSerializerNode get_Serializer();
}
internal static class ProtoBuf.Internal.Serializers.MapDecorator : object {
    public static IRuntimeProtoSerializerNode Create(RepeatedSerializerStub provider, Type keyType, Type valueType, int fieldNumber, SerializerFeatures features, SerializerFeatures keyFeatures, CompatibilityLevel keyCompatibilityLevel, DataFormat keyDataFormat, SerializerFeatures valueFeatures, CompatibilityLevel valueCompatibilityLevel, DataFormat valueDataFormat);
}
internal class ProtoBuf.Internal.Serializers.MapDecorator`3 : object {
    private int _fieldNumber;
    private SerializerFeatures _features;
    private SerializerFeatures _keyFeatures;
    private SerializerFeatures _valueFeatures;
    private CompatibilityLevel _keyCompatibilityLevel;
    private CompatibilityLevel _valueCompatibilityLevel;
    private DataFormat _keyDataFormat;
    private DataFormat _valueDataFormat;
    private RepeatedSerializerStub _provider;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    private MapSerializer`3<TCollection, TKey, TValue> Serializer { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public MapDecorator`3(int fieldNumber, SerializerFeatures features, SerializerFeatures keyFeatures, CompatibilityLevel keyCompatibilityLevel, DataFormat keyDataFormat, SerializerFeatures valueFeatures, CompatibilityLevel valueCompatibilityLevel, DataFormat valueDataFormat, RepeatedSerializerStub provider);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    private MapSerializer`3<TCollection, TKey, TValue> get_Serializer();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    public sealed virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public sealed virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.MemberSpecifiedDecorator : ProtoDecoratorBase {
    private MethodInfo getSpecified;
    private MethodInfo setSpecified;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public MemberSpecifiedDecorator(MethodInfo getSpecified, MethodInfo setSpecified, IRuntimeProtoSerializerNode tail);
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(State& state, object value);
    public virtual object Read(State& state, object value);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.ParseableSerializer : object {
    private MethodInfo parse;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private ParseableSerializer(MethodInfo parse);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public static ParseableSerializer TryCreate(Type type);
    private static MethodInfo GetCustomToString(Type type);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.PropertyDecorator : ProtoDecoratorBase {
    [CompilerGeneratedAttribute]
private Type <ExpectedType>k__BackingField;
    private PropertyInfo property;
    private bool readOptionsWriteValue;
    private MethodInfo shadowSetter;
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public PropertyDecorator(Type forType, PropertyInfo property, IRuntimeProtoSerializerNode tail);
    [CompilerGeneratedAttribute]
public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    private static void SanityCheck(PropertyInfo property, IRuntimeProtoSerializerNode tail, Boolean& writeValue, bool nonPublic, bool allowInternal);
    private static MethodInfo GetShadowSetter(PropertyInfo property);
    public virtual void Write(State& state, object value);
    public virtual object Read(State& state, object value);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    internal static Type ChooseReadLocalType(Type memberType, Type tailType);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal abstract class ProtoBuf.Internal.Serializers.ProtoDecoratorBase : object {
    protected IRuntimeProtoSerializerNode Tail;
    public bool IsScalar { get; }
    public Type ExpectedType { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    protected ProtoDecoratorBase(IRuntimeProtoSerializerNode tail);
    public virtual bool get_IsScalar();
    public abstract virtual Type get_ExpectedType();
    public abstract virtual bool get_ReturnsValue();
    public abstract virtual bool get_RequiresOldValue();
    public abstract virtual void Write(State& state, object value);
    public abstract virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    protected abstract virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
    protected abstract virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal static class ProtoBuf.Internal.Serializers.RepeatedDecorator : object {
    public static IRuntimeProtoSerializerNode Create(RepeatedSerializerStub stub, int fieldNumber, SerializerFeatures features, CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
    internal static IRepeatedSerializer`1<T> GetSerializer(MemberInfo original);
}
internal class ProtoBuf.Internal.Serializers.RepeatedDecorator`2 : object {
    private int _fieldNumber;
    private SerializerFeatures _features;
    private CompatibilityLevel _compatibilityLevel;
    private DataFormat _dataFormat;
    private RepeatedSerializerStub _stub;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    private RepeatedSerializer`2<TCollection, T> Serializer { get; }
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    public RepeatedDecorator`2(int fieldNumber, SerializerFeatures features, CompatibilityLevel compatibilityLevel, DataFormat dataFormat, RepeatedSerializerStub stub);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    private RepeatedSerializer`2<TCollection, T> get_Serializer();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual bool get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    public sealed virtual void Write(State& state, object value);
    public sealed virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.SByteSerializer : object {
    internal static SByteSerializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static SByteSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.SimpleCompiledSerializer`1 : CompiledSerializer {
    protected ProtoSerializer`1<T> serializer;
    protected ProtoDeserializer`1<T> deserializer;
    private Func`2<ISerializationContext, T> factory;
    public SimpleCompiledSerializer`1(IProtoTypeSerializer head, RuntimeTypeModel model);
    private sealed virtual override T ProtoBuf.Serializers.ISerializer<T>.Read(State& state, T value);
    public virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Serializers.ISerializer<T>.Write(State& state, T value);
    public virtual void Write(State& state, object value);
    private sealed virtual override T ProtoBuf.Serializers.IFactory<T>.Create(ISerializationContext context);
}
internal class ProtoBuf.Internal.Serializers.SingleSerializer : object {
    internal static SingleSerializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static SingleSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.StringSerializer : object {
    internal static StringSerializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static StringSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IDirectWriteNode.CanEmitDirectWrite(WireType wireType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IDirectWriteNode.EmitDirectWrite(int fieldNumber, WireType wireType, CompilerContext ctx, Local valueFrom);
}
internal abstract class ProtoBuf.Internal.Serializers.SubItemSerializer : object {
    private static Dictionary`2<int, MethodInfo> s_WriteMessage;
    private static Dictionary`2<int, MethodInfo> s_WriteGroup;
    private static MethodInfo s_ReadMessage;
    [CompilerGeneratedAttribute]
private MetaType <MetaType>k__BackingField;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    private SerializerFeatures ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Features { get; }
    public bool IsSubType { get; }
    public Type ExpectedType { get; }
    public Type BaseType { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasInheritance { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.ShouldEmitCreateInstance { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    protected ISerializerProxy Proxy { get; }
    protected MetaType MetaType { get; private set; }
    private static SubItemSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    private sealed virtual override SerializerFeatures ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_Features();
    public abstract virtual bool get_IsSubType();
    public abstract virtual Type get_ExpectedType();
    public virtual Type get_BaseType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_HasInheritance();
    public abstract virtual void Write(State& state, object value);
    public abstract virtual object Read(State& state, object value);
    public abstract virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public abstract virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitReadRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitWriteRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_ShouldEmitCreateInstance();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, ISerializationContext context);
    private sealed virtual override object ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CreateInstance(ISerializationContext source);
    protected static void EmitLoadCustomSerializer(CompilerContext ctx, Type serializerType, Type forType);
    public static void EmitWriteMessage(Nullable`1<int> fieldNumber, WireType wireType, CompilerContext ctx, Local value, FieldInfo serializer, bool applyRecursionCheck, Type serializerType);
    private static void LoadSerializer(CompilerContext ctx, FieldInfo serializer, Type serializerType);
    public static void EmitReadMessage(CompilerContext ctx, Local value, FieldInfo serializer, Type serializerType);
    protected ISerializerProxy get_Proxy();
    [CompilerGeneratedAttribute]
protected MetaType get_MetaType();
    [CompilerGeneratedAttribute]
private void set_MetaType(MetaType value);
    internal static IRuntimeProtoSerializerNode Create(Type type, MetaType metaType, DataFormat& dataFormat, WireType& defaultWireType);
    protected virtual WireType GetDefaultWireType(DataFormat& dataFormat);
    internal static IRuntimeProtoSerializerNode Create(Type actualType, MetaType metaType, Type parentType);
}
internal class ProtoBuf.Internal.Serializers.SubTypeSerializer`2 : SubItemSerializer {
    private static Dictionary`2<int, MethodInfo> s_WriteSubType;
    public bool IsSubType { get; }
    public Type ExpectedType { get; }
    public Type BaseType { get; }
    private static SubTypeSerializer`2();
    public virtual bool get_IsSubType();
    public virtual Type get_ExpectedType();
    public virtual Type get_BaseType();
    public virtual void Write(State& state, object value);
    public virtual object Read(State& state, object value);
    public virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IDirectWriteNode.CanEmitDirectWrite(WireType wireType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IDirectWriteNode.EmitDirectWrite(int fieldNumber, WireType wireType, CompilerContext ctx, Local valueFrom);
    public virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.SubValueSerializer`1 : SubItemSerializer {
    private ISerializer`1<T> _customSerializer;
    public bool IsSubType { get; }
    public Type ExpectedType { get; }
    private ISerializer`1<T> CustomSerializer { get; }
    public virtual bool get_IsSubType();
    public virtual Type get_ExpectedType();
    private ISerializer`1<T> get_CustomSerializer();
    private ISerializer`1<T> CreateExternal();
    public virtual void Write(State& state, object value);
    private SerializerFeatures GetCategory();
    public virtual object Read(State& state, object value);
    protected virtual WireType GetDefaultWireType(DataFormat& dataFormat);
    public virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public virtual void EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IDirectWriteNode.CanEmitDirectWrite(WireType wireType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IDirectWriteNode.EmitDirectWrite(int fieldNumber, WireType wireType, CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.SurrogateSerializer`1 : object {
    private Type declaredType;
    private MethodInfo toTail;
    private MethodInfo fromTail;
    private IRuntimeProtoSerializerNode rootTail;
    private SerializerFeatures features;
    public SerializerFeatures Features { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.IsSubType { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.ShouldEmitCreateInstance { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public bool ReturnsValue { get; }
    public bool RequiresOldValue { get; }
    public Type ExpectedType { get; }
    private Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.BaseType { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasInheritance { get; }
    public SurrogateSerializer`1(Type declaredType, MethodInfo toTail, MethodInfo fromTail, IRuntimeProtoSerializerNode rootTail, SerializerFeatures features);
    public sealed virtual SerializerFeatures get_Features();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_IsSubType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasCallbacks(CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_ShouldEmitCreateInstance();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    private sealed virtual override object ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CreateInstance(ISerializationContext source);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, ISerializationContext context);
    private sealed virtual override T ProtoBuf.Serializers.ISerializer<T>.Read(State& state, T value);
    private sealed virtual override void ProtoBuf.Serializers.ISerializer<T>.Write(State& state, T value);
    public sealed virtual bool get_ReturnsValue();
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_BaseType();
    private static bool HasCast(Type type, Type from, Type to, MethodInfo& op);
    public MethodInfo GetConversion(bool toTail);
    public sealed virtual void Write(State& state, object value);
    public sealed virtual object Read(State& state, object value);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_HasInheritance();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitReadRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitWriteRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.SystemTypeSerializer : object {
    internal static SystemTypeSerializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static SystemTypeSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Write(State& state, object value);
    private sealed virtual override object ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Read(State& state, object value);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.TagDecorator : ProtoDecoratorBase {
    private bool strict;
    private int fieldNumber;
    private WireType wireType;
    private SerializerFeatures ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Features { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.IsSubType { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.ShouldEmitCreateInstance { get; }
    public Type ExpectedType { get; }
    private Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.BaseType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    private bool NeedsHint { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasInheritance { get; }
    public TagDecorator(int fieldNumber, WireType wireType, bool strict, IRuntimeProtoSerializerNode tail);
    private sealed virtual override SerializerFeatures ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_Features();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_IsSubType();
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual bool CanCreateInstance();
    public sealed virtual object CreateInstance(ISerializationContext source);
    public sealed virtual void Callback(object value, CallbackType callbackType, ISerializationContext context);
    public sealed virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public sealed virtual void EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_ShouldEmitCreateInstance();
    public virtual Type get_ExpectedType();
    private sealed virtual override Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_BaseType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    private bool get_NeedsHint();
    public virtual object Read(State& state, object value);
    public virtual void Write(State& state, object value);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_HasInheritance();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitReadRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitWriteRoot(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    public bool CanEmitDirectWrite();
    public void EmitDirectWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal class ProtoBuf.Internal.Serializers.TimeSpanSerializer : object {
    private static TimeSpanSerializer s_Legacy;
    private static TimeSpanSerializer s_Duration;
    private static Type expectedType;
    private bool _useDuration;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private TimeSpanSerializer(bool useDuration);
    private static TimeSpanSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public static TimeSpanSerializer Create(CompatibilityLevel compatibilityLevel);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.TupleSerializer`1 : object {
    [CompilerGeneratedAttribute]
private SerializerFeatures <Features>k__BackingField;
    private MemberInfo[] members;
    private ConstructorInfo ctor;
    private IRuntimeProtoSerializerNode[] tails;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public SerializerFeatures Features { get; private set; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.IsSubType { get; }
    public Type ExpectedType { get; }
    private Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.BaseType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.ShouldEmitCreateInstance { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.HasInheritance { get; }
    public TupleSerializer`1(RuntimeTypeModel model, ConstructorInfo ctor, MemberInfo[] members, SerializerFeatures features, CompatibilityLevel compatibilityLevel);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    [CompilerGeneratedAttribute]
public sealed virtual SerializerFeatures get_Features();
    [CompilerGeneratedAttribute]
private void set_Features(SerializerFeatures value);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_IsSubType();
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual void EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_BaseType();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, ISerializationContext context);
    private sealed virtual override object ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CreateInstance(ISerializationContext source);
    private object GetValue(object obj, int index);
    private sealed virtual override T ProtoBuf.Serializers.ISerializer<T>.Read(State& state, T value);
    private sealed virtual override void ProtoBuf.Serializers.ISerializer<T>.Write(State& state, T value);
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    public sealed virtual bool get_RequiresOldValue();
    public sealed virtual bool get_ReturnsValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private Type GetMemberType(int index);
    public sealed virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_ShouldEmitCreateInstance();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitReadRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitWriteRoot(CompilerContext ctx, Local valueFrom);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_HasInheritance();
    public sealed virtual void EmitRead(CompilerContext ctx, Local incoming);
}
internal abstract class ProtoBuf.Internal.Serializers.TypeSerializer : object {
    public static IProtoTypeSerializer Create(Type forType, Int32[] fieldNumbers, IRuntimeProtoSerializerNode[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, bool assertKnownType, CallbackSet callbacks, Type constructType, MethodInfo factory, Type rootType, SerializerFeatures features);
    internal abstract virtual void Init(Int32[] fieldNumbers, IRuntimeProtoSerializerNode[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, bool assertKnownType, CallbackSet callbacks, Type constructType, MethodInfo factory, SerializerFeatures features);
}
internal class ProtoBuf.Internal.Serializers.TypeSerializer`1 : TypeSerializer {
    private Type constructType;
    private IRuntimeProtoSerializerNode[] serializers;
    private Int32[] fieldNumbers;
    private StateFlags<T> flags;
    private CallbackSet callbacks;
    private MethodInfo[] baseCtorCallbacks;
    private MethodInfo factory;
    [CompilerGeneratedAttribute]
private SerializerFeatures <Features>k__BackingField;
    protected Action`2<T, ISerializationContext> _subTypeOnBeforeDeserialize;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public bool HasInheritance { get; }
    public bool IsSubType { get; }
    public Type ExpectedType { get; }
    internal Type BaseType { get; }
    private Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.BaseType { get; }
    public SerializerFeatures Features { get; private set; }
    private bool CanHaveInheritance { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private bool UseTypedExtensible { get; }
    private bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.ShouldEmitCreateInstance { get; }
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public virtual bool get_HasInheritance();
    public virtual void EmitReadRoot(CompilerContext context, Local valueFrom);
    public virtual void EmitWriteRoot(CompilerContext context, Local valueFrom);
    private sealed virtual override T ProtoBuf.Serializers.IFactory<T>.Create(ISerializationContext context);
    public virtual void Write(State& state, T value);
    public virtual T Read(State& state, T value);
    public virtual bool get_IsSubType();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Write(State& state, object value);
    private sealed virtual override object ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.Read(State& state, object value);
    public sealed virtual bool HasCallbacks(CallbackType callbackType);
    public sealed virtual Type get_ExpectedType();
    internal virtual Type get_BaseType();
    private sealed virtual override Type ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_BaseType();
    private void SetFlag(StateFlags<T> flag, bool value);
    private bool GetFlag(StateFlags<T> flag);
    [CompilerGeneratedAttribute]
public sealed virtual SerializerFeatures get_Features();
    [CompilerGeneratedAttribute]
private void set_Features(SerializerFeatures value);
    internal virtual void Init(Int32[] fieldNumbers, IRuntimeProtoSerializerNode[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, bool assertKnownType, CallbackSet callbacks, Type constructType, MethodInfo factory, SerializerFeatures features);
    private bool get_CanHaveInheritance();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CanCreateInstance();
    private sealed virtual override object ProtoBuf.Internal.Serializers.IProtoTypeSerializer.CreateInstance(ISerializationContext context);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.Callback(object value, CallbackType callbackType, ISerializationContext context);
    public void Callback(T& value, CallbackType callbackType, ISerializationContext context);
    private IRuntimeProtoSerializerNode GetMoreSpecificSerializer(object value);
    protected void SerializeImpl(State& state, T value);
    protected void DeserializeBody(State& state, TState& bodyState, StateGetter`1<T, TState> getter, StateSetter`1<T, TState> setter);
    private object InvokeCallback(MethodInfo method, object obj, ISerializationContext serializationContext);
    private object CreateInstance(ISerializationContext context);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    private void LoadFromState(CompilerContext ctx, Local value);
    private void WriteToState(CompilerContext ctx, Local state, Local value, Type type);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private bool get_UseTypedExtensible();
    private static void EmitInvokeCallback(CompilerContext ctx, MethodInfo method, Type constructType, Type type, Local valueFrom);
    private void EmitCallbackIfNeeded(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, CallbackType callbackType);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local valueFrom);
    private void WriteFieldHandler(CompilerContext ctx, Type expected, Local loc, CodeLabel handler, CodeLabel continue, IRuntimeProtoSerializerNode serializer);
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IProtoTypeSerializer.get_ShouldEmitCreateInstance();
    private sealed virtual override void ProtoBuf.Internal.Serializers.IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx, bool callNoteObject);
    private void EmitCreateIfNull(CompilerContext ctx, Local storage);
    [CompilerGeneratedAttribute]
private void <Init>b__34_0(T val, ISerializationContext ctx);
}
internal static class ProtoBuf.Internal.Serializers.TypeSerializerMethodCache : object {
    internal static Type Type_IExtensible;
    internal static Type Type_ITypedIExtensible;
    internal static MethodInfo Method_Write_AppendExtensionData_IExtensible;
    internal static MethodInfo Method_Write_AppendExtensionData_ITypedExtensible;
    internal static MethodInfo Method_Read_AppendExtensionData_IExtensible;
    internal static MethodInfo Method_Read_AppendExtensionData_ITypedExtensible;
    internal static Dictionary`2<int, MethodInfo> ThrowUnexpectedSubtype;
    private static TypeSerializerMethodCache();
}
internal class ProtoBuf.Internal.Serializers.UInt16Serializer : object {
    internal static UInt16Serializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static UInt16Serializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public virtual object Read(State& state, object value);
    public virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.UInt32Serializer : object {
    internal static UInt32Serializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static UInt32Serializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.UInt64Serializer : object {
    internal static UInt64Serializer Instance;
    private static Type expectedType;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static UInt64Serializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual object Read(State& state, object value);
    public sealed virtual void Write(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.UIntPtrSerializer : object {
    internal static UIntPtrSerializer Instance;
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.IsScalar { get; }
    public Type ExpectedType { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.RequiresOldValue { get; }
    private bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.ReturnsValue { get; }
    private static UIntPtrSerializer();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_IsScalar();
    public sealed virtual Type get_ExpectedType();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_RequiresOldValue();
    private sealed virtual override bool ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.get_ReturnsValue();
    public sealed virtual void Write(State& state, object value);
    public sealed virtual object Read(State& state, object value);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitWrite(CompilerContext ctx, Local valueFrom);
    private sealed virtual override void ProtoBuf.Internal.Serializers.IRuntimeProtoSerializerNode.EmitRead(CompilerContext ctx, Local entity);
}
internal class ProtoBuf.Internal.Serializers.UriDecorator : ProtoDecoratorBase {
    private static Type expectedType;
    public bool IsScalar { get; }
    public Type ExpectedType { get; }
    public bool RequiresOldValue { get; }
    public bool ReturnsValue { get; }
    public UriDecorator(IRuntimeProtoSerializerNode tail);
    private static UriDecorator();
    public virtual bool get_IsScalar();
    public virtual Type get_ExpectedType();
    public virtual bool get_RequiresOldValue();
    public virtual bool get_ReturnsValue();
    public virtual void Write(State& state, object value);
    public virtual object Read(State& state, object value);
    protected virtual void EmitWrite(CompilerContext ctx, Local valueFrom);
    protected virtual void EmitRead(CompilerContext ctx, Local valueFrom);
}
internal static class ProtoBuf.Internal.TypeCompatibilityHelper : object {
    private static Dictionary`2<Module, CompatibilityLevel> s_ByModule;
    private static TypeCompatibilityHelper();
    internal static CompatibilityLevel GetModuleCompatibilityLevel(Module module);
    internal static CompatibilityLevel GetTypeCompatibilityLevel(Type type, CompatibilityLevel defaultLevel);
    internal static CompatibilityLevel GetMemberCompatibilityLevel(MemberInfo member, CompatibilityLevel typeLevel);
    [CompilerGeneratedAttribute]
internal static CompatibilityLevel <GetModuleCompatibilityLevel>g__Calculate|1_0(Module module);
}
internal abstract class ProtoBuf.Meta.AttributeMap : object {
    public Type AttributeType { get; }
    public object Target { get; }
    [ObsoleteAttribute("Please use AttributeType instead")]
public Type GetType();
    public virtual string ToString();
    public abstract virtual bool TryGet(string key, bool publicOnly, Object& value);
    public bool TryGet(string key, Object& value);
    public abstract virtual Type get_AttributeType();
    public static AttributeMap[] Create(Type type, bool inherit);
    public static AttributeMap[] Create(MemberInfo member, bool inherit);
    public static AttributeMap[] Create(Assembly assembly);
    public abstract virtual object get_Target();
}
public class ProtoBuf.Meta.AutoCompileTypeModel : TypeModel {
    private static Hashtable s_assemblyModels;
    [CompilerGeneratedAttribute]
private static TypeModel <Instance>k__BackingField;
    public static TypeModel Instance { get; }
    private static AutoCompileTypeModel();
    public static TypeModel CreateForAssembly();
    public static TypeModel CreateForAssembly(Type type);
    public static TypeModel CreateForAssembly(Assembly assembly);
    public static TypeModel CreateForAssembly(Assembly assembly, CompilerOptions options);
    [CompilerGeneratedAttribute]
public static TypeModel get_Instance();
    private static TypeModel ForAssembly(Type type);
    public virtual string GetSchema(SchemaGenerationOptions options);
    protected virtual ISerializer`1<T> GetSerializer();
    internal virtual bool IsKnownType(CompatibilityLevel ambient);
    private static TypeModel CreateForAssemblyImpl(Assembly assembly, CompilerOptions options);
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.CallbackSet : object {
    private MetaType metaType;
    private MethodInfo beforeSerialize;
    private MethodInfo afterSerialize;
    private MethodInfo beforeDeserialize;
    private MethodInfo afterDeserialize;
    internal MethodInfo Item { get; }
    public MethodInfo BeforeSerialize { get; public set; }
    public MethodInfo BeforeDeserialize { get; public set; }
    public MethodInfo AfterSerialize { get; public set; }
    public MethodInfo AfterDeserialize { get; public set; }
    public bool NonTrivial { get; }
    internal CallbackSet(MetaType metaType);
    internal MethodInfo get_Item(CallbackType callbackType);
    internal static bool CheckCallbackParameters(MethodInfo method);
    private MethodInfo SanityCheckCallback(MethodInfo callback);
    internal static Exception CreateInvalidCallbackSignature(MethodInfo method);
    public MethodInfo get_BeforeSerialize();
    public void set_BeforeSerialize(MethodInfo value);
    public MethodInfo get_BeforeDeserialize();
    public void set_BeforeDeserialize(MethodInfo value);
    public MethodInfo get_AfterSerialize();
    public void set_AfterSerialize(MethodInfo value);
    public MethodInfo get_AfterDeserialize();
    public void set_AfterDeserialize(MethodInfo value);
    public bool get_NonTrivial();
}
[IsReadOnlyAttribute]
public class ProtoBuf.Meta.EnumMember : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    internal bool HasValue { get; }
    public EnumMember(object value, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    internal bool get_HasValue();
    internal Nullable`1<int> TryGetInt32();
    internal static Nullable`1<int> TryGetInt32(object value);
    public EnumMember WithName(string name);
    public EnumMember WithValue(object value);
    public EnumMember Normalize(Type type);
    public bool Equals(T value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EnumMember other);
    public static bool op_Equality(EnumMember x, EnumMember y);
    public static bool op_Inequality(EnumMember x, EnumMember y);
    private static object Normalize(object value, Type type);
    public static EnumMember Create(T value);
    internal void Validate();
}
public class ProtoBuf.Meta.LockContentedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <OwnerStackTrace>k__BackingField;
    public string OwnerStackTrace { get; }
    internal LockContentedEventArgs(string ownerStackTrace);
    [CompilerGeneratedAttribute]
public string get_OwnerStackTrace();
}
public class ProtoBuf.Meta.LockContentedEventHandler : MulticastDelegate {
    public LockContentedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LockContentedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, LockContentedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.MetaType : object {
    private MetaType baseType;
    private CompatibilityLevel _compatibilityLevel;
    private List`1<SubType> _subTypes;
    private CallbackSet callbacks;
    private string name;
    private string origin;
    private MethodInfo factory;
    private RuntimeTypeModel model;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    private IProtoTypeSerializer _serializer;
    private Type constructType;
    internal Type surrogateType;
    internal DataFormat surrogateDataFormat;
    private MethodInfo underlyingToSurrogate;
    private MethodInfo surrogateToUnderlying;
    private List`1<ValueMember> _fields;
    private List`1<EnumMember> _enums;
    private TypeOptions modreq(System.Runtime.CompilerServices.IsVolatile) flags;
    private Type _serializerType;
    private List`1<ProtoReservedAttribute> _reservations;
    private IRuntimeProtoSerializerNode ProtoBuf.Internal.Serializers.ISerializerProxy.Serializer { get; }
    public MetaType BaseType { get; }
    internal RuntimeTypeModel Model { get; }
    public CompatibilityLevel CompatibilityLevel { get; public set; }
    public bool IncludeSerializerMethod { get; public set; }
    public bool AsReferenceDefault { get; public set; }
    public bool HasCallbacks { get; }
    public bool HasSubtypes { get; }
    public CallbackSet Callbacks { get; }
    private bool IsValueType { get; }
    public string Name { get; public set; }
    public string Origin { get; public set; }
    public Type Type { get; }
    internal IProtoTypeSerializer Serializer { get; }
    public bool UseConstructor { get; public set; }
    public Type ConstructType { get; public set; }
    internal bool HasSurrogate { get; }
    public ValueMember Item { get; }
    public ValueMember Item { get; }
    internal bool HasFields { get; }
    internal List`1<ValueMember> Fields { get; }
    internal List`1<EnumMember> Enums { get; }
    internal bool HasEnums { get; }
    public bool EnumPassthru { get; public set; }
    public bool IgnoreListHandling { get; public set; }
    public bool IgnoreUnknownSubTypes { get; public set; }
    internal bool Pending { get; internal set; }
    public Type SerializerType { get; public set; }
    internal bool IsAutoTuple { get; }
    public bool IsGroup { get; public set; }
    internal bool HasReservations { get; }
    internal MetaType(RuntimeTypeModel model, Type type, MethodInfo factory);
    public virtual string ToString();
    private sealed virtual override IRuntimeProtoSerializerNode ProtoBuf.Internal.Serializers.ISerializerProxy.get_Serializer();
    public MetaType get_BaseType();
    internal RuntimeTypeModel get_Model();
    public CompatibilityLevel get_CompatibilityLevel();
    public void set_CompatibilityLevel(CompatibilityLevel value);
    public bool get_IncludeSerializerMethod();
    public void set_IncludeSerializerMethod(bool value);
    public bool get_AsReferenceDefault();
    [ObsoleteAttribute("Reference-tracking and dynamic-type are not currently implemented in this build; they may be reinstated later; this is partly due to doubts over whether the features are adviseable, and partly over confidence in testing all the scenarios (it takes time; that time hasn't get happened); feedback is invited", "True")]
public void set_AsReferenceDefault(bool value);
    private bool IsValidSubType(Type subType);
    public MetaType AddSubType(int fieldNumber, Type derivedType);
    private static void ThrowSubTypeWithSurrogate(Type type);
    public MetaType AddSubType(int fieldNumber, Type derivedType, DataFormat dataFormat);
    private static void ThrowTupleTypeWithInheritance(Type type);
    private void SetBaseType(MetaType baseType);
    public bool get_HasCallbacks();
    public bool get_HasSubtypes();
    public CallbackSet get_Callbacks();
    private bool get_IsValueType();
    public MetaType SetCallbacks(MethodInfo beforeSerialize, MethodInfo afterSerialize, MethodInfo beforeDeserialize, MethodInfo afterDeserialize);
    private void CheckSetCallbacks();
    public MetaType SetCallbacks(string beforeSerialize, string afterSerialize, string beforeDeserialize, string afterDeserialize);
    public string GetSchemaTypeName();
    internal string GetSchemaTypeName(HashSet`1<Type> callstack);
    internal string GuessPackage();
    public string get_Name();
    public void set_Name(string value);
    public string get_Origin();
    public void set_Origin(string value);
    public MetaType SetFactory(MethodInfo factory);
    public MetaType SetFactory(string factory);
    private MethodInfo ResolveMethod(string name, bool instance);
    internal static Exception InbuiltType(Type type, Exception innerException);
    internal void ThrowIfFrozen();
    [CompilerGeneratedAttribute]
public Type get_Type();
    internal IProtoTypeSerializer get_Serializer();
    internal Type GetInheritanceRoot();
    private SerializerFeatures GetFeatures();
    private bool HasRealInheritance();
    private IProtoTypeSerializer BuildSerializer();
    private static Type GetBaseType(MetaType type);
    internal static bool GetAsReferenceDefault(Type type);
    internal void ApplyDefaultBehaviour(CompatibilityLevel ambient);
    private void ApplyDefaultBehaviourImpl(CompatibilityLevel ambient);
    internal void Assert(CompatibilityLevel expected);
    private static void ApplyDefaultBehaviour_AddMembers(AttributeFamily family, bool isEnum, List`1<AttributeMap> partialMembers, int dataMemberOffset, bool inferTagByName, ImplicitFields implicitMode, List`1<ProtoMemberAttribute> members, MemberInfo member, Boolean& forced, bool isPublic, bool isField, Type& effectiveType, List`1<EnumMember> enumMembers, MemberInfo backingMember);
    private static MethodInfo Coalesce(MethodInfo[] arr, int x, int y);
    internal static AttributeFamily GetContractFamily(RuntimeTypeModel model, Type type, AttributeMap[] attributes);
    internal static ConstructorInfo ResolveTupleConstructor(Type type, MemberInfo[]& mappedMembers);
    private static void CheckForCallback(MethodInfo method, AttributeMap[] attributes, string callbackTypeName, MethodInfo[]& callbacks, int index);
    private static bool HasFamily(AttributeFamily value, AttributeFamily required);
    private static ProtoMemberAttribute NormalizeProtoMember(MemberInfo member, AttributeFamily family, bool forced, bool isEnum, List`1<AttributeMap> partialMembers, int dataMemberOffset, bool inferByTagName, EnumMember& enumMember, MemberInfo backingMember);
    private ValueMember ApplyDefaultBehaviour(bool isEnum, ProtoMemberAttribute normalizedAttribute);
    private static void GetDataFormat(DataFormat& value, AttributeMap attrib, string memberName);
    private static void GetIgnore(Boolean& ignore, AttributeMap attrib, AttributeMap[] attribs, string fullName);
    private static void GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName);
    private static bool GetFieldBoolean(Boolean& value, AttributeMap attrib, string memberName, bool publicOnly);
    private static void GetFieldNumber(Int32& value, AttributeMap attrib, string memberName);
    private static void GetFieldName(String& name, AttributeMap attrib, string memberName);
    private static AttributeMap GetAttribute(AttributeMap[] attribs, string fullName);
    public MetaType Add(int fieldNumber, string memberName);
    public ValueMember AddField(int fieldNumber, string memberName);
    public bool get_UseConstructor();
    public void set_UseConstructor(bool value);
    public Type get_ConstructType();
    public void set_ConstructType(Type value);
    public MetaType Add(string memberName);
    public void SetSurrogate(Type surrogateType);
    internal void SetSurrogate(Type surrogateType, MethodInfo underlyingToSurrogate, MethodInfo surrogateToUnderlying, DataFormat dataFormat);
    internal bool get_HasSurrogate();
    internal MetaType GetSurrogateOrSelf();
    internal MetaType GetSurrogateOrBaseOrSelf(bool deep);
    private int GetNextFieldNumber();
    public MetaType Add(String[] memberNames);
    public MetaType Add(int fieldNumber, string memberName, object defaultValue);
    public MetaType Add(int fieldNumber, string memberName, Type itemType, Type defaultType);
    public ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType);
    private void ThrowIfAutoTuple();
    private ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType, object defaultValue);
    private void Add(ValueMember member);
    public ValueMember get_Item(int fieldNumber);
    public ValueMember get_Item(MemberInfo member);
    internal bool get_HasFields();
    internal List`1<ValueMember> get_Fields();
    internal List`1<EnumMember> get_Enums();
    internal bool get_HasEnums();
    public ValueMember[] GetFields();
    public EnumMember[] GetEnumValues();
    public void SetEnumValues(EnumMember[] values);
    internal bool IsValidEnum();
    internal static bool IsValidEnum(IList`1<EnumMember> values);
    public SubType[] GetSubtypes();
    internal IEnumerable`1<Type> GetAllGenericArguments();
    [IteratorStateMachineAttribute("ProtoBuf.Meta.MetaType/<GetAllGenericArguments>d__137")]
private static IEnumerable`1<Type> GetAllGenericArguments(Type type);
    public void CompileInPlace();
    internal bool IsDefined(int fieldNumber);
    [ObsoleteAttribute("Enum value maps have been deprecated and are no longer supported; all enums are now effectively pass-thru; custom maps should be applied via shadow properties; in C#, lambda-based 'switch expressions' make for very convenient shadow properties", "False")]
public bool get_EnumPassthru();
    [ObsoleteAttribute("Enum value maps have been deprecated and are no longer supported; all enums are now effectively pass-thru; custom maps should be applied via shadow properties; in C#, lambda-based 'switch expressions' make for very convenient shadow properties", "True")]
public void set_EnumPassthru(bool value);
    public bool get_IgnoreListHandling();
    public void set_IgnoreListHandling(bool value);
    public bool get_IgnoreUnknownSubTypes();
    public void set_IgnoreUnknownSubTypes(bool value);
    internal bool get_Pending();
    internal void set_Pending(bool value);
    private bool HasFlag(TypeOptions flag);
    private void SetFlag(TypeOptions flag, bool value, bool throwIfFrozen);
    public Type get_SerializerType();
    public void set_SerializerType(Type value);
    internal static MetaType GetRootType(MetaType source);
    internal bool IsPrepared();
    internal static StringBuilder NewLine(StringBuilder builder, int indent);
    internal bool get_IsAutoTuple();
    public bool get_IsGroup();
    public void set_IsGroup(bool value);
    internal void WriteSchema(HashSet`1<Type> callstack, StringBuilder builder, int indent, HashSet`1<string> imports, ProtoSyntax syntax, string package, SchemaGenerationFlags flags);
    private static StringBuilder AddOption(StringBuilder builder, Boolean& hasOption);
    private static StringBuilder CloseOption(StringBuilder builder, Boolean& hasOption);
    private static bool IsImplicitDefault(object value);
    private static bool CanPack(Type type);
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("2")]
public void ApplyFieldOffset(int offset);
    internal static void AssertValidFieldNumber(int fieldNumber);
    public MetaType AddReservation(int field, string comment);
    public MetaType AddReservation(int from, int to, string comment);
    public MetaType AddReservation(string field, string comment);
    private MetaType AddReservation(ProtoReservedAttribute reservation);
    internal bool get_HasReservations();
    internal void Validate();
    internal void ValidateReservations();
    [CompilerGeneratedAttribute]
private string <GetSchemaTypeName>g__GetArrayName|39_1(Type elementType, <>c__DisplayClass39_0& );
    [CompilerGeneratedAttribute]
internal static string <GetSchemaTypeName>g__LastPart|39_0(string value);
    [CompilerGeneratedAttribute]
internal static bool <ResolveTupleConstructor>g__IsPublicSetter|76_0(MethodInfo method);
    [CompilerGeneratedAttribute]
internal static void <ThrowIfAutoTuple>g__Throw|113_0();
    [CompilerGeneratedAttribute]
private EnumMember <SetEnumValues>b__132_0(EnumMember val);
    [CompilerGeneratedAttribute]
private void <WriteSchema>g__WriteValueMember|168_3(string schemaModelTypeName, bool hasGroupModifier, <>c__DisplayClass168_0& , <>c__DisplayClass168_1& , <>c__DisplayClass168_2& );
    [CompilerGeneratedAttribute]
private void <WriteSchema>g__AddExtraLayerSchemaModels|168_0(ExtraLayerValueMembers extraLayerValueMembers, int pos, <>c__DisplayClass168_0& );
    [CompilerGeneratedAttribute]
private void <WriteSchema>g__WriteWrappedFieldPayload|168_4(<>c__DisplayClass168_0& , <>c__DisplayClass168_3& , <>c__DisplayClass168_4& );
    [CompilerGeneratedAttribute]
private void <WriteSchema>g__AddNamespace|168_1(HashSet`1<string> imports, <>c__DisplayClass168_0& );
    [CompilerGeneratedAttribute]
private void <WriteSchema>g__AppendReservations|168_2(<>c__DisplayClass168_0& );
    [CompilerGeneratedAttribute]
internal static string <ValidateReservations>g__CommentSuffix|183_0(ProtoReservedAttribute reservation);
}
internal class ProtoBuf.Meta.NullWrappedValueMemberData : object {
    private string _originalSchemaTypeName;
    private string _alternativeTypeName;
    private bool _hasSchemaTypeNameCollision;
    private ValueMember _valueMember;
    public string SchemaTypeName { get; }
    public string WrappedSchemaTypeName { get; }
    public bool HasSchemaTypeNameCollision { get; }
    public Type ItemType { get; }
    public bool HasGroupModifier { get; }
    public NullWrappedValueMemberData(ValueMember valueMember, string originalSchemaTypeName, string alternativeTypeName, bool hasSchemaTypeNameCollision);
    public string get_SchemaTypeName();
    public string get_WrappedSchemaTypeName();
    public bool get_HasSchemaTypeNameCollision();
    public Type get_ItemType();
    public bool get_HasGroupModifier();
    private bool HasKnownTypeSchema();
}
[DefaultMemberAttribute("Item")]
public class ProtoBuf.Meta.RuntimeTypeModel : TypeModel {
    private RuntimeTypeModelOptions _options;
    [CompilerGeneratedAttribute]
private CompilerContextScope <Scope>k__BackingField;
    private CompatibilityLevel _defaultCompatibilityLevel;
    private static MatchPredicate BasicTypeFinder;
    private static MatchPredicate MetaTypeFinder;
    private BasicList types;
    private BasicList basicTypes;
    [CompilerGeneratedAttribute]
private EventHandler`1<TypeAddedEventArgs> BeforeApplyDefaultBehaviour;
    [CompilerGeneratedAttribute]
private EventHandler`1<TypeAddedEventArgs> AfterApplyDefaultBehaviour;
    private Hashtable _serviceCache;
    private int metadataTimeoutMilliseconds;
    private int contentionCounter;
    [CompilerGeneratedAttribute]
private LockContentedEventHandler LockContended;
    private MethodInfo defaultFactory;
    private string _name;
    private static object s_ModelSyncLock;
    private Hashtable _externalProviders;
    public TypeModelOptions Options { get; }
    internal CompilerContextScope Scope { get; }
    public bool InferTagFromNameDefault { get; public set; }
    public bool AutoAddProtoContractTypesOnly { get; public set; }
    public bool UseImplicitZeroDefaults { get; public set; }
    public bool AllowParseableTypes { get; public set; }
    public bool IncludeDateTimeKind { get; public set; }
    public bool SkipZeroLengthPackedArrays { get; public set; }
    public bool AllowPackedEncodingAtRoot { get; public set; }
    public bool InternStrings { get; public set; }
    public static RuntimeTypeModel Default { get; }
    public CompatibilityLevel DefaultCompatibilityLevel { get; public set; }
    public MetaType Item { get; }
    public bool AutoCompile { get; public set; }
    public bool AutoAddMissingTypes { get; public set; }
    public int MetadataTimeoutMilliseconds { get; public set; }
    internal RuntimeTypeModel(bool isDefault, string name);
    private static RuntimeTypeModel();
    public static void Initialize();
    public virtual TypeModelOptions get_Options();
    private bool GetOption(RuntimeTypeModelOptions option);
    private void SetOption(RuntimeTypeModelOptions option, bool value);
    [CompilerGeneratedAttribute]
internal CompilerContextScope get_Scope();
    public bool get_InferTagFromNameDefault();
    public void set_InferTagFromNameDefault(bool value);
    public bool get_AutoAddProtoContractTypesOnly();
    public void set_AutoAddProtoContractTypesOnly(bool value);
    public bool get_UseImplicitZeroDefaults();
    public void set_UseImplicitZeroDefaults(bool value);
    public bool get_AllowParseableTypes();
    public void set_AllowParseableTypes(bool value);
    public bool get_IncludeDateTimeKind();
    public void set_IncludeDateTimeKind(bool value);
    public bool get_SkipZeroLengthPackedArrays();
    public void set_SkipZeroLengthPackedArrays(bool value);
    public bool get_AllowPackedEncodingAtRoot();
    public void set_AllowPackedEncodingAtRoot(bool value);
    public bool get_InternStrings();
    public void set_InternStrings(bool value);
    public static RuntimeTypeModel get_Default();
    public IEnumerable GetTypes();
    public CompatibilityLevel get_DefaultCompatibilityLevel();
    public void set_DefaultCompatibilityLevel(CompatibilityLevel value);
    public virtual string GetSchema(SchemaGenerationOptions options);
    private void CascadeRepeated(List`1<MetaType> list, RepeatedSerializerStub provider, CompatibilityLevel ambient, DataFormat keyFormat, HashSet`1<string> imports, string origin);
    private void CascadeDependents(List`1<MetaType> list, MetaType metaType, HashSet`1<string> imports, string origin);
    private void TryGetCoreSerializer(List`1<MetaType> list, Type itemType, CompatibilityLevel ambient, HashSet`1<string> imports, string origin);
    internal static bool EnableAutoCompile();
    public MetaType get_Item(Type type);
    internal MetaType FindWithAmbientCompatibility(Type type, CompatibilityLevel ambient);
    internal MetaType FindWithoutAdd(Type type);
    private void WaitOnLock();
    internal IRuntimeProtoSerializerNode TryGetBasicTypeSerializer(Type type);
    internal int FindOrAddAuto(Type type, bool demand, bool addWithContractOnly, bool addEvenIfAutoDisabled, CompatibilityLevel ambient);
    private MetaType RecogniseCommonTypes(Type type);
    private MetaType Create(Type type);
    public MetaType Add(bool applyDefaultBehaviour, CompatibilityLevel compatibilityLevel);
    public MetaType Add(Type type, bool applyDefaultBehaviour);
    public MetaType Add(Type type, bool applyDefaultBehaviour, CompatibilityLevel compatibilityLevel);
    [CompilerGeneratedAttribute]
public void add_BeforeApplyDefaultBehaviour(EventHandler`1<TypeAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeforeApplyDefaultBehaviour(EventHandler`1<TypeAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AfterApplyDefaultBehaviour(EventHandler`1<TypeAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AfterApplyDefaultBehaviour(EventHandler`1<TypeAddedEventArgs> value);
    internal static void OnBeforeApplyDefaultBehaviour(MetaType metaType, TypeAddedEventArgs& args);
    internal static void OnAfterApplyDefaultBehaviour(MetaType metaType, TypeAddedEventArgs& args);
    private static void OnApplyDefaultBehaviour(EventHandler`1<TypeAddedEventArgs> handler, MetaType metaType, TypeAddedEventArgs& args);
    public bool get_AutoCompile();
    public void set_AutoCompile(bool value);
    public bool get_AutoAddMissingTypes();
    public void set_AutoAddMissingTypes(bool value);
    private void ThrowIfFrozen();
    public void Freeze();
    protected virtual ISerializer`1<T> GetSerializer();
    internal virtual ISerializer`1<T> GetSerializerCore(CompatibilityLevel ambient);
    internal virtual bool IsKnownType(CompatibilityLevel ambient);
    private object GetServices(CompatibilityLevel ambient);
    internal void ResetServiceCache(Type type);
    private object GetServicesSlow(Type type, CompatibilityLevel ambient);
    public virtual string ToString();
    internal ProtoSerializer`1<TActual> GetSerializer(IRuntimeProtoSerializerNode serializer, bool compiled);
    public void CompileInPlace();
    private void BuildAllSerializers();
    internal static ILGenerator Override(TypeBuilder type, string name);
    internal static ILGenerator Override(TypeBuilder type, string name, Type[]& genericArgs);
    public TypeModel Compile(CompilerOptions options);
    private void WriteConstructorsAndOverrides(TypeBuilder type, Type serviceType);
    private void WriteEnumsAndProxies(TypeBuilder type);
    internal static MemberInfo GetUnderlyingProvider(MemberInfo provider, Type forType);
    internal static void EmitProvider(MemberInfo provider, ILGenerator il);
    internal RepeatedSerializerStub TryGetRepeatedProvider(Type type, CompatibilityLevel ambient);
    private static void AddProxy(TypeBuilder building, Type proxying, MemberInfo provider, bool includeNullable);
    private void WriteSerializers(CompilerContextScope scope, TypeBuilder type);
    private static TypeBuilder WriteBasicTypeModel(string typeName, ModuleBuilder module, Type baseType, bool internal);
    private void WriteAssemblyAttributes(CompilerOptions options, string assemblyName, AssemblyBuilder asm);
    internal bool IsPrepared(Type type);
    public int get_MetadataTimeoutMilliseconds();
    public void set_MetadataTimeoutMilliseconds(int value);
    internal void TakeLock(Int32& opaqueToken);
    private int GetContention();
    private void AddContention();
    internal void ReleaseLock(int opaqueToken);
    [CompilerGeneratedAttribute]
public void add_LockContended(LockContentedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LockContended(LockContentedEventHandler value);
    internal string GetSchemaTypeName(HashSet`1<Type> callstack, Type effectiveType, DataFormat dataFormat, CompatibilityLevel compatibilityLevel, bool asReference, bool dynamicType, HashSet`1<string> imports);
    private static bool IsWrappersProtoType(Type type, String& name, HashSet`1<string> imports);
    private static bool IsWellKnownType(Type type, String& name, HashSet`1<string> imports);
    internal string GetSchemaTypeName(HashSet`1<Type> callstack, Type effectiveType, DataFormat dataFormat, CompatibilityLevel compatibilityLevel, bool asReference, bool dynamicType, HashSet`1<string> imports, String& altName, bool considerWrappersProtoTypes);
    public void SetDefaultFactory(MethodInfo methodInfo);
    internal static void VerifyFactory(MethodInfo factory, Type type);
    public static RuntimeTypeModel Create(string name);
    internal static bool IsFullyPublic(Type type);
    internal static bool IsFullyPublic(Type type, Type& cause);
    public static TypeModel CreateForAssembly();
    public static TypeModel CreateForAssembly(Type type);
    public static TypeModel CreateForAssembly(Assembly assembly);
    public void MakeDefault();
    private static void ThrowDefaultAutoAddMissingTypes();
    private static void ThrowDefaultUseImplicitZeroDefaults();
    private static void ThrowDefaultFrozen();
    private static RuntimeTypeModel CreateDefaultModelInstance();
    public RuntimeTypeModel SetSurrogate(Func`2<TUnderlying, TSurrogate> underlyingToSurrogate, Func`2<TSurrogate, TUnderlying> surrogateToUnderlying, DataFormat dataFormat, CompatibilityLevel compatibilityLevel);
    public RuntimeTypeModel AddSerializer(Type collectionType, Type serializerType);
    [CompilerGeneratedAttribute]
private bool <GetSchema>g__IsOutputForcedFor|41_0(Type type, <>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
private MetaType <GetSchema>g__AddType|41_1(Type type, bool forceOutput, bool inferPackageAndOrigin, <>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
private void <GetSchema>g__AddMetaType|41_2(MetaType toAdd, <>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
internal static object <GetServicesSlow>g__GetServicesImpl|88_0(RuntimeTypeModel model, Type type, CompatibilityLevel ambient);
    [CompilerGeneratedAttribute]
internal static bool <WriteEnumsAndProxies>g__ShouldEmitCustomSerializerProxy|100_0(Type serializerType);
    [CompilerGeneratedAttribute]
internal static MethodInfo <WriteSerializers>g__GetFeaturesMethod|105_0(SerializerFeatures features, <>c__DisplayClass105_0& );
    [CompilerGeneratedAttribute]
internal static void <WriteAssemblyAttributes>g__WriteAssemblyInfoAttributes|107_0(CompilerOptions options, AssemblyBuilder asm);
    [CompilerGeneratedAttribute]
internal static void <WriteAssemblyAttributes>g__WriteAssemblyInfoAttribute|107_1(CompilerOptions options, AssemblyBuilder asm, string value);
    [CompilerGeneratedAttribute]
internal static MethodInfo <SetSurrogate>g__GetMethod|141_0(Delegate value, string paramName);
}
public class ProtoBuf.Meta.SubType : object {
    private int _fieldNumber;
    private MetaType derivedType;
    private DataFormat dataFormat;
    private IRuntimeProtoSerializerNode serializer;
    public int FieldNumber { get; internal set; }
    public MetaType DerivedType { get; }
    public SubType(int fieldNumber, MetaType derivedType, DataFormat format);
    public int get_FieldNumber();
    internal void set_FieldNumber(int value);
    private void ThrowIfFrozen();
    public MetaType get_DerivedType();
    internal IRuntimeProtoSerializerNode GetSerializer(Type parentType);
    private IRuntimeProtoSerializerNode BuildSerializer(Type parentType);
}
public class ProtoBuf.Meta.TypeAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <ApplyDefaultBehaviour>k__BackingField;
    [CompilerGeneratedAttribute]
private MetaType <MetaType>k__BackingField;
    public bool ApplyDefaultBehaviour { get; public set; }
    public MetaType MetaType { get; }
    public Type Type { get; }
    public RuntimeTypeModel Model { get; }
    internal TypeAddedEventArgs(MetaType metaType);
    [CompilerGeneratedAttribute]
public bool get_ApplyDefaultBehaviour();
    [CompilerGeneratedAttribute]
public void set_ApplyDefaultBehaviour(bool value);
    [CompilerGeneratedAttribute]
public MetaType get_MetaType();
    public Type get_Type();
    public RuntimeTypeModel get_Model();
}
public class ProtoBuf.Meta.ValueMember : object {
    private int _fieldNumber;
    private MemberInfo backingMember;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    private object _defaultValue;
    [CompilerGeneratedAttribute]
private Type <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DefaultType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParentType>k__BackingField;
    private CompatibilityLevel _compatibilityLevel;
    private RuntimeTypeModel model;
    private IRuntimeProtoSerializerNode serializer;
    private DataFormat dataFormat;
    private DataFormat mapKeyFormat;
    private DataFormat mapValueFormat;
    private MethodInfo getSpecified;
    private MethodInfo setSpecified;
    private string name;
    private static ushort OPTIONS_IsStrict;
    private static ushort OPTIONS_IsPacked;
    private static ushort OPTIONS_IsRequired;
    private static ushort OPTIONS_OverwriteList;
    private static ushort OPTIONS_NullWrappedValue;
    private static ushort OPTIONS_NullWrappedValueGroup;
    private static ushort OPTIONS_IsMap;
    private static ushort OPTIONS_NullWrappedCollection;
    private static ushort OPTIONS_NullWrappedCollectionGroup;
    private static ushort OPTIONS_SupportNull;
    private ushort flags;
    public int FieldNumber { get; internal set; }
    public MemberInfo Member { get; }
    public MemberInfo BackingMember { get; public set; }
    public Type ItemType { get; }
    public Type MemberType { get; }
    public Type DefaultType { get; }
    public Type ParentType { get; }
    public object DefaultValue { get; public set; }
    public CompatibilityLevel CompatibilityLevel { get; public set; }
    internal IRuntimeProtoSerializerNode Serializer { get; }
    public DataFormat DataFormat { get; public set; }
    public bool IsStrict { get; public set; }
    public bool IsPacked { get; public set; }
    public bool OverwriteList { get; public set; }
    public bool IsRequired { get; public set; }
    public bool AsReference { get; public set; }
    public bool DynamicType { get; public set; }
    public bool IsMap { get; public set; }
    public DataFormat MapKeyFormat { get; public set; }
    public DataFormat MapValueFormat { get; public set; }
    public string Name { get; public set; }
    public bool SupportNull { get; public set; }
    internal bool NullWrappedValue { get; internal set; }
    internal bool NullWrappedValueGroup { get; internal set; }
    internal bool NullWrappedCollection { get; internal set; }
    internal bool NullWrappedCollectionGroup { get; internal set; }
    internal bool RequiresGroupModifier { get; }
    public ValueMember(RuntimeTypeModel model, Type parentType, int fieldNumber, MemberInfo member, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat, object defaultValue);
    internal ValueMember(RuntimeTypeModel model, int fieldNumber, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat);
    public int get_FieldNumber();
    internal void set_FieldNumber(int value);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    public MemberInfo get_BackingMember();
    public void set_BackingMember(MemberInfo value);
    [CompilerGeneratedAttribute]
public Type get_ItemType();
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public Type get_DefaultType();
    [CompilerGeneratedAttribute]
public Type get_ParentType();
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    public CompatibilityLevel get_CompatibilityLevel();
    public void set_CompatibilityLevel(CompatibilityLevel value);
    internal static CompatibilityLevel GetEffectiveCompatibilityLevel(CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
    internal object GetRawEnumValue();
    private static object ParseDefaultValue(Type type, object value);
    internal IRuntimeProtoSerializerNode get_Serializer();
    public DataFormat get_DataFormat();
    public void set_DataFormat(DataFormat value);
    public bool get_IsStrict();
    public void set_IsStrict(bool value);
    public bool get_IsPacked();
    public void set_IsPacked(bool value);
    public bool get_OverwriteList();
    public void set_OverwriteList(bool value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public bool get_AsReference();
    [ObsoleteAttribute("Reference-tracking and dynamic-type are not currently implemented in this build; they may be reinstated later; this is partly due to doubts over whether the features are adviseable, and partly over confidence in testing all the scenarios (it takes time; that time hasn't get happened); feedback is invited", "True")]
public void set_AsReference(bool value);
    public bool get_DynamicType();
    [ObsoleteAttribute("Reference-tracking and dynamic-type are not currently implemented in this build; they may be reinstated later; this is partly due to doubts over whether the features are adviseable, and partly over confidence in testing all the scenarios (it takes time; that time hasn't get happened); feedback is invited", "True")]
public void set_DynamicType(bool value);
    public bool get_IsMap();
    public void set_IsMap(bool value);
    public DataFormat get_MapKeyFormat();
    public void set_MapKeyFormat(DataFormat value);
    public DataFormat get_MapValueFormat();
    public void set_MapValueFormat(DataFormat value);
    public void SetSpecified(MethodInfo getSpecified, MethodInfo setSpecified);
    private void ThrowIfFrozen();
    internal static IRuntimeProtoSerializerNode CreateMap(RepeatedSerializerStub repeated, RuntimeTypeModel model, DataFormat dataFormat, CompatibilityLevel compatibilityLevel, DataFormat keyFormat, DataFormat valueFormat, bool asReference, bool dynamicType, bool isMap, bool overwriteList, int fieldNumber, ValueMember member);
    private void ComposeListFeatures(SerializerFeatures& listFeatures);
    private IRuntimeProtoSerializerNode BuildSerializer();
    private static WireType GetIntWireType(DataFormat format, int width);
    private static WireType GetDateTimeWireType(DataFormat format);
    internal static IRuntimeProtoSerializerNode TryGetCoreSerializer(RuntimeTypeModel model, DataFormat dataFormat, CompatibilityLevel compatibilityLevel, Type type, WireType& defaultWireType, bool asReference, bool dynamicType, bool overwriteList, bool allowComplexTypes);
    internal void SetName(string name);
    public string get_Name();
    public void set_Name(string value);
    private bool HasFlag(ushort flag);
    private void SetFlag(ushort flag, bool value, bool throwIfFrozen);
    public bool get_SupportNull();
    public void set_SupportNull(bool value);
    internal bool get_NullWrappedValue();
    internal void set_NullWrappedValue(bool value);
    internal bool get_NullWrappedValueGroup();
    internal void set_NullWrappedValueGroup(bool value);
    internal bool get_NullWrappedCollection();
    internal void set_NullWrappedCollection(bool value);
    internal bool get_NullWrappedCollectionGroup();
    internal void set_NullWrappedCollectionGroup(bool value);
    internal bool HasExtendedNullSupport();
    internal bool RequiresExtraLayerInSchema();
    internal bool get_RequiresGroupModifier();
    internal string GetSchemaTypeName(HashSet`1<Type> callstack, bool applyNetObjectProxy, HashSet`1<string> imports, String& altName, bool considerWrappersProtoTypes);
    [CompilerGeneratedAttribute]
internal static Type <CreateMap>g__FlattenRepeated|77_0(RuntimeTypeModel model, Type type);
}
public static class ProtoBuf.Serializer : object {
    private static string ProtoBinaryField;
    public static int ListItemTag;
    public static string GetProto();
    public static string GetProto(ProtoSyntax syntax);
    public static string GetProto(SchemaGenerationOptions options);
    public static T DeepClone(T instance, SerializationContext context);
    public static T DeepClone(T instance, object userState);
    public static MeasureState`1<T> Measure(T value, object userState, long abortAfter);
    public static T Merge(Stream source, T instance);
    public static TTo ChangeType(TFrom instance);
    public static void Merge(XmlReader reader, T instance);
    public static void Merge(SerializationInfo info, T instance);
    public static void Merge(SerializationInfo info, StreamingContext context, T instance);
    public static void PrepareSerializer();
    public static IFormatter CreateFormatter();
    public static IEnumerable`1<T> DeserializeItems(Stream source, PrefixStyle style, int fieldNumber);
    public static T DeserializeWithLengthPrefix(Stream source, PrefixStyle style);
    public static T DeserializeWithLengthPrefix(Stream source, PrefixStyle style, int fieldNumber);
    public static T MergeWithLengthPrefix(Stream source, T instance, PrefixStyle style);
    public static bool TryReadLengthPrefix(Stream source, PrefixStyle style, Int32& length);
    public static bool TryReadLengthPrefix(Byte[] buffer, int index, int count, PrefixStyle style, Int32& length);
    [ObsoleteAttribute("This API is no longer required and may be removed in a future release")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public static void FlushPool();
    public static T Deserialize(Stream source);
    public static T Deserialize(Stream source, T value, SerializationContext context, long length);
    public static T Deserialize(Stream source, T value, object userState, long length);
    public static object Deserialize(Type type, Stream source);
    public static T Deserialize(ReadOnlyMemory`1<byte> source, T value, object userState);
    public static T Deserialize(ReadOnlySequence`1<byte> source, T value, object userState);
    public static T Deserialize(ReadOnlySpan`1<byte> source, T value, object userState);
    public static void Serialize(Stream destination, T instance);
    public static void Serialize(Stream destination, T instance, object userState);
    public static void Serialize(IBufferWriter`1<byte> destination, T instance, object userState);
    public static void Serialize(SerializationInfo info, T instance);
    public static void Serialize(SerializationInfo info, StreamingContext context, T instance);
    public static void Serialize(XmlWriter writer, T instance);
    public static void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style);
    public static void SerializeWithLengthPrefix(Stream destination, T instance, PrefixStyle style, int fieldNumber);
}
internal static class ProtoBuf.Serializers.EnumSerializers : object {
    internal static object GetSerializer(Type type);
    internal static MemberInfo GetProvider(Type type);
}
internal static class ProtoBuf.Serializers.RepeatedSerializers : object {
    private static Hashtable s_providers;
    private static Hashtable s_methodsPerDeclaringType;
    private static Hashtable s_knownTypes;
    private static Registration s_Array;
    private static Type[] NotSupportedFlavors;
    private static MethodInfo s_NestedNotSupported;
    private static MethodInfo s_GeneralNotSupported;
    private static RepeatedSerializers();
    internal static MemberInfo Resolve(Type declaringType, string methodName, Type[] targs);
    public static void Add(Type type, Func`4<Type, Type, Type[], MemberInfo> implementation, bool exactOnly, Hashtable externalProviders);
    internal static RepeatedSerializerStub TryGetRepeatedProvider(Type type, Hashtable externalProvders);
    internal static RepeatedSerializerStub NotSupported(MethodInfo kind, Type collectionType, Type itemType);
    private static bool TestIfNestedNotSupported(RepeatedSerializerStub repeated);
    private static MemberInfo GetProviderForType(Type type, Hashtable externalProviders);
    private static bool TryGetProvider(Type root, Type current, int bestMatchPriority, MemberInfo& member, Int32& priority);
    private static bool TryGetExternalProvider(Type root, Type current, int bestMatchPriority, MemberInfo& member, Int32& priority, Hashtable externalProviders);
    [CompilerGeneratedAttribute]
internal static void <GetProviderForType>g__Consider|14_0(MemberInfo member, int priority, <>c__DisplayClass14_0& );
}
internal class ProtoBuf.Serializers.RepeatedSerializerStub : object {
    internal static RepeatedSerializerStub Empty;
    [CompilerGeneratedAttribute]
private MemberInfo <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ForType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemType>k__BackingField;
    private object _serializer;
    public MemberInfo Provider { get; }
    public bool IsMap { get; }
    public bool IsEmpty { get; }
    public object Serializer { get; }
    public Type ForType { get; }
    public Type ItemType { get; }
    private RepeatedSerializerStub(Type forType, MemberInfo provider);
    private static RepeatedSerializerStub();
    [CompilerGeneratedAttribute]
public MemberInfo get_Provider();
    [CompilerGeneratedAttribute]
public bool get_IsMap();
    internal bool IsValidProtobufMap(RuntimeTypeModel model, CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
    public bool get_IsEmpty();
    public object get_Serializer();
    [CompilerGeneratedAttribute]
public Type get_ForType();
    [CompilerGeneratedAttribute]
public Type get_ItemType();
    private object CreateSerializer();
    internal void EmitProvider(CompilerContext ctx);
    private void EmitProvider(ILGenerator il);
    public static RepeatedSerializerStub Create(Type forType, MemberInfo provider);
    private static bool CheckIsMap(MemberInfo provider, Type& itemType);
    internal void ResolveMapTypes(Type& keyType, Type& valueType);
    [CompilerGeneratedAttribute]
internal static bool <IsValidProtobufMap>g__IsValidKey|7_0(Type type, CompatibilityLevel compatibilityLevel, DataFormat dataFormat);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.5.119.9565")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
