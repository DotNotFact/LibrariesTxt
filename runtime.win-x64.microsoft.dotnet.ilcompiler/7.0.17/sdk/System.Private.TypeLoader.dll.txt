internal static class FxResources.System.Private.TypeLoader.SR : object {
}
[ExtensionAttribute]
internal static class Internal.Metadata.NativeFormat.MetadataTypeHashingAlgorithms : object {
    private static TypeAttributes NestedMask;
    private static void AppendNamespaceHashCode(HashCodeBuilder& builder, NamespaceDefinitionHandle namespaceDefHandle, MetadataReader reader);
    private static void AppendNamespaceHashCode(HashCodeBuilder& builder, NamespaceReferenceHandle namespaceRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static int ComputeHashCode(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static int ComputeHashCode(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
private static bool IsNested(TypeAttributes flags);
}
internal enum Internal.NativeFormat.BagElementKind : Enum {
    public UInt32 value__;
    public static BagElementKind End;
    public static BagElementKind BaseType;
    public static BagElementKind ImplementedInterfaces;
    public static BagElementKind DictionaryLayout;
    public static BagElementKind TypeFlags;
    public static BagElementKind NonGcStaticData;
    public static BagElementKind GcStaticData;
    public static BagElementKind NonGcStaticDataSize;
    public static BagElementKind GcStaticDataSize;
    public static BagElementKind GcStaticDesc;
    public static BagElementKind ThreadStaticDataSize;
    public static BagElementKind ThreadStaticDesc;
    public static BagElementKind ThreadStaticIndex;
    public static BagElementKind ThreadStaticOffset;
    public static BagElementKind FieldLayout;
    public static BagElementKind VTableMethodSignatures;
    public static BagElementKind SealedVTableEntries;
    public static BagElementKind ClassConstructorPointer;
    public static BagElementKind BaseTypeSize;
    public static BagElementKind GenericVarianceInfo;
    public static BagElementKind DelegateInvokeSignature;
}
internal enum Internal.NativeFormat.CallingConventionConverterKind : Enum {
    public UInt32 value__;
    public static CallingConventionConverterKind NoInstantiatingParam;
    public static CallingConventionConverterKind HasInstantiatingParam;
    public static CallingConventionConverterKind MaybeInstantiatingParam;
}
internal enum Internal.NativeFormat.FieldStorage : Enum {
    public UInt32 value__;
    public static FieldStorage Instance;
    public static FieldStorage NonGCStatic;
    public static FieldStorage GCStatic;
    public static FieldStorage TLSStatic;
}
internal enum Internal.NativeFormat.FixupSignatureKind : Enum {
    public UInt32 value__;
    public static FixupSignatureKind Null;
    public static FixupSignatureKind TypeHandle;
    public static FixupSignatureKind InterfaceCall;
    public static FixupSignatureKind MethodDictionary;
    public static FixupSignatureKind StaticData;
    public static FixupSignatureKind UnwrapNullableType;
    public static FixupSignatureKind FieldLdToken;
    public static FixupSignatureKind MethodLdToken;
    public static FixupSignatureKind AllocateObject;
    public static FixupSignatureKind DefaultConstructor;
    public static FixupSignatureKind ThreadStaticIndex;
    public static FixupSignatureKind Method;
    public static FixupSignatureKind IsInst;
    public static FixupSignatureKind CastClass;
    public static FixupSignatureKind AllocateArray;
    public static FixupSignatureKind TypeSize;
    public static FixupSignatureKind FieldOffset;
    public static FixupSignatureKind CallingConventionConverter;
    public static FixupSignatureKind VTableOffset;
    public static FixupSignatureKind NonGenericConstrainedMethod;
    public static FixupSignatureKind GenericConstrainedMethod;
    public static FixupSignatureKind NonGenericDirectConstrainedMethod;
    public static FixupSignatureKind PointerToOtherSlot;
    public static FixupSignatureKind IntValue;
    public static FixupSignatureKind NonGenericStaticConstrainedMethod;
    public static FixupSignatureKind GenericStaticConstrainedMethod;
    public static FixupSignatureKind NotYetSupported;
}
internal enum Internal.NativeFormat.GenericContextKind : Enum {
    public UInt32 value__;
    public static GenericContextKind FromThis;
    public static GenericContextKind FromHiddenArg;
    public static GenericContextKind FromMethodHiddenArg;
    public static GenericContextKind HasDeclaringType;
    public static GenericContextKind NeedsUSGContext;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodCallingConvention : Enum {
    public UInt32 value__;
    public static MethodCallingConvention Generic;
    public static MethodCallingConvention Static;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodFlags : Enum {
    public UInt32 value__;
    public static MethodFlags HasInstantiation;
    public static MethodFlags IsUnboxingStub;
    public static MethodFlags HasFunctionPointer;
    public static MethodFlags FunctionPointerIsUSG;
}
internal class Internal.NativeFormat.NativeHashtable : ValueType {
    private NativeReader _reader;
    private UInt32 _baseOffset;
    private UInt32 _bucketMask;
    private byte _entryIndexSize;
    public bool IsNull { get; }
    public NativeHashtable(NativeParser parser);
    public bool get_IsNull();
    private NativeParser GetParserForBucket(UInt32 bucket, UInt32& endOffset);
    public Enumerator Lookup(int hashcode);
    public AllEntriesEnumerator EnumerateAllEntries();
}
internal class Internal.NativeFormat.NativeParser : ValueType {
    private NativeReader _reader;
    private UInt32 _offset;
    public bool IsNull { get; }
    public NativeReader Reader { get; }
    public UInt32 Offset { get; public set; }
    public NativeParser(NativeReader reader, UInt32 offset);
    public bool get_IsNull();
    public NativeReader get_Reader();
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public static void ThrowBadImageFormatException();
    public byte GetUInt8();
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public int GetSigned();
    public UInt32 GetRelativeOffset();
    public void SkipInteger();
    public NativeParser GetParserFromRelativeOffset();
    public UInt32 GetSequenceCount();
    public BagElementKind GetBagElementKind();
    public FixupSignatureKind GetFixupSignatureKind();
    public TypeSignatureKind GetTypeSignatureKind(UInt32& data);
    public NativeParser GetLookbackParser(UInt32 lookback);
    public Nullable`1<UInt32> GetUnsignedForBagElementKind(BagElementKind kindToFind);
    public NativeParser GetParserForBagElementKind(BagElementKind kindToFind);
    public string GetString();
    public void SkipString();
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static void ThrowBadImageFormatException();
    public static UInt32 DecodeUnsigned(Byte*& stream, Byte* streamEnd);
    public static int DecodeSigned(Byte*& stream, Byte* streamEnd);
    public static ulong DecodeUnsignedLong(Byte*& stream, Byte* streamEnd);
    public static long DecodeSignedLong(Byte*& stream, Byte* streamEnd);
    public static void SkipInteger(Byte*& stream);
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.NativeFormat.NativePrimitiveEncoder : ValueType {
    private Byte[] _buffer;
    private int _size;
    public int Size { get; }
    public void Init();
    public int get_Size();
    public void Clear();
    public void RollbackTo(int offset);
    public void WriteByte(byte b);
    public void WriteUInt8(byte value);
    public void WriteUInt16(ushort value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteFloat(float value);
    public void WriteDouble(double value);
    public void WriteUnsigned(UInt32 d);
    public static int GetUnsignedEncodingSize(UInt32 d);
    public void WriteSigned(int i);
    public void WriteUnsignedLong(ulong i);
    public void WriteSignedLong(long i);
    public void PatchByteAt(int offset, byte value);
    public void Save(Stream stream);
    public bool Save(Byte* stream, int streamLength);
    public Byte[] GetBytes();
}
internal class Internal.NativeFormat.NativeReader : object {
    private Byte* _base;
    private UInt32 _size;
    public UInt32 Size { get; }
    public NativeReader(Byte* base_, UInt32 size);
    public UInt32 get_Size();
    public UInt32 AddressToOffset(IntPtr address);
    public IntPtr OffsetToAddress(UInt32 offset);
    public static void ThrowBadImageFormatException();
    private UInt32 EnsureOffsetInRange(UInt32 offset, UInt32 lookAhead);
    public byte ReadUInt8(UInt32 offset);
    public ushort ReadUInt16(UInt32 offset);
    public UInt32 ReadUInt32(UInt32 offset);
    public ulong ReadUInt64(UInt32 offset);
    public float ReadFloat(UInt32 offset);
    public double ReadDouble(UInt32 offset);
    public UInt32 DecodeUnsigned(UInt32 offset, UInt32& value);
    public UInt32 DecodeSigned(UInt32 offset, Int32& value);
    public UInt32 DecodeUnsignedLong(UInt32 offset, UInt64& value);
    public UInt32 DecodeSignedLong(UInt32 offset, Int64& value);
    public UInt32 SkipInteger(UInt32 offset);
    public string ReadString(UInt32 offset);
    public UInt32 DecodeString(UInt32 offset, String& value);
    public UInt32 SkipString(UInt32 offset);
    public bool StringEquals(UInt32 offset, string value);
}
internal enum Internal.NativeFormat.StaticDataKind : Enum {
    public UInt32 value__;
    public static StaticDataKind Gc;
    public static StaticDataKind NonGc;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.TypeFlags : Enum {
    public UInt32 value__;
    public static TypeFlags HasClassConstructor;
    public static TypeFlags HasInstantiationDeterminedSize;
}
public static class Internal.NativeFormat.TypeHashingAlgorithms : object {
    private static int _rotl(int value, int shift);
    public static int ComputeNameHashCode(string src);
    public static int ComputeASCIINameHashCode(Byte* data, int length, Boolean& isAscii);
    private static string IntToString(int arg);
    public static int ComputeArrayTypeHashCode(int elementTypeHashCode, int rank);
    public static int ComputeArrayTypeHashCode(T elementType, int rank);
    public static int ComputePointerTypeHashCode(int pointeeTypeHashCode);
    public static int ComputePointerTypeHashCode(T pointeeType);
    public static int ComputeByrefTypeHashCode(int parameterTypeHashCode);
    public static int ComputeByrefTypeHashCode(T parameterType);
    public static int ComputeNestedTypeHashCode(int enclosingTypeHashCode, int nestedTypeNameHash);
    public static int ComputeGenericInstanceHashCode(int genericDefinitionHashCode, ARG[] genericTypeArguments);
    public static int ComputeMethodSignatureHashCode(int returnTypeHashCode, ARG[] parameters);
    public static int ComputeMethodHashCode(int typeHashCode, int nameOrNameAndGenericArgumentsHashCode);
    public static int ComputeSignatureVariableHashCode(int index, bool method);
}
internal enum Internal.NativeFormat.TypeModifierKind : Enum {
    public UInt32 value__;
    public static TypeModifierKind Array;
    public static TypeModifierKind ByRef;
    public static TypeModifierKind Pointer;
}
internal enum Internal.NativeFormat.TypeSignatureKind : Enum {
    public UInt32 value__;
    public static TypeSignatureKind Null;
    public static TypeSignatureKind Lookback;
    public static TypeSignatureKind Modifier;
    public static TypeSignatureKind Instantiation;
    public static TypeSignatureKind Variable;
    public static TypeSignatureKind BuiltIn;
    public static TypeSignatureKind External;
    public static TypeSignatureKind MultiDimArray;
    public static TypeSignatureKind FunctionPointer;
}
public class Internal.Reflection.Execution.AssemblyBinderImplementation : AssemblyBinder {
    [CompilerGeneratedAttribute]
private static AssemblyBinderImplementation <Instance>k__BackingField;
    private KeyValuePair`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopeGroups;
    public static AssemblyBinderImplementation Instance { get; }
    private KeyValuePair`2[] ScopeGroups { get; }
    private static AssemblyBinderImplementation();
    [CompilerGeneratedAttribute]
public static AssemblyBinderImplementation get_Instance();
    public sealed virtual bool Bind(string assemblyPath, AssemblyBindResult& bindResult, Exception& exception);
    public sealed virtual bool Bind(ReadOnlySpan`1<byte> rawAssembly, ReadOnlySpan`1<byte> rawSymbolStore, AssemblyBindResult& bindResult, Exception& exception);
    public sealed virtual bool Bind(RuntimeAssemblyName refName, bool cacheMissedLookups, AssemblyBindResult& result, Exception& exception);
    public sealed virtual IList`1<AssemblyBindResult> GetLoadedAssemblies();
    private static bool AssemblyNameMatches(RuntimeAssemblyName refName, RuntimeAssemblyName defName, Exception& preferredException);
    private static bool AssemblyVersionMatches(Version refVersion, Version defVersion);
    private void RegisterModule(ModuleInfo moduleInfo);
    private KeyValuePair`2[] get_ScopeGroups();
    private static void AddScopesFromReaderToGroups(LowLevelDictionaryWithIEnumerable`2<RuntimeAssemblyName, ScopeDefinitionGroup> groups, MetadataReader reader);
}
internal class Internal.Runtime.ArchitectureConstants : ValueType {
    public static int MAX_ARG_SIZE;
    public static int NUM_ARGUMENT_REGISTERS;
    public static int ARGUMENTREGISTERS_SIZE;
    public static int ENREGISTERED_RETURNTYPE_MAXSIZE;
    public static int ENREGISTERED_RETURNTYPE_INTEGER_MAXSIZE;
    public static int ENREGISTERED_RETURNTYPE_INTEGER_MAXSIZE_PRIMITIVE;
    public static int ENREGISTERED_PARAMTYPE_MAXSIZE;
    public static int STACK_ELEM_SIZE;
    public static int StackElemSize(int size);
}
internal class Internal.Runtime.ArgumentRegisters : ValueType {
    private IntPtr rdx;
    private IntPtr rcx;
    private IntPtr r8;
    private IntPtr r9;
}
internal static class Internal.Runtime.ArrayTypesConstants : object {
    public static int MaxSizeForValueClassInArray;
}
public class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
internal class Internal.Runtime.DispatchMap : ValueType {
    private ushort _standardEntryCount;
    private ushort _defaultEntryCount;
    private ushort _standardStaticEntryCount;
    private ushort _defaultStaticEntryCount;
    private DispatchMapEntry _dispatchMap;
    public UInt32 NumStandardEntries { get; public set; }
    public UInt32 NumDefaultEntries { get; public set; }
    public UInt32 NumStandardStaticEntries { get; public set; }
    public UInt32 NumDefaultStaticEntries { get; public set; }
    public int Size { get; }
    public UInt32 get_NumStandardEntries();
    public void set_NumStandardEntries(UInt32 value);
    public UInt32 get_NumDefaultEntries();
    public void set_NumDefaultEntries(UInt32 value);
    public UInt32 get_NumStandardStaticEntries();
    public void set_NumStandardStaticEntries(UInt32 value);
    public UInt32 get_NumDefaultStaticEntries();
    public void set_NumDefaultStaticEntries(UInt32 value);
    public int get_Size();
    public DispatchMapEntry* GetEntry(int index);
    public DispatchMapEntry* GetStaticEntry(int index);
}
internal class Internal.Runtime.DynamicInvokeMapEntry : ValueType {
    public static UInt32 IsImportMethodFlag;
    public static UInt32 InstantiationDetailIndexMask;
}
internal class Internal.Runtime.DynamicModule : ValueType {
    private int _cbSize;
    private method _dynamicTypeSlotDispatchResolve;
    private method _getRuntimeException;
    public static int DynamicModuleSize;
    public int CbSize { get; public set; }
    public method DynamicTypeSlotDispatchResolve { get; public set; }
    public method GetRuntimeException { get; public set; }
    private static DynamicModule();
    public int get_CbSize();
    public void set_CbSize(int value);
    public method get_DynamicTypeSlotDispatchResolve();
    public void set_DynamicTypeSlotDispatchResolve(method value);
    public method get_GetRuntimeException();
    public void set_GetRuntimeException(method value);
}
internal class Internal.Runtime.EEInterfaceInfo : ValueType {
    private InterfaceTypeUnion _interfaceType;
    internal MethodTable* InterfaceType { get; internal set; }
    internal MethodTable* get_InterfaceType();
    internal void set_InterfaceType(MethodTable* value);
}
internal static class Internal.Runtime.EETypeBuilderHelpers : object {
    private static UInt32 ValueTypePaddingLowMask;
    private static UInt32 ValueTypePaddingHighMask;
    private static UInt32 ValueTypePaddingMax;
    private static int ValueTypePaddingHighShift;
    private static UInt32 ValueTypePaddingAlignmentMask;
    private static int ValueTypePaddingAlignmentShift;
    private static EETypeElementType ComputeEETypeElementType(TypeDesc type);
    public static ushort ComputeFlags(TypeDesc type);
    internal static UInt32 ComputeValueTypeFieldPaddingFieldValue(UInt32 padding, UInt32 alignment, int targetPointerSize);
}
internal enum Internal.Runtime.EETypeElementType : Enum {
    public int value__;
    public static EETypeElementType Unknown;
    public static EETypeElementType Void;
    public static EETypeElementType Boolean;
    public static EETypeElementType Char;
    public static EETypeElementType SByte;
    public static EETypeElementType Byte;
    public static EETypeElementType Int16;
    public static EETypeElementType UInt16;
    public static EETypeElementType Int32;
    public static EETypeElementType UInt32;
    public static EETypeElementType Int64;
    public static EETypeElementType UInt64;
    public static EETypeElementType IntPtr;
    public static EETypeElementType UIntPtr;
    public static EETypeElementType Single;
    public static EETypeElementType Double;
    public static EETypeElementType ValueType;
    public static EETypeElementType Nullable;
    public static EETypeElementType Class;
    public static EETypeElementType Interface;
    public static EETypeElementType SystemArray;
    public static EETypeElementType Array;
    public static EETypeElementType SzArray;
    public static EETypeElementType ByRef;
    public static EETypeElementType Pointer;
}
internal enum Internal.Runtime.EETypeField : Enum {
    public int value__;
    public static EETypeField ETF_InterfaceMap;
    public static EETypeField ETF_TypeManagerIndirection;
    public static EETypeField ETF_WritableData;
    public static EETypeField ETF_Finalizer;
    public static EETypeField ETF_OptionalFieldsPtr;
    public static EETypeField ETF_SealedVirtualSlots;
    public static EETypeField ETF_DynamicTemplateType;
    public static EETypeField ETF_DynamicDispatchMap;
    public static EETypeField ETF_DynamicModule;
    public static EETypeField ETF_GenericDefinition;
    public static EETypeField ETF_GenericComposition;
    public static EETypeField ETF_DynamicGcStatics;
    public static EETypeField ETF_DynamicNonGcStatics;
    public static EETypeField ETF_DynamicThreadStaticOffset;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeFlags : Enum {
    public ushort value__;
    public static EETypeFlags EETypeKindMask;
    public static EETypeFlags RelatedTypeViaIATFlag;
    public static EETypeFlags IsDynamicTypeFlag;
    public static EETypeFlags HasFinalizerFlag;
    public static EETypeFlags HasPointersFlag;
    public static EETypeFlags IDynamicInterfaceCastableFlag;
    public static EETypeFlags GenericVarianceFlag;
    public static EETypeFlags OptionalFieldsFlag;
    public static EETypeFlags IsGenericFlag;
    public static EETypeFlags ElementTypeMask;
    public static EETypeFlags ElementTypeShift;
    public static EETypeFlags ComplexCastingMask;
}
internal enum Internal.Runtime.EETypeKind : Enum {
    public ushort value__;
    public static EETypeKind CanonicalEEType;
    public static EETypeKind ClonedEEType;
    public static EETypeKind ParameterizedEEType;
    public static EETypeKind GenericTypeDefEEType;
}
internal enum Internal.Runtime.EETypeOptionalFieldTag : Enum {
    public byte value__;
    public static EETypeOptionalFieldTag RareFlags;
    public static EETypeOptionalFieldTag DispatchMap;
    public static EETypeOptionalFieldTag ValueTypeFieldPadding;
    public static EETypeOptionalFieldTag NullableValueOffset;
    public static EETypeOptionalFieldTag Count;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeRareFlags : Enum {
    public int value__;
    public static EETypeRareFlags RequiresAlign8Flag;
    public static EETypeRareFlags HasCctorFlag;
    public static EETypeRareFlags HasDynamicallyAllocatedDispatchMapFlag;
    public static EETypeRareFlags IsHFAFlag;
    public static EETypeRareFlags HasSealedVTableEntriesFlag;
    public static EETypeRareFlags IsDynamicTypeWithGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithNonGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithThreadStatics;
    public static EETypeRareFlags HasDynamicModuleFlag;
    public static EETypeRareFlags IsAbstractClassFlag;
    public static EETypeRareFlags IsByRefLikeFlag;
}
internal class Internal.Runtime.EETypeRef : ValueType {
    private Byte* _value;
    public MethodTable* Value { get; public set; }
    public MethodTable* get_Value();
    public void set_Value(MethodTable* value);
}
[FlagsAttribute]
public enum Internal.Runtime.FieldTableFlags : Enum {
    public UInt32 value__;
    public static FieldTableFlags Instance;
    public static FieldTableFlags NonGCStatic;
    public static FieldTableFlags GCStatic;
    public static FieldTableFlags ThreadStatic;
    public static FieldTableFlags StorageClass;
    public static FieldTableFlags IsUniversalCanonicalEntry;
    public static FieldTableFlags HasMetadataHandle;
    public static FieldTableFlags FieldOffsetEncodedDirectly;
    public static FieldTableFlags IsAnyCanonicalEntry;
    public static FieldTableFlags IsInitOnly;
}
internal class Internal.Runtime.FloatArgumentRegisters : ValueType {
    private M128A d0;
    private M128A d1;
    private M128A d2;
    private M128A d3;
}
internal enum Internal.Runtime.GC_ALLOC_FLAGS : Enum {
    public int value__;
    public static GC_ALLOC_FLAGS GC_ALLOC_NO_FLAGS;
    public static GC_ALLOC_FLAGS GC_ALLOC_ZEROING_OPTIONAL;
    public static GC_ALLOC_FLAGS GC_ALLOC_PINNED_OBJECT_HEAP;
}
internal static class Internal.Runtime.GCStaticRegionConstants : object {
    public static int Uninitialized;
    public static int HasPreInitializedData;
    public static int Mask;
}
internal enum Internal.Runtime.GenericVariance : Enum {
    public byte value__;
    public static GenericVariance NonVariant;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
    public static GenericVariance ArrayCovariant;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwarePointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwareRelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal static class Internal.Runtime.IndirectionConstants : object {
    public static int IndirectionCellPointer;
    public static UInt32 RVAPointsToIndirection;
}
[FlagsAttribute]
public enum Internal.Runtime.InvokeTableFlags : Enum {
    public UInt32 value__;
    public static InvokeTableFlags HasVirtualInvoke;
    public static InvokeTableFlags IsGenericMethod;
    public static InvokeTableFlags HasMetadataHandle;
    public static InvokeTableFlags IsDefaultConstructor;
    public static InvokeTableFlags RequiresInstArg;
    public static InvokeTableFlags HasEntrypoint;
    public static InvokeTableFlags IsUniversalCanonicalEntry;
    public static InvokeTableFlags NeedsParameterInterpretation;
    public static InvokeTableFlags CallingConventionDefault;
    public static InvokeTableFlags Cdecl;
    public static InvokeTableFlags Winapi;
    public static InvokeTableFlags StdCall;
    public static InvokeTableFlags ThisCall;
    public static InvokeTableFlags FastCall;
    public static InvokeTableFlags CallingConventionMask;
}
internal class Internal.Runtime.M128A : ValueType {
    private IntPtr a;
    private IntPtr b;
}
internal class Internal.Runtime.MethodTable : ValueType {
    private static int POINTER_SIZE;
    private static int PADDING;
    internal static int SZARRAY_BASE_SIZE;
    private ushort _usComponentSize;
    private ushort _usFlags;
    private UInt32 _uBaseSize;
    private RelatedTypeUnion _relatedType;
    private ushort _usNumVtableSlots;
    private ushort _usNumInterfaces;
    private UInt32 _uHashCode;
    private static UInt32 ValueTypePaddingLowMask;
    private static UInt32 ValueTypePaddingHighMask;
    private static UInt32 ValueTypePaddingMax;
    private static int ValueTypePaddingHighShift;
    private static UInt32 ValueTypePaddingAlignmentMask;
    private static int ValueTypePaddingAlignmentShift;
    internal static bool SupportsRelativePointers { get; }
    internal static bool SupportsWritableData { get; }
    internal ushort ComponentSize { get; internal set; }
    internal ushort GenericArgumentCount { get; internal set; }
    internal ushort Flags { get; internal set; }
    internal UInt32 BaseSize { get; internal set; }
    internal ushort NumVtableSlots { get; internal set; }
    internal ushort NumInterfaces { get; internal set; }
    internal UInt32 HashCode { get; internal set; }
    private EETypeKind Kind { get; }
    internal bool HasOptionalFields { get; }
    internal bool HasGenericVariance { get; }
    internal bool IsFinalizable { get; }
    internal bool IsNullable { get; }
    internal bool IsCloned { get; }
    internal bool IsCanonical { get; }
    internal bool IsString { get; }
    internal bool IsArray { get; }
    internal int ArrayRank { get; }
    internal bool IsSzArray { get; }
    internal bool IsGeneric { get; }
    internal bool IsGenericTypeDefinition { get; }
    internal MethodTable* GenericDefinition { get; internal set; }
    internal UInt32 GenericArity { get; internal set; }
    internal EETypeRef* GenericArguments { get; }
    internal GenericVariance* GenericVariance { get; }
    internal bool IsPointerType { get; }
    internal bool IsByRefType { get; }
    internal bool IsInterface { get; }
    internal bool IsAbstract { get; }
    internal bool IsByRefLike { get; }
    internal bool IsDynamicType { get; }
    internal bool HasDynamicallyAllocatedDispatchMap { get; }
    internal bool IsParameterizedType { get; }
    internal UInt32 ParameterizedTypeShape { get; internal set; }
    internal bool IsRelatedTypeViaIAT { get; }
    internal bool RequiresAlign8 { get; }
    internal bool IsIDynamicInterfaceCastable { get; }
    internal bool IsValueType { get; }
    internal bool IsPrimitive { get; }
    internal bool HasGCPointers { get; internal set; }
    internal bool IsHFA { get; }
    internal UInt32 ValueTypeFieldPadding { get; }
    internal UInt32 ValueTypeSize { get; }
    internal UInt32 FieldByteCountNonGCAligned { get; }
    internal EEInterfaceInfo* InterfaceMap { get; }
    internal bool HasDispatchMap { get; }
    internal DispatchMap* DispatchMap { get; }
    internal IntPtr FinalizerCode { get; internal set; }
    internal MethodTable* BaseType { get; internal set; }
    internal MethodTable* NonArrayBaseType { get; }
    internal MethodTable* NonClonedNonArrayBaseType { get; }
    internal MethodTable* RawBaseType { get; }
    internal MethodTable* CanonicalEEType { get; }
    internal MethodTable* NullableType { get; }
    internal byte NullableValueOffset { get; }
    internal MethodTable* RelatedParameterType { get; internal set; }
    internal Byte* OptionalFieldsPtr { get; internal set; }
    internal MethodTable* DynamicTemplateType { get; internal set; }
    internal IntPtr DynamicGcStaticsData { get; internal set; }
    internal IntPtr DynamicNonGcStaticsData { get; internal set; }
    internal IntPtr DynamicThreadStaticsIndex { get; internal set; }
    internal DynamicModule* DynamicModule { get; internal set; }
    internal TypeManagerHandle TypeManager { get; }
    internal IntPtr PointerToTypeManager { get; internal set; }
    internal IntPtr WritableData { get; internal set; }
    internal EETypeRareFlags RareFlags { get; }
    internal int FieldAlignmentRequirement { get; }
    internal EETypeElementType ElementType { get; }
    public bool HasCctor { get; }
    [IntrinsicAttribute]
internal static bool get_SupportsRelativePointers();
    internal static bool get_SupportsWritableData();
    [IntrinsicAttribute]
internal static MethodTable* Of();
    internal ushort get_ComponentSize();
    internal void set_ComponentSize(ushort value);
    internal ushort get_GenericArgumentCount();
    internal void set_GenericArgumentCount(ushort value);
    internal ushort get_Flags();
    internal void set_Flags(ushort value);
    internal UInt32 get_BaseSize();
    internal void set_BaseSize(UInt32 value);
    internal ushort get_NumVtableSlots();
    internal void set_NumVtableSlots(ushort value);
    internal ushort get_NumInterfaces();
    internal void set_NumInterfaces(ushort value);
    internal UInt32 get_HashCode();
    internal void set_HashCode(UInt32 value);
    private EETypeKind get_Kind();
    internal bool get_HasOptionalFields();
    internal bool get_HasGenericVariance();
    internal bool get_IsFinalizable();
    internal bool get_IsNullable();
    internal bool get_IsCloned();
    internal bool get_IsCanonical();
    internal bool get_IsString();
    internal bool get_IsArray();
    internal int get_ArrayRank();
    internal bool get_IsSzArray();
    internal bool get_IsGeneric();
    internal bool get_IsGenericTypeDefinition();
    internal MethodTable* get_GenericDefinition();
    internal void set_GenericDefinition(MethodTable* value);
    internal static int GetGenericCompositionSize(int numArguments, bool hasVariance);
    internal void SetGenericComposition(IntPtr data);
    internal UInt32 get_GenericArity();
    internal void set_GenericArity(UInt32 value);
    internal EETypeRef* get_GenericArguments();
    internal GenericVariance* get_GenericVariance();
    internal bool get_IsPointerType();
    internal bool get_IsByRefType();
    internal bool get_IsInterface();
    internal bool get_IsAbstract();
    internal bool get_IsByRefLike();
    internal bool get_IsDynamicType();
    internal bool get_HasDynamicallyAllocatedDispatchMap();
    internal bool get_IsParameterizedType();
    internal UInt32 get_ParameterizedTypeShape();
    internal void set_ParameterizedTypeShape(UInt32 value);
    internal bool get_IsRelatedTypeViaIAT();
    internal bool get_RequiresAlign8();
    internal bool get_IsIDynamicInterfaceCastable();
    internal bool get_IsValueType();
    internal bool get_IsPrimitive();
    internal bool get_HasGCPointers();
    internal void set_HasGCPointers(bool value);
    internal bool get_IsHFA();
    internal UInt32 get_ValueTypeFieldPadding();
    internal UInt32 get_ValueTypeSize();
    internal UInt32 get_FieldByteCountNonGCAligned();
    internal EEInterfaceInfo* get_InterfaceMap();
    internal bool get_HasDispatchMap();
    internal DispatchMap* get_DispatchMap();
    internal IntPtr get_FinalizerCode();
    internal void set_FinalizerCode(IntPtr value);
    internal MethodTable* get_BaseType();
    internal void set_BaseType(MethodTable* value);
    internal MethodTable* get_NonArrayBaseType();
    internal MethodTable* get_NonClonedNonArrayBaseType();
    internal MethodTable* get_RawBaseType();
    internal MethodTable* get_CanonicalEEType();
    internal MethodTable* get_NullableType();
    internal byte get_NullableValueOffset();
    internal MethodTable* get_RelatedParameterType();
    internal void set_RelatedParameterType(MethodTable* value);
    internal IntPtr* GetVTableStartAddress();
    private static IntPtr FollowRelativePointer(Int32* pDist);
    internal IntPtr GetSealedVirtualSlot(ushort slotNumber);
    internal void SetSealedVirtualSlot(IntPtr value, ushort slotNumber);
    internal Byte* get_OptionalFieldsPtr();
    internal void set_OptionalFieldsPtr(Byte* value);
    internal MethodTable* get_DynamicTemplateType();
    internal void set_DynamicTemplateType(MethodTable* value);
    internal IntPtr get_DynamicGcStaticsData();
    internal void set_DynamicGcStaticsData(IntPtr value);
    internal IntPtr get_DynamicNonGcStaticsData();
    internal void set_DynamicNonGcStaticsData(IntPtr value);
    internal IntPtr get_DynamicThreadStaticsIndex();
    internal void set_DynamicThreadStaticsIndex(IntPtr value);
    internal DynamicModule* get_DynamicModule();
    internal void set_DynamicModule(DynamicModule* value);
    internal TypeManagerHandle get_TypeManager();
    internal IntPtr get_PointerToTypeManager();
    internal void set_PointerToTypeManager(IntPtr value);
    internal IntPtr get_WritableData();
    internal void set_WritableData(IntPtr value);
    internal EETypeRareFlags get_RareFlags();
    internal int get_FieldAlignmentRequirement();
    internal EETypeElementType get_ElementType();
    public bool get_HasCctor();
    public UInt32 GetFieldOffset(EETypeField eField);
    public T& GetField(EETypeField eField);
    public T& GetField(UInt32 offset);
    internal static UInt32 GetSizeofEEType(ushort cVirtuals, ushort cInterfaces, bool fHasFinalizer, bool fRequiresOptionalFields, bool fHasSealedVirtuals, bool fHasGenericInfo, bool fHasNonGcStatics, bool fHasGcStatics, bool fHasThreadStatics);
    private static MethodTable* GetArrayEEType();
    internal RuntimeTypeHandle ToRuntimeTypeHandle();
}
internal class Internal.Runtime.ObjHeader : ValueType {
    private IntPtr _objHeaderContents;
}
internal static class Internal.Runtime.ParameterizedTypeShapeConstants : object {
    public static int Pointer;
    public static int ByRef;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.Pointer : ValueType {
    private IntPtr _value;
    public IntPtr Value { get; }
    public IntPtr get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.Pointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
internal enum Internal.Runtime.ReflectionMapBlob : Enum {
    public int value__;
    public static ReflectionMapBlob TypeMap;
    public static ReflectionMapBlob ArrayMap;
    public static ReflectionMapBlob BlockReflectionTypeMap;
    public static ReflectionMapBlob InvokeMap;
    public static ReflectionMapBlob VirtualInvokeMap;
    public static ReflectionMapBlob CommonFixupsTable;
    public static ReflectionMapBlob FieldAccessMap;
    public static ReflectionMapBlob CCtorContextMap;
    public static ReflectionMapBlob EmbeddedMetadata;
    public static ReflectionMapBlob DefaultConstructorMap;
    public static ReflectionMapBlob UnboxingAndInstantiatingStubMap;
    public static ReflectionMapBlob StructMarshallingStubMap;
    public static ReflectionMapBlob DelegateMarshallingStubMap;
    public static ReflectionMapBlob GenericVirtualMethodTable;
    public static ReflectionMapBlob InterfaceGenericVirtualMethodTable;
    public static ReflectionMapBlob TypeTemplateMap;
    public static ReflectionMapBlob GenericMethodsTemplateMap;
    public static ReflectionMapBlob BlobIdResourceIndex;
    public static ReflectionMapBlob BlobIdResourceData;
    public static ReflectionMapBlob BlobIdStackTraceEmbeddedMetadata;
    public static ReflectionMapBlob BlobIdStackTraceMethodRvaToTokenMapping;
    public static ReflectionMapBlob NativeLayoutInfo;
    public static ReflectionMapBlob NativeReferences;
    public static ReflectionMapBlob GenericsHashtable;
    public static ReflectionMapBlob NativeStatics;
    public static ReflectionMapBlob StaticsInfoHashtable;
    public static ReflectionMapBlob GenericMethodsHashtable;
    public static ReflectionMapBlob ExactMethodInstantiationsHashtable;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.RelativePointer : ValueType {
    private int _value;
    public IntPtr Value { get; }
    public IntPtr get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.RelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal class Internal.Runtime.ReturnBlock : ValueType {
    private IntPtr returnValue;
}
internal enum Internal.Runtime.RuntimeHelperKind : Enum {
    public int value__;
    public static RuntimeHelperKind AllocateObject;
    public static RuntimeHelperKind IsInst;
    public static RuntimeHelperKind CastClass;
    public static RuntimeHelperKind AllocateArray;
}
internal static class Internal.Runtime.SpecialDispatchMapSlot : object {
    public static ushort Diamond;
    public static ushort Reabstraction;
}
internal static class Internal.Runtime.SpecialGVMInterfaceEntry : object {
    public static UInt32 Diamond;
    public static UInt32 Reabstraction;
}
internal static class Internal.Runtime.StaticVirtualMethodContextSource : object {
    public static ushort None;
    public static ushort ContextFromThisClass;
    public static ushort ContextFromFirstInterface;
}
internal static class Internal.Runtime.StringComponentSize : object {
    public static int Value;
}
internal class Internal.Runtime.TransitionBlock : ValueType {
    private IntPtr m_returnBlockPadding;
    private ReturnBlock m_returnBlock;
    private IntPtr m_alignmentPadding;
    private IntPtr m_ReturnAddress;
    public static int InvalidOffset;
    public static int GetOffsetOfReturnValuesBlock();
    public static int GetOffsetOfArgumentRegisters();
    public static byte GetOffsetOfArgs();
    public static bool IsStackArgumentOffset(int offset);
    public static bool IsArgumentRegisterOffset(int offset);
    public static int GetArgumentIndexFromOffset(int offset);
    public static int GetStackArgumentIndexFromOffset(int offset);
    public static bool IsFloatArgumentRegisterOffset(int offset);
    public static int GetOffsetOfFloatArgumentRegisters();
    public static int GetNegSpaceSize();
    public static int GetThisOffset();
}
internal class Internal.Runtime.TypeLoader.Callbacks : TypeLoaderCallbacks {
    public virtual TypeManagerHandle GetModuleForMetadataReader(MetadataReader reader);
    public virtual bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public virtual IntPtr GetThreadStaticGCDescForDynamicType(TypeManagerHandle typeManagerHandle, int index);
    public virtual IntPtr GenericLookupFromContextAndSignature(IntPtr context, IntPtr signature, IntPtr& auxResult);
    public virtual bool GetRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    public virtual RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public virtual bool CompareMethodSignatures(RuntimeSignature signature1, RuntimeSignature signature2);
    public virtual IntPtr TryGetDefaultConstructorForType(RuntimeTypeHandle runtimeTypeHandle);
    public virtual bool TryGetGenericVirtualTargetForTypeAndSlot(RuntimeTypeHandle targetHandle, RuntimeTypeHandle& declaringType, RuntimeTypeHandle[] genericArguments, String& methodName, RuntimeSignature& methodSignature, bool lookForDefaultImplementation, IntPtr& methodPointer, IntPtr& dictionaryPointer, Boolean& slotUpdated);
    public virtual bool GetRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    public virtual RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string fieldName);
    public virtual IntPtr ConvertUnboxingFunctionPointerToUnderlyingNonUnboxingPointer(IntPtr unboxingFunctionPointer, RuntimeTypeHandle declaringType);
    public virtual bool TryGetPointerTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public virtual bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public virtual IntPtr UpdateFloatingDictionary(IntPtr context, IntPtr dictionaryPtr);
    public virtual void RegisterThunk(IntPtr thunkAddress);
}
public class Internal.Runtime.TypeLoader.CanonicallyEquivalentEntryLocator : ValueType {
    private RuntimeTypeHandle _typeToFind;
    private RuntimeTypeHandle _genericDefinition;
    private RuntimeTypeHandle[] _genericArgs;
    private DefType _defType;
    private CanonicalFormKind _canonKind;
    public int LookupHashCode { get; }
    public CanonicallyEquivalentEntryLocator(RuntimeTypeHandle typeToFind, CanonicalFormKind kind);
    internal CanonicallyEquivalentEntryLocator(DefType typeToFind, CanonicalFormKind kind);
    public int get_LookupHashCode();
    public bool IsCanonicallyEquivalent(RuntimeTypeHandle other);
    public bool ConversionToCanonFormIsAChange();
}
internal static class Internal.Runtime.TypeLoader.EETypeCreator : object {
    private static IntPtr s_emptyGCDesc;
    private static void CreateEETypeWorker(MethodTable* pTemplateEEType, UInt32 hashCodeOfNewType, int arity, bool requireVtableSlotMapping, TypeBuilderState state);
    private static IntPtr CreateStaticGCDesc(LowLevelList`1<bool> gcBitfield, Boolean& allocated, Int32& cbGCDesc);
    private static void CreateInstanceGCDesc(TypeBuilderState state, MethodTable* pTemplateEEType, MethodTable* pEEType, int baseSize, int cbGCDesc, bool isValueType, bool isArray, bool isSzArray, int arrayRank);
    private static int GetInstanceGCDescSize(TypeBuilderState state, MethodTable* pTemplateEEType, bool isValueType, bool isArray);
    private static int CreateArrayGCDesc(LowLevelList`1<bool> bitfield, int rank, bool isSzArray, Void* gcdesc);
    private static int CreateGCDesc(LowLevelList`1<bool> bitfield, int size, bool isValueType, bool isStatic, Void* gcdesc);
    [ConditionalAttribute("GENERICS_FORCE_USG")]
private static void TestGCDescsForEquality(IntPtr dynamicGCDesc, IntPtr templateGCDesc, int cbGCDesc, bool isInstanceGCDesc);
    public static RuntimeTypeHandle CreatePointerEEType(UInt32 hashCodeOfNewType, RuntimeTypeHandle pointeeTypeHandle, TypeDesc pointerType);
    public static RuntimeTypeHandle CreateByRefEEType(UInt32 hashCodeOfNewType, RuntimeTypeHandle pointeeTypeHandle, TypeDesc byRefType);
    public static RuntimeTypeHandle CreateEEType(TypeDesc type, TypeBuilderState state);
    public static int GetDictionaryOffsetInEEtype(MethodTable* pEEType);
    public static IntPtr GetDictionaryAtOffset(MethodTable* pEEType, int offset);
    public static IntPtr GetDictionary(MethodTable* pEEType);
    public static int GetDictionarySlotInVTable(TypeDesc type);
    private static int GetMostDerivedDictionarySlot(TypeDesc& nextTypeToExamineForDictionarySlot, TypeDesc& typeWithDictionary);
    public static MethodTable* GetBaseEETypeForDictionaryPtr(MethodTable* pEEType, IntPtr dictionaryPtr);
}
public class Internal.Runtime.TypeLoader.ExternalReferencesTable : ValueType {
    private IntPtr _elements;
    private UInt32 _elementsCount;
    private bool Initialize(TypeManagerHandle typeManager, ReflectionMapBlob blobId);
    public bool IsInitialized();
    public bool InitializeCommonFixupsTable(TypeManagerHandle module);
    public IntPtr GetIntPtrFromIndex(UInt32 index);
    public IntPtr GetFunctionPointerFromIndex(UInt32 index);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromIndex(UInt32 index);
    public IntPtr GetGenericDictionaryFromIndex(UInt32 index);
    public IntPtr GetAddressFromIndex(UInt32 index);
    private bool Initialize(NativeFormatModuleInfo module, ReflectionMapBlob blobId);
    public bool InitializeNativeReferences(NativeFormatModuleInfo module);
    public bool InitializeNativeStatics(NativeFormatModuleInfo module);
    public bool InitializeCommonFixupsTable(NativeFormatModuleInfo module);
    public UInt32 GetRvaFromIndex(UInt32 index);
}
public class Internal.Runtime.TypeLoader.FieldAccessMetadata : ValueType {
    public TypeManagerHandle MappingTableModule;
    public IntPtr Cookie;
    public FieldTableFlags Flags;
    public int Offset;
}
[FlagsAttribute]
internal enum Internal.Runtime.TypeLoader.FieldLoadState : Enum {
    public int value__;
    public static FieldLoadState None;
    public static FieldLoadState Instance;
    public static FieldLoadState Statics;
}
internal abstract class Internal.Runtime.TypeLoader.GenericDictionary : object {
    protected GenericDictionaryCell[] _cells;
    protected IntPtr _addressOfFirstCellSlot;
    public GenericDictionary(GenericDictionaryCell[] cells);
    public abstract virtual IntPtr Allocate();
    public void Finish(TypeBuilder typeBuilder);
}
public abstract class Internal.Runtime.TypeLoader.GenericDictionaryCell : object {
    internal abstract virtual void Prepare(TypeBuilder builder);
    internal abstract virtual IntPtr Create(TypeBuilder builder);
    internal virtual void WriteCellIntoDictionary(TypeBuilder typeBuilder, IntPtr* pDictionary, int slotIndex);
    internal virtual IntPtr CreateLazyLookupCell(TypeBuilder builder, IntPtr& auxResult);
    private static RuntimeTypeHandle GetRuntimeTypeHandleWithNullableTransform(TypeBuilder builder, TypeDesc type);
    public static GenericDictionaryCell CreateTypeHandleCell(TypeDesc type);
    public static GenericDictionaryCell CreateIntPtrCell(IntPtr ptrValue);
    internal static GenericDictionaryCell[] BuildDictionary(TypeBuilder typeBuilder, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser parser);
    internal static GenericDictionaryCell[] BuildFloatingDictionary(TypeBuilder typeBuilder, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser parser, Int32& floatingVersionCellIndex, Int32& floatingVersionInLayout);
    private static TypeDesc TransformNullable(TypeDesc type);
    internal static GenericDictionaryCell CreateMethodCell(MethodDesc method, bool exactCallableAddressNeeded);
    internal static GenericDictionaryCell ParseAndCreateCell(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser& parser);
}
internal class Internal.Runtime.TypeLoader.GenericMethodDictionary : GenericDictionary {
    public GenericMethodDictionary(GenericDictionaryCell[] cells);
    public virtual IntPtr Allocate();
}
internal class Internal.Runtime.TypeLoader.GenericTypeDictionary : GenericDictionary {
    public GenericTypeDictionary(GenericDictionaryCell[] cells);
    public virtual IntPtr Allocate();
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.LowLevelListExtensions : object {
    [ExtensionAttribute]
public static void Expand(LowLevelList`1<T> list, int count);
    [ExtensionAttribute]
public static bool HasSetBits(LowLevelList`1<bool> list);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.LowLevelStringConverter : object {
    private static string HexDigits;
    private static string LowLevelToString(ulong arg, int shift);
    [ExtensionAttribute]
public static string LowLevelToString(LayoutInt arg);
    [ExtensionAttribute]
public static string LowLevelToString(byte arg);
    [ExtensionAttribute]
public static string LowLevelToString(ushort arg);
    [ExtensionAttribute]
public static string LowLevelToString(int arg);
    [ExtensionAttribute]
public static string LowLevelToString(UInt32 arg);
    [ExtensionAttribute]
public static string LowLevelToString(ulong arg);
    [ExtensionAttribute]
public static string LowLevelToString(IntPtr arg);
    [ExtensionAttribute]
public static string LowLevelToString(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static string LowLevelToStringRawEETypeAddress(RuntimeTypeHandle rtth);
}
internal static class Internal.Runtime.TypeLoader.MemoryHelpers : object {
    public static int AlignUp(int val, int alignment);
    public static void Memset(IntPtr destination, int length, byte value);
    public static IntPtr AllocateMemory(int cbBytes);
    public static void FreeMemory(IntPtr memoryPtrToFree);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.MetadataNameExtensions : object {
    [ExtensionAttribute]
public static string GetFullName(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ByReferenceSignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(PointerSignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ArraySignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(SZArraySignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(TypeSpecificationHandle typeSpecHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(TypeInstantiationSignatureHandle typeInstSigHandle, MetadataReader reader);
    [ExtensionAttribute]
public static void GetFullName(TypeDefinitionHandle typeDefHandle, MetadataReader reader, String& name, String& enclosing, String& nspace);
    [ExtensionAttribute]
public static string GetFullName(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetContainingModuleName(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(NamespaceDefinitionHandle namespaceHandle, MetadataReader reader);
    [ExtensionAttribute]
public static void GetFullName(TypeReferenceHandle typeRefHandle, MetadataReader reader, String& name, String& enclosing, String& nspace);
    [ExtensionAttribute]
public static string GetFullName(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetContainingModuleName(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(NamespaceReferenceHandle namespaceHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ScopeDefinitionHandle scopeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ScopeReferenceHandle scopeRefHandle, MetadataReader reader);
}
public class Internal.Runtime.TypeLoader.MetadataReaderEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal MetadataReaderEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public MetadataReaderEnumerator GetEnumerator();
}
public class Internal.Runtime.TypeLoader.MetadataReaderEnumerator : ValueType {
    private NativeFormatModuleInfoEnumerator _moduleInfoEnumerator;
    public MetadataReader Current { get; }
    internal MetadataReaderEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public MetadataReader get_Current();
}
public static class Internal.Runtime.TypeLoader.MetadataReaderHelpers : object {
    public static bool CompareTypeReferenceAcrossModules(TypeReferenceHandle tr1, MetadataReader mr1, TypeReferenceHandle tr2, MetadataReader mr2);
    public static bool CompareNamespaceReferenceAcrossModules(NamespaceReferenceHandle nr1, MetadataReader mr1, NamespaceReferenceHandle nr2, MetadataReader mr2);
    public static bool CompareScopeReferenceAcrossModules(ScopeReferenceHandle sr1, MetadataReader mr1, ScopeReferenceHandle sr2, MetadataReader mr2);
    public static bool CompareTypeReferenceToDefinition(TypeReferenceHandle tr1, MetadataReader mr1, TypeDefinitionHandle td2, MetadataReader mr2);
    public static bool CompareNamespaceReferenceToDefinition(NamespaceReferenceHandle nr1, MetadataReader mr1, NamespaceDefinitionHandle nd2, MetadataReader mr2);
    public static bool CompareScopeReferenceToDefinition(ScopeReferenceHandle sr1, MetadataReader mr1, ScopeDefinitionHandle sd2, MetadataReader mr2);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.MethodDescExtensions : object {
    [ExtensionAttribute]
public static bool CanShareNormalGenericCode(InstantiatedMethod method);
}
public class Internal.Runtime.TypeLoader.MethodInvokeMetadata : ValueType {
    public NativeFormatModuleInfo MappingTableModule;
    public IntPtr MethodEntryPoint;
    public IntPtr RawMethodEntryPoint;
    public IntPtr DictionaryComponent;
    public UInt32 DynamicInvokeCookie;
    public InvokeTableFlags InvokeTableFlags;
}
public class Internal.Runtime.TypeLoader.MethodSignatureComparer : ValueType {
    private MetadataReader _metadataReader;
    private MethodHandle _methodHandle;
    private Method _method;
    private MethodSignature _methodSignature;
    private bool _isStatic;
    private bool _isGeneric;
    public MethodSignatureComparer(QMethodDefinition methodHandle);
    public MethodSignatureComparer(MetadataReader metadataReader, MethodHandle methodHandle);
    public bool IsMatchingNativeLayoutMethodNameAndSignature(string name, RuntimeSignature signature);
    public bool IsMatchingNativeLayoutMethodSignature(RuntimeSignature signature);
    internal static NativeParser GetNativeParserForSignature(RuntimeSignature signature);
    private bool CompareTypeSigWithType(NativeParser& parser, TypeManagerHandle moduleHandle, Handle typeHandle);
    private bool CompareCallingConventions(MethodCallingConvention callingConvention);
    private static bool CanGetTypeHandle(Type type);
}
public class Internal.Runtime.TypeLoader.ModuleHandleEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal ModuleHandleEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public ModuleHandleEnumerator GetEnumerator();
}
public class Internal.Runtime.TypeLoader.ModuleHandleEnumerator : ValueType {
    private ModuleInfoEnumerator _moduleInfoEnumerator;
    public TypeManagerHandle Current { get; }
    internal ModuleHandleEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public TypeManagerHandle get_Current();
}
public class Internal.Runtime.TypeLoader.ModuleInfo : object {
    [CompilerGeneratedAttribute]
private TypeManagerHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicModule* <DynamicModulePtr>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleType <ModuleType>k__BackingField;
    public TypeManagerHandle Handle { get; private set; }
    internal DynamicModule* DynamicModulePtr { get; private set; }
    public IntPtr DynamicModulePtrAsIntPtr { get; }
    internal ModuleType ModuleType { get; private set; }
    internal ModuleInfo(TypeManagerHandle moduleHandle, ModuleType moduleType);
    [CompilerGeneratedAttribute]
public TypeManagerHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(TypeManagerHandle value);
    [CompilerGeneratedAttribute]
internal DynamicModule* get_DynamicModulePtr();
    [CompilerGeneratedAttribute]
private void set_DynamicModulePtr(DynamicModule* value);
    public IntPtr get_DynamicModulePtrAsIntPtr();
    [CompilerGeneratedAttribute]
internal ModuleType get_ModuleType();
    [CompilerGeneratedAttribute]
private void set_ModuleType(ModuleType value);
    internal static IntPtr ResolveTypeSlotDispatch(MethodTable* targetType, MethodTable* interfaceType, ushort slot);
}
public class Internal.Runtime.TypeLoader.ModuleInfoEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal ModuleInfoEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public ModuleInfoEnumerator GetEnumerator();
}
public class Internal.Runtime.TypeLoader.ModuleInfoEnumerator : ValueType {
    private ModuleInfo[] _modules;
    private int _preferredIndex;
    private int _iterationIndex;
    private ModuleInfo _currentModule;
    public ModuleInfo Current { get; }
    internal ModuleInfoEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public ModuleInfo get_Current();
}
public class Internal.Runtime.TypeLoader.ModuleList : object {
    private ModuleMap modreq(System.Runtime.CompilerServices.IsVolatile) _loadedModuleMap;
    private Action`1<ModuleInfo> _moduleRegistrationCallbacks;
    private Lock _moduleRegistrationLock;
    private ModuleInfo _systemModule;
    public static ModuleList Instance { get; }
    public ModuleInfo SystemModule { get; }
    internal ModuleMap GetLoadedModuleMapInternal();
    public static ModuleList get_Instance();
    public static void AddModuleRegistrationCallback(Action`1<ModuleInfo> newModuleRegistrationCallback);
    public void RegisterNewModules(ModuleType moduleType);
    public void RegisterModule(ModuleInfo newModuleInfo);
    public NativeFormatModuleInfo GetModuleInfoByHandle(TypeManagerHandle moduleHandle);
    public bool TryGetModuleInfoByHandle(TypeManagerHandle moduleHandle, ModuleInfo& moduleInfo);
    public MetadataReader GetMetadataReaderForModule(TypeManagerHandle moduleHandle);
    public ModuleInfo GetModuleInfoForDynamicModule(IntPtr dynamicModuleHandle);
    public NativeFormatModuleInfo GetModuleInfoForMetadataReader(MetadataReader reader);
    public TypeManagerHandle GetModuleForMetadataReader(MetadataReader reader);
    public ModuleInfo get_SystemModule();
    public static NativeFormatModuleInfoEnumerable EnumerateModules();
    public static NativeFormatModuleInfoEnumerable EnumerateModules(TypeManagerHandle preferredModule);
    public static MetadataReaderEnumerable EnumerateMetadataReaders();
    public static MetadataReaderEnumerable EnumerateMetadataReaders(TypeManagerHandle preferredModule);
    public static ModuleHandleEnumerable Enumerate();
    public static ModuleHandleEnumerable Enumerate(TypeManagerHandle preferredModule);
}
internal class Internal.Runtime.TypeLoader.ModuleMap : object {
    public ModuleInfo[] Modules;
    public LowLevelDictionary`2<TypeManagerHandle, int> HandleToModuleIndex;
    internal ModuleMap(ModuleInfo[] modules);
}
public enum Internal.Runtime.TypeLoader.ModuleType : Enum {
    public int value__;
    public static ModuleType Eager;
    public static ModuleType ReadyToRun;
    public static ModuleType Ecma;
}
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfo : ModuleInfo {
    [CompilerGeneratedAttribute]
private MetadataReader <MetadataReader>k__BackingField;
    public MetadataReader MetadataReader { get; private set; }
    internal NativeFormatModuleInfo(TypeManagerHandle moduleHandle, ModuleType moduleType, IntPtr pBlob, int cbBlob);
    [CompilerGeneratedAttribute]
public MetadataReader get_MetadataReader();
    [CompilerGeneratedAttribute]
private void set_MetadataReader(MetadataReader value);
    internal bool TryFindBlob(ReflectionMapBlob blobId, Byte*& pBlob, UInt32& cbBlob);
    public bool TryFindBlob(int blobId, Byte*& pBlob, UInt32& cbBlob);
}
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfoEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal NativeFormatModuleInfoEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public NativeFormatModuleInfoEnumerator GetEnumerator();
}
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfoEnumerator : ValueType {
    private ModuleInfo[] _modules;
    private int _preferredIndex;
    private int _iterationIndex;
    private NativeFormatModuleInfo _currentModule;
    public NativeFormatModuleInfo Current { get; }
    internal NativeFormatModuleInfoEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public NativeFormatModuleInfo get_Current();
}
internal class Internal.Runtime.TypeLoader.NativeLayoutFieldAlgorithm : FieldLayoutAlgorithm {
    private NoMetadataFieldLayoutAlgorithm _noMetadataFieldLayoutAlgorithm;
    private static int InstanceAlignmentEntry;
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    private static ComputedStaticFieldLayout ParseStaticRegionSizesFromNativeLayout(TypeDesc type);
    internal static void EnsureFieldLayoutLoadedForGenericType(DefType type);
    private static void EnsureFieldLayoutLoadedForUniversalType(DefType type, NativeLayoutInfoLoadContext loadContext, NativeParser fieldLayoutParser);
    private static void EnsureFieldLayoutLoadedForNonUniversalType(DefType type);
    private static NativeLayoutFieldDesc[] ParseFieldLayout(DefType owningType, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser fieldLayoutParser);
    internal static void ComputeTypeSizeBeforeFields(TypeDesc type, LayoutInt& initialSize, LayoutInt& alignRequired);
    internal static bool ShouldProcessField(FieldStorage fieldStorage, FieldLoadState loadRequested);
    internal LayoutInt[] ComputeTypeSizeAndAlignment(TypeDesc type, FieldLoadState loadRequested, LowLevelList`1& fieldOffsets);
    internal void GetFieldSizeAlignment(TypeDesc fieldType, LayoutInt& size, LayoutInt& alignment);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    public virtual bool ComputeIsUnsafeValueType(DefType type);
}
internal class Internal.Runtime.TypeLoader.NativeLayoutFieldDesc : FieldDesc {
    private DefType _owningType;
    private TypeDesc _fieldType;
    private FieldStorage _fieldStorage;
    public TypeSystemContext Context { get; }
    public TypeDesc FieldType { get; }
    public bool HasRva { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsStatic { get; }
    public bool IsThreadStatic { get; }
    internal FieldStorage FieldStorage { get; }
    public DefType OwningType { get; }
    public NativeLayoutFieldDesc(DefType owningType, TypeDesc fieldType, FieldStorage fieldStorage);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_FieldType();
    public virtual EmbeddedSignatureData[] GetEmbeddedSignatureData();
    public virtual bool get_HasRva();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsLiteral();
    public virtual bool get_IsStatic();
    public virtual bool get_IsThreadStatic();
    internal FieldStorage get_FieldStorage();
    public virtual DefType get_OwningType();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInfo : ValueType {
    public UInt32 Offset;
    public NativeFormatModuleInfo Module;
    public NativeReader Reader;
    public NativeLayoutInfoLoadContext LoadContext;
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInfoLoadContext : object {
    public TypeSystemContext _typeSystemContext;
    public NativeFormatModuleInfo _module;
    private ExternalReferencesTable _staticInfoLookup;
    private ExternalReferencesTable _externalReferencesLookup;
    public Instantiation _typeArgumentHandles;
    public Instantiation _methodArgumentHandles;
    private TypeDesc GetInstantiationType(NativeParser& parser, UInt32 arity);
    private TypeDesc GetModifierType(NativeParser& parser, TypeModifierKind modifier);
    private void InitializeExternalReferencesLookup();
    private IntPtr GetExternalReferencePointer(UInt32 index);
    internal TypeDesc GetExternalType(UInt32 index);
    internal IntPtr GetGCStaticInfo(UInt32 index);
    private TypeDesc GetLookbackType(NativeParser& parser, UInt32 lookback);
    internal TypeDesc GetType(NativeParser& parser);
    internal MethodDesc GetMethod(NativeParser& parser, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    internal MethodDesc GetMethod(NativeParser& parser);
    internal TypeDesc[] GetTypeSequence(NativeParser& parser);
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
    private static bool InterfaceInSet(DefType[] interfaces, int numInterfaces, DefType interfaceType);
}
internal class Internal.Runtime.TypeLoader.NoMetadataFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    private static NativeLayoutFieldAlgorithm s_nativeLayoutFieldAlgorithm;
    private static NoMetadataFieldLayoutAlgorithm();
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    public virtual bool ComputeIsUnsafeValueType(DefType type);
}
internal class Internal.Runtime.TypeLoader.NoMetadataRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
}
internal class Internal.Runtime.TypeLoader.OptionalFieldsRuntimeBuilder : object {
    private NativePrimitiveEncoder _encoder;
    private OptionalField[] _rgFields;
    internal OptionalFieldsRuntimeBuilder(Byte* pInitializeFromOptionalFields);
    internal UInt32 GetFieldValue(EETypeOptionalFieldTag eTag, UInt32 defaultValueIfNotFound);
    internal void SetFieldValue(EETypeOptionalFieldTag eTag, UInt32 value);
    internal void ClearField(EETypeOptionalFieldTag eTag);
    internal int Encode();
    internal void WriteToEEType(MethodTable* pEEType, int sizeOfOptionalFieldsDataInEEType);
}
public class Internal.Runtime.TypeLoader.PermanentAllocatedMemoryBlobs : object {
    private static PermanentlyAllocatedMemoryRegions_Uint_In_IntPtr s_uintCellValues;
    private static PermanentlyAllocatedMemoryRegions_IntPtr_In_IntPtr s_pointerIndirectionCellValues;
    private static PermanentAllocatedMemoryBlobs();
    public static IntPtr GetPointerToUInt(UInt32 value);
    public static IntPtr GetPointerToIntPtr(IntPtr value);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.RuntimeHandleExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static bool IsDynamic(RuntimeFieldHandle rtfh);
    [ExtensionAttribute]
public static bool IsDynamic(RuntimeMethodHandle rtfh);
}
[ExtensionAttribute]
public static class Internal.Runtime.TypeLoader.RuntimeSignatureExtensions : object {
    [ExtensionAttribute]
public static IntPtr NativeLayoutSignature(RuntimeSignature signature);
}
[ExtensionAttribute]
public static class Internal.Runtime.TypeLoader.RuntimeSignatureHelper : object {
    [ExtensionAttribute]
public static ModuleInfo GetModuleInfo(RuntimeSignature methodSignature);
    public static bool TryCreate(MethodDesc method, RuntimeSignature& methodSignature);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.RuntimeTypeHandleEETypeExtensions : object {
    [ExtensionAttribute]
public static MethodTable* ToEETypePtr(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static IntPtr ToIntPtr(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static bool IsDynamicType(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static int GetNumVtableSlots(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static TypeManagerHandle GetTypeManager(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static IntPtr GetDictionary(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static void SetDictionary(RuntimeTypeHandle rtth, int dictionarySlot, IntPtr dictionary);
    [ExtensionAttribute]
public static void SetInterface(RuntimeTypeHandle rtth, int interfaceIndex, RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
public static void SetGenericDefinition(RuntimeTypeHandle rtth, RuntimeTypeHandle genericDefinitionHandle);
    [ExtensionAttribute]
public static void SetGenericVariance(RuntimeTypeHandle rtth, int argumentIndex, GenericVariance variance);
    [ExtensionAttribute]
public static void SetGenericArity(RuntimeTypeHandle rtth, UInt32 arity);
    [ExtensionAttribute]
public static void SetGenericArgument(RuntimeTypeHandle rtth, int argumentIndex, RuntimeTypeHandle argumentType);
    [ExtensionAttribute]
public static void SetRelatedParameterType(RuntimeTypeHandle rtth, RuntimeTypeHandle relatedTypeHandle);
    [ExtensionAttribute]
public static void SetParameterizedTypeShape(RuntimeTypeHandle rtth, UInt32 value);
    [ExtensionAttribute]
public static void SetBaseType(RuntimeTypeHandle rtth, RuntimeTypeHandle baseTypeHandle);
    [ExtensionAttribute]
public static void SetComponentSize(RuntimeTypeHandle rtth, ushort componentSize);
}
internal class Internal.Runtime.TypeLoader.SerializedDebugData : object {
    private static IntPtr DBGVISIBLE_serializedDataHeader;
    private static int SerializationFormatVersion;
    private static int HeaderBufferListSize;
    private static int HeaderBufferListOffset;
    private static int PhysicalBufferSize;
    private static int PhysicalBufferDataOffset;
    internal static SerializedDebugData Instance;
    private IntPtr _activePhysicalBuffer;
    private int _activePhysicalBufferIdx;
    private int _activePhysicalBufferOffset;
    private int _activePhysicalBufferAvailableSize;
    private int _serializedDataHeaderSize;
    private static bool s_tailCallThunkSizeRegistered;
    private static SerializedDebugData();
    private void InitializeHeader(int physicalBufferListSize);
    private int GetAllocatedPhysicalBufferCount();
    private void AddAllocatedBufferToHeader(IntPtr buffer, int insertIdx);
    private int AllocatePhysicalBuffer(IntPtr& buffer);
    private int GetPhysicalBuffer(int requestedSize, IntPtr& bufferPtr);
    private void UpdatePhysicalBufferUsedSize();
    private void ThreadSafeWriteBytes(Byte[] src);
    public static void SerializeDataBlobTypeAndFlags(NativePrimitiveEncoder& encoder, SerializedDataBlobKind blobType, byte flags);
    public static void RegisterDebugDataForType(TypeBuilder typeBuilder, DefType defType, TypeBuilderState state);
    public static void RegisterDebugDataForNativeFormatType(TypeBuilder typeBuilder, DefType defType, TypeBuilderState state);
    public static void RegisterDebugDataForMethod(TypeBuilder typeBuilder, InstantiatedMethod method);
    public static void RegisterTailCallThunk(IntPtr thunk);
}
internal static class Internal.Runtime.TypeLoader.SigParsing : object {
    public static RuntimeTypeHandle GetTypeFromNativeLayoutSignature(NativeParser& parser, TypeManagerHandle moduleHandle, UInt32 offset);
}
internal class Internal.Runtime.TypeLoader.TemplateLocator : ValueType {
    private static UInt32 BadTokenFixupValue;
    public static TypeDesc TryGetTypeTemplate(TypeDesc concreteType, NativeLayoutInfo& nativeLayoutInfo);
    public static TypeDesc TryGetUniversalTypeTemplate(TypeDesc concreteType, NativeLayoutInfo& nativeLayoutInfo);
    public static bool TryGetMetadataNativeLayout(TypeDesc concreteType, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    public static bool TryGetMetadataNativeLayout(MethodDesc concreteMethod, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private static TypeDesc TryGetTypeTemplate_Internal(TypeDesc concreteType, CanonicalFormKind kind, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    public static InstantiatedMethod TryGetGenericMethodTemplate(InstantiatedMethod concreteMethod, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private static InstantiatedMethod TryGetGenericMethodTemplate_Internal(InstantiatedMethod concreteMethod, CanonicalFormKind kind, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private static NativeHashtable LoadHashtable(NativeFormatModuleInfo module, ReflectionMapBlob hashtableBlobId, ExternalReferencesTable& externalFixupsTable);
}
internal class Internal.Runtime.TypeLoader.ThreadStaticFieldOffsets : ValueType {
    public UInt32 StartingOffsetInTlsBlock;
    public UInt32 FieldOffset;
}
internal class Internal.Runtime.TypeLoader.TypeBuilder : object {
    private static int MinimumValueTypeSize;
    public static int ClassConstructorOffset;
    private LowLevelList`1<TypeDesc> _typesThatNeedTypeHandles;
    private LowLevelList`1<InstantiatedMethod> _methodsThatNeedDictionaries;
    private LowLevelList`1<TypeDesc> _typesThatNeedPreparation;
    private object _epoch;
    private static TypeBuilder();
    private static bool CheckAllHandlesValidForMethod(MethodDesc method);
    internal static bool RetrieveExactFunctionPointerIfPossible(MethodDesc method, IntPtr& result);
    internal static bool RetrieveMethodDictionaryIfPossible(InstantiatedMethod method);
    public void RegisterForPreparation(TypeDesc type);
    public void PrepareMethod(MethodDesc method);
    private void InsertIntoNeedsTypeHandleList(TypeBuilderState state, TypeDesc type);
    internal void PrepareType(TypeDesc type);
    private void PrepareRuntimeInterfaces(TypeDesc type);
    private void PrepareBaseTypeAndDictionaries(TypeDesc type);
    private void ProcessTypesNeedingPreparation();
    private static GenericDictionaryCell[] GetGenericMethodDictionaryCellsForMetadataBasedLoad(InstantiatedMethod method, InstantiatedMethod nonTemplateMethod);
    internal void ParseNativeLayoutInfo(InstantiatedMethod method);
    internal void ParseNativeLayoutInfo(TypeBuilderState state, TypeDesc type);
    private void ComputeVTableLayout(TypeDesc currentType, TypeDesc currentTemplateType, TypeBuilderState targetTypeState);
    private void AllocateRuntimeType(TypeDesc type);
    private static void AllocateRuntimeMethodDictionary(InstantiatedMethod method);
    private RuntimeTypeHandle[] GetGenericContextOfBaseType(DefType type, int vtableMethodSlot);
    public RuntimeTypeHandle GetRuntimeTypeHandle(TypeDesc type);
    public RuntimeTypeHandle[] GetRuntimeTypeHandles(Instantiation types);
    public static DefType GetBaseTypeUsingRuntimeTypeHandle(TypeDesc type);
    public static DefType GetBaseTypeThatIsCorrectForMDArrays(TypeDesc type);
    private void FinishInterfaces(TypeDesc type, TypeBuilderState state);
    private void FinishTypeDictionary(TypeDesc type);
    private void FinishMethodDictionary(InstantiatedMethod method);
    private void FinishClassConstructor(TypeDesc type, TypeBuilderState state);
    private void CopyDictionaryFromTypeToAppropriateSlotInDerivedType(TypeDesc baseType, TypeBuilderState derivedTypeState);
    private void FinishBaseTypeAndDictionaries(TypeDesc type, TypeBuilderState state);
    private void FinishRuntimeType(TypeDesc type);
    [IteratorStateMachineAttribute("Internal.Runtime.TypeLoader.TypeBuilder/<TypesToRegister>d__37")]
private IEnumerable`1<TypeEntryToRegister> TypesToRegister();
    [IteratorStateMachineAttribute("Internal.Runtime.TypeLoader.TypeBuilder/<MethodsToRegister>d__38")]
private IEnumerable`1<GenericMethodEntry> MethodsToRegister();
    private void RegisterGenericTypesAndMethods();
    private void RegisterDebugDataForTypesAndMethods();
    private void FinishTypeAndMethodBuilding();
    internal void BuildType(TypeDesc type);
    internal static bool TryComputeFieldOffset(DefType declaringType, UInt32 fieldOrdinal, Int32& fieldOffset);
    private void BuildMethod(InstantiatedMethod method);
    private static DefType GetExactDeclaringType(DefType srcDefType, DefType dstDefType);
    private IntPtr BuildGenericLookupTarget(TypeSystemContext typeSystemContext, IntPtr context, IntPtr signature, IntPtr& auxResult);
    private IntPtr BuildFloatingDictionary(TypeSystemContext typeSystemContext, IntPtr context, bool isTypeContext, IntPtr fixedDictionary, Boolean& isNewlyAllocatedDictionary);
    public static bool TryBuildGenericType(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public static bool TryBuildArrayType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public static bool TryBuildPointerType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public static bool TryBuildByRefType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public static bool TryBuildGenericMethod(RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle[] genericMethodArgHandles, MethodNameAndSignature methodNameAndSignature, IntPtr& methodDictionary);
    internal static bool TryBuildGenericMethod(InstantiatedMethod methodBeingLoaded, IntPtr& methodDictionary);
    private void ResolveSingleCell_Worker(GenericDictionaryCell cell, IntPtr& fixupResolution);
    private void ResolveMultipleCells_Worker(GenericDictionaryCell[] cells, IntPtr[]& fixups);
    internal static void ResolveSingleCell(GenericDictionaryCell cell, IntPtr& fixupResolution);
    public static void ResolveMultipleCells(GenericDictionaryCell[] cells, IntPtr[]& fixups);
    public static IntPtr BuildGenericLookupTarget(IntPtr typeContext, IntPtr signature, IntPtr& auxResult);
    public static bool TryGetFieldOffset(RuntimeTypeHandle declaringTypeHandle, UInt32 fieldOrdinal, Int32& fieldOffset);
    internal static bool TryGetDelegateInvokeMethodSignature(RuntimeTypeHandle delegateTypeHandle, RuntimeSignature& signature);
    internal static IntPtr TryBuildFloatingDictionary(IntPtr context, bool isTypeContext, IntPtr fixedDictionary, Boolean& isNewlyAllocatedDictionary);
}
public static class Internal.Runtime.TypeLoader.TypeBuilderApi : object {
    public static void ResolveMultipleCells(GenericDictionaryCell[] cells, IntPtr[]& fixups);
}
internal class Internal.Runtime.TypeLoader.TypeBuilderState : object {
    public TypeDesc TypeBeingBuilt;
    public bool AttemptedAndFailedToRetrieveTypeHandle;
    public bool NeedsTypeHandle;
    public bool HasBeenPrepared;
    public RuntimeTypeHandle HalfBakedRuntimeTypeHandle;
    public IntPtr HalfBakedDictionary;
    public IntPtr HalfBakedSealedVTable;
    private bool _templateComputed;
    private bool _nativeLayoutTokenComputed;
    private TypeDesc _templateType;
    private bool _nativeLayoutComputed;
    private bool _templateTypeLoaderNativeLayout;
    private bool _readyToRunNativeLayout;
    private NativeLayoutInfo _nativeLayoutInfo;
    private NativeLayoutInfo _r2rnativeLayoutInfo;
    private Nullable`1<bool> _hasDictionarySlotInVTable;
    private Nullable`1<bool> _hasDictionaryInVTable;
    private Nullable`1<ushort> _numVTableSlots;
    public GenericTypeDictionary Dictionary;
    public Nullable`1<IntPtr> ClassConstructorPointer;
    public IntPtr GcStaticDesc;
    public IntPtr ThreadStaticDesc;
    public bool AllocatedStaticGCDesc;
    public bool AllocatedThreadStaticGCDesc;
    public UInt32 ThreadStaticOffset;
    public UInt32 NumSealedVTableEntries;
    public GenericVariance[] GenericVarianceFlags;
    private static LowLevelList`1<bool> s_emptyLayout;
    private LowLevelList`1<bool> _instanceGCLayout;
    public LowLevelList`1<bool> StaticGCLayout;
    public LowLevelList`1<bool> ThreadStaticGCLayout;
    private bool _staticGCLayoutPrepared;
    public VTableLayoutInfo[] VTableMethodSignatures;
    public int NumSealedVTableMethodSignatures;
    public VTableSlotMapper VTableSlotsMapping;
    public TypeDesc TemplateType { get; }
    public NativeLayoutInfo NativeLayoutInfo { get; }
    public NativeLayoutInfo R2RNativeLayoutInfo { get; }
    public DefType[] RuntimeInterfaces { get; }
    public bool HasDictionarySlotInVTable { get; }
    public bool HasDictionaryInVTable { get; }
    public ushort NumVTableSlots { get; }
    public int NonGcDataSize { get; }
    public int GcDataSize { get; }
    public int ThreadDataSize { get; }
    public bool HasStaticConstructor { get; }
    public LowLevelList`1<bool> InstanceGCLayout { get; }
    public bool IsArrayOfReferenceTypes { get; }
    public Nullable`1<int> ArrayRank { get; }
    public Nullable`1<int> BaseTypeSize { get; }
    public Nullable`1<int> TypeSize { get; }
    public Nullable`1<int> UnalignedTypeSize { get; }
    public Nullable`1<int> FieldAlignment { get; }
    public Nullable`1<ushort> ComponentSize { get; }
    public UInt32 NullableValueOffset { get; }
    public bool IsHFA { get; }
    public TypeBuilderState(TypeDesc typeBeingBuilt);
    private static TypeBuilderState();
    public TypeDesc get_TemplateType();
    private void EnsureNativeLayoutInfoComputed();
    private static void FinishInitNativeLayoutInfo(TypeDesc type, NativeLayoutInfo& nativeLayoutInfo);
    public NativeLayoutInfo get_NativeLayoutInfo();
    public NativeLayoutInfo get_R2RNativeLayoutInfo();
    public NativeParser GetParserForNativeLayoutInfo();
    public NativeParser GetParserForReadyToRunNativeLayoutInfo();
    public NativeParser GetParserForUniversalNativeLayoutInfo(NativeLayoutInfoLoadContext& universalLayoutLoadContext, NativeLayoutInfo& universalLayoutInfo);
    public DefType[] get_RuntimeInterfaces();
    private bool ComputeHasDictionarySlotInVTable();
    public bool get_HasDictionarySlotInVTable();
    private bool ComputeHasDictionaryInVTable();
    public bool get_HasDictionaryInVTable();
    private ushort ComputeNumVTableSlots();
    public ushort get_NumVTableSlots();
    public int get_NonGcDataSize();
    public int get_GcDataSize();
    public int get_ThreadDataSize();
    public bool get_HasStaticConstructor();
    public LowLevelList`1<bool> get_InstanceGCLayout();
    public void PrepareStaticGCLayout();
    private IEnumerable`1<FieldDesc> GetFieldsForGCLayout();
    private static GCLayout GetInstanceGCLayout(TypeDesc type);
    private static GCLayout GetFieldGCLayout(TypeDesc fieldType);
    public bool get_IsArrayOfReferenceTypes();
    public Nullable`1<int> get_ArrayRank();
    public Nullable`1<int> get_BaseTypeSize();
    public Nullable`1<int> get_TypeSize();
    public Nullable`1<int> get_UnalignedTypeSize();
    public Nullable`1<int> get_FieldAlignment();
    public Nullable`1<ushort> get_ComponentSize();
    public UInt32 get_NullableValueOffset();
    public bool get_IsHFA();
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.TypeDescExtensions : object {
    [ExtensionAttribute]
public static bool CanShareNormalGenericCode(TypeDesc type);
    [ExtensionAttribute]
public static bool IsGeneric(TypeDesc type);
    [ExtensionAttribute]
public static DefType GetClosestDefType(TypeDesc type);
}
public class Internal.Runtime.TypeLoader.TypeLoaderEnvironment : object {
    private DynamicGenericMethodsHashtable _dynamicGenericMethods;
    private DynamicGenericMethodComponentsHashtable _dynamicGenericMethodComponents;
    private Lock _dynamicGenericsLock;
    private DynamicGenericTypesHashtable _dynamicGenericTypes;
    private LowLevelDictionary`2<LazyDictionaryContext, IntPtr> _lazyGenericDictionaries;
    [ThreadStaticAttribute]
private static bool t_isReentrant;
    [CompilerGeneratedAttribute]
private static TypeLoaderEnvironment <Instance>k__BackingField;
    public ModuleList ModuleList;
    [ThreadStaticAttribute]
private static LowLevelDictionary`2<TypeManagerHandle, NativeReader> t_moduleNativeReaders;
    private Lock _typeLoaderLock;
    private LowLevelDictionary`2<string, IntPtr> _nativeFormatStrings;
    private LowLevelDictionary`2<RuntimeFieldHandleKey, RuntimeFieldHandle> _runtimeFieldHandles;
    private LowLevelDictionary`2<RuntimeMethodHandleKey, RuntimeMethodHandle> _runtimeMethodHandles;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _namedTypeLookupLiveVersion;
    private NamedTypeRuntimeTypeHandleToMetadataHashtable _runtimeTypeHandleToMetadataHashtable;
    [CompilerGeneratedAttribute]
private static IntPtr <NoStaticsData>k__BackingField;
    private QTypeDefinitionToRuntimeTypeHandleHashtable _metadataToRuntimeTypeHandleHashtable;
    private Lock _threadStaticsLock;
    private LowLevelDictionary`2<IntPtr, UInt32> _maxThreadLocalIndex;
    private LowLevelDictionary`2<IntPtr, LowLevelDictionary`2<UInt32, IntPtr>> _dynamicGenericsThreadStaticDescs;
    public static TypeLoaderEnvironment Instance { get; }
    public static IntPtr NoStaticsData { get; }
    private static TypeLoaderEnvironment();
    internal bool TryLookupGenericMethodDictionaryForComponents(GenericMethodLookupData lookupData, IntPtr& result);
    public bool TryLookupGenericMethodDictionaryForComponents(RuntimeTypeHandle declaringType, MethodNameAndSignature nameAndSignature, RuntimeTypeHandle[] genericMethodArgumentHandles, IntPtr& result);
    public bool TryGetGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    public bool TryLookupExactMethodPointerForComponents(RuntimeTypeHandle declaringType, MethodNameAndSignature nameAndSignature, RuntimeTypeHandle[] genericMethodArgumentHandles, IntPtr& result);
    public bool TryGetGenericVirtualMethodPointer(RuntimeTypeHandle targetTypeHandle, MethodNameAndSignature nameAndSignature, RuntimeTypeHandle[] genericMethodArgumentHandles, IntPtr& methodPointer, IntPtr& dictionaryPointer);
    private bool TryGetDynamicGenericMethodDictionaryForComponents(GenericMethodLookupData lookupData, IntPtr& result);
    private static bool TryGetStaticGenericMethodDictionaryForComponents(GenericMethodLookupData lookupData, IntPtr& result);
    private bool TryGetDynamicGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    private bool TryGetStaticGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    internal void RegisterDynamicGenericTypesAndMethods(DynamicGenericsRegistrationData registrationData);
    public void RegisterConstructedLazyDictionaryForContext(IntPtr context, IntPtr signature, IntPtr dictionary);
    internal bool TryLookupConstructedGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryLookupConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryLookupConstructedLazyDictionaryForContext(IntPtr context, IntPtr signature, IntPtr& dictionary);
    private bool TryGetDynamicGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    internal static bool TryGetStaticGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    [CompilerGeneratedAttribute]
public static TypeLoaderEnvironment get_Instance();
    internal static void Initialize();
    public void VerifyTypeLoaderLockHeld();
    public void RunUnderTypeLoaderLock(Action action);
    public IntPtr GenericLookupFromContextAndSignature(IntPtr context, IntPtr signature, IntPtr& auxResult);
    private bool EnsureTypeHandleForType(TypeDesc type);
    internal TypeDesc GetConstructedTypeFromParserAndNativeLayoutContext(NativeParser& parser, NativeLayoutInfoLoadContext nativeLayoutContext);
    internal bool GetTypeFromSignatureAndContext(RuntimeSignature signature, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType, RuntimeSignature& remainingSignature);
    internal bool GetTypeFromSignatureAndContext(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType);
    public bool GetMethodFromSignatureAndContext(RuntimeSignature signature, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles, RuntimeSignature& remainingSignature);
    internal bool GetMethodFromSignatureAndContext(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    internal static NativeReader GetNativeLayoutInfoReader(NativeFormatModuleInfo module);
    internal static NativeReader GetNativeLayoutInfoReader(RuntimeSignature signature);
    internal static NativeReader GetNativeLayoutInfoReader(TypeManagerHandle moduleHandle);
    private static RuntimeTypeHandle[] GetTypeSequence(ExternalReferencesTable& extRefs, NativeParser& parser);
    private static RuntimeTypeHandle[] TypeDescsToRuntimeHandles(Instantiation types);
    public bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    internal static bool TryGetArrayTypeForElementType_LookupOnly(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public bool TryGetPointerTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public bool TryGetByRefTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public int GetCanonicalHashCode(RuntimeTypeHandle typeHandle, CanonicalFormKind kind);
    private object TryParseNativeSignatureWorker(TypeSystemContext typeSystemContext, TypeManagerHandle moduleHandle, NativeParser& parser, RuntimeTypeHandle[] typeGenericArgumentHandles, RuntimeTypeHandle[] methodGenericArgumentHandles, bool isMethodSignature);
    public bool TryGetGenericMethodDictionaryForComponents(RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle[] genericMethodArgHandles, MethodNameAndSignature nameAndSignature, IntPtr& methodDictionary);
    public bool TryGetFieldOffset(RuntimeTypeHandle declaringTypeHandle, UInt32 fieldOrdinal, Int32& fieldOffset);
    public IntPtr UpdateFloatingDictionary(IntPtr context, IntPtr dictionaryPtr);
    public bool CanInstantiationsShareCode(RuntimeTypeHandle[] genericArgHandles1, RuntimeTypeHandle[] genericArgHandles2, CanonicalFormKind kind);
    public bool ConversionToCanonFormIsAChange(RuntimeTypeHandle[] genericArgHandles, CanonicalFormKind kind);
    private static bool GetHashtableFromBlob(NativeFormatModuleInfo module, ReflectionMapBlob blobId, NativeHashtable& hashtable, ExternalReferencesTable& externalReferencesLookup);
    public static void GetFieldAlignmentAndSize(RuntimeTypeHandle fieldType, Int32& alignment, Int32& size);
    public static bool TryGetTargetOfUnboxingAndInstantiatingStub(IntPtr maybeInstantiatingAndUnboxingStub, IntPtr& targetMethod);
    public bool TryComputeHasInstantiationDeterminedSize(RuntimeTypeHandle typeHandle, Boolean& hasInstantiationDeterminedSize);
    public bool TryComputeHasInstantiationDeterminedSize(RuntimeTypeHandle typeHandle, TypeSystemContext context, Boolean& hasInstantiationDeterminedSize);
    internal static bool TryComputeHasInstantiationDeterminedSize(DefType type, Boolean& hasInstantiationDeterminedSize);
    public bool TryDispatchMethodOnTarget(NativeFormatModuleInfo module, int metadataToken, RuntimeTypeHandle targetInstanceType, IntPtr& methodAddress);
    internal bool TryResolveTypeSlotDispatch(MethodTable* targetType, MethodTable* interfaceType, ushort slot, IntPtr& methodAddress);
    public bool TryGetOrCreateNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public static IntPtr ConvertUnboxingFunctionPointerToUnderlyingNonUnboxingPointer(IntPtr unboxingFunctionPointer, RuntimeTypeHandle declaringType);
    public static bool TryGetFieldAccessMetadata(MetadataReader metadataReader, RuntimeTypeHandle runtimeTypeHandle, FieldHandle fieldHandle, FieldAccessMetadata& fieldAccessMetadata);
    private static bool TryGetFieldAccessMetadataFromFieldAccessMap(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, FieldHandle fieldHandle, CanonicalFormKind canonFormKind, FieldAccessMetadata& fieldAccessMetadata);
    public static IntPtr RvaToNonGenericStaticFieldAddress(TypeManagerHandle moduleHandle, int staticFieldRVA);
    private static bool TryGetStaticFieldBaseFromFieldAccessMap(RuntimeTypeHandle declaringTypeHandle, FieldAccessStaticDataKind fieldAccessKind, IntPtr& staticsRegionAddress);
    private static bool TryGetFieldAccessMetadataFromNativeFormatMetadata(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, FieldHandle fieldHandle, TypeSystemContext context, FieldAccessMetadata& fieldAccessMetadata);
    private static bool TryGetFieldAccessMetadataForNativeFormatType(TypeDesc type, string fieldName, FieldAccessMetadata& fieldAccessMetadata);
    public bool TryGetGenericVirtualTargetForTypeAndSlot(RuntimeTypeHandle targetHandle, RuntimeTypeHandle& declaringType, RuntimeTypeHandle[] genericArguments, String& methodName, RuntimeSignature& methodSignature, bool lookForDefaultImplementation, IntPtr& methodPointer, IntPtr& dictionaryPointer, Boolean& slotUpdated);
    private static MethodNameAndSignature GetMethodNameAndSignatureFromNativeReader(NativeReader nativeLayoutReader, TypeManagerHandle moduleHandle, UInt32 nativeLayoutOffset);
    private static RuntimeTypeHandle GetOpenTypeDefinition(RuntimeTypeHandle typeHandle, RuntimeTypeHandle[]& typeArgumentsHandles);
    private static RuntimeTypeHandle GetTypeDefinition(RuntimeTypeHandle typeHandle);
    private static bool FindMatchingInterfaceSlot(NativeFormatModuleInfo module, NativeReader nativeLayoutReader, NativeParser& entryParser, ExternalReferencesTable& extRefs, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature, RuntimeTypeHandle instanceTypeHandle, RuntimeTypeHandle openTargetTypeHandle, RuntimeTypeHandle[] targetTypeInstantiation, bool variantDispatch, bool defaultMethods);
    private static bool ResolveInterfaceGenericVirtualMethodSlot(RuntimeTypeHandle targetTypeHandle, bool lookForDefaultImplementation, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature);
    private static bool ResolveInterfaceGenericVirtualMethodSlot_Static(RuntimeTypeHandle targetTypeHandle, bool lookForDefaultImplementation, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature);
    public static bool IsPregeneratedOrTemplateRuntimeTypeHandle(RuntimeTypeHandle rtth);
    private bool ResolveGenericVirtualMethodTarget(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle[] genericArguments, MethodNameAndSignature callingMethodNameAndSignature, IntPtr& methodPointer, IntPtr& dictionaryPointer);
    private bool ResolveGenericVirtualMethodTarget_Static(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle declaringType, RuntimeTypeHandle[] genericArguments, MethodNameAndSignature callingMethodNameAndSignature, IntPtr& methodPointer, IntPtr& dictionaryPointer);
    private static string GetStringFromMemoryInNativeFormat(IntPtr pointerToDataStream);
    public IntPtr GetNativeFormatStringForString(string str);
    public RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string fieldName);
    public RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, IntPtr fieldName);
    public bool TryGetRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    private bool TryGetDynamicRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    private bool TryGetStaticRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    public RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, IntPtr methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public bool TryGetRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    private bool TryGetDynamicRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    private bool TryGetStaticRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    private static bool SequenceEqual(T[] seq1, T[] seq2);
    internal static NativeReader GetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob);
    public static bool TryGetTypeReferenceForNamedType(RuntimeTypeHandle runtimeTypeHandle, MetadataReader& metadataReader, TypeReferenceHandle& typeRefHandle);
    public static bool TryGetNamedTypeForTypeReference(MetadataReader metadataReader, TypeReferenceHandle typeRefHandle, RuntimeTypeHandle& runtimeTypeHandle, bool searchAllModules);
    public static bool TryResolveNamedTypeForTypeReference(MetadataReader metadataReader, TypeReferenceHandle typeRefHandle, RuntimeTypeHandle& runtimeTypeHandle);
    private static bool TryGetNamedTypeForTypeReference_Inner(MetadataReader metadataReader, NativeFormatModuleInfo typeRefModule, TypeReferenceHandle typeRefHandle, int hashCode, NativeFormatModuleInfo module, RuntimeTypeHandle& runtimeTypeHandle);
    public static bool TryGetArrayTypeForNonDynamicElementType(RuntimeTypeHandle elementTypeHandle, RuntimeTypeHandle& arrayTypeHandle);
    public bool TryGetArrayTypeHandleForNonDynamicArrayTypeFromTemplateTable(ArrayType arrayType, RuntimeTypeHandle& arrayTypeHandle);
    private static NativeHashtable LoadHashtable(NativeFormatModuleInfo module, ReflectionMapBlob hashtableBlobId, ExternalReferencesTable& externalFixupsTable);
    public static IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle typeHandle);
    private static bool TryGetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob, NativeReader& reader);
    internal static IntPtr TryGetDefaultConstructorForType(TypeDesc type);
    public IntPtr TryGetDefaultConstructorForType(RuntimeTypeHandle runtimeTypeHandle);
    private static IntPtr TryGetDefaultConstructorForTypeViaMetadata_Inner(TypeDesc type);
    internal static IntPtr TryGetDefaultConstructorForType_Inner(NativeFormatModuleInfo mappingTableModule, CanonicallyEquivalentEntryLocator& canonHelper);
    public static bool TryResolveMemberReference(MetadataReader metadataReader, MemberReferenceHandle memberReferenceHandle, MetadataReader& resolvedMetadataReader, RuntimeTypeHandle& resolvedContainingTypeHandle, Handle& resolvedMemberHandle);
    public static bool TryGetMethodMethodNameAndSigFromVTableSlotForPregeneratedOrTemplateType(TypeSystemContext context, RuntimeTypeHandle type, int vtableSlot, MethodNameAndSignature& methodNameAndSig);
    public static bool TryGetVirtualResolveData(NativeFormatModuleInfo module, RuntimeTypeHandle methodHandleDeclaringType, RuntimeTypeHandle[] genericArgs, MethodSignatureComparer& methodSignatureComparer, VirtualResolveDataResult& lookupResult);
    private static bool TryGetMethodNameAndSigFromVirtualResolveData(NativeFormatModuleInfo module, RuntimeTypeHandle declaringType, int logicalSlot, MethodNameAndSignature& methodNameAndSig);
    public static bool TryGetMethodInvokeMetadata(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    private static bool TryGetMethodInvokeMetadataFromInvokeMap(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, MethodHandle methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    private static bool TryGetMethodInvokeMetadataFromNativeFormatMetadata(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, TypeSystemContext typeSystemContext, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    public static ModuleInfo GetModuleInfoForType(TypeDesc type);
    public bool TryGetMetadataForTypeMethodNameAndSignature(RuntimeTypeHandle declaringTypeHandle, MethodNameAndSignature nameAndSignature, QMethodDefinition& methodHandle);
    public static bool TryGetMethodAddressFromMethodDesc(MethodDesc method, IntPtr& methodAddress, IntPtr& unboxingStubAddress, MethodAddressType& foundAddressType);
    private static bool TryGetMethodAddressFromTypeSystemMethodViaInvokeMap(MethodDesc method, IntPtr& methodAddress, IntPtr& unboxingStubAddress, MethodAddressType& foundAddressType);
    private static bool TryDispatchMethodOnTarget_Inner(NativeFormatModuleInfo module, int metadataToken, RuntimeTypeHandle targetInstanceType, IntPtr& methodAddress);
    private static bool TryResolveTypeSlotDispatch_Inner(MethodTable* pTargetType, MethodTable* pInterfaceType, ushort slot, IntPtr& methodAddress);
    [CompilerGeneratedAttribute]
public static IntPtr get_NoStaticsData();
    public bool TryGetMetadataForNamedType(RuntimeTypeHandle runtimeTypeHandle, QTypeDefinition& qTypeDefinition);
    public bool TryGetStaticsInfoForNamedType(RuntimeTypeHandle runtimeTypeHandle, IntPtr& nonGcStaticsData, IntPtr& gcStaticsData);
    public bool TryGetNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public void RegisterNewNamedTypeRuntimeTypeHandle(QTypeDefinition qTypeDefinition, RuntimeTypeHandle runtimeTypeHandle, IntPtr nonGcStaticFields, IntPtr gcStaticFields);
    public void UnregisterNewNamedTypeRuntimeTypeHandle(QTypeDefinition qTypeDefinition, RuntimeTypeHandle runtimeTypeHandle);
    public void FinishAddingNewNamedTypes();
    public bool CompareMethodSignatures(RuntimeSignature signature1, RuntimeSignature signature2);
    public UInt32 GetGenericArgumentCountFromMethodNameAndSignature(MethodNameAndSignature signature);
    public bool TryGetMethodNameAndSignatureFromNativeLayoutSignature(RuntimeSignature signature, MethodNameAndSignature& nameAndSignature);
    public bool TryGetMethodNameAndSignaturePointersFromNativeLayoutSignature(TypeManagerHandle module, UInt32 methodNameAndSigToken, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    public bool TryGetMethodNameAndSignatureFromNativeLayoutOffset(TypeManagerHandle moduleHandle, UInt32 nativeLayoutOffset, MethodNameAndSignature& nameAndSignature);
    internal static MethodNameAndSignature GetMethodNameAndSignature(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    internal static bool IsStaticMethodSignature(RuntimeSignature methodSig);
    internal bool GetCallingConverterDataFromMethodSignature(TypeSystemContext context, RuntimeSignature methodSig, Instantiation typeInstantiation, Instantiation methodInstantiation, Boolean& hasThis, TypeDesc[]& parameters, Boolean[]& parametersWithGenericDependentLayout);
    internal bool GetCallingConverterDataFromMethodSignature_NativeLayout(TypeSystemContext context, RuntimeSignature methodSig, Instantiation typeInstantiation, Instantiation methodInstantiation, Boolean& hasThis, TypeDesc[]& parameters, Boolean[]& parametersWithGenericDependentLayout);
    internal bool GetCallingConverterDataFromMethodSignature_NativeLayout_Common(TypeSystemContext context, RuntimeSignature methodSig, Instantiation typeInstantiation, Instantiation methodInstantiation, Boolean& hasThis, TypeDesc[]& parameters, Boolean[]& parametersWithGenericDependentLayout, NativeReader nativeReader);
    internal bool MethodSignatureHasVarsNeedingCallingConventionConverter(TypeSystemContext context, RuntimeSignature methodSig);
    private bool MethodSignatureHasVarsNeedingCallingConventionConverter_NativeLayout(TypeSystemContext context, RuntimeSignature methodSig);
    private bool TypeSignatureHasVarsNeedingCallingConventionConverter(NativeParser& parser, NativeFormatModuleInfo moduleHandle, TypeSystemContext context, HasVarsInvestigationLevel investigationLevel);
    private bool TryGetTypeFromSimpleTypeSignature(NativeParser& parser, NativeFormatModuleInfo moduleHandle, RuntimeTypeHandle& typeHandle);
    private static RuntimeTypeHandle GetExternalTypeHandle(NativeFormatModuleInfo moduleHandle, UInt32 typeIndex);
    private static UInt32 GetGenericArgCountFromSig(NativeParser parser);
    private bool CompareMethodSigs(NativeParser parser1, NativeFormatModuleInfo moduleHandle1, NativeParser parser2, NativeFormatModuleInfo moduleHandle2);
    private bool CompareTypeSigs(NativeParser& parser1, NativeFormatModuleInfo moduleHandle1, NativeParser& parser2, NativeFormatModuleInfo moduleHandle2);
    public IntPtr TryGetNonGcStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetGcStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetThreadStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr GetThreadStaticGCDescForDynamicType(TypeManagerHandle typeManagerHandle, UInt32 index);
    public UInt32 GetNextThreadStaticsOffsetValue(TypeManagerHandle typeManagerHandle);
    public void RegisterDynamicThreadStaticsInfo(RuntimeTypeHandle runtimeTypeHandle, UInt32 offsetValue, IntPtr gcDesc);
    private static bool GetStaticsInfoHashtable(NativeFormatModuleInfo module, NativeHashtable& staticsInfoHashtable, ExternalReferencesTable& externalReferencesLookup, ExternalReferencesTable& staticInfoLookup);
    private static NativeParser GetStaticInfo(RuntimeTypeHandle instantiatedType, ExternalReferencesTable& staticsInfoLookup);
    private static IntPtr TryCreateDictionaryCellWithValue(UInt32 value);
}
internal static class Internal.Runtime.TypeLoader.TypeLoaderLogger : object {
    internal static int s_pauseHash;
    [ConditionalAttribute("TYPE_LOADER_TRACE")]
public static void WriteLine(string message);
}
public class Internal.Runtime.TypeLoader.TypeLoaderTypeSystemContext : TypeSystemContext {
    private static NoMetadataFieldLayoutAlgorithm s_noMetadataFieldLayoutAlgorithm;
    private static NoMetadataRuntimeInterfacesAlgorithm s_noMetadataRuntimeInterfacesAlgorithm;
    private static NativeLayoutFieldAlgorithm s_nativeLayoutFieldAlgorithm;
    private static NativeLayoutInterfacesAlgorithm s_nativeLayoutInterfacesAlgorithm;
    public bool SupportsUniversalCanon { get; }
    public bool SupportsCanon { get; }
    public TypeLoaderTypeSystemContext(TargetDetails targetDetails);
    private static TypeLoaderTypeSystemContext();
    public virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    protected internal sealed virtual bool IsIDynamicInterfaceCastableInterface(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    public virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    public virtual ModuleDesc ResolveAssembly(AssemblyName name, bool throwErrorIfNotFound);
    public virtual VirtualMethodAlgorithm GetVirtualMethodAlgorithmForType(TypeDesc type);
    protected internal virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    protected internal virtual bool ComputeHasGCStaticBase(FieldDesc field);
    protected internal virtual bool ComputeHasStaticConstructor(TypeDesc type);
    public virtual bool get_SupportsUniversalCanon();
    public virtual bool get_SupportsCanon();
}
public static class Internal.Runtime.TypeLoader.TypeSystemContextFactory : object {
    private static GCHandle s_cachedContext;
    private static Lock s_lock;
    private static TypeSystemContextFactory();
    public static TypeSystemContext Create();
    public static void Recycle(TypeSystemContext context);
}
[ExtensionAttribute]
public static class Internal.Runtime.TypeLoader.WellKnownTypeExtensions : object {
    [ExtensionAttribute]
public static RuntimeTypeHandle GetRuntimeTypeHandle(WellKnownType wkt);
}
internal class Internal.Runtime.VirtualInvokeTableEntry : ValueType {
    public static int GenericVirtualMethod;
    public static int FlagsMask;
}
internal static class Internal.Runtime.WritableData : object {
    public static int GetSize(int pointerSize);
    public static int GetAlignment(int pointerSize);
}
[ExtensionAttribute]
public static class Internal.TypeSystem.AlignmentHelper : object {
    [ExtensionAttribute]
public static int AlignUp(int val, int alignment);
}
public class Internal.TypeSystem.ArrayMethod : MethodDesc {
    private ArrayType _owningType;
    private ArrayMethodKind _kind;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public ArrayType OwningArray { get; }
    public ArrayMethodKind Kind { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    internal ArrayMethod(ArrayType owningType, ArrayMethodKind kind);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public ArrayType get_OwningArray();
    public ArrayMethodKind get_Kind();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual MethodNameAndSignature get_NameAndSignature();
}
public enum Internal.TypeSystem.ArrayMethodKind : Enum {
    public int value__;
    public static ArrayMethodKind Get;
    public static ArrayMethodKind Set;
    public static ArrayMethodKind Address;
    public static ArrayMethodKind AddressWithHiddenArg;
    public static ArrayMethodKind Ctor;
}
public class Internal.TypeSystem.ArrayOfTRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    private MetadataType _arrayOfTType;
    public ArrayOfTRuntimeInterfacesAlgorithm(MetadataType arrayOfTType);
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
}
public class Internal.TypeSystem.ArrayType : ParameterizedType {
    private int _rank;
    internal MethodDesc[] _methods;
    public DefType BaseType { get; }
    public TypeDesc ElementType { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public int Rank { get; }
    internal ArrayType(TypeDesc elementType, int rank);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual DefType get_BaseType();
    public TypeDesc get_ElementType();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public int get_Rank();
    private void InitializeMethods();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual IEnumerable`1<MethodDesc> GetVirtualMethods();
    public MethodDesc GetArrayMethod(ArrayMethodKind kind);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
public class Internal.TypeSystem.BaseTypeRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    private static RuntimeInterfacesAlgorithm _singleton;
    public static RuntimeInterfacesAlgorithm Instance { get; }
    private static BaseTypeRuntimeInterfacesAlgorithm();
    public static RuntimeInterfacesAlgorithm get_Instance();
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
}
public class Internal.TypeSystem.ByRefType : ParameterizedType {
    internal ByRefType(TypeDesc parameter);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
public abstract class Internal.TypeSystem.CanonBaseType : MetadataType {
    private TypeSystemContext _context;
    public TypeSystemContext Context { get; }
    public MetadataType MetadataBaseType { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsSequentialLayout { get; }
    public bool IsExplicitLayout { get; }
    public ModuleDesc Module { get; }
    public bool IsModuleType { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public CanonBaseType(TypeSystemContext context);
    public sealed virtual TypeSystemContext get_Context();
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MetadataType get_MetadataBaseType();
    public virtual DefType get_ContainingType();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsExplicitLayout();
    public virtual ModuleDesc get_Module();
    public virtual bool get_IsModuleType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual MetadataType GetNestedType(string name);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
}
public enum Internal.TypeSystem.CanonicalFormKind : Enum {
    public int value__;
    public static CanonicalFormKind Specific;
    public static CanonicalFormKind Universal;
    public static CanonicalFormKind Any;
}
internal class Internal.TypeSystem.CanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public bool IsSealed { get; }
    public DefType BaseType { get; }
    public CanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual bool get_IsSealed();
    private void Initialize();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class Internal.TypeSystem.CastingHelper : object {
    [ExtensionAttribute]
public static bool CanCastTo(TypeDesc thisType, TypeDesc otherType);
    private static TypeFlags GetReducedTypeElementType(TypeDesc type);
    private static TypeFlags GetVerificationTypeElementType(TypeDesc type);
    private static bool AreVerificationTypesEqual(TypeDesc type1, TypeDesc type2);
    private static bool IsMethodSignatureCompatibleWith(TypeDesc fn1Ttype, TypeDesc fn2Type);
    [ExtensionAttribute]
public static bool IsCompatibleWith(TypeDesc thisType, TypeDesc otherType);
    [ExtensionAttribute]
private static bool IsEquivalentTo(TypeDesc thisType, TypeDesc otherType);
    [ExtensionAttribute]
private static bool CanCastToInternal(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastGenericParameterTo(GenericParameterDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastArrayTo(ArrayType thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastParamTo(ParameterizedType thisType, TypeDesc paramType, StackOverflowProtect protect);
    private static bool IsConstrainedAsGCPointer(GenericParameterDesc type);
    private static TypeFlags GetNormalizedIntegralArrayElementType(TypeDesc type);
    public static bool IsArrayElementTypeCastableBySize(TypeDesc elementType);
    [ExtensionAttribute]
private static bool CanCastToClassOrInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToNonVariantInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastByVarianceToInterfaceOrDelegate(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protectInput);
    [ExtensionAttribute]
private static bool CanCastToClass(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool IsBoxedAndCanCastTo(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
}
public class Internal.TypeSystem.ClassLayoutMetadata : ValueType {
    public int PackingSize;
    public int Size;
    public FieldAndOffset[] Offsets;
}
public class Internal.TypeSystem.ComputedInstanceFieldLayout : ValueType {
    public LayoutInt FieldSize;
    public LayoutInt FieldAlignment;
    public LayoutInt ByteCountUnaligned;
    public LayoutInt ByteCountAlignment;
    public bool LayoutAbiStable;
    public bool IsAutoLayoutOrHasAutoLayoutFields;
    public bool IsInt128OrHasInt128Fields;
    public FieldAndOffset[] Offsets;
}
public class Internal.TypeSystem.ComputedStaticFieldLayout : ValueType {
    public StaticsBlock NonGcStatics;
    public StaticsBlock GcStatics;
    public StaticsBlock ThreadNonGcStatics;
    public StaticsBlock ThreadGcStatics;
    public FieldAndOffset[] Offsets;
}
[ExtensionAttribute]
public static class Internal.TypeSystem.ConstructedTypeRewritingHelpers : object {
    [ExtensionAttribute]
public static bool IsConstructedOverType(TypeDesc type, TypeDesc[] typesToFind);
    [ExtensionAttribute]
public static TypeDesc ReplaceTypesInConstructionOfType(TypeDesc type, TypeDesc[] typesToReplace, TypeDesc[] replacementTypes);
    [ExtensionAttribute]
public static MethodDesc ReplaceTypesInConstructionOfMethod(MethodDesc method, TypeDesc[] typesToReplace, TypeDesc[] replacementTypes);
}
public enum Internal.TypeSystem.DefaultInterfaceMethodResolution : Enum {
    public int value__;
    public static DefaultInterfaceMethodResolution None;
    public static DefaultInterfaceMethodResolution DefaultImplementation;
    public static DefaultInterfaceMethodResolution Reabstraction;
    public static DefaultInterfaceMethodResolution Diamond;
}
public abstract class Internal.TypeSystem.DefType : TypeDesc {
    private ThreadSafeFlags _fieldLayoutFlags;
    private LayoutInt _instanceFieldSize;
    private LayoutInt _instanceFieldAlignment;
    private LayoutInt _instanceByteCountUnaligned;
    private LayoutInt _instanceByteAlignment;
    private StaticBlockInfo _staticBlockInfo;
    private ValueTypeShapeCharacteristics _valueTypeShapeCharacteristics;
    internal static LayoutInt MaximumAlignmentPossible;
    public string Namespace { get; }
    public string Name { get; }
    public DefType ContainingType { get; }
    public bool ContainsGCPointers { get; }
    public bool IsUnsafeValueType { get; }
    public bool IsAutoLayoutOrHasAutoLayoutFields { get; }
    public bool IsInt128OrHasInt128Fields { get; }
    public LayoutInt InstanceFieldSize { get; }
    public LayoutInt InstanceFieldAlignment { get; }
    public LayoutInt InstanceByteCount { get; }
    public LayoutInt InstanceByteCountUnaligned { get; }
    public LayoutInt InstanceByteAlignment { get; }
    public bool IsZeroSizedReferenceType { get; }
    public bool LayoutAbiStable { get; }
    public LayoutInt NonGCStaticFieldSize { get; }
    public LayoutInt NonGCStaticFieldAlignment { get; }
    public LayoutInt GCStaticFieldSize { get; }
    public LayoutInt GCStaticFieldAlignment { get; }
    public LayoutInt ThreadNonGcStaticFieldSize { get; }
    public LayoutInt ThreadNonGcStaticFieldAlignment { get; }
    public LayoutInt ThreadGcStaticFieldSize { get; }
    public LayoutInt ThreadGcStaticFieldAlignment { get; }
    public ValueTypeShapeCharacteristics ValueTypeShapeCharacteristics { get; }
    public bool IsHomogeneousAggregate { get; }
    public bool HasNativeLayout { get; }
    private static DefType();
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual DefType get_ContainingType();
    public bool get_ContainsGCPointers();
    public bool get_IsUnsafeValueType();
    public virtual bool get_IsAutoLayoutOrHasAutoLayoutFields();
    public virtual bool get_IsInt128OrHasInt128Fields();
    public LayoutInt get_InstanceFieldSize();
    public LayoutInt get_InstanceFieldAlignment();
    public LayoutInt get_InstanceByteCount();
    public LayoutInt get_InstanceByteCountUnaligned();
    public LayoutInt get_InstanceByteAlignment();
    public bool get_IsZeroSizedReferenceType();
    public bool get_LayoutAbiStable();
    public LayoutInt get_NonGCStaticFieldSize();
    public LayoutInt get_NonGCStaticFieldAlignment();
    public LayoutInt get_GCStaticFieldSize();
    public LayoutInt get_GCStaticFieldAlignment();
    public LayoutInt get_ThreadNonGcStaticFieldSize();
    public LayoutInt get_ThreadNonGcStaticFieldAlignment();
    public LayoutInt get_ThreadGcStaticFieldSize();
    public LayoutInt get_ThreadGcStaticFieldAlignment();
    public ValueTypeShapeCharacteristics get_ValueTypeShapeCharacteristics();
    private void ComputeValueTypeShapeCharacteristics();
    public bool get_IsHomogeneousAggregate();
    public int GetHomogeneousAggregateElementSize();
    public void ComputeInstanceLayout(InstanceLayoutKind layoutKind);
    public void ComputeStaticFieldLayout(StaticLayoutKind layoutKind);
    public void ComputeTypeContainsGCPointers();
    public void ComputeIsUnsafeValueType();
    internal IEnumerable`1<FieldDesc> GetDiagnosticFields();
    public FieldDesc GetFieldByNativeLayoutOrdinal(UInt32 ordinal);
    public virtual bool get_HasNativeLayout();
}
public class Internal.TypeSystem.EmbeddedSignatureData : ValueType {
    public string index;
    public EmbeddedSignatureDataKind kind;
    public TypeDesc type;
}
public enum Internal.TypeSystem.EmbeddedSignatureDataKind : Enum {
    public int value__;
    public static EmbeddedSignatureDataKind RequiredCustomModifier;
    public static EmbeddedSignatureDataKind OptionalCustomModifier;
    public static EmbeddedSignatureDataKind ArrayShape;
}
public class Internal.TypeSystem.ExceptionTypeNameFormatter : TypeNameFormatter {
    [CompilerGeneratedAttribute]
private static ExceptionTypeNameFormatter <Instance>k__BackingField;
    public static ExceptionTypeNameFormatter Instance { get; }
    private static ExceptionTypeNameFormatter();
    [CompilerGeneratedAttribute]
public static ExceptionTypeNameFormatter get_Instance();
    public virtual void AppendName(StringBuilder sb, PointerType type);
    public virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    public virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public virtual void AppendName(StringBuilder sb, ByRefType type);
    public virtual void AppendName(StringBuilder sb, ArrayType type);
    protected virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    private static string GetTypeName(DefType type);
    private static string GetTypeNamespace(DefType type);
}
public class Internal.TypeSystem.ExplicitLayoutValidator : ValueType {
    private int _pointerSize;
    private List`1<FieldLayoutInterval> _fieldLayout;
    private MetadataType _typeBeingValidated;
    private ExplicitLayoutValidator(MetadataType type, int typeSizeInBytes);
    public static void Validate(MetadataType type, ComputedInstanceFieldLayout layout);
    private void AddToFieldLayout(int offset, TypeDesc fieldType);
    private void MarkByRefAndORefLocations(MetadataType type, List`1<FieldLayoutInterval> refMap, int offset);
    private void SetFieldLayout(List`1<FieldLayoutInterval> fieldLayoutInterval, int offset, int count, FieldLayoutTag tag);
    private void ValidateAndMergeIntervalWithFollowingIntervals(List`1<FieldLayoutInterval> fieldLayoutInterval, int intervalIndex);
    private void SetFieldLayout(int offset, int count, FieldLayoutTag tag);
    private void ThrowFieldLayoutError(int offset);
}
public class Internal.TypeSystem.FieldAndOffset : ValueType {
    public static LayoutInt InvalidOffset;
    public FieldDesc Field;
    public LayoutInt Offset;
    public FieldAndOffset(FieldDesc field, LayoutInt offset);
    private static FieldAndOffset();
}
public abstract class Internal.TypeSystem.FieldDesc : TypeSystemEntity {
    public static FieldDesc[] EmptyFields;
    private LayoutInt _offset;
    public string Name { get; }
    public DefType OwningType { get; }
    public TypeDesc FieldType { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    public bool IsTypicalFieldDefinition { get; }
    public LayoutInt Offset { get; }
    public bool HasGCStaticBase { get; }
    private static FieldDesc();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string get_Name();
    public abstract virtual DefType get_OwningType();
    public abstract virtual TypeDesc get_FieldType();
    public abstract virtual EmbeddedSignatureData[] GetEmbeddedSignatureData();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsThreadStatic();
    public abstract virtual bool get_HasRva();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
    public bool get_IsTypicalFieldDefinition();
    public virtual FieldDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public LayoutInt get_Offset();
    public bool get_HasGCStaticBase();
    internal void InitializeOffset(LayoutInt offset);
}
public class Internal.TypeSystem.FieldForInstantiatedType : FieldDesc {
    private FieldDesc _fieldDef;
    private InstantiatedType _instantiatedType;
    public TypeSystemContext Context { get; }
    public DefType OwningType { get; }
    public string Name { get; }
    public TypeDesc FieldType { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    internal FieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_OwningType();
    public virtual string get_Name();
    public virtual TypeDesc get_FieldType();
    public virtual EmbeddedSignatureData[] GetEmbeddedSignatureData();
    public virtual bool get_IsStatic();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsThreadStatic();
    public virtual bool get_HasRva();
    public virtual bool get_IsLiteral();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
}
public abstract class Internal.TypeSystem.FieldLayoutAlgorithm : object {
    public abstract virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public abstract virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public abstract virtual bool ComputeContainsGCPointers(DefType type);
    public abstract virtual bool ComputeIsUnsafeValueType(DefType type);
    public abstract virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
}
public class Internal.TypeSystem.FunctionPointerType : TypeDesc {
    private MethodSignature _signature;
    private int _hashCode;
    public MethodSignature Signature { get; }
    public TypeSystemContext Context { get; }
    internal FunctionPointerType(MethodSignature signature);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public MethodSignature get_Signature();
    public virtual TypeSystemContext get_Context();
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
[FlagsAttribute]
public enum Internal.TypeSystem.GenericConstraints : Enum {
    public int value__;
    public static GenericConstraints None;
    public static GenericConstraints ReferenceTypeConstraint;
    public static GenericConstraints NotNullableValueTypeConstraint;
    public static GenericConstraints DefaultConstructorConstraint;
    public static GenericConstraints AcceptByRefLike;
}
public abstract class Internal.TypeSystem.GenericParameterDesc : TypeDesc {
    public string Name { get; }
    public GenericParameterKind Kind { get; }
    public int Index { get; }
    public GenericVariance Variance { get; }
    public GenericConstraints Constraints { get; }
    public IEnumerable`1<TypeDesc> TypeConstraints { get; }
    public bool HasNotNullableValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool IsCovariant { get; }
    public bool IsContravariant { get; }
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected sealed virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Name();
    public abstract virtual GenericParameterKind get_Kind();
    public abstract virtual int get_Index();
    public virtual GenericVariance get_Variance();
    public virtual GenericConstraints get_Constraints();
    public virtual IEnumerable`1<TypeDesc> get_TypeConstraints();
    public bool get_HasNotNullableValueTypeConstraint();
    public bool get_HasReferenceTypeConstraint();
    public bool get_HasDefaultConstructorConstraint();
    public bool get_IsCovariant();
    public bool get_IsContravariant();
    protected sealed virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public sealed virtual int GetHashCode();
}
public enum Internal.TypeSystem.GenericParameterKind : Enum {
    public int value__;
    public static GenericParameterKind Type;
    public static GenericParameterKind Method;
}
public enum Internal.TypeSystem.GenericVariance : Enum {
    public int value__;
    public static GenericVariance None;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
}
public interface Internal.TypeSystem.IAssemblyDesc {
    public abstract virtual AssemblyName GetName();
}
public interface Internal.TypeSystem.IModuleResolver {
    public abstract virtual ModuleDesc ResolveAssembly(AssemblyName name, bool throwIfNotFound);
    public abstract virtual ModuleDesc ResolveModule(IAssemblyDesc referencingModule, string fileName, bool throwIfNotFound);
}
public enum Internal.TypeSystem.InstanceLayoutKind : Enum {
    public int value__;
    public static InstanceLayoutKind TypeOnly;
    public static InstanceLayoutKind TypeAndFields;
}
public class Internal.TypeSystem.InstantiatedMethod : MethodDesc {
    private InstantiatedMethod _specificCanonCache;
    private InstantiatedMethod _universalCanonCache;
    private MethodDesc _methodDef;
    private Instantiation _instantiation;
    private MethodSignature _signature;
    [CompilerGeneratedAttribute]
private bool <NeedsDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <RuntimeMethodDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericDictionary <Dictionary>k__BackingField;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsDefaultConstructor { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public bool NeedsDictionary { get; public set; }
    public IntPtr RuntimeMethodDictionary { get; private set; }
    internal GenericDictionary Dictionary { get; private set; }
    public bool UnboxingStub { get; }
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation, int hashcode);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    private InstantiatedMethod GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, InstantiatedMethod value);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    protected virtual int ComputeHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual bool get_IsDefaultConstructor();
    public virtual MethodDesc GetMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual string get_Name();
    public virtual MethodNameAndSignature get_NameAndSignature();
    protected virtual bool ComputeIsNonSharableMethod();
    [CompilerGeneratedAttribute]
public bool get_NeedsDictionary();
    [CompilerGeneratedAttribute]
public void set_NeedsDictionary(bool value);
    [CompilerGeneratedAttribute]
public IntPtr get_RuntimeMethodDictionary();
    [CompilerGeneratedAttribute]
private void set_RuntimeMethodDictionary(IntPtr value);
    [CompilerGeneratedAttribute]
internal GenericDictionary get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(GenericDictionary value);
    internal void SetGenericDictionary(GenericDictionary dictionary);
    public void AssociateWithRuntimeMethodDictionary(IntPtr rmd);
    public virtual bool get_UnboxingStub();
}
public class Internal.TypeSystem.InstantiatedType : MetadataType {
    private MetadataType _typeDef;
    private Instantiation _instantiation;
    private int _hashCode;
    private MetadataType _baseType;
    private DefType[] _implementedInterfaces;
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public DefType BaseType { get; }
    public MetadataType MetadataBaseType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsModuleType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public ModuleDesc Module { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    internal InstantiatedType(MetadataType typeDef, Instantiation instantiation);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual Instantiation get_Instantiation();
    private MetadataType InitializeBaseType();
    public virtual DefType get_BaseType();
    public virtual MetadataType get_MetadataBaseType();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual string get_Name();
    public virtual string get_Namespace();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetMethods>d__23")]
public virtual IEnumerable`1<MethodDesc> GetMethods();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetVirtualMethods>d__24")]
public virtual IEnumerable`1<MethodDesc> GetVirtualMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature, Instantiation substitution);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual MethodDesc GetFinalizer();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetFields>d__29")]
public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public static T[] InstantiateTypeArray(T[] uninstantiatedTypes, Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual bool get_IsExplicitLayout();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsModuleType();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual ModuleDesc get_Module();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual DefType get_ContainingType();
    public virtual MetadataType GetNestedType(string name);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    private DefType[] InitializeImplementedInterfaces();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    private MethodImplRecord[] InstantiateMethodImpls(MethodImplRecord[] uninstMethodImpls);
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
}
[DefaultMemberAttribute("GenericParameters")]
public class Internal.TypeSystem.Instantiation : ValueType {
    private TypeDesc[] _genericParameters;
    public static Instantiation Empty;
    public TypeDesc GenericParameters { get; }
    public int Length { get; }
    public bool IsNull { get; }
    public Instantiation(TypeDesc[] genericParameters);
    private static Instantiation();
    public TypeDesc get_GenericParameters(int index);
    public static ReadOnlySpan`1<TypeDesc> op_Implicit(Instantiation instantiation);
    public int get_Length();
    public bool get_IsNull();
    public int ComputeGenericInstanceHashCode(int genericDefinitionHashCode);
    public Enumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(Instantiation other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Internal.TypeSystem.LayoutInt : ValueType {
    private int _value;
    public static LayoutInt Indeterminate;
    public static LayoutInt Zero;
    public static LayoutInt One;
    public bool IsIndeterminate { get; }
    public int AsInt { get; }
    public LayoutInt(int input);
    private static LayoutInt();
    private static LayoutInt CreateIndeterminateLayoutInt();
    public bool get_IsIndeterminate();
    public int get_AsInt();
    public virtual string ToString();
    public string ToStringInvariant();
    public static bool op_Equality(LayoutInt left, LayoutInt right);
    public static bool op_Inequality(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Addition(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Subtraction(LayoutInt left, LayoutInt right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LayoutInt Max(LayoutInt left, LayoutInt right);
    public static LayoutInt Min(LayoutInt left, LayoutInt right);
    public static LayoutInt AlignUp(LayoutInt value, LayoutInt alignment, TargetDetails target);
}
public class Internal.TypeSystem.LockFreeObjectInterner : LockFreeReaderHashtableOfPointers`2<object, GCHandle> {
    private static LockFreeObjectInterner s_interner;
    private static LockFreeObjectInterner();
    public static GCHandle GetInternedObjectHandle(object obj);
    protected virtual int GetKeyHashCode(object key);
    protected virtual int GetValueHashCode(GCHandle value);
    protected virtual bool CompareKeyToValue(object key, GCHandle value);
    protected virtual bool CompareValueToValue(GCHandle value1, GCHandle value2);
    protected virtual GCHandle CreateValueFromKey(object key);
    protected virtual IntPtr ConvertValueToIntPtr(GCHandle value);
    protected virtual GCHandle ConvertIntPtrToValue(IntPtr pointer);
}
public abstract class Internal.TypeSystem.LockFreeReaderHashtableOfPointers`2 : object {
    private static int _initialSize;
    private static int _fillPercentageBeforeResize;
    private IntPtr[] modreq(System.Runtime.CompilerServices.IsVolatile) _hashtable;
    private IntPtr[] modreq(System.Runtime.CompilerServices.IsVolatile) _newHashTable;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _count;
    private int _reserve;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _resizeCount;
    public int Count { get; }
    private IntPtr[] GetCurrentHashtable();
    private void SetCurrentHashtable(IntPtr[] hashtable);
    public static int HashInt1(int key);
    public static int HashInt2(int key);
    public int get_Count();
    public bool TryGetValue(TKey key, TValue& value);
    private static IntPtr WaitForSentinelInHashtableToDisappear(IntPtr[] hashtable, int tableIndex);
    private void Expand(IntPtr[] oldHashtable);
    public void Reserve(int size);
    public bool TryAdd(TValue value);
    public TValue AddOrGetExisting(TValue value);
    private TValue AddOrGetExistingInner(TValue value, Boolean& addedValue);
    private static IntPtr VolatileReadNonSentinelFromHashtable(IntPtr[] hashTable, int tableIndex);
    private bool TryAddOrGetExisting(TValue value, Boolean& addedValue, TValue& valueInHashtable);
    private static bool TryWriteSentinelToLocation(IntPtr[] hashTableLocal, int tableIndex);
    private static void WriteValueToLocation(IntPtr value, IntPtr[] hashTableLocal, int tableIndex);
    private static void WriteAbortNullToLocation(IntPtr[] hashTableLocal, int tableIndex);
    private TValue CreateValueAndEnsureValueIsInTable(TKey key);
    public TValue GetOrCreateValue(TKey key);
    public bool Contains(TKey key);
    public TValue GetValueIfExists(TValue value);
    protected abstract virtual int GetKeyHashCode(TKey key);
    protected abstract virtual int GetValueHashCode(TValue value);
    protected abstract virtual bool CompareKeyToValue(TKey key, TValue value);
    protected abstract virtual bool CompareValueToValue(TValue value1, TValue value2);
    protected abstract virtual TValue CreateValueFromKey(TKey key);
    protected abstract virtual IntPtr ConvertValueToIntPtr(TValue value);
    protected abstract virtual TValue ConvertIntPtrToValue(IntPtr pointer);
}
public class Internal.TypeSystem.MarshalAsDescriptor : object {
    private TypeDesc _marshallerType;
    private string _cookie;
    [CompilerGeneratedAttribute]
private NativeTypeKind <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NativeTypeKind <ArraySubType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <SizeParamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <SizeConst>k__BackingField;
    public NativeTypeKind Type { get; }
    public NativeTypeKind ArraySubType { get; }
    public Nullable`1<UInt32> SizeParamIndex { get; }
    public Nullable`1<UInt32> SizeConst { get; }
    public TypeDesc MarshallerType { get; }
    public string Cookie { get; }
    public MarshalAsDescriptor(NativeTypeKind type, NativeTypeKind arraySubType, Nullable`1<UInt32> sizeParamIndex, Nullable`1<UInt32> sizeConst, TypeDesc customMarshallerType, string cookie);
    [CompilerGeneratedAttribute]
public NativeTypeKind get_Type();
    [CompilerGeneratedAttribute]
public NativeTypeKind get_ArraySubType();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_SizeParamIndex();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_SizeConst();
    public TypeDesc get_MarshallerType();
    public string get_Cookie();
}
public abstract class Internal.TypeSystem.MetadataType : DefType {
    private MethodImplRecord[] _allVirtualMethodImplsForType;
    public string Name { get; }
    public string Namespace { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsModuleType { get; }
    public ModuleDesc Module { get; }
    public MetadataType MetadataBaseType { get; }
    public DefType BaseType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public MethodImplRecord[] VirtualMethodImplsForType { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public abstract virtual ClassLayoutMetadata GetClassLayout();
    public abstract virtual bool get_IsExplicitLayout();
    public abstract virtual bool get_IsSequentialLayout();
    public abstract virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsModuleType();
    public abstract virtual ModuleDesc get_Module();
    public abstract virtual MetadataType get_MetadataBaseType();
    public abstract virtual DefType get_BaseType();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public abstract virtual DefType get_ContainingType();
    public abstract virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public abstract virtual MetadataType GetNestedType(string name);
    public abstract virtual DefType[] get_ExplicitlyImplementedInterfaces();
    protected abstract virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public MethodImplRecord[] get_VirtualMethodImplsForType();
    public abstract virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    public abstract virtual PInvokeStringFormat get_PInvokeStringFormat();
}
public abstract class Internal.TypeSystem.MethodDesc : TypeSystemEntity {
    public static MethodDesc[] EmptyMethods;
    private int _hashcode;
    private IntPtr _functionPointer;
    private IntPtr _usgFunctionPointer;
    private Nullable`1<bool> _isNonSharableCache;
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public bool IsConstructor { get; }
    public bool IsDefaultConstructor { get; }
    public bool IsStaticConstructor { get; }
    public string Name { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsMethodDefinition { get; }
    public bool IsTypicalMethodDefinition { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsFinalizer { get; }
    public IntPtr FunctionPointer { get; }
    public IntPtr UsgFunctionPointer { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public bool IsNonSharableMethod { get; }
    public bool UnboxingStub { get; }
    private static MethodDesc();
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    protected void SetHashCode(int hashcode);
    public sealed virtual int GetHashCode();
    private int AcquireHashCode();
    protected virtual int ComputeHashCode();
    public virtual bool Equals(object o);
    public abstract virtual TypeDesc get_OwningType();
    public abstract virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    public bool get_IsConstructor();
    public virtual bool get_IsDefaultConstructor();
    public bool get_IsStaticConstructor();
    public virtual string get_Name();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetMethodDefinition();
    public bool get_IsMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public bool get_IsTypicalMethodDefinition();
    public bool get_IsGenericMethodDefinition();
    public bool get_IsFinalizer();
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public void SetFunctionPointer(IntPtr functionPointer, bool isFunctionPointerUSG);
    public IntPtr get_FunctionPointer();
    public IntPtr get_UsgFunctionPointer();
    public abstract virtual MethodNameAndSignature get_NameAndSignature();
    public virtual bool get_IsNonSharableMethod();
    protected virtual bool ComputeIsNonSharableMethod();
    public virtual bool get_UnboxingStub();
}
public class Internal.TypeSystem.MethodForInstantiatedType : MethodDesc {
    private MethodDesc _typicalMethodDef;
    private InstantiatedType _instantiatedType;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsDefaultConstructor { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType, int hashcode);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual bool get_IsDefaultConstructor();
    public virtual string get_Name();
    public virtual MethodNameAndSignature get_NameAndSignature();
}
public class Internal.TypeSystem.MethodImplRecord : ValueType {
    public MethodDesc Decl;
    public MethodDesc Body;
    public MethodImplRecord(MethodDesc decl, MethodDesc body);
}
[DefaultMemberAttribute("Parameter")]
public class Internal.TypeSystem.MethodSignature : TypeSystemEntity {
    internal MethodSignatureFlags _flags;
    internal int _genericParameterCount;
    internal TypeDesc _returnType;
    internal TypeDesc[] _parameters;
    internal EmbeddedSignatureData[] _embeddedSignatureData;
    public static string IndexOfCustomModifiersOnReturnType;
    public static EmbeddedSignatureData[] EmbeddedSignatureMismatchPermittedFlag;
    public MethodSignatureFlags Flags { get; }
    public bool IsStatic { get; }
    public int GenericParameterCount { get; }
    public TypeDesc ReturnType { get; }
    public TypeDesc Parameter { get; }
    public int Length { get; }
    public bool HasEmbeddedSignatureData { get; }
    public bool EmbeddedSignatureMismatchPermitted { get; }
    public TypeSystemContext Context { get; }
    public MethodSignature(MethodSignatureFlags flags, int genericParameterCount, TypeDesc returnType, TypeDesc[] parameters, EmbeddedSignatureData[] embeddedSignatureData);
    private static MethodSignature();
    public static string GetIndexOfCustomModifierOnPointedAtTypeByParameterIndex(int parameterIndex);
    public MethodSignature ApplySubstitution(Instantiation substitution);
    public MethodSignatureFlags get_Flags();
    public bool get_IsStatic();
    public int get_GenericParameterCount();
    public TypeDesc get_ReturnType();
    public TypeDesc get_Parameter(int index);
    public int get_Length();
    public bool get_HasEmbeddedSignatureData();
    public bool get_EmbeddedSignatureMismatchPermitted();
    public EmbeddedSignatureData[] GetEmbeddedSignatureData();
    public sealed virtual bool Equals(MethodSignature otherSignature);
    public bool EqualsWithCovariantReturnType(MethodSignature otherSignature);
    private bool Equals(MethodSignature otherSignature, bool allowCovariantReturn);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SignatureEnumerator GetEnumerator();
    public virtual TypeSystemContext get_Context();
}
[DefaultMemberAttribute("Parameter")]
public class Internal.TypeSystem.MethodSignatureBuilder : ValueType {
    private MethodSignature _template;
    private MethodSignatureFlags _flags;
    private int _genericParameterCount;
    private TypeDesc _returnType;
    private TypeDesc[] _parameters;
    private EmbeddedSignatureData[] _embeddedSignatureData;
    unknown MethodSignatureFlags Flags {public set; }
    unknown TypeDesc ReturnType {public set; }
    unknown TypeDesc Parameter {public set; }
    unknown int Length {public set; }
    public MethodSignatureBuilder(MethodSignature template);
    public void set_Flags(MethodSignatureFlags value);
    public void set_ReturnType(TypeDesc value);
    public void set_Parameter(int index, TypeDesc value);
    public void set_Length(int value);
    public void SetEmbeddedSignatureData(EmbeddedSignatureData[] embeddedSignatureData);
    public MethodSignature ToSignature();
}
[FlagsAttribute]
public enum Internal.TypeSystem.MethodSignatureFlags : Enum {
    public int value__;
    public static MethodSignatureFlags None;
    public static MethodSignatureFlags UnmanagedCallingConventionMask;
    public static MethodSignatureFlags UnmanagedCallingConventionCdecl;
    public static MethodSignatureFlags UnmanagedCallingConventionStdCall;
    public static MethodSignatureFlags UnmanagedCallingConventionThisCall;
    public static MethodSignatureFlags CallingConventionVarargs;
    public static MethodSignatureFlags UnmanagedCallingConvention;
    public static MethodSignatureFlags Static;
}
public abstract class Internal.TypeSystem.ModuleDesc : TypeSystemEntity {
    [CompilerGeneratedAttribute]
private TypeSystemContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblyDesc <Assembly>k__BackingField;
    public TypeSystemContext Context { get; }
    public IAssemblyDesc Assembly { get; }
    public ModuleDesc(TypeSystemContext context, IAssemblyDesc assembly);
    [CompilerGeneratedAttribute]
public virtual TypeSystemContext get_Context();
    [CompilerGeneratedAttribute]
public virtual IAssemblyDesc get_Assembly();
    public MetadataType GetType(string nameSpace, string name, bool throwIfNotFound);
    public abstract virtual object GetType(string nameSpace, string name, NotFoundBehavior notFoundBehavior);
    public abstract virtual MetadataType GetGlobalModuleType();
    public abstract virtual IEnumerable`1<MetadataType> GetAllTypes();
}
public enum Internal.TypeSystem.NativeTypeKind : Enum {
    public byte value__;
    public static NativeTypeKind Boolean;
    public static NativeTypeKind I1;
    public static NativeTypeKind U1;
    public static NativeTypeKind I2;
    public static NativeTypeKind U2;
    public static NativeTypeKind I4;
    public static NativeTypeKind U4;
    public static NativeTypeKind I8;
    public static NativeTypeKind U8;
    public static NativeTypeKind R4;
    public static NativeTypeKind R8;
    public static NativeTypeKind Currency;
    public static NativeTypeKind BStr;
    public static NativeTypeKind LPStr;
    public static NativeTypeKind LPWStr;
    public static NativeTypeKind LPTStr;
    public static NativeTypeKind ByValTStr;
    public static NativeTypeKind IUnknown;
    public static NativeTypeKind IDispatch;
    public static NativeTypeKind Struct;
    public static NativeTypeKind Intf;
    public static NativeTypeKind SafeArray;
    public static NativeTypeKind ByValArray;
    public static NativeTypeKind SysInt;
    public static NativeTypeKind SysUInt;
    public static NativeTypeKind AnsiBStr;
    public static NativeTypeKind TBStr;
    public static NativeTypeKind VariantBool;
    public static NativeTypeKind Func;
    public static NativeTypeKind AsAny;
    public static NativeTypeKind Array;
    public static NativeTypeKind LPStruct;
    public static NativeTypeKind CustomMarshaler;
    public static NativeTypeKind LPUTF8Str;
    public static NativeTypeKind Default;
    public static NativeTypeKind Variant;
}
internal abstract class Internal.TypeSystem.NoMetadata.NoMetadataMethodDesc : MethodDesc {
}
internal class Internal.TypeSystem.NoMetadata.NoMetadataType : DefType {
    private TypeSystemContext _context;
    private int _hashcode;
    private RuntimeTypeHandle _genericTypeDefinition;
    private DefType _genericTypeDefinitionAsDefType;
    private Instantiation _instantiation;
    private DefType _baseType;
    public TypeSystemContext Context { get; }
    public DefType BaseType { get; }
    public Instantiation Instantiation { get; }
    public TypeDesc UnderlyingType { get; }
    public string NamespaceForDiagnostics { get; }
    public string NameForDiagnostics { get; }
    public string DiagnosticModuleName { get; }
    public NoMetadataType(TypeSystemContext context, RuntimeTypeHandle genericTypeDefinition, DefType genericTypeDefinitionAsDefType, Instantiation instantiation, int hashcode);
    public virtual int GetHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_BaseType();
    internal virtual void ParseBaseType(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser baseTypeParser);
    public void SetBaseType(DefType baseType);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual TypeDesc GetTypeDefinition();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual Instantiation get_Instantiation();
    public virtual TypeDesc get_UnderlyingType();
    private void GetTypeNameHelper(String& name, String& nsName, String& assemblyName);
    public string get_NamespaceForDiagnostics();
    public string get_NameForDiagnostics();
    public string get_DiagnosticModuleName();
}
internal class Internal.TypeSystem.NoMetadata.RuntimeMethodDesc : NoMetadataMethodDesc {
    private Instantiation _instantiation;
    private TypeDesc _owningType;
    private MethodNameAndSignature _nameAndSignature;
    private bool _unboxingStub;
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public string Name { get; }
    public bool UnboxingStub { get; }
    public RuntimeMethodDesc(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, int hashcode);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual Instantiation get_Instantiation();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual MethodNameAndSignature get_NameAndSignature();
    public virtual string get_Name();
    public virtual bool get_UnboxingStub();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
public enum Internal.TypeSystem.NotFoundBehavior : Enum {
    public int value__;
    public static NotFoundBehavior Throw;
    public static NotFoundBehavior ReturnNull;
    public static NotFoundBehavior ReturnResolutionFailure;
}
public abstract class Internal.TypeSystem.ParameterizedType : TypeDesc {
    private TypeDesc _parameterType;
    public TypeDesc ParameterType { get; }
    public TypeSystemContext Context { get; }
    internal ParameterizedType(TypeDesc parameterType);
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public TypeDesc get_ParameterType();
    public virtual TypeSystemContext get_Context();
}
public enum Internal.TypeSystem.PInvokeStringFormat : Enum {
    public int value__;
    public static PInvokeStringFormat AnsiClass;
    public static PInvokeStringFormat UnicodeClass;
    public static PInvokeStringFormat AutoClass;
}
public class Internal.TypeSystem.PointerType : ParameterizedType {
    internal PointerType(TypeDesc parameterType);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
public class Internal.TypeSystem.ResolutionFailure : object {
    private FailureType _failureType;
    private string _namespace;
    private string _name;
    private string _moduleName;
    private ModuleDesc _module;
    private TypeDesc _owningType;
    private MethodSignature _methodSignature;
    public static ResolutionFailure GetTypeLoadResolutionFailure(string nestedTypeName, ModuleDesc module);
    public static ResolutionFailure GetTypeLoadResolutionFailure(string namespace, string name, ModuleDesc module);
    public static ResolutionFailure GetTypeLoadResolutionFailure(string namespace, string name, string moduleName);
    public static ResolutionFailure GetMissingMethodFailure(TypeDesc owningType, string methodName, MethodSignature signature);
    public static ResolutionFailure GetMissingFieldFailure(TypeDesc owningType, string fieldName);
    public static ResolutionFailure GetAssemblyResolutionFailure(string simpleName);
    public void Throw();
}
public abstract class Internal.TypeSystem.RuntimeInterfacesAlgorithm : object {
    public abstract virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
}
public class Internal.TypeSystem.SignatureMethodVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    internal SignatureMethodVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public class Internal.TypeSystem.SignatureTypeVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    internal SignatureTypeVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public abstract class Internal.TypeSystem.SignatureVariable : TypeDesc {
    private TypeSystemContext _context;
    private int _index;
    public int Index { get; }
    public TypeSystemContext Context { get; }
    public bool IsMethodSignatureVariable { get; }
    internal SignatureVariable(TypeSystemContext context, int index);
    public int get_Index();
    public virtual TypeSystemContext get_Context();
    public abstract virtual bool get_IsMethodSignatureVariable();
}
public static class Internal.TypeSystem.StandardCanonicalizationAlgorithm : object {
    public static Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    public static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    private static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind& kind);
}
public enum Internal.TypeSystem.StaticLayoutKind : Enum {
    public int value__;
    public static StaticLayoutKind StaticRegionSizes;
    public static StaticLayoutKind StaticRegionSizesAndFields;
}
public class Internal.TypeSystem.StaticsBlock : ValueType {
    public LayoutInt Size;
    public LayoutInt LargestAlignment;
}
public enum Internal.TypeSystem.TargetAbi : Enum {
    public int value__;
    public static TargetAbi Unknown;
    public static TargetAbi NativeAot;
    public static TargetAbi NativeAotArmel;
    public static TargetAbi Jit;
    public static TargetAbi CppCodegen;
}
public enum Internal.TypeSystem.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture Unknown;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARM64;
    public static TargetArchitecture X64;
    public static TargetArchitecture X86;
    public static TargetArchitecture Wasm32;
    public static TargetArchitecture LoongArch64;
}
public class Internal.TypeSystem.TargetDetails : object {
    [CompilerGeneratedAttribute]
private TargetArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetOS <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetAbi <Abi>k__BackingField;
    public TargetArchitecture Architecture { get; }
    public TargetOS OperatingSystem { get; }
    public TargetAbi Abi { get; }
    public int PointerSize { get; }
    public bool SupportsRelativePointers { get; }
    public int MaximumAlignment { get; }
    public LayoutInt LayoutPointerSize { get; }
    public int DefaultPackingSize { get; }
    public int MinimumFunctionAlignment { get; }
    public int OptimumFunctionAlignment { get; }
    public int MinimumCodeAlignment { get; }
    public static int MaximumLog2PrimitiveSize { get; }
    public static int MaximumPrimitiveSize { get; }
    public bool IsWindows { get; }
    public bool IsOSX { get; }
    public int MaxHomogeneousAggregateElementCount { get; }
    public TargetDetails(TargetArchitecture architecture, TargetOS targetOS, TargetAbi abi);
    [CompilerGeneratedAttribute]
public TargetArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
public TargetOS get_OperatingSystem();
    [CompilerGeneratedAttribute]
public TargetAbi get_Abi();
    public int get_PointerSize();
    public bool get_SupportsRelativePointers();
    public int get_MaximumAlignment();
    public LayoutInt get_LayoutPointerSize();
    public int get_DefaultPackingSize();
    public int get_MinimumFunctionAlignment();
    public int get_OptimumFunctionAlignment();
    public int get_MinimumCodeAlignment();
    public static int get_MaximumLog2PrimitiveSize();
    public static int get_MaximumPrimitiveSize();
    public LayoutInt GetWellKnownTypeSize(DefType type);
    public LayoutInt GetWellKnownTypeAlignment(DefType type);
    public LayoutInt GetObjectAlignment(LayoutInt fieldAlignment);
    public bool get_IsWindows();
    public bool get_IsOSX();
    public int get_MaxHomogeneousAggregateElementCount();
}
public enum Internal.TypeSystem.TargetOS : Enum {
    public int value__;
    public static TargetOS Unknown;
    public static TargetOS Windows;
    public static TargetOS Linux;
    public static TargetOS OSX;
    public static TargetOS FreeBSD;
    public static TargetOS NetBSD;
    public static TargetOS SunOS;
    public static TargetOS WebAssembly;
}
public class Internal.TypeSystem.ThreadSafeFlags : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public int Value { get; }
    public int get_Value();
    public bool HasFlags(int value);
    public void AddFlags(int flagsToAdd);
}
public static class Internal.TypeSystem.ThrowHelper : object {
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string nestedTypeName, ModuleDesc module);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string namespace, string name, ModuleDesc module);
    public static void ThrowTypeLoadException(string namespace, string name, string moduleName);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(TypeDesc type);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, MethodDesc method);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type, string messageArg);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type);
    private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName, string messageArg);
    private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName);
    public static void ThrowMissingMethodException(TypeDesc owningType, string methodName, MethodSignature signature);
    public static void ThrowMissingFieldException(TypeDesc owningType, string fieldName);
    public static void ThrowFileNotFoundException(ExceptionStringID id, string fileName);
    public static void ThrowInvalidProgramException();
    public static void ThrowInvalidProgramException(ExceptionStringID id, MethodDesc method);
    public static void ThrowBadImageFormatException();
}
public abstract class Internal.TypeSystem.TypeDesc : TypeSystemEntity {
    private TypeDesc _specificCanonCache;
    private TypeDesc _universalCanonCache;
    public static TypeDesc[] EmptyTypes;
    private TypeFlags _typeFlags;
    private DefType[] _runtimeInterfaces;
    private RuntimeTypeHandle _runtimeTypeHandle;
    private NativeLayoutFieldDesc[] _nativeLayoutFields;
    [CompilerGeneratedAttribute]
private TypeBuilderState <TypeBuilderState>k__BackingField;
    internal bool IsCanonicalType { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public TypeFlags Category { get; }
    public bool IsInterface { get; }
    public bool IsValueType { get; }
    public bool IsPrimitive { get; }
    public bool IsPrimitiveNumeric { get; }
    public bool IsEnum { get; }
    public bool IsDelegate { get; }
    public bool IsVoid { get; }
    public bool IsString { get; }
    public bool IsObject { get; }
    public bool IsTypedReference { get; }
    public bool IsNullable { get; }
    public bool IsArray { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsFunctionPointer { get; }
    public bool IsSignatureVariable { get; }
    public bool IsGenericParameter { get; }
    public bool IsParameterizedType { get; }
    public bool IsDefType { get; }
    public bool IsGCPointer { get; }
    public DefType BaseType { get; }
    public bool HasBaseType { get; }
    public TypeDesc UnderlyingType { get; }
    public bool HasStaticConstructor { get; }
    public bool IsTypeDefinition { get; }
    public bool HasFinalizer { get; }
    public bool HasVariance { get; }
    public bool IsGenericDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsIDynamicInterfaceCastable { get; }
    public DefType[] RuntimeInterfaces { get; }
    public RuntimeTypeHandle RuntimeTypeHandle { get; }
    internal NativeLayoutFieldDesc[] NativeLayoutFields { get; internal set; }
    internal TypeBuilderState TypeBuilderState { get; internal set; }
    private static TypeDesc();
    private TypeDesc GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, TypeDesc value);
    public TypeDesc ConvertToCanonForm(CanonicalFormKind kind);
    protected abstract virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public abstract virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    internal bool get_IsCanonicalType();
    public abstract virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    internal void SetWellKnownType(WellKnownType wellKnownType);
    protected abstract virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    private TypeFlags InitializeTypeFlags(TypeFlags mask);
    protected internal TypeFlags GetTypeFlags(TypeFlags mask);
    public TypeFlags get_Category();
    public bool get_IsInterface();
    public bool get_IsValueType();
    public bool get_IsPrimitive();
    public bool get_IsPrimitiveNumeric();
    public bool get_IsEnum();
    public bool get_IsDelegate();
    public bool get_IsVoid();
    public bool get_IsString();
    public bool get_IsObject();
    public bool get_IsTypedReference();
    public bool get_IsNullable();
    public bool get_IsArray();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public bool get_IsByRef();
    public bool get_IsPointer();
    public bool get_IsFunctionPointer();
    public bool get_IsSignatureVariable();
    public bool get_IsGenericParameter();
    public bool get_IsParameterizedType();
    public bool get_IsDefType();
    public bool get_IsGCPointer();
    public virtual DefType get_BaseType();
    public bool get_HasBaseType();
    public virtual TypeDesc get_UnderlyingType();
    public bool get_HasStaticConstructor();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    [IteratorStateMachineAttribute("Internal.TypeSystem.TypeDesc/<GetVirtualMethods>d__76")]
public virtual IEnumerable`1<MethodDesc> GetVirtualMethods();
    public MethodDesc GetMethod(string name, MethodSignature signature);
    public virtual MethodDesc GetMethod(string name, MethodSignature signature, Instantiation substitution);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public bool get_IsTypeDefinition();
    public bool HasSameTypeDefinition(TypeDesc otherType);
    public bool get_HasFinalizer();
    public virtual MethodDesc GetFinalizer();
    public bool get_HasVariance();
    public bool get_IsGenericDefinition();
    public bool get_IsByRefLike();
    public bool get_IsIDynamicInterfaceCastable();
    public DefType[] get_RuntimeInterfaces();
    private DefType[] InitializeRuntimeInterfaces();
    public RuntimeTypeHandle get_RuntimeTypeHandle();
    public void SetRuntimeTypeHandleUnsafe(RuntimeTypeHandle runtimeTypeHandle);
    public RuntimeTypeHandle GetRuntimeTypeHandle();
    internal NativeLayoutFieldDesc[] get_NativeLayoutFields();
    internal void set_NativeLayoutFields(NativeLayoutFieldDesc[] value);
    [CompilerGeneratedAttribute]
internal TypeBuilderState get_TypeBuilderState();
    [CompilerGeneratedAttribute]
internal void set_TypeBuilderState(TypeBuilderState value);
    internal bool RetrieveRuntimeTypeHandleIfPossible();
    internal TypeBuilderState GetTypeBuilderStateIfExist();
    internal TypeBuilderState GetTypeBuilderState();
    internal TypeBuilderState GetOrCreateTypeBuilderState();
    internal virtual void ParseBaseType(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser baseTypeParser);
    internal TypeDesc ComputeTemplate(bool templateRequired);
    internal static TypeDesc ComputeTemplate(TypeBuilderState state, bool templateRequired);
    internal bool IsTemplateUniversal();
    internal bool IsTemplateCanonical();
}
[FlagsAttribute]
public enum Internal.TypeSystem.TypeFlags : Enum {
    public int value__;
    public static TypeFlags CategoryMask;
    public static TypeFlags Unknown;
    public static TypeFlags Void;
    public static TypeFlags Boolean;
    public static TypeFlags Char;
    public static TypeFlags SByte;
    public static TypeFlags Byte;
    public static TypeFlags Int16;
    public static TypeFlags UInt16;
    public static TypeFlags Int32;
    public static TypeFlags UInt32;
    public static TypeFlags Int64;
    public static TypeFlags UInt64;
    public static TypeFlags IntPtr;
    public static TypeFlags UIntPtr;
    public static TypeFlags Single;
    public static TypeFlags Double;
    public static TypeFlags ValueType;
    public static TypeFlags Enum;
    public static TypeFlags Nullable;
    public static TypeFlags Class;
    public static TypeFlags Interface;
    public static TypeFlags Array;
    public static TypeFlags SzArray;
    public static TypeFlags ByRef;
    public static TypeFlags Pointer;
    public static TypeFlags FunctionPointer;
    public static TypeFlags GenericParameter;
    public static TypeFlags SignatureTypeVariable;
    public static TypeFlags SignatureMethodVariable;
    public static TypeFlags HasGenericVariance;
    public static TypeFlags HasGenericVarianceComputed;
    public static TypeFlags HasStaticConstructor;
    public static TypeFlags HasStaticConstructorComputed;
    public static TypeFlags HasFinalizerComputed;
    public static TypeFlags HasFinalizer;
    public static TypeFlags IsByRefLike;
    public static TypeFlags AttributeCacheComputed;
    public static TypeFlags IsIntrinsic;
    public static TypeFlags IsIDynamicInterfaceCastable;
    public static TypeFlags IsIDynamicInterfaceCastableComputed;
}
public abstract class Internal.TypeSystem.TypeNameFormatter : object {
    public void AppendName(StringBuilder sb, TypeDesc type);
    public void AppendName(StringBuilder sb, DefType type);
    public abstract virtual void AppendName(StringBuilder sb, ArrayType type);
    public abstract virtual void AppendName(StringBuilder sb, ByRefType type);
    public abstract virtual void AppendName(StringBuilder sb, PointerType type);
    public abstract virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public abstract virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    protected abstract virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    protected abstract virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected abstract virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    public string FormatName(TypeDesc type);
}
public abstract class Internal.TypeSystem.TypeNameFormatter`2 : object {
    public TState AppendName(StringBuilder sb, TypeDesc type, TOptions options);
    public TState AppendName(StringBuilder sb, DefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ArrayType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ByRefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, PointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, FunctionPointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, GenericParameterDesc type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureMethodVariable type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureTypeVariable type, TOptions options);
    protected abstract virtual TState AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType, TOptions options);
    protected abstract virtual TState AppendNameForNamespaceType(StringBuilder sb, DefType type, TOptions options);
    protected abstract virtual TState AppendNameForInstantiatedType(StringBuilder sb, DefType type, TOptions options);
    protected virtual DefType GetContainingType(DefType possibleInnerType, TOptions options);
    public string FormatName(TypeDesc type, TOptions options);
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.TypeNameHelper : object {
    [ExtensionAttribute]
public static T WithDebugName(T type);
}
public abstract class Internal.TypeSystem.TypeSystemContext : object {
    private CanonType _canonType;
    private UniversalCanonType _universalCanonType;
    [CompilerGeneratedAttribute]
private TargetDetails <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleDesc <SystemModule>k__BackingField;
    private ArrayTypeKeyHashtable _arrayTypes;
    private ByRefHashtable _byRefTypes;
    private PointerHashtable _pointerTypes;
    private FunctionPointerHashtable _functionPointerTypes;
    private InstantiatedTypeKeyHashtable _instantiatedTypes;
    private InstantiatedMethodKeyHashtable _instantiatedMethods;
    private MethodForInstantiatedTypeKeyHashtable _methodForInstantiatedTypes;
    private FieldForInstantiatedTypeKeyHashtable _fieldForInstantiatedTypes;
    private SignatureVariableHashtable _signatureVariables;
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable[] s_ArrayTypesCaches;
    [CompilerGeneratedAttribute]
private static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable <PointerTypesCache>k__BackingField;
    [CompilerGeneratedAttribute]
private static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable <ByRefTypesCache>k__BackingField;
    private LowLevelDictionary`2<RuntimeTypeHandle, TypeDesc> _runtimeTypeHandleResolutionCache;
    private RuntimeMethodKeyHashtable _runtimeMethods;
    private LowLevelDictionary`2<GenericTypeInstanceKey, DefType> _genericTypeInstances;
    private LowLevelList`1<TypeDesc> _typesToFlushTypeSystemStateFrom;
    public CanonBaseType CanonType { get; }
    public CanonBaseType UniversalCanonType { get; }
    public bool SupportsCanon { get; }
    public bool SupportsUniversalCanon { get; }
    public TargetDetails Target { get; }
    public ModuleDesc SystemModule { get; private set; }
    internal static TemplateLocator TemplateLookup { get; }
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable PointerTypesCache { get; }
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable ByRefTypesCache { get; }
    public int LoadFactor { get; }
    public TypeSystemContext(TargetDetails target);
    private static TypeSystemContext();
    public CanonBaseType get_CanonType();
    public CanonBaseType get_UniversalCanonType();
    public bool IsCanonicalDefinitionType(TypeDesc type, CanonicalFormKind kind);
    public Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind);
    protected internal virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    public abstract virtual bool get_SupportsCanon();
    public abstract virtual bool get_SupportsUniversalCanon();
    public MetadataType GetCanonType(string name);
    [CompilerGeneratedAttribute]
public TargetDetails get_Target();
    [CompilerGeneratedAttribute]
public ModuleDesc get_SystemModule();
    [CompilerGeneratedAttribute]
private void set_SystemModule(ModuleDesc value);
    protected void InitializeSystemModule(ModuleDesc systemModule);
    public abstract virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    public virtual ModuleDesc ResolveAssembly(AssemblyName name, bool throwIfNotFound);
    internal virtual ModuleDesc ResolveModule(IAssemblyDesc referencingModule, string fileName, bool throwIfNotFound);
    private sealed virtual override ModuleDesc Internal.TypeSystem.IModuleResolver.ResolveModule(IAssemblyDesc referencingModule, string fileName, bool throwIfNotFound);
    public ArrayType GetArrayType(TypeDesc elementType);
    public ArrayType GetArrayType(TypeDesc elementType, int rank);
    public ByRefType GetByRefType(TypeDesc parameterType);
    public PointerType GetPointerType(TypeDesc parameterType);
    public FunctionPointerType GetFunctionPointerType(MethodSignature signature);
    public InstantiatedType GetInstantiatedType(MetadataType typeDef, Instantiation instantiation);
    public InstantiatedMethod GetInstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    public MethodDesc GetMethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    public FieldDesc GetFieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public TypeDesc GetSignatureVariable(int index, bool method);
    protected internal virtual IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    protected internal virtual IEnumerable`1<MethodDesc> GetAllVirtualMethods(TypeDesc type);
    public virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(DefType type);
    public RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForType(TypeDesc type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    public virtual VirtualMethodAlgorithm GetVirtualMethodAlgorithmForType(TypeDesc type);
    protected internal virtual bool ComputeHasGCStaticBase(FieldDesc field);
    internal TypeFlags ComputeTypeFlags(TypeDesc type, TypeFlags flags, TypeFlags mask);
    protected internal abstract virtual bool ComputeHasStaticConstructor(TypeDesc type);
    protected internal abstract virtual bool IsIDynamicInterfaceCastableInterface(DefType type);
    internal static TemplateLocator get_TemplateLookup();
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable GetArrayTypesCache(bool isMdArray, int rank);
    [CompilerGeneratedAttribute]
internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable get_PointerTypesCache();
    [CompilerGeneratedAttribute]
internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable get_ByRefTypesCache();
    public Instantiation ResolveRuntimeTypeHandles(RuntimeTypeHandle[] runtimeTypeHandles);
    private static TypeDesc TryGetMetadataBasedTypeFromRuntimeTypeHandle_Uncached(RuntimeTypeHandle rtth);
    public TypeDesc ResolveRuntimeTypeHandle(RuntimeTypeHandle rtth);
    internal MethodDesc ResolveRuntimeMethod(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, IntPtr functionPointer, bool usgFunctionPointer);
    public DefType ResolveGenericInstantiation(DefType typeDef, Instantiation arguments);
    public MethodDesc ResolveGenericMethodInstantiation(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, Instantiation methodInstantiation, IntPtr functionPointer, bool usgFunctionPointer);
    public virtual int get_LoadFactor();
    internal void RegisterTypeForTypeSystemStateFlushing(TypeDesc type);
    internal void FlushTypeBuilderStates();
}
public abstract class Internal.TypeSystem.TypeSystemEntity : object {
    public TypeSystemContext Context { get; }
    public abstract virtual TypeSystemContext get_Context();
}
[ExtensionAttribute]
public static class Internal.TypeSystem.TypeSystemHelpers : object {
    [ExtensionAttribute]
public static bool IsWellKnownType(TypeDesc type, WellKnownType wellKnownType);
    [ExtensionAttribute]
public static InstantiatedType MakeInstantiatedType(MetadataType typeDef, Instantiation instantiation);
    [ExtensionAttribute]
public static InstantiatedType MakeInstantiatedType(MetadataType typeDef, TypeDesc[] genericParameters);
    [ExtensionAttribute]
public static InstantiatedMethod MakeInstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    [ExtensionAttribute]
public static InstantiatedMethod MakeInstantiatedMethod(MethodDesc methodDef, TypeDesc[] genericParameters);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeDesc type);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeDesc type, int rank);
    [ExtensionAttribute]
public static ByRefType MakeByRefType(TypeDesc type);
    [ExtensionAttribute]
public static PointerType MakePointerType(TypeDesc type);
    [ExtensionAttribute]
public static TypeDesc GetParameterType(TypeDesc type);
    [ExtensionAttribute]
public static bool HasLayout(MetadataType mdType);
    [ExtensionAttribute]
public static LayoutInt GetElementSize(TypeDesc type);
    [ExtensionAttribute]
public static MethodDesc GetParameterlessConstructor(TypeDesc type);
    [ExtensionAttribute]
public static bool HasExplicitOrImplicitDefaultConstructor(TypeDesc type);
    [ExtensionAttribute]
internal static MethodDesc FindMethodOnExactTypeWithMatchingTypicalMethod(TypeDesc type, MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc FindMethodOnTypeWithMatchingTypicalMethod(TypeDesc targetType, MethodDesc method);
    [ExtensionAttribute]
public static string GetFullName(DefType metadataType);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDesc> GetAllVirtualMethods(TypeDesc type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDesc> EnumAllVirtualSlots(TypeDesc type);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodToStaticVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static MethodDesc ResolveVariantInterfaceMethodToStaticVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static DefaultInterfaceMethodResolution ResolveInterfaceMethodToDefaultImplementationOnType(TypeDesc type, MethodDesc interfaceMethod, MethodDesc& implMethod);
    [ExtensionAttribute]
public static DefaultInterfaceMethodResolution ResolveVariantInterfaceMethodToDefaultImplementationOnType(TypeDesc type, MethodDesc interfaceMethod, MethodDesc& implMethod);
    [ExtensionAttribute]
public static MethodDesc FindVirtualFunctionTargetMethodOnObjectType(TypeDesc type, MethodDesc targetMethod);
    [ExtensionAttribute]
public static TypeDesc InstantiateAsOpen(TypeDesc type);
    [ExtensionAttribute]
public static FieldDesc InstantiateAsOpen(FieldDesc field);
    [ExtensionAttribute]
public static MethodDesc InstantiateAsOpen(MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodTarget(TypeDesc thisType, MethodDesc interfaceMethodToResolve);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodTargetWithVariance(TypeDesc thisType, MethodDesc interfaceMethodToResolve);
    [ExtensionAttribute]
public static bool ContainsSignatureVariables(TypeDesc thisType, bool treatGenericParameterLikeSignatureVariable);
    [ExtensionAttribute]
public static bool RequiresSlotUnification(MethodDesc method);
    [ExtensionAttribute]
public static bool RequiresAlign8(TypeDesc type);
}
public class Internal.TypeSystem.UniversalCanonLayoutAlgorithm : FieldLayoutAlgorithm {
    public static UniversalCanonLayoutAlgorithm Instance;
    private static UniversalCanonLayoutAlgorithm();
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public virtual bool ComputeIsUnsafeValueType(DefType type);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
}
internal class Internal.TypeSystem.UniversalCanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public bool IsSealed { get; }
    public DefType BaseType { get; }
    public UniversalCanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual bool get_IsSealed();
    private void Initialize();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
}
public enum Internal.TypeSystem.ValueTypeShapeCharacteristics : Enum {
    public int value__;
    public static ValueTypeShapeCharacteristics None;
    public static ValueTypeShapeCharacteristics Float32Aggregate;
    public static ValueTypeShapeCharacteristics Float64Aggregate;
    public static ValueTypeShapeCharacteristics Vector64Aggregate;
    public static ValueTypeShapeCharacteristics Vector128Aggregate;
    public static ValueTypeShapeCharacteristics FloatingPointAggregateMask;
    public static ValueTypeShapeCharacteristics ShortVectorAggregateMask;
    public static ValueTypeShapeCharacteristics AggregateMask;
}
public abstract class Internal.TypeSystem.VirtualMethodAlgorithm : object {
    public abstract virtual MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveInterfaceMethodToStaticVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveVariantInterfaceMethodToStaticVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual DefaultInterfaceMethodResolution ResolveInterfaceMethodToDefaultImplementationOnType(MethodDesc interfaceMethod, TypeDesc currentType, MethodDesc& impl);
    public abstract virtual DefaultInterfaceMethodResolution ResolveVariantInterfaceMethodToDefaultImplementationOnType(MethodDesc interfaceMethod, TypeDesc currentType, MethodDesc& impl);
    public abstract virtual MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, TypeDesc objectType);
    public abstract virtual IEnumerable`1<MethodDesc> ComputeAllVirtualSlots(TypeDesc type);
}
public enum Internal.TypeSystem.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Unknown;
    public static WellKnownType Void;
    public static WellKnownType Boolean;
    public static WellKnownType Char;
    public static WellKnownType SByte;
    public static WellKnownType Byte;
    public static WellKnownType Int16;
    public static WellKnownType UInt16;
    public static WellKnownType Int32;
    public static WellKnownType UInt32;
    public static WellKnownType Int64;
    public static WellKnownType UInt64;
    public static WellKnownType IntPtr;
    public static WellKnownType UIntPtr;
    public static WellKnownType Single;
    public static WellKnownType Double;
    public static WellKnownType ValueType;
    public static WellKnownType Enum;
    public static WellKnownType Nullable;
    public static WellKnownType Object;
    public static WellKnownType String;
    public static WellKnownType Array;
    public static WellKnownType MulticastDelegate;
    public static WellKnownType RuntimeTypeHandle;
    public static WellKnownType RuntimeMethodHandle;
    public static WellKnownType RuntimeFieldHandle;
    public static WellKnownType Exception;
    public static WellKnownType TypedReference;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private T[] _items;
    private int _count;
    public int Count { get; }
    public T Item { get; public set; }
    public T[] ToArray();
    public void Add(T item);
    public void Append(T[] newItems);
    public void Append(T[] newItems, int offset, int length);
    public void Append(ArrayBuilder`1<T> newItems);
    public void ZeroExtend(int numItems);
    public void EnsureCapacity(int requestedCapacity);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public bool Contains(T t);
    public bool Any(Func`2<T, bool> func);
}
[ForceDictionaryLookupsAttribute]
internal static class System.Collections.Generic.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
[DefaultMemberAttribute("Item")]
[ForceDictionaryLookupsAttribute]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    internal TValue LookupOrAdd(TKey key, TValue value);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal class System.Collections.Generic.LowLevelDictionaryWithIEnumerable`2 : LowLevelDictionary`2<TKey, TValue> {
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ForceDictionaryLookupsAttribute]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    private void EnsureCapacity(int min);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockAllReflectionAttribute : Attribute {
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.SR : object {
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static bool _resourceManagerInited;
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string FileNotFound_AssemblyNotFound { get; }
    internal static string FileLoadException_RefDefMismatch { get; }
    private static SR();
    private static string InternalGetResourceString(string key);
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_FileNotFound_AssemblyNotFound();
    internal static string get_FileLoadException_RefDefMismatch();
}
[ExtensionAttribute]
internal static class System.TypeLoaderFormattingHelpers : object {
    [ExtensionAttribute]
public static string ToStringInvariant(int arg);
    [ExtensionAttribute]
public static string ToStringInvariant(UInt32 arg);
    [ExtensionAttribute]
public static string ToStringInvariant(byte arg);
    [ExtensionAttribute]
public static string ToStringInvariant(ushort arg);
    [ExtensionAttribute]
public static string ToStringInvariant(ulong arg);
    [ExtensionAttribute]
public static string ToStringInvariant(float arg);
    [ExtensionAttribute]
public static string ToStringInvariant(double arg);
}
