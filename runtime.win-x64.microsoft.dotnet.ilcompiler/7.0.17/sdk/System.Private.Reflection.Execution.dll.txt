internal static class FxResources.System.Private.Reflection.Execution.SR : object {
}
[ExtensionAttribute]
internal static class Internal.LowLevelLinq.LowLevelEnumerable : object {
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values, Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__2`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(IEnumerable`1<T> values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(T[] values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Where>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Where(IEnumerable`1<T> source, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<T> AsEnumerable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<T> enumeration);
    [ExtensionAttribute]
public static T[] ToArray(IEnumerable`1<T> values);
}
internal enum Internal.NativeFormat.BagElementKind : Enum {
    public UInt32 value__;
    public static BagElementKind End;
    public static BagElementKind BaseType;
    public static BagElementKind ImplementedInterfaces;
    public static BagElementKind DictionaryLayout;
    public static BagElementKind TypeFlags;
    public static BagElementKind NonGcStaticData;
    public static BagElementKind GcStaticData;
    public static BagElementKind NonGcStaticDataSize;
    public static BagElementKind GcStaticDataSize;
    public static BagElementKind GcStaticDesc;
    public static BagElementKind ThreadStaticDataSize;
    public static BagElementKind ThreadStaticDesc;
    public static BagElementKind ThreadStaticIndex;
    public static BagElementKind ThreadStaticOffset;
    public static BagElementKind FieldLayout;
    public static BagElementKind VTableMethodSignatures;
    public static BagElementKind SealedVTableEntries;
    public static BagElementKind ClassConstructorPointer;
    public static BagElementKind BaseTypeSize;
    public static BagElementKind GenericVarianceInfo;
    public static BagElementKind DelegateInvokeSignature;
}
internal enum Internal.NativeFormat.CallingConventionConverterKind : Enum {
    public UInt32 value__;
    public static CallingConventionConverterKind NoInstantiatingParam;
    public static CallingConventionConverterKind HasInstantiatingParam;
    public static CallingConventionConverterKind MaybeInstantiatingParam;
}
internal enum Internal.NativeFormat.FieldStorage : Enum {
    public UInt32 value__;
    public static FieldStorage Instance;
    public static FieldStorage NonGCStatic;
    public static FieldStorage GCStatic;
    public static FieldStorage TLSStatic;
}
internal enum Internal.NativeFormat.FixupSignatureKind : Enum {
    public UInt32 value__;
    public static FixupSignatureKind Null;
    public static FixupSignatureKind TypeHandle;
    public static FixupSignatureKind InterfaceCall;
    public static FixupSignatureKind MethodDictionary;
    public static FixupSignatureKind StaticData;
    public static FixupSignatureKind UnwrapNullableType;
    public static FixupSignatureKind FieldLdToken;
    public static FixupSignatureKind MethodLdToken;
    public static FixupSignatureKind AllocateObject;
    public static FixupSignatureKind DefaultConstructor;
    public static FixupSignatureKind ThreadStaticIndex;
    public static FixupSignatureKind Method;
    public static FixupSignatureKind IsInst;
    public static FixupSignatureKind CastClass;
    public static FixupSignatureKind AllocateArray;
    public static FixupSignatureKind TypeSize;
    public static FixupSignatureKind FieldOffset;
    public static FixupSignatureKind CallingConventionConverter;
    public static FixupSignatureKind VTableOffset;
    public static FixupSignatureKind NonGenericConstrainedMethod;
    public static FixupSignatureKind GenericConstrainedMethod;
    public static FixupSignatureKind NonGenericDirectConstrainedMethod;
    public static FixupSignatureKind PointerToOtherSlot;
    public static FixupSignatureKind IntValue;
    public static FixupSignatureKind NonGenericStaticConstrainedMethod;
    public static FixupSignatureKind GenericStaticConstrainedMethod;
    public static FixupSignatureKind NotYetSupported;
}
internal enum Internal.NativeFormat.GenericContextKind : Enum {
    public UInt32 value__;
    public static GenericContextKind FromThis;
    public static GenericContextKind FromHiddenArg;
    public static GenericContextKind FromMethodHiddenArg;
    public static GenericContextKind HasDeclaringType;
    public static GenericContextKind NeedsUSGContext;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodCallingConvention : Enum {
    public UInt32 value__;
    public static MethodCallingConvention Generic;
    public static MethodCallingConvention Static;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodFlags : Enum {
    public UInt32 value__;
    public static MethodFlags HasInstantiation;
    public static MethodFlags IsUnboxingStub;
    public static MethodFlags HasFunctionPointer;
    public static MethodFlags FunctionPointerIsUSG;
}
internal class Internal.NativeFormat.NativeHashtable : ValueType {
    private NativeReader _reader;
    private UInt32 _baseOffset;
    private UInt32 _bucketMask;
    private byte _entryIndexSize;
    public bool IsNull { get; }
    public NativeHashtable(NativeParser parser);
    public bool get_IsNull();
    private NativeParser GetParserForBucket(UInt32 bucket, UInt32& endOffset);
    public Enumerator Lookup(int hashcode);
    public AllEntriesEnumerator EnumerateAllEntries();
}
internal class Internal.NativeFormat.NativeParser : ValueType {
    private NativeReader _reader;
    private UInt32 _offset;
    public bool IsNull { get; }
    public NativeReader Reader { get; }
    public UInt32 Offset { get; public set; }
    public NativeParser(NativeReader reader, UInt32 offset);
    public bool get_IsNull();
    public NativeReader get_Reader();
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public static void ThrowBadImageFormatException();
    public byte GetUInt8();
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public int GetSigned();
    public UInt32 GetRelativeOffset();
    public void SkipInteger();
    public NativeParser GetParserFromRelativeOffset();
    public UInt32 GetSequenceCount();
    public BagElementKind GetBagElementKind();
    public FixupSignatureKind GetFixupSignatureKind();
    public TypeSignatureKind GetTypeSignatureKind(UInt32& data);
    public NativeParser GetLookbackParser(UInt32 lookback);
    public Nullable`1<UInt32> GetUnsignedForBagElementKind(BagElementKind kindToFind);
    public NativeParser GetParserForBagElementKind(BagElementKind kindToFind);
    public string GetString();
    public void SkipString();
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static void ThrowBadImageFormatException();
    public static UInt32 DecodeUnsigned(Byte*& stream, Byte* streamEnd);
    public static int DecodeSigned(Byte*& stream, Byte* streamEnd);
    public static ulong DecodeUnsignedLong(Byte*& stream, Byte* streamEnd);
    public static long DecodeSignedLong(Byte*& stream, Byte* streamEnd);
    public static void SkipInteger(Byte*& stream);
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.NativeFormat.NativeReader : object {
    private Byte* _base;
    private UInt32 _size;
    public UInt32 Size { get; }
    public NativeReader(Byte* base_, UInt32 size);
    public UInt32 get_Size();
    public UInt32 AddressToOffset(IntPtr address);
    public IntPtr OffsetToAddress(UInt32 offset);
    public static void ThrowBadImageFormatException();
    private UInt32 EnsureOffsetInRange(UInt32 offset, UInt32 lookAhead);
    public byte ReadUInt8(UInt32 offset);
    public ushort ReadUInt16(UInt32 offset);
    public UInt32 ReadUInt32(UInt32 offset);
    public ulong ReadUInt64(UInt32 offset);
    public float ReadFloat(UInt32 offset);
    public double ReadDouble(UInt32 offset);
    public UInt32 DecodeUnsigned(UInt32 offset, UInt32& value);
    public UInt32 DecodeSigned(UInt32 offset, Int32& value);
    public UInt32 DecodeUnsignedLong(UInt32 offset, UInt64& value);
    public UInt32 DecodeSignedLong(UInt32 offset, Int64& value);
    public UInt32 SkipInteger(UInt32 offset);
    public string ReadString(UInt32 offset);
    public UInt32 DecodeString(UInt32 offset, String& value);
    public UInt32 SkipString(UInt32 offset);
    public bool StringEquals(UInt32 offset, string value);
}
internal enum Internal.NativeFormat.StaticDataKind : Enum {
    public UInt32 value__;
    public static StaticDataKind Gc;
    public static StaticDataKind NonGc;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.TypeFlags : Enum {
    public UInt32 value__;
    public static TypeFlags HasClassConstructor;
    public static TypeFlags HasInstantiationDeterminedSize;
}
internal enum Internal.NativeFormat.TypeModifierKind : Enum {
    public UInt32 value__;
    public static TypeModifierKind Array;
    public static TypeModifierKind ByRef;
    public static TypeModifierKind Pointer;
}
internal enum Internal.NativeFormat.TypeSignatureKind : Enum {
    public UInt32 value__;
    public static TypeSignatureKind Null;
    public static TypeSignatureKind Lookback;
    public static TypeSignatureKind Modifier;
    public static TypeSignatureKind Instantiation;
    public static TypeSignatureKind Variable;
    public static TypeSignatureKind BuiltIn;
    public static TypeSignatureKind External;
    public static TypeSignatureKind MultiDimArray;
    public static TypeSignatureKind FunctionPointer;
}
[ExtensionAttribute]
internal static class Internal.Reflection.Execution.ConstraintValidator : object {
    [ExtensionAttribute]
private static bool SatisfiesConstraints(Type genericVariable, SigTypeContext typeContextOfConstraintDeclarer, Type typeArg);
    private static void EnsureSatisfiesClassConstraints(Type[] typeParameters, Type[] typeArguments, object definition, SigTypeContext typeContext);
    public static void EnsureSatisfiesClassConstraints(Type typeDefinition, Type[] typeArguments);
    public static void EnsureSatisfiesClassConstraints(MethodInfo reflectionMethodInfo);
    [ExtensionAttribute]
private static Type Instantiate(Type type, SigTypeContext context);
    [ExtensionAttribute]
private static bool IsInstantiatedTypeInfo(Type type);
    [ExtensionAttribute]
private static bool IsNullable(Type type);
    [ExtensionAttribute]
private static Type GetNullableType(Type type);
    [ExtensionAttribute]
private static bool IsSystemObject(Type type);
    [ExtensionAttribute]
private static bool IsSystemValueType(Type type);
    [ExtensionAttribute]
private static bool IsSystemArray(Type type);
    [ExtensionAttribute]
private static bool IsSystemVoid(Type type);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private static bool HasExplicitOrImplicitPublicDefaultConstructor(Type type);
    [ExtensionAttribute]
private static int NormalizedPrimitiveTypeSizeForIntegerTypes(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private static bool ImplementsInterface(Type pObjType, Type pTargetType);
    private static bool TypesAreCompatibleViaGenericVariance(Type pSourceType, Type pTargetType);
    private static bool TypeParametersAreCompatible(Type[] pSourceInstantiation, Type[] pTargetInstantiation, Type[] pVarianceInfo, bool fForceCovariance);
    private static bool AreTypesAssignable(Type pSourceType, Type pTargetType);
    private static bool AreTypesAssignableInternal(Type pSourceType, Type pTargetType, bool fBoxedSource, bool fAllowSizeEquivalence);
    private static bool IsDerived(Type pDerivedType, Type pBaseType);
    private static bool AreTypesEquivalentInternal(Type pType1, Type pType2);
    private static bool ArePrimitiveTypesEquivalentSize(Type pType1, Type pType2);
}
internal class Internal.Reflection.Execution.ExecutionEnvironmentImplementation : ExecutionEnvironment {
    private KeyValuePair`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _ldftnReverseLookup_InvokeMap;
    private KeyValuePair`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _ldftnReverseLookup_ExactInstantiations;
    private Func`2<NativeFormatModuleInfo, FunctionPointersToOffsets> _computeLdFtnLookupInvokeMapInvokeMap;
    private Func`2<NativeFormatModuleInfo, FunctionPointersToOffsets> _computeLdFtnLookupExactInstantiations;
    private static LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_extractedResourceDictionary;
    public RuntimeTypeHandle ProjectionTypeForArrays { get; }
    private static LowLevelDictionary`2<string, LowLevelList`1<ResourceInfo>> ExtractedResourceDictionary { get; }
    public sealed virtual object NewObject(RuntimeTypeHandle typeHandle);
    public sealed virtual Array NewArray(RuntimeTypeHandle typeHandleForArrayType, int count);
    public sealed virtual Array NewMultiDimArray(RuntimeTypeHandle typeHandleForArrayType, Int32[] lengths, Int32[] lowerBounds);
    public sealed virtual RuntimeTypeHandle get_ProjectionTypeForArrays();
    public sealed virtual bool IsAssignableFrom(RuntimeTypeHandle dstType, RuntimeTypeHandle srcType);
    public sealed virtual bool TryGetBaseType(RuntimeTypeHandle typeHandle, RuntimeTypeHandle& baseTypeHandle);
    public sealed virtual IEnumerable`1<RuntimeTypeHandle> TryGetImplementedInterfaces(RuntimeTypeHandle typeHandle);
    public sealed virtual void VerifyInterfaceIsImplemented(RuntimeTypeHandle typeHandle, RuntimeTypeHandle ifaceHandle);
    public sealed virtual void GetInterfaceMap(Type instanceType, Type interfaceType, MethodInfo[]& interfaceMethods, MethodInfo[]& targetMethods);
    public sealed virtual string GetLastResortString(RuntimeTypeHandle typeHandle);
    public sealed virtual FieldAccessor CreateLiteralFieldAccessor(object value, RuntimeTypeHandle fieldTypeHandle);
    public sealed virtual EnumInfo GetEnumInfo(RuntimeTypeHandle typeHandle);
    public virtual IntPtr GetDynamicInvokeThunk(MethodInvoker invoker);
    private static RuntimeTypeHandle GetOpenTypeDefinition(RuntimeTypeHandle typeHandle, RuntimeTypeHandle[]& typeArgumentsHandles);
    private static RuntimeTypeHandle GetTypeDefinition(RuntimeTypeHandle typeHandle);
    private static bool RuntimeTypeHandleIsNonDefault(RuntimeTypeHandle runtimeTypeHandle);
    private static NativeReader GetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob);
    private static bool TryGetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob, NativeReader& reader);
    public sealed virtual bool TryGetMetadataForNamedType(RuntimeTypeHandle runtimeTypeHandle, QTypeDefinition& qTypeDefinition);
    public sealed virtual bool IsReflectionBlocked(RuntimeTypeHandle runtimeTypeHandle);
    public sealed virtual bool TryGetNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public sealed virtual bool TryGetTypeReferenceForNamedType(RuntimeTypeHandle runtimeTypeHandle, MetadataReader& metadataReader, TypeReferenceHandle& typeRefHandle);
    public sealed virtual bool TryGetNamedTypeForTypeReference(MetadataReader metadataReader, TypeReferenceHandle typeRefHandle, RuntimeTypeHandle& runtimeTypeHandle);
    public sealed virtual bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, RuntimeTypeHandle& arrayTypeHandle);
    public sealed virtual bool TryGetArrayTypeElementType(RuntimeTypeHandle arrayTypeHandle, RuntimeTypeHandle& elementTypeHandle);
    public sealed virtual bool TryGetMultiDimArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public sealed virtual bool TryGetPointerTypeForTargetType(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public sealed virtual bool TryGetPointerTypeTargetType(RuntimeTypeHandle pointerTypeHandle, RuntimeTypeHandle& targetTypeHandle);
    public sealed virtual bool TryGetByRefTypeForTargetType(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public sealed virtual bool TryGetByRefTypeTargetType(RuntimeTypeHandle byRefTypeHandle, RuntimeTypeHandle& targetTypeHandle);
    public sealed virtual bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public sealed virtual MethodInvoker TryGetMethodInvoker(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles);
    private static IntPtr GetDynamicMethodInvoke(NativeFormatModuleInfo module, UInt32 cookie);
    private static RuntimeTypeHandle[] GetTypeSequence(ExternalReferencesTable& extRefs, NativeParser& parser);
    private static IntPtr TryGetVirtualResolveData(NativeFormatModuleInfo module, RuntimeTypeHandle methodHandleDeclaringType, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericArgs, MethodSignatureComparer& methodSignatureComparer);
    private static MethodInvokeInfo TryGetMethodInvokeInfo(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodBase methodInfo, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind);
    private static RuntimeTypeHandle GetExactDeclaringType(RuntimeTypeHandle dstType, RuntimeTypeHandle srcType);
    private KeyValuePair`2[] GetLdFtnReverseLookups_Helper(KeyValuePair`2[]& ldftnReverseLookupStatic, Func`2<NativeFormatModuleInfo, FunctionPointersToOffsets> lookupComputer);
    private KeyValuePair`2[] GetLdFtnReverseLookups_InvokeMap();
    private KeyValuePair`2[] GetLdFtnReverseLookups_ExactInstantiations();
    internal void GetFunctionPointerAndInstantiationArgumentForOriginalLdFtnResult(IntPtr originalLdFtnResult, IntPtr& canonOriginalLdFtnResult, IntPtr& instantiationArgument);
    internal bool TryGetMethodForOriginalLdFtnResult(IntPtr originalLdFtnResult, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    internal bool TryGetMethodForStartAddress(IntPtr methodStartAddress, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle);
    private static FunctionPointersToOffsets ComputeLdftnReverseLookup_InvokeMap(NativeFormatModuleInfo mappingTableModule);
    private bool TryGetMethodForOriginalLdFtnResult_InvokeMap_Inner(NativeFormatModuleInfo mappingTableModule, bool forStartAddress, IntPtr canonOriginalLdFtnResult, IntPtr instantiationArgument, UInt32 parserOffset, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    private static FunctionPointersToOffsets ComputeLdftnReverseLookup_ExactInstantiations(NativeFormatModuleInfo mappingTableModule);
    private static bool TryGetMethodForOriginalLdFtnResult_ExactInstantiation_Inner(NativeFormatModuleInfo mappingTableModule, bool forStartAddress, IntPtr canonOriginalLdFtnResult, UInt32 parserOffset, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    private static bool TryGetMethodForOriginalLdFtnResult_GenericMethodWithInstantiationArgument(IntPtr instantiationArgument, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public sealed virtual FieldAccessor TryGetFieldAccessor(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle, FieldHandle fieldHandle);
    public sealed virtual bool TryGetMethodFromHandle(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public sealed virtual bool TryGetMethodFromHandleAndType(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public sealed virtual bool TryGetFieldFromHandle(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, FieldHandle& fieldHandle);
    public sealed virtual bool TryGetFieldFromHandleAndType(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle declaringTypeHandle, FieldHandle& fieldHandle);
    internal static IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle typeHandle);
    public sealed virtual ManifestResourceInfo GetManifestResourceInfo(Assembly assembly, string resourceName);
    public sealed virtual String[] GetManifestResourceNames(Assembly assembly);
    public sealed virtual Stream GetManifestResourceStream(Assembly assembly, string name);
    private static Stream ReadResourceFromBlob(ResourceInfo resourceInfo);
    private static LowLevelList`1<ResourceInfo> GetExtractedResources(Assembly assembly);
    private static LowLevelDictionary`2<string, LowLevelList`1<ResourceInfo>> get_ExtractedResourceDictionary();
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.InstanceFieldAccessor : FieldAccessor {
    [CompilerGeneratedAttribute]
private int <OffsetPlusHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <DeclaringTypeHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <FieldTypeHandle>k__BackingField;
    public int Offset { get; }
    protected int OffsetPlusHeader { get; }
    protected RuntimeTypeHandle DeclaringTypeHandle { get; }
    protected RuntimeTypeHandle FieldTypeHandle { get; }
    public InstanceFieldAccessor(RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle, int offsetPlusHeader);
    public sealed virtual int get_Offset();
    public sealed virtual object GetField(object obj);
    public sealed virtual object GetFieldDirect(TypedReference typedReference);
    protected abstract virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    public sealed virtual void SetField(object obj, object value, BinderBundle binderBundle);
    public sealed virtual void SetFieldDirect(TypedReference typedReference, object value);
    protected abstract virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
    protected abstract virtual object UncheckedGetField(object obj);
    protected abstract virtual void UncheckedSetField(object obj, object value);
    [CompilerGeneratedAttribute]
protected int get_OffsetPlusHeader();
    [CompilerGeneratedAttribute]
protected RuntimeTypeHandle get_DeclaringTypeHandle();
    [CompilerGeneratedAttribute]
protected RuntimeTypeHandle get_FieldTypeHandle();
}
internal class Internal.Reflection.Execution.FieldAccessors.LiteralFieldAccessor : StaticFieldAccessor {
    private object _value;
    public LiteralFieldAccessor(object value, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void SetFieldBypassCctor(object value, BinderBundle binderBundle);
    protected sealed virtual void SetFieldDirectBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.PointerTypeFieldAccessorForInstanceFields : InstanceFieldAccessor {
    public PointerTypeFieldAccessorForInstanceFields(int offsetPlusHeader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object UncheckedGetField(object obj);
    protected sealed virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    protected sealed virtual void UncheckedSetField(object obj, object value);
    protected sealed virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.PointerTypeFieldAccessorForStaticFields : RegularStaticFieldAccessor {
    public PointerTypeFieldAccessorForStaticFields(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, FieldTableFlags fieldBase, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ReferenceTypeFieldAccessorForInstanceFields : InstanceFieldAccessor {
    public ReferenceTypeFieldAccessorForInstanceFields(int offsetPlusHeader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object UncheckedGetField(object obj);
    protected sealed virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    protected sealed virtual void UncheckedSetField(object obj, object value);
    protected sealed virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ReferenceTypeFieldAccessorForStaticFields : RegularStaticFieldAccessor {
    public ReferenceTypeFieldAccessorForStaticFields(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, FieldTableFlags fieldBase, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.RegularStaticFieldAccessor : WritableStaticFieldAccessor {
    [CompilerGeneratedAttribute]
private IntPtr <StaticsBase>k__BackingField;
    private FieldTableFlags _fieldFlags;
    [CompilerGeneratedAttribute]
private int <FieldOffset>k__BackingField;
    protected IntPtr StaticsBase { get; }
    protected int FieldOffset { get; }
    protected FieldTableFlags FieldBase { get; }
    protected bool IsFieldInitOnly { get; }
    protected RegularStaticFieldAccessor(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, FieldTableFlags fieldBase, RuntimeTypeHandle fieldTypeHandle);
    [CompilerGeneratedAttribute]
protected IntPtr get_StaticsBase();
    [CompilerGeneratedAttribute]
protected int get_FieldOffset();
    protected FieldTableFlags get_FieldBase();
    protected sealed virtual bool get_IsFieldInitOnly();
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.StaticFieldAccessor : FieldAccessor {
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <FieldTypeHandle>k__BackingField;
    private IntPtr _cctorContext;
    protected RuntimeTypeHandle FieldTypeHandle { get; }
    public int Offset { get; }
    public StaticFieldAccessor(IntPtr cctorContext, RuntimeTypeHandle fieldTypeHandle);
    [CompilerGeneratedAttribute]
protected RuntimeTypeHandle get_FieldTypeHandle();
    public sealed virtual object GetField(object obj);
    public sealed virtual object GetFieldDirect(TypedReference typedReference);
    public sealed virtual void SetField(object obj, object value, BinderBundle binderBundle);
    public sealed virtual void SetFieldDirect(TypedReference typedReference, object value);
    public sealed virtual int get_Offset();
    protected abstract virtual object GetFieldBypassCctor();
    protected abstract virtual void SetFieldBypassCctor(object value, BinderBundle binderBundle);
    protected abstract virtual void SetFieldDirectBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ValueTypeFieldAccessorForInstanceFields : InstanceFieldAccessor {
    public ValueTypeFieldAccessorForInstanceFields(int offsetPlusHeader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object UncheckedGetField(object obj);
    protected sealed virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    protected sealed virtual void UncheckedSetField(object obj, object value);
    protected sealed virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ValueTypeFieldAccessorForStaticFields : RegularStaticFieldAccessor {
    public ValueTypeFieldAccessorForStaticFields(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, FieldTableFlags fieldBase, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.WritableStaticFieldAccessor : StaticFieldAccessor {
    protected bool IsFieldInitOnly { get; }
    protected WritableStaticFieldAccessor(IntPtr cctorContext, RuntimeTypeHandle fieldTypeHandle);
    protected abstract virtual object GetFieldBypassCctor();
    protected abstract virtual bool get_IsFieldInitOnly();
    protected sealed virtual void SetFieldBypassCctor(object value, BinderBundle binderBundle);
    protected sealed virtual void SetFieldDirectBypassCctor(object value);
    protected abstract virtual void UncheckedSetFieldBypassCctor(object value);
}
[ExtensionAttribute]
internal static class Internal.Reflection.Execution.MetadataReaderExtensions : object {
    [ExtensionAttribute]
public static string GetString(ConstantStringValueHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetStringOrNull(ConstantStringValueHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsMethodHandle(int i);
    [ExtensionAttribute]
public static int AsInt(MethodHandle methodHandle);
    [ExtensionAttribute]
public static MethodHandle AsMethodHandle(int i);
    [ExtensionAttribute]
public static int AsInt(FieldHandle fieldHandle);
    [ExtensionAttribute]
public static FieldHandle AsFieldHandle(int i);
    [ExtensionAttribute]
public static TypeDefinitionHandle AsTypeDefinitionHandle(int i);
    [ExtensionAttribute]
public static int WithoutHandleType(int constantStringValueHandle);
    [ExtensionAttribute]
public static bool IsConstantStringValueHandle(int i);
}
internal class Internal.Reflection.Execution.MethodInvokeInfo : DynamicInvokeInfo {
    [CompilerGeneratedAttribute]
private IntPtr <LdFtnResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <VirtualResolveData>k__BackingField;
    public IntPtr LdFtnResult { get; public set; }
    public IntPtr VirtualResolveData { get; public set; }
    public MethodInvokeInfo(MethodBase method, IntPtr invokeThunk);
    [CompilerGeneratedAttribute]
public IntPtr get_LdFtnResult();
    [CompilerGeneratedAttribute]
public void set_LdFtnResult(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_VirtualResolveData();
    [CompilerGeneratedAttribute]
public void set_VirtualResolveData(IntPtr value);
}
internal class Internal.Reflection.Execution.MethodInvokers.InstanceMethodInvoker : MethodInvokerWithMethodInvokeInfo {
    private RuntimeTypeHandle _declaringTypeHandle;
    public IntPtr LdFtnResult { get; }
    public InstanceMethodInvoker(MethodInvokeInfo methodInvokeInfo, RuntimeTypeHandle declaringTypeHandle);
    [DebuggerGuidedStepThroughAttribute]
protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public sealed virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal abstract class Internal.Reflection.Execution.MethodInvokers.MethodInvokerWithMethodInvokeInfo : MethodInvoker {
    [CompilerGeneratedAttribute]
private MethodInvokeInfo <MethodInvokeInfo>k__BackingField;
    internal MethodInvokeInfo MethodInvokeInfo { get; private set; }
    public MethodInvokerWithMethodInvokeInfo(MethodInvokeInfo methodInvokeInfo);
    public virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    internal static MethodInvoker CreateMethodInvoker(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, MethodInvokeInfo methodInvokeInfo);
    [CompilerGeneratedAttribute]
internal MethodInvokeInfo get_MethodInvokeInfo();
    [CompilerGeneratedAttribute]
private void set_MethodInvokeInfo(MethodInvokeInfo value);
}
internal class Internal.Reflection.Execution.MethodInvokers.StaticMethodInvoker : MethodInvokerWithMethodInvokeInfo {
    public IntPtr LdFtnResult { get; }
    public StaticMethodInvoker(MethodInvokeInfo methodInvokeInfo);
    [DebuggerGuidedStepThroughAttribute]
protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal class Internal.Reflection.Execution.MethodInvokers.VirtualMethodInvoker : MethodInvokerWithMethodInvokeInfo {
    private RuntimeTypeHandle _declaringTypeHandle;
    public IntPtr LdFtnResult { get; }
    public VirtualMethodInvoker(MethodInvokeInfo methodInvokeInfo, RuntimeTypeHandle declaringTypeHandle);
    public sealed virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    [DebuggerGuidedStepThroughAttribute]
protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    internal IntPtr ResolveTarget(RuntimeTypeHandle type);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal static class Internal.Reflection.Execution.NativeFormatEnumInfo : object {
    public static EnumInfo Create(RuntimeTypeHandle typeHandle, MetadataReader reader, TypeDefinitionHandle typeDefHandle);
}
internal static class Internal.Reflection.Execution.PayForPlayExperience.DiagnosticMappingTables : object {
    public static bool TryGetDiagnosticStringForNamedType(RuntimeTypeHandle runtimeTypeHandle, String& diagnosticName);
    private static string GetTypeFullNameFromTypeRef(TypeReferenceHandle typeReferenceHandle, MetadataReader reader);
    private static string GetTypeFullNameFromTypeDef(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader);
}
[ExtensionAttribute]
public static class Internal.Reflection.Execution.PayForPlayExperience.MissingMetadataExceptionCreator : object {
    internal static NotSupportedException Create(Type pertainant);
    private static NotSupportedException CreateFromString(string pertainant);
    internal static NotSupportedException CreateMissingArrayTypeException(Type elementType, bool isMultiDim, int rank);
    internal static NotSupportedException CreateMissingConstructedGenericTypeException(Type genericTypeDefinition, Type[] genericTypeArguments);
    internal static NotSupportedException CreateFromMetadataObject(string resourceId, Type pertainant);
    public static string ComputeUsefulPertainantIfPossible(MemberInfo memberInfo);
    [ExtensionAttribute]
internal static string ToDisplayStringIfAvailable(Type type);
    private static string CreateArrayTypeStringIfAvailable(Type elementType, int rank);
    private static string CreateConstructedGenericTypeStringIfAvailable(Type genericTypeDefinition, Type[] genericTypeArguments);
}
internal class Internal.Reflection.Execution.ReflectionDomainSetupImplementation : ReflectionDomainSetup {
    public AssemblyBinder AssemblyBinder { get; }
    public sealed virtual AssemblyBinder get_AssemblyBinder();
    public sealed virtual Exception CreateMissingMetadataException(Type pertainant);
    public sealed virtual Exception CreateNonInvokabilityException(MemberInfo pertainant);
    public sealed virtual Exception CreateMissingArrayTypeException(Type elementType, bool isMultiDim, int rank);
    public sealed virtual Exception CreateMissingConstructedGenericTypeException(Type genericTypeDefinition, Type[] genericTypeArguments);
}
public static class Internal.Reflection.Execution.ReflectionExecution : object {
    [CompilerGeneratedAttribute]
private static ExecutionEnvironmentImplementation <ExecutionEnvironment>k__BackingField;
    internal static ExecutionEnvironmentImplementation ExecutionEnvironment { get; private set; }
    internal static void Initialize();
    public static Type GetType(string typeName, string callingAssemblyName, bool throwOnError, bool ignoreCase);
    public static Type ExtensibleGetType(string typeName, string callingAssemblyName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static bool TryGetMethodMetadataFromStartAddress(IntPtr methodStartAddress, MetadataReader& reader, TypeDefinitionHandle& typeHandle, MethodHandle& methodHandle);
    [CompilerGeneratedAttribute]
internal static ExecutionEnvironmentImplementation get_ExecutionEnvironment();
    [CompilerGeneratedAttribute]
private static void set_ExecutionEnvironment(ExecutionEnvironmentImplementation value);
}
internal class Internal.Reflection.Execution.ReflectionExecutionDomainCallbacksImplementation : ReflectionExecutionDomainCallbacks {
    private ExecutionDomain _executionDomain;
    private ExecutionEnvironmentImplementation _executionEnvironment;
    public ReflectionExecutionDomainCallbacksImplementation(ExecutionDomain executionDomain, ExecutionEnvironmentImplementation executionEnvironment);
    public sealed virtual Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, string defaultAssemblyName);
    public sealed virtual bool IsReflectionBlocked(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetNamedTypeForHandle(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    public sealed virtual Type GetArrayTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetMdArrayTypeForHandle(RuntimeTypeHandle typeHandle, int rank);
    public sealed virtual Type GetPointerTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetByRefTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetConstructedGenericTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Exception CreateMissingMetadataException(Type pertainant);
    public sealed virtual string GetBetterDiagnosticInfoIfAvailable(RuntimeTypeHandle runtimeTypeHandle);
    public sealed virtual MethodBase GetMethodBaseFromStartAddressIfAvailable(IntPtr methodStartAddress);
    public sealed virtual Assembly GetAssemblyForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle runtimeTypeHandle);
    public sealed virtual RuntimeTypeHandle GetTypeHandleIfAvailable(Type type);
    public sealed virtual bool SupportsReflection(Type type);
    public sealed virtual MethodInfo GetDelegateMethod(Delegate del);
    public sealed virtual Exception GetExceptionForHR(int hr);
}
[ExtensionAttribute]
internal static class Internal.Reflection.Execution.RuntimeHandlesExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle rtth);
}
public static class Internal.Reflection.Extensions.NonPortable.DelegateMethodInfoRetriever : object {
    public static MethodInfo GetDelegateMethodInfo(Delegate del);
}
public class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
internal enum Internal.Runtime.ReflectionMapBlob : Enum {
    public int value__;
    public static ReflectionMapBlob TypeMap;
    public static ReflectionMapBlob ArrayMap;
    public static ReflectionMapBlob BlockReflectionTypeMap;
    public static ReflectionMapBlob InvokeMap;
    public static ReflectionMapBlob VirtualInvokeMap;
    public static ReflectionMapBlob CommonFixupsTable;
    public static ReflectionMapBlob FieldAccessMap;
    public static ReflectionMapBlob CCtorContextMap;
    public static ReflectionMapBlob EmbeddedMetadata;
    public static ReflectionMapBlob DefaultConstructorMap;
    public static ReflectionMapBlob UnboxingAndInstantiatingStubMap;
    public static ReflectionMapBlob StructMarshallingStubMap;
    public static ReflectionMapBlob DelegateMarshallingStubMap;
    public static ReflectionMapBlob GenericVirtualMethodTable;
    public static ReflectionMapBlob InterfaceGenericVirtualMethodTable;
    public static ReflectionMapBlob TypeTemplateMap;
    public static ReflectionMapBlob GenericMethodsTemplateMap;
    public static ReflectionMapBlob BlobIdResourceIndex;
    public static ReflectionMapBlob BlobIdResourceData;
    public static ReflectionMapBlob BlobIdStackTraceEmbeddedMetadata;
    public static ReflectionMapBlob BlobIdStackTraceMethodRvaToTokenMapping;
    public static ReflectionMapBlob NativeLayoutInfo;
    public static ReflectionMapBlob NativeReferences;
    public static ReflectionMapBlob GenericsHashtable;
    public static ReflectionMapBlob NativeStatics;
    public static ReflectionMapBlob StaticsInfoHashtable;
    public static ReflectionMapBlob GenericMethodsHashtable;
    public static ReflectionMapBlob ExactMethodInstantiationsHashtable;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class System.Collections.Generic.Empty`1 : object {
    private static IEnumerable`1<T> _enumerable;
    public static IEnumerable`1<T> Enumerable { get; }
    private static Empty`1();
    public static IEnumerable`1<T> get_Enumerable();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    internal TValue LookupOrAdd(TKey key, TValue value);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal class System.Collections.Generic.LowLevelDictionaryWithIEnumerable`2 : LowLevelDictionary`2<TKey, TValue> {
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    private void EnsureCapacity(int min);
    public void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int index);
    public sealed virtual void Insert(int index, T item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public sealed virtual bool Remove(T item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public T[] ToArray();
}
internal class System.Collections.Generic.LowLevelListWithIList`1 : LowLevelList`1<T> {
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public LowLevelListWithIList`1(int capacity);
    public LowLevelListWithIList`1(IEnumerable`1<T> collection);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.Collections.HashHelpers : object {
    public static UInt32 HashCollisionThreshold;
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    private static Int32[] s_primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockAllReflectionAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.SR : object {
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static bool _resourceManagerInited;
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Reflection_InsufficientMetadata_NoHelpAvailable { get; }
    internal static string Reflection_InsufficientMetadata_EdbNeeded { get; }
    internal static string Arg_DlgtTargMeth { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string MissingMember { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string InvalidOperation_NoValue { get; }
    internal static string RFLCT_Targ_StatFldReqTarg { get; }
    internal static string MissingConstructor_Name { get; }
    internal static string MultiDim_Of_This_Rank_Not_Supported { get; }
    internal static string Object_NotInvokable { get; }
    internal static string MakeGenericMethod_NoMetadata { get; }
    internal static string PlatformNotSupported_CannotInvokeDelegateCtor { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_GenericArgsCount { get; }
    internal static string Argument_NeverValidGenericArgument { get; }
    internal static string Argument_ConstraintFailed { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string InvalidOperation_AsyncIOInProgress { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Acc_ReadOnly { get; }
    internal static string DelegateGetMethodInfo_NoDynamic { get; }
    internal static string DelegateGetMethodInfo_NoDynamic_WithDisplayString { get; }
    internal static string DelegateGetMethodInfo_NoInstantiation { get; }
    internal static string DelegateGetMethodInfo_ObjectArrayDelegate { get; }
    internal static string Argument_InterfaceMap { get; }
    internal static string Arg_MustBeInterface { get; }
    internal static string Arg_NotFoundIFace { get; }
    internal static string Arg_InterfaceMapMustNotBeAbstract { get; }
    internal static string Acc_InitOnlyStatic { get; }
    private static SR();
    private static string InternalGetResourceString(string key);
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Reflection_InsufficientMetadata_NoHelpAvailable();
    internal static string get_Reflection_InsufficientMetadata_EdbNeeded();
    internal static string get_Arg_DlgtTargMeth();
    internal static string get_Arg_EmptyArray();
    internal static string get_MissingMember();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_InvalidOperation_NoValue();
    internal static string get_RFLCT_Targ_StatFldReqTarg();
    internal static string get_MissingConstructor_Name();
    internal static string get_MultiDim_Of_This_Rank_Not_Supported();
    internal static string get_Object_NotInvokable();
    internal static string get_MakeGenericMethod_NoMetadata();
    internal static string get_PlatformNotSupported_CannotInvokeDelegateCtor();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_GenericArgsCount();
    internal static string get_Argument_NeverValidGenericArgument();
    internal static string get_Argument_ConstraintFailed();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_InvalidOperation_AsyncIOInProgress();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Acc_ReadOnly();
    internal static string get_DelegateGetMethodInfo_NoDynamic();
    internal static string get_DelegateGetMethodInfo_NoDynamic_WithDisplayString();
    internal static string get_DelegateGetMethodInfo_NoInstantiation();
    internal static string get_DelegateGetMethodInfo_ObjectArrayDelegate();
    internal static string get_Argument_InterfaceMap();
    internal static string get_Arg_MustBeInterface();
    internal static string get_Arg_NotFoundIFace();
    internal static string get_Arg_InterfaceMapMustNotBeAbstract();
    internal static string get_Acc_InitOnlyStatic();
}
