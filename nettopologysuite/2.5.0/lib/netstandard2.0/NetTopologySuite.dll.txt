internal static class Consts : object {
    public static string PublicKeyToken;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class NetTopologySuite.Algorithm.AngleUtility : object {
    public static double PiTimes2;
    public static double PiOver2;
    public static double PiOver4;
    public static double ToDegrees(double radians);
    public static double ToRadians(double angleDegrees);
    public static double Angle(Coordinate p0, Coordinate p1);
    public static double Angle(Coordinate p);
    public static bool IsAcute(Coordinate p0, Coordinate p1, Coordinate p2);
    public static bool IsObtuse(Coordinate p0, Coordinate p1, Coordinate p2);
    public static double AngleBetween(Coordinate tip1, Coordinate tail, Coordinate tip2);
    public static double AngleBetweenOriented(Coordinate tip1, Coordinate tail, Coordinate tip2);
    public static double Bisector(Coordinate tip1, Coordinate tail, Coordinate tip2);
    public static double InteriorAngle(Coordinate p0, Coordinate p1, Coordinate p2);
    public static OrientationIndex GetTurn(double ang1, double ang2);
    public static double Normalize(double angle);
    public static double NormalizePositive(double angle);
    public static double Diff(double ang1, double ang2);
    public static Coordinate Project(Coordinate p, double angle, double dist);
}
public static class NetTopologySuite.Algorithm.Area : object {
    public static double OfRing(Coordinate[] ring);
    public static double OfRing(CoordinateSequence ring);
    public static double OfRingSigned(Coordinate[] ring);
    public static double OfRingSigned(CoordinateSequence ring);
}
public static class NetTopologySuite.Algorithm.BoundaryNodeRules : object {
    public static IBoundaryNodeRule Mod2BoundaryRule;
    public static IBoundaryNodeRule EndpointBoundaryRule;
    public static IBoundaryNodeRule MultivalentEndpointBoundaryRule;
    public static IBoundaryNodeRule MonoValentEndpointBoundaryRule;
    public static IBoundaryNodeRule OgcSfsBoundaryRule;
    private static BoundaryNodeRules();
}
public class NetTopologySuite.Algorithm.Centroid : object {
    private Coordinate _areaBasePt;
    private Coordinate _triangleCent3;
    private double _areasum2;
    private Coordinate _cg3;
    private Coordinate _lineCentSum;
    private double _totalLength;
    private int _ptCount;
    private Coordinate _ptCentSum;
    public Centroid(Geometry geom);
    public static Coordinate GetCentroid(Geometry geom);
    private void Add(Geometry geom);
    public Coordinate GetCentroid();
    private void SetAreaBasePoint(Coordinate basePt);
    private void Add(Polygon poly);
    private void AddShell(Coordinate[] pts);
    private void AddHole(Coordinate[] pts);
    private void AddTriangle(Coordinate p0, Coordinate p1, Coordinate p2, bool isPositiveArea);
    private static void Centroid3(Coordinate p1, Coordinate p2, Coordinate p3, Coordinate c);
    private static double Area2(Coordinate p1, Coordinate p2, Coordinate p3);
    private void AddLineSegments(Coordinate[] pts);
    private void AddPoint(Coordinate pt);
}
public static class NetTopologySuite.Algorithm.CGAlgorithms3D : object {
    public static double Distance(Coordinate p0, Coordinate p1);
    public static double DistancePointSegment(Coordinate p, Coordinate A, Coordinate B);
    public static double DistanceSegmentSegment(Coordinate A, Coordinate B, Coordinate C, Coordinate D);
}
public static class NetTopologySuite.Algorithm.CGAlgorithmsDD : object {
    private static double DoublePrecisionSafeEpsilon;
    public static int OrientationIndex(Coordinate p1, Coordinate p2, Coordinate q);
    public static int OrientationIndex(double p1x, double p1y, double p2x, double p2y, double qx, double qy);
    public static int SignOfDet2x2(DD x1, DD y1, DD x2, DD y2);
    private static int OrientationIndexFilter(double pax, double pay, double pbx, double pby, double pcx, double pcy);
    private static int Signum(double x);
    public static Coordinate Intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
}
public class NetTopologySuite.Algorithm.Construct.LargestEmptyCircle : object {
    private Geometry _obstacles;
    private double _tolerance;
    private GeometryFactory _factory;
    private Geometry _boundary;
    private IndexedPointInAreaLocator _ptLocater;
    private IndexedFacetDistance _obstacleDistance;
    private IndexedFacetDistance _boundaryDistance;
    private Cell _farthestCell;
    private Cell _centerCell;
    private Coordinate _centerPt;
    private Point _centerPoint;
    private Coordinate _radiusPt;
    private Point _radiusPoint;
    public LargestEmptyCircle(Geometry obstacles, double tolerance);
    public static Point GetCenter(Geometry obstacles, double tolerance);
    public static LineString GetRadiusLine(Geometry obstacles, double tolerance);
    private void SetBoundary(Geometry obstacles);
    public Point GetCenter();
    public Point GetRadiusPoint();
    public LineString GetRadiusLine();
    private double DistanceToConstraints(Point p);
    private double DistanceToConstraints(double x, double y);
    private void Compute();
    private bool MayContainCircleCenter(Cell cell);
    private void CreateInitialGrid(Envelope env, PriorityQueue`1<Cell> cellQueue);
    private Cell CreateCell(double x, double y, double h);
    private Cell CreateCentroidCell(Geometry geom);
}
public class NetTopologySuite.Algorithm.Construct.MaximumInscribedCircle : object {
    private Geometry _inputGeom;
    private double _tolerance;
    private GeometryFactory _factory;
    private IndexedPointInAreaLocator _ptLocater;
    private IndexedFacetDistance _indexedDistance;
    private Cell _centerCell;
    private Coordinate _centerPt;
    private Coordinate _radiusPt;
    private Point _centerPoint;
    private Point _radiusPoint;
    public MaximumInscribedCircle(Geometry polygonal, double tolerance);
    public static Point GetCenter(Geometry polygonal, double tolerance);
    public static LineString GetRadiusLine(Geometry polygonal, double tolerance);
    public Point GetCenter();
    public Point GetRadiusPoint();
    public LineString GetRadiusLine();
    private double DistanceToBoundary(Point p);
    private double DistanceToBoundary(double x, double y);
    private void Compute();
    private void CreateInitialGrid(Envelope env, PriorityQueue`1<Cell> cellQueue);
    private Cell CreateCell(double x, double y, double hSide);
    private Cell CreateCentroidCell(Geometry geom);
}
public class NetTopologySuite.Algorithm.ConvexHull : object {
    private GeometryFactory _geomFactory;
    private Coordinate[] _inputPts;
    public ConvexHull(Geometry geometry);
    public ConvexHull(IEnumerable`1<Coordinate> pts, GeometryFactory geomFactory);
    public static Geometry Create(IEnumerable`1<Geometry> geoms);
    private static HashSet`1<Coordinate> ExtractCoordinates(Geometry geom);
    public Geometry GetConvexHull();
    private static Coordinate[] Reduce(Coordinate[] pts);
    private static Coordinate[] PadArray3(Coordinate[] pts);
    private static Coordinate[] PreSort(Coordinate[] pts);
    private static Stack`1<Coordinate> GrahamScan(Coordinate[] c);
    private static bool IsBetween(Coordinate c1, Coordinate c2, Coordinate c3);
    private static Coordinate[] ComputeOctRing(Coordinate[] inputPts);
    private static Coordinate[] ComputeOctPts(Coordinate[] inputPts);
    private Geometry LineOrPolygon(Coordinate[] coordinates);
    private static Coordinate[] CleanRing(Coordinate[] original);
}
public class NetTopologySuite.Algorithm.Distance.DiscreteFrechetDistance : object {
    private Geometry _g0;
    private Geometry _g1;
    private PointPairDistance _ptDist;
    public Coordinate[] Coordinates { get; }
    public DiscreteFrechetDistance(Geometry g0, Geometry g1);
    public static double Distance(Geometry g0, Geometry g1);
    private double Distance();
    private static MatrixStorage CreateMatrixStorage(int rows, int cols);
    public Coordinate[] get_Coordinates();
    private static PointPairDistance ComputeFrechet(Coordinate[] coords0, Coordinate[] coords1, Int32[] diagonal, MatrixStorage distances, Dictionary`2<double, Int32[]> distanceToPair);
    private static double GetMinDistanceAtCorner(MatrixStorage matrix, int i, int j);
    private void ComputeCoordinateDistances(Coordinate[] coords0, Coordinate[] coords1, Int32[] diagonal, MatrixStorage distances, Dictionary`2<double, Int32[]> distanceToPair);
    internal static Int32[] BresenhamDiagonal(int numCols, int numRows);
}
public class NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance : object {
    private Geometry _g0;
    private Geometry _g1;
    private PointPairDistance _ptDist;
    private double _densifyFrac;
    public double DensifyFraction { get; public set; }
    public Coordinate[] Coordinates { get; }
    public DiscreteHausdorffDistance(Geometry g0, Geometry g1);
    public static double Distance(Geometry g0, Geometry g1);
    public static double Distance(Geometry g0, Geometry g1, double densifyFraction);
    public double get_DensifyFraction();
    public void set_DensifyFraction(double value);
    public double Distance();
    public double OrientedDistance();
    public Coordinate[] get_Coordinates();
    private void Compute(Geometry g0, Geometry g1);
    private void ComputeOrientedDistance(Geometry discreteGeom, Geometry geom, PointPairDistance ptDist);
}
public static class NetTopologySuite.Algorithm.Distance.DistanceToPoint : object {
    public static void ComputeDistance(Geometry geom, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(LineString line, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(LineSegment segment, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(Polygon poly, Coordinate pt, PointPairDistance ptDist);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Algorithm.Distance.PointPairDistance : object {
    private Coordinate[] _pt;
    private double _distance;
    private bool _isNull;
    public double Distance { get; }
    public Coordinate[] Coordinates { get; }
    public Coordinate Item { get; }
    public void Initialize();
    public void Initialize(Coordinate p0, Coordinate p1);
    internal void Initialize(Coordinate p0, Coordinate p1, double distance);
    public double get_Distance();
    public Coordinate[] get_Coordinates();
    public Coordinate get_Item(int i);
    public void SetMaximum(PointPairDistance ptDist);
    public void SetMaximum(Coordinate p0, Coordinate p1);
    public void SetMinimum(PointPairDistance ptDist);
    public void SetMinimum(Coordinate p0, Coordinate p1);
    public virtual string ToString();
}
public static class NetTopologySuite.Algorithm.DistanceComputer : object {
    public static double SegmentToSegment(Coordinate A, Coordinate B, Coordinate C, Coordinate D);
    public static double PointToSegmentString(Coordinate p, Coordinate[] line);
    public static double PointToSegmentString(Coordinate p, CoordinateSequence line);
    public static double PointToSegment(Coordinate p, Coordinate A, Coordinate B);
    public static double PointToLinePerpendicular(Coordinate p, Coordinate A, Coordinate B);
}
public class NetTopologySuite.Algorithm.HCoordinate : object {
    private double _x;
    private double _y;
    private double _w;
    public Coordinate Coordinate { get; }
    public HCoordinate(double x, double y, double w);
    public HCoordinate(Coordinate p);
    public HCoordinate(HCoordinate p1, HCoordinate p2);
    public HCoordinate(Coordinate p1, Coordinate p2);
    public HCoordinate(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    [ObsoleteAttribute("Use Intersection.Compute(Coordinate, Coordinate, Coordinate, Coordinate)")]
public static Coordinate Intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public static Coordinate OldIntersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public double GetX();
    public double GetY();
    public Coordinate get_Coordinate();
}
public class NetTopologySuite.Algorithm.Hull.ConcaveHull : object {
    private Geometry _inputGeometry;
    private double _maxEdgeLength;
    private double _maxEdgeLengthRatio;
    private bool _isHolesAllowed;
    private GeometryFactory _geomFactory;
    public double MaximumEdgeLength { get; public set; }
    public double MaximumEdgeLengthRatio { get; public set; }
    public bool HolesAllowed { get; public set; }
    public ConcaveHull(Geometry geom);
    public static double UniformGridEdgeLength(Geometry geom);
    public static Geometry ConcaveHullByLength(Geometry geom, double maxLength);
    public static Geometry ConcaveHullByLength(Geometry geom, double maxLength, bool isHolesAllowed);
    public static Geometry ConcaveHullByLengthRatio(Geometry geom, double lengthRatio);
    public static Geometry ConcaveHullByLengthRatio(Geometry geom, double lengthRatio, bool isHolesAllowed);
    public double get_MaximumEdgeLength();
    public void set_MaximumEdgeLength(double value);
    public double get_MaximumEdgeLengthRatio();
    public void set_MaximumEdgeLengthRatio(double value);
    public bool get_HolesAllowed();
    public void set_HolesAllowed(bool value);
    public Geometry GetHull();
    private static double ComputeTargetEdgeLength(IList`1<Tri> triList, double edgeLengthRatio);
    private void ComputeHull(IList`1<Tri> triList);
    private void ComputeHullBorder(IList`1<Tri> triList);
    private PriorityQueue`1<HullTri> CreateBorderQueue(IList`1<Tri> triList);
    private void AddBorderTri(HullTri tri, PriorityQueue`1<HullTri> queue);
    private bool IsBelowLengthThreshold(HullTri tri);
    private void ComputeHullHoles(IList`1<Tri> triList);
    private static IList`1<Tri> FindCandidateHoles(IList`1<Tri> triList, double minEdgeLen);
    private void RemoveHole(IList`1<Tri> triList, HullTri triHole);
    private bool IsRemovableBorder(HullTri tri);
    private bool IsRemovableHole(HullTri tri);
    private Geometry ToGeometry(IList`1<Tri> triList, GeometryFactory geomFactory);
}
public class NetTopologySuite.Algorithm.Hull.ConcaveHullOfPolygons : object {
    private static int FRAME_EXPAND_FACTOR;
    private Geometry _inputPolygons;
    private double _maxEdgeLength;
    private double _maxEdgeLengthRatio;
    private bool _isHolesAllowed;
    private bool _isTight;
    private GeometryFactory _geomFactory;
    private LinearRing[] _polygonRings;
    private ISet`1<Tri> _hullTris;
    private Queue`1<Tri> _borderTriQue;
    private IDictionary`2<Tri, int> _borderEdgeMap;
    public double MaximumEdgeLength { get; public set; }
    public double MaximumEdgeLengthRatio { get; public set; }
    public bool HolesAllowed { get; public set; }
    public bool Tight { get; public set; }
    public ConcaveHullOfPolygons(Geometry polygons);
    public static Geometry ConcaveHullByLength(Geometry polygons, double maxLength);
    public static Geometry ConcaveHullByLength(Geometry polygons, double maxLength, bool isTight, bool isHolesAllowed);
    public static Geometry ConcaveHullByLengthRatio(Geometry polygons, double lengthRatio);
    public static Geometry ConcaveHullByLengthRatio(Geometry polygons, double lengthRatio, bool isTight, bool isHolesAllowed);
    public static Geometry ConcaveFillByLength(Geometry polygons, double maxLength);
    public static Geometry ConcaveFillByLengthRatio(Geometry polygons, double lengthRatio);
    public double get_MaximumEdgeLength();
    public void set_MaximumEdgeLength(double value);
    public double get_MaximumEdgeLengthRatio();
    public void set_MaximumEdgeLengthRatio(double value);
    public bool get_HolesAllowed();
    public void set_HolesAllowed(bool value);
    public bool get_Tight();
    public void set_Tight(bool value);
    public Geometry GetHull();
    public Geometry GetFill();
    private Geometry CreateEmptyHull();
    private void BuildHullTris();
    private static double ComputeTargetEdgeLength(IList`1<Tri> triList, Coordinate[] frameCorners, double edgeLengthRatio);
    private static bool IsFrameTri(Tri tri, Coordinate[] frameCorners);
    private ISet`1<Tri> RemoveFrameCornerTris(IList`1<Tri> tris, Coordinate[] frameCorners);
    private static int VertexIndex(Tri tri, Coordinate[] pts);
    private void RemoveBorderTris();
    private void RemoveHoleTris();
    private Tri FindHoleSeedTri(ISet`1<Tri> tris);
    private bool IsHoleSeedTri(Tri tri);
    private bool IsBorderTri(Tri tri);
    private bool IsRemovable(Tri tri);
    private bool IsTouchingSinglePolygon(Tri tri);
    private void AddBorderTris(Tri tri);
    private void AddBorderTri(Tri tri, int index);
    private void RemoveBorderTri(Tri tri);
    private static bool HasAllVertices(LinearRing ring, Tri tri);
    private static bool HasVertex(LinearRing ring, Coordinate v);
    private static Envelope Envelope(Tri tri);
    private Geometry CreateHullGeometry(ISet`1<Tri> hullTris, bool isIncludeInput);
    private static Polygon CreateFrame(Envelope polygonsEnv, LinearRing[] polygonRings, GeometryFactory geomFactory);
    private static LinearRing[] ExtractShellRings(Geometry polygons);
}
internal class NetTopologySuite.Algorithm.Hull.HullTri : Tri {
    [CompilerGeneratedAttribute]
private double <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarked>k__BackingField;
    public double Size { get; public set; }
    public bool IsMarked { get; public set; }
    public bool IsRemoved { get; }
    public int BoundaryIndex { get; }
    public int BoundaryIndexCCW { get; }
    public int BoundaryIndexCW { get; }
    public bool IsConnecting { get; }
    public double LengthOfLongestEdge { get; }
    public double LengthOfBoundary { get; }
    public bool HasBoundaryTouch { get; }
    public HullTri(Coordinate p0, Coordinate p1, Coordinate p2);
    [CompilerGeneratedAttribute]
public double get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(double value);
    public void SetSizeToBoundary();
    [CompilerGeneratedAttribute]
public bool get_IsMarked();
    [CompilerGeneratedAttribute]
public void set_IsMarked(bool value);
    public bool get_IsRemoved();
    public int get_BoundaryIndex();
    public int get_BoundaryIndexCCW();
    public int get_BoundaryIndexCW();
    public bool get_IsConnecting();
    public int Adjacent2VertexIndex();
    public int IsolatedVertexIndex(IList`1<Tri> triList);
    public double get_LengthOfLongestEdge();
    public double get_LengthOfBoundary();
    public sealed virtual int CompareTo(HullTri o);
    private sealed virtual override int System.IComparable.CompareTo(object o);
    public bool get_HasBoundaryTouch();
    private bool IsBoundaryTouch(int index);
    public static HullTri FindTri(IEnumerable`1<Tri> triList, Tri exceptTri);
    public static bool AreAllMarked(IEnumerable`1<Tri> triList);
    public static void ClearMarks(IEnumerable`1<Tri> triList);
    public static void MarkConnected(HullTri triStart, Tri exceptTri);
    public static bool IsConnected(IList`1<Tri> triList, HullTri exceptTri);
}
internal static class NetTopologySuite.Algorithm.Hull.HullTriangulation : object {
    public static IList`1<Tri> CreateDelaunayTriangulation(Geometry geom);
    private static IList`1<Tri> ToTris(QuadEdgeSubdivision subdiv);
    public static Geometry Union(IList`1<Tri> triList, GeometryFactory geomFactory);
    public static Geometry TraceBoundaryPolygon(IList`1<Tri> triList, GeometryFactory geomFactory);
    private static Coordinate[] TraceBoundary(IList`1<Tri> triList);
    private static HullTri FindBorderTri(IList`1<Tri> triList);
    public static HullTri NextBorderTri(Tri triStart);
}
public interface NetTopologySuite.Algorithm.IBoundaryNodeRule {
    public abstract virtual bool IsInBoundary(int boundaryCount);
}
public static class NetTopologySuite.Algorithm.InteriorPoint : object {
    [ObsoleteAttribute("Use GetInteriorCoord")]
public static Point GetInteriorPoint(Geometry geom);
    public static Coordinate GetInteriorCoord(Geometry geom);
    private static Dimension EffectiveDimension(Geometry geom);
}
public class NetTopologySuite.Algorithm.InteriorPointArea : object {
    private Coordinate _interiorPoint;
    private double _maxWidth;
    public Coordinate InteriorPoint { get; }
    public InteriorPointArea(Geometry g);
    public static Coordinate GetInteriorPoint(Geometry geom);
    private static double Avg(double a, double b);
    public Coordinate get_InteriorPoint();
    private void Process(Geometry geom);
    private void ProcessPolygon(Polygon polygon);
    private static bool IntersectsHorizontalLine(Envelope env, double y);
    private static bool IntersectsHorizontalLine(Coordinate p0, Coordinate p1, double y);
}
public class NetTopologySuite.Algorithm.InteriorPointLine : object {
    private Coordinate _centroid;
    private double _minDistance;
    private Coordinate _interiorPoint;
    public Coordinate InteriorPoint { get; }
    public InteriorPointLine(Geometry g);
    public static Coordinate GetInteriorPoint(Geometry geom);
    public Coordinate get_InteriorPoint();
    private void AddInterior(Geometry geom);
    private void AddInterior(Coordinate[] pts);
    private void AddEndpoints(Geometry geom);
    private void AddEndpoints(Coordinate[] pts);
    private void Add(Coordinate point);
}
public class NetTopologySuite.Algorithm.InteriorPointPoint : object {
    private Coordinate _centroid;
    private double _minDistance;
    private Coordinate _interiorPoint;
    public Coordinate InteriorPoint { get; }
    public InteriorPointPoint(Geometry g);
    public static Coordinate GetInteriorPoint(Geometry geom);
    private void Add(Geometry geom);
    private void Add(Coordinate point);
    public Coordinate get_InteriorPoint();
}
public class NetTopologySuite.Algorithm.IntersectionComputer : object {
    public static Coordinate Intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public static Coordinate LineSegment(Coordinate line1, Coordinate line2, Coordinate seg1, Coordinate seg2);
}
public interface NetTopologySuite.Algorithm.IPointInAreaLocator {
    public abstract virtual Location Locate(Coordinate p);
}
public class NetTopologySuite.Algorithm.Length : object {
    public static double OfLine(CoordinateSequence pts);
}
public abstract class NetTopologySuite.Algorithm.LineIntersector : object {
    public static int NoIntersection;
    public static int PointIntersection;
    public static int CollinearIntersection;
    protected int Result;
    protected Coordinate[][] InputLines;
    protected Coordinate[] IntersectionPoint;
    protected Int32[] IntersectionLineIndex;
    private bool _isProper;
    private PrecisionModel _precisionModel;
    protected Coordinate Pa { get; }
    protected Coordinate Pb { get; }
    public PrecisionModel PrecisionModel { get; public set; }
    protected bool IsCollinear { get; }
    protected bool IsEndPoint { get; }
    public bool HasIntersection { get; }
    public int IntersectionNum { get; }
    public bool IsProper { get; protected set; }
    public static double ComputeEdgeDistance(Coordinate p, Coordinate p0, Coordinate p1);
    public static double NonRobustComputeEdgeDistance(Coordinate p, Coordinate p1, Coordinate p2);
    protected Coordinate get_Pa();
    protected Coordinate get_Pb();
    public PrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(PrecisionModel value);
    public Coordinate GetEndpoint(int segmentIndex, int ptIndex);
    public abstract virtual void ComputeIntersection(Coordinate p, Coordinate p1, Coordinate p2);
    protected bool get_IsCollinear();
    public void ComputeIntersection(Coordinate p1, Coordinate p2, Coordinate p3, Coordinate p4);
    public abstract virtual int ComputeIntersect(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public virtual string ToString();
    protected bool get_IsEndPoint();
    public bool get_HasIntersection();
    public int get_IntersectionNum();
    public Coordinate GetIntersection(int intIndex);
    protected void ComputeIntLineIndex();
    public bool IsIntersection(Coordinate pt);
    public bool IsInteriorIntersection();
    public bool IsInteriorIntersection(int inputLineIndex);
    public bool get_IsProper();
    protected void set_IsProper(bool value);
    public Coordinate GetIntersectionAlongSegment(int segmentIndex, int intIndex);
    public int GetIndexAlongSegment(int segmentIndex, int intIndex);
    protected void ComputeIntLineIndex(int segmentIndex);
    public double GetEdgeDistance(int segmentIndex, int intIndex);
}
public class NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator : object {
    private Geometry _geom;
    private IntervalIndexedGeometry _index;
    public IndexedPointInAreaLocator(Geometry g);
    public sealed virtual Location Locate(Coordinate p);
    private void CreateIndex();
}
public interface NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator {
    public abstract virtual Location Locate(Coordinate p);
}
public static class NetTopologySuite.Algorithm.Locate.PointOnGeometryLocatorExtensions : object {
    public static bool Intersects(IPointOnGeometryLocator locator, Coordinate coordinate);
}
public class NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator : object {
    private Geometry _geom;
    public SimplePointInAreaLocator(Geometry geom);
    public static Location Locate(Coordinate p, Geometry geom);
    public static bool IsContained(Coordinate p, Geometry geom);
    private static Location LocateInGeometry(Coordinate p, Geometry geom);
    private static Location LocatePointInPolygon(Coordinate p, Polygon poly);
    public static bool ContainsPointInPolygon(Coordinate p, Polygon poly);
    private static Location LocatePointInRing(Coordinate p, LinearRing ring);
    public sealed virtual Location Locate(Coordinate p);
}
public class NetTopologySuite.Algorithm.Match.AreaSimilarityMeasure : object {
    public sealed virtual double Measure(Geometry g1, Geometry g2);
}
public class NetTopologySuite.Algorithm.Match.FrechetSimilarityMeasure : object {
    public sealed virtual double Measure(Geometry g1, Geometry g2);
}
public class NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure : object {
    private static double DensifyFraction;
    public sealed virtual double Measure(Geometry g1, Geometry g2);
    public static double DiagonalSize(Envelope env);
}
public interface NetTopologySuite.Algorithm.Match.ISimilarityMeasure {
    public abstract virtual double Measure(Geometry g1, Geometry g2);
}
public static class NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner : object {
    public static double Combine(double measure1, double measure2);
}
public class NetTopologySuite.Algorithm.MinimumBoundingCircle : object {
    private Geometry _input;
    private Coordinate[] _extremalPts;
    private Coordinate _centre;
    private double _radius;
    public MinimumBoundingCircle(Geometry geom);
    public Geometry GetCircle();
    public Geometry GetMaximumDiameter();
    [ObsoleteAttribute("Use GetMaximumDiameter()")]
public Geometry GetFarthestPoints();
    private static Coordinate[] FarthestPoints(Coordinate[] pts);
    public Geometry GetDiameter();
    public Coordinate[] GetExtremalPoints();
    public Coordinate GetCentre();
    public double GetRadius();
    private void ComputeCentre();
    private void Compute();
    private void ComputeCirclePoints();
    private static Coordinate LowestPoint(Coordinate[] pts);
    private static Coordinate PointWitMinAngleWithX(Coordinate[] pts, Coordinate P);
    private static Coordinate PointWithMinAngleWithSegment(Coordinate[] pts, Coordinate P, Coordinate Q);
}
public class NetTopologySuite.Algorithm.MinimumDiameter : object {
    private Geometry _inputGeom;
    private bool _isConvex;
    private Coordinate[] _convexHullPts;
    private LineSegment _minBaseSeg;
    private Coordinate _minWidthPt;
    private int _minPtIndex;
    private double _minWidth;
    public double Length { get; }
    public Coordinate WidthCoordinate { get; }
    public LineString SupportingSegment { get; }
    public LineString Diameter { get; }
    public MinimumDiameter(Geometry inputGeom);
    public MinimumDiameter(Geometry inputGeom, bool isConvex);
    public static Geometry GetMinimumRectangle(Geometry geom);
    public static Geometry GetMinimumDiameter(Geometry geom);
    public double get_Length();
    public Coordinate get_WidthCoordinate();
    public LineString get_SupportingSegment();
    public LineString get_Diameter();
    private void ComputeMinimumDiameter();
    private void ComputeWidthConvex(Geometry convexGeom);
    private void ComputeConvexRingMinDiameter(Coordinate[] pts);
    private int FindMaxPerpDistance(Coordinate[] pts, LineSegment seg, int startIndex);
    private static int NextIndex(Coordinate[] pts, int index);
    public Geometry GetMinimumRectangle();
    private static LineString ComputeMaximumLine(Coordinate[] pts, GeometryFactory factory);
    private static double ComputeC(double a, double b, Coordinate p);
    private static LineSegment ComputeSegmentForLine(double a, double b, double c);
}
public class NetTopologySuite.Algorithm.NotRepresentableException : ApplicationException {
}
public static class NetTopologySuite.Algorithm.Orientation : object {
    public static OrientationIndex Index(Coordinate p1, Coordinate p2, Coordinate q);
    public static bool IsCCW(Coordinate[] ring);
    public static bool IsCCW(CoordinateSequence ring);
    public static bool IsCCWArea(Coordinate[] ring);
    public static bool IsCCWArea(CoordinateSequence ring);
    public static OrientationIndex ReOrient(OrientationIndex orientation);
}
public enum NetTopologySuite.Algorithm.OrientationIndex : Enum {
    public int value__;
    public static OrientationIndex Collinear;
    public static OrientationIndex None;
    public static OrientationIndex Straight;
    public static OrientationIndex CounterClockwise;
    public static OrientationIndex Left;
    public static OrientationIndex Clockwise;
    public static OrientationIndex Right;
}
public static class NetTopologySuite.Algorithm.PointLocation : object {
    public static bool IsOnLine(Coordinate p, Coordinate[] line);
    public static bool IsOnLine(Coordinate p, CoordinateSequence line);
    public static bool IsInRing(Coordinate p, Coordinate[] ring);
    public static bool IsInRing(Coordinate p, CoordinateSequence ring);
    public static Location LocateInRing(Coordinate p, Coordinate[] ring);
    public static Location LocateInRing(Coordinate p, CoordinateSequence ring);
}
public class NetTopologySuite.Algorithm.PointLocator : object {
    private IBoundaryNodeRule _boundaryRule;
    private bool _isIn;
    private int _numBoundaries;
    public PointLocator(IBoundaryNodeRule boundaryRule);
    public bool Intersects(Coordinate p, Geometry geom);
    public Location Locate(Coordinate p, Geometry geom);
    private void ComputeLocation(Coordinate p, Geometry geom);
    private void UpdateLocationInfo(Location loc);
    private static Location LocateOnPoint(Coordinate p, Point pt);
    private static Location LocateOnLineString(Coordinate p, LineString l);
    private static Location LocateInPolygonRing(Coordinate p, LinearRing ring);
    private Location LocateInPolygon(Coordinate p, Polygon poly);
}
public class NetTopologySuite.Algorithm.RayCrossingCounter : object {
    private Coordinate _p;
    private int _crossingCount;
    private bool _isPointOnSegment;
    public bool IsOnSegment { get; }
    public Location Location { get; }
    public bool IsPointInPolygon { get; }
    public RayCrossingCounter(Coordinate p);
    public static Location LocatePointInRing(Coordinate p, Coordinate[] ring);
    public static Location LocatePointInRing(Coordinate p, CoordinateSequence ring);
    public void CountSegment(Coordinate p1, Coordinate p2);
    public bool get_IsOnSegment();
    public Location get_Location();
    public bool get_IsPointInPolygon();
}
public class NetTopologySuite.Algorithm.RectangleLineIntersector : object {
    private LineIntersector _li;
    private Envelope _rectEnv;
    private Coordinate _diagUp0;
    private Coordinate _diagUp1;
    private Coordinate _diagDown0;
    private Coordinate _diagDown1;
    public RectangleLineIntersector(Envelope rectEnv);
    public bool Intersects(Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Algorithm.RobustDeterminant : object {
    public static int SignOfDet2x2(double x1, double y1, double x2, double y2);
    public static int OrientationIndex(Coordinate p1, Coordinate p2, Coordinate q);
}
public class NetTopologySuite.Algorithm.RobustLineIntersector : LineIntersector {
    public virtual void ComputeIntersection(Coordinate p, Coordinate p1, Coordinate p2);
    public virtual int ComputeIntersect(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private int ComputeCollinearIntersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private static Coordinate CopyWithZInterpolate(Coordinate p, Coordinate p1, Coordinate p2);
    private static Coordinate CopyWithZ(Coordinate p, double z);
    private Coordinate Intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private static Coordinate IntersectionSafe(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private bool IsInSegmentEnvelopes(Coordinate intPoint);
    private static Coordinate NearestEndpoint(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    private static double zGet(Coordinate p, Coordinate q);
    private static double zGetOrInterpolate(Coordinate p, Coordinate p1, Coordinate p2);
    private static double zInterpolate(Coordinate p, Coordinate p1, Coordinate p2);
    private static double zInterpolate(Coordinate p, Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
}
public class NetTopologySuite.DataStructures.Interval : ValueType {
    public double Min;
    public double Max;
    private bool IsEmpty { get; }
    public double Width { get; }
    public double Centre { get; }
    private Interval(double value);
    private Interval(double min, double max);
    public Interval ExpandedByValue(double p);
    private bool get_IsEmpty();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Interval other);
    public virtual string ToString();
    public double get_Width();
    public double get_Centre();
    public Interval ExpandedByInterval(Interval interval);
    public bool Overlaps(Interval interval);
    public bool Overlaps(double min, double max);
    public bool Contains(Interval interval);
    public bool Contains(double min, double max);
    public bool Contains(double p);
    public bool Intersects(Interval other);
    public bool Intersects(double min, double max);
    public static Interval Create();
    public static Interval Create(double value);
    public static Interval Create(double val1, double val2);
    public static Interval Create(Interval interval);
    public static bool op_Equality(Interval lhs, Interval rhs);
    public static bool op_Inequality(Interval lhs, Interval rhs);
}
public class NetTopologySuite.Densify.Densifier : object {
    private Geometry _inputGeom;
    private double _distanceTolerance;
    private bool _validate;
    public double DistanceTolerance { get; public set; }
    public bool Validate { get; public set; }
    public Densifier(Geometry inputGeom);
    public static Geometry Densify(Geometry geom, double distanceTolerance);
    private static Coordinate[] DensifyPoints(Coordinate[] pts, double distanceTolerance, PrecisionModel precModel);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public bool get_Validate();
    public void set_Validate(bool value);
    public Geometry GetResultGeometry();
}
public class NetTopologySuite.Dissolve.DissolveEdgeGraph : EdgeGraph {
    protected virtual HalfEdge CreateEdge(Coordinate p0);
}
public class NetTopologySuite.Dissolve.DissolveHalfEdge : MarkHalfEdge {
    private bool _isStart;
    public bool IsStart { get; }
    public DissolveHalfEdge(Coordinate orig);
    public bool get_IsStart();
    public void SetStart();
}
public class NetTopologySuite.Dissolve.LineDissolver : object {
    private Geometry _result;
    private GeometryFactory _factory;
    private DissolveEdgeGraph _graph;
    private IList`1<Geometry> _lines;
    private Stack`1<HalfEdge> _nodeEdgeStack;
    private DissolveHalfEdge _ringStartEdge;
    public static Geometry Dissolve(Geometry g);
    public void Add(Geometry geometry);
    public void Add(IEnumerable`1<Geometry> geometries);
    private void Add(LineString lineString);
    public Geometry GetResult();
    private void ComputeResult();
    private void Process(HalfEdge e);
    private void BuildLines();
    private void UpdateRingStartEdge(DissolveHalfEdge e);
    private void BuildLine(HalfEdge eStart);
    private void BuildRing(HalfEdge eStartRing);
    private void AddLine(CoordinateList line);
    private void StackEdges(HalfEdge node);
    [CompilerGeneratedAttribute]
private void <Add>b__6_0(Geometry c);
}
public class NetTopologySuite.EdgeGraph.EdgeGraph : object {
    private IDictionary`2<Coordinate, HalfEdge> _vertexMap;
    protected virtual HalfEdge CreateEdge(Coordinate orig);
    private HalfEdge Create(Coordinate p0, Coordinate p1);
    public virtual HalfEdge AddEdge(Coordinate orig, Coordinate dest);
    public static bool IsValidEdge(Coordinate orig, Coordinate dest);
    private HalfEdge Insert(Coordinate orig, Coordinate dest, HalfEdge eAdj);
    public IEnumerable`1<HalfEdge> GetVertexEdges();
    public HalfEdge FindEdge(Coordinate orig, Coordinate dest);
}
public class NetTopologySuite.EdgeGraph.EdgeGraphBuilder : object {
    private EdgeGraph graph;
    public static EdgeGraph Build(IEnumerable`1<Geometry> geoms);
    public EdgeGraph GetGraph();
    public void Add(Geometry geometry);
    public void Add(IEnumerable`1<Geometry> geometries);
    private void Add(LineString lineString);
    [CompilerGeneratedAttribute]
private void <Add>b__4_0(Geometry c);
}
public class NetTopologySuite.EdgeGraph.HalfEdge : object {
    private Coordinate _orig;
    private HalfEdge _sym;
    private HalfEdge _next;
    public Coordinate Orig { get; }
    public Coordinate Dest { get; }
    private double DirectionX { get; }
    private double DirectionY { get; }
    protected Coordinate DirectionPt { get; }
    public HalfEdge Sym { get; private set; }
    public HalfEdge Next { get; private set; }
    public HalfEdge Prev { get; }
    public HalfEdge ONext { get; }
    public bool IsEdgesSorted { get; }
    [ObsoleteAttribute("Use DirectionX")]
public double DeltaX { get; }
    [ObsoleteAttribute("Use DirectionY")]
public double DeltaY { get; }
    public HalfEdge(Coordinate orig);
    public static HalfEdge Create(Coordinate p0, Coordinate p1);
    [ObsoleteAttribute]
public static HalfEdge Init(HalfEdge e0, HalfEdge e1);
    public virtual void Link(HalfEdge sym);
    [ObsoleteAttribute("Use Link")]
protected virtual void Init(HalfEdge e);
    public Coordinate get_Orig();
    public Coordinate get_Dest();
    private double get_DirectionX();
    private double get_DirectionY();
    protected virtual Coordinate get_DirectionPt();
    public HalfEdge get_Sym();
    private void set_Sym(HalfEdge value);
    public HalfEdge get_Next();
    private void set_Next(HalfEdge value);
    public HalfEdge get_Prev();
    public HalfEdge get_ONext();
    public HalfEdge Find(Coordinate dest);
    public bool Equals(Coordinate p0, Coordinate p1);
    public void Insert(HalfEdge eAdd);
    private HalfEdge InsertionEdge(HalfEdge eAdd);
    private void InsertAfter(HalfEdge e);
    public bool get_IsEdgesSorted();
    private HalfEdge FindLowest();
    public sealed virtual int CompareTo(HalfEdge e);
    public int CompareAngularDirection(HalfEdge e);
    public double get_DeltaX();
    public double get_DeltaY();
    public virtual string ToString();
    public string ToStringNode();
    public int Degree();
    public HalfEdge PrevNode();
}
public class NetTopologySuite.EdgeGraph.MarkHalfEdge : HalfEdge {
    private bool _marked;
    public bool Marked { get; public set; }
    public MarkHalfEdge(Coordinate orig);
    public static bool IsMarked(HalfEdge e);
    public static void Mark(HalfEdge e);
    public static void SetMark(HalfEdge e, bool isMarked);
    public static void SetMarkBoth(HalfEdge e, bool isMarked);
    public static void MarkBoth(HalfEdge e);
    public void Mark();
    public bool get_Marked();
    public void set_Marked(bool value);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.Coordinate : object {
    public static double NullOrdinate;
    private double _x;
    private double _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double M { get; public set; }
    public double Item { get; public set; }
    public double Item { get; public set; }
    public Coordinate CoordinateValue { get; public set; }
    public bool IsValid { get; }
    public Coordinate(double x, double y);
    public Coordinate(Coordinate c);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual double get_Z();
    public virtual void set_Z(double value);
    public virtual double get_M();
    public virtual void set_M(double value);
    public virtual double get_Item(Ordinate ordinate);
    public virtual void set_Item(Ordinate ordinate, double value);
    public virtual double get_Item(int ordinateIndex);
    public virtual void set_Item(int ordinateIndex, double value);
    public virtual Coordinate get_CoordinateValue();
    public virtual void set_CoordinateValue(Coordinate value);
    public bool get_IsValid();
    private static bool IsFinite(double value);
    public bool Equals2D(Coordinate other);
    public bool Equals2D(Coordinate c, double tolerance);
    protected static bool EqualsWithTolerance(double v1, double v2, double tolerance);
    public bool Equals(Coordinate other);
    public sealed virtual int CompareTo(object o);
    public sealed virtual int CompareTo(Coordinate other);
    public virtual Coordinate Copy();
    public virtual Coordinate Create(double x, double y, double z, double m);
    public double Distance(Coordinate c);
    public sealed virtual bool Equals(object o);
    public sealed virtual int GetHashCode();
    public virtual string ToString();
}
public static class NetTopologySuite.Geometries.CoordinateArrays : object {
    public static int Dimension(Coordinate[] pts);
    public static int Measures(Coordinate[] pts);
    public static void EnforceConsistency(Coordinate[] array);
    public static Coordinate[] EnforceConsistency(Coordinate[] array, int dimension, int measures);
    public static bool IsRing(Coordinate[] pts);
    public static Coordinate PointNotInList(Coordinate[] testPts, Coordinate[] pts);
    public static int Compare(Coordinate[] pts1, Coordinate[] pts2);
    public static int IncreasingDirection(Coordinate[] pts);
    private static bool IsEqualReversed(Coordinate[] pts1, Coordinate[] pts2);
    public static Coordinate[] CopyDeep(Coordinate[] coordinates);
    public static void CopyDeep(Coordinate[] src, int srcStart, Coordinate[] dest, int destStart, int length);
    public static Coordinate[] ToCoordinateArray(IEnumerable`1<Coordinate> coordList);
    public static bool HasRepeatedPoints(Coordinate[] coord);
    public static Coordinate[] AtLeastNCoordinatesOrNothing(int n, Coordinate[] c);
    public static Coordinate[] RemoveRepeatedPoints(Coordinate[] coord);
    public static bool HasRepeatedOrInvalidPoints(Coordinate[] coord);
    public static Coordinate[] RemoveRepeatedOrInvalidPoints(Coordinate[] coord);
    public static Coordinate[] RemoveNull(Coordinate[] coord);
    public static void Reverse(Coordinate[] coord);
    public static bool Equals(Coordinate[] coord1, Coordinate[] coord2);
    public static bool Equals(Coordinate[] coord1, Coordinate[] coord2, IComparer`1<Coordinate[]> coordinateComparer);
    public static Coordinate MinCoordinate(Coordinate[] coordinates);
    public static void Scroll(Coordinate[] coordinates, Coordinate firstCoordinate);
    public static void Scroll(Coordinate[] coordinates, int indexOfFirstCoordinate);
    public static void Scroll(Coordinate[] coordinates, int indexOfFirstCoordinate, bool ensureRing);
    public static int IndexOf(Coordinate coordinate, Coordinate[] coordinates);
    public static Coordinate[] Extract(Coordinate[] pts, int start, int end);
    public static Envelope Envelope(Coordinate[] coordinates);
    public static Coordinate[] Intersection(Coordinate[] coordinates, Envelope env);
}
public class NetTopologySuite.Geometries.CoordinateEqualityComparer : EqualityComparer`1<Coordinate> {
    public sealed virtual bool Equals(Coordinate x, Coordinate y);
    public bool Equals(Coordinate x, Coordinate y, double tolerance);
    public sealed virtual int GetHashCode(Coordinate c);
    protected virtual bool AreEqual(Coordinate a, Coordinate b, double tolerance);
}
public class NetTopologySuite.Geometries.CoordinateList : List`1<Coordinate> {
    public CoordinateList(int capacity);
    public CoordinateList(Coordinate[] coord);
    public CoordinateList(IList`1<Coordinate> coordList);
    public CoordinateList(IList`1<Coordinate> coordList, bool allowRepeated);
    public CoordinateList(Coordinate[] coord, bool allowRepeated);
    public Coordinate GetCoordinate(int i);
    public bool Add(Coordinate[] coord, bool allowRepeated, int start, int end);
    public bool Add(Coordinate[] coord, bool allowRepeated, bool direction);
    public bool Add(Coordinate[] coord, bool allowRepeated);
    public bool Add(object obj, bool allowRepeated);
    public bool Add(Coordinate coord, bool allowRepeated);
    public void Add(int i, Coordinate coord, bool allowRepeated);
    public bool AddAll(IEnumerable`1<Coordinate> coll, bool allowRepeated);
    public void CloseRing();
    public Coordinate[] ToCoordinateArray();
    public Coordinate[] ToCoordinateArray(bool isForward);
    public sealed virtual object Clone();
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.CoordinateM : Coordinate {
    [CompilerGeneratedAttribute]
private double <M>k__BackingField;
    public double M { get; public set; }
    public double Item { get; public set; }
    public Coordinate CoordinateValue { get; public set; }
    public CoordinateM(double x, double y, double m);
    public CoordinateM(Coordinate c);
    public CoordinateM(double x, double y);
    [CompilerGeneratedAttribute]
public virtual double get_M();
    [CompilerGeneratedAttribute]
public virtual void set_M(double value);
    public virtual double get_Item(int ordinateIndex);
    public virtual void set_Item(int ordinateIndex, double value);
    public virtual Coordinate get_CoordinateValue();
    public virtual void set_CoordinateValue(Coordinate value);
    public virtual Coordinate Create(double x, double y, double z, double m);
    public virtual string ToString();
}
public static class NetTopologySuite.Geometries.Coordinates : object {
    public static Coordinate Create(int dimension);
    public static Coordinate Create(int dimension, int measures);
    public static int Dimension(Coordinate coordinate);
    public static int Measures(Coordinate coordinate);
}
public abstract class NetTopologySuite.Geometries.CoordinateSequence : object {
    private int _zIndex;
    private int _mIndex;
    [CompilerGeneratedAttribute]
private int <Dimension>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Measures>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spatial>k__BackingField;
    [CompilerGeneratedAttribute]
private Ordinates <Ordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Dimension { get; }
    public int Measures { get; }
    public int Spatial { get; }
    public Ordinates Ordinates { get; }
    public bool HasZ { get; }
    public bool HasM { get; }
    public int ZOrdinateIndex { get; }
    public int MOrdinateIndex { get; }
    public Coordinate First { get; }
    public Coordinate Last { get; }
    public int Count { get; }
    protected CoordinateSequence(int count, int dimension, int measures);
    [CompilerGeneratedAttribute]
public int get_Dimension();
    [CompilerGeneratedAttribute]
public int get_Measures();
    [CompilerGeneratedAttribute]
public int get_Spatial();
    [CompilerGeneratedAttribute]
public Ordinates get_Ordinates();
    public bool get_HasZ();
    public bool get_HasM();
    public int get_ZOrdinateIndex();
    public int get_MOrdinateIndex();
    public virtual Coordinate CreateCoordinate();
    public virtual Coordinate GetCoordinate(int i);
    public virtual Coordinate GetCoordinateCopy(int i);
    public virtual void GetCoordinate(int index, Coordinate coord);
    public virtual double GetX(int index);
    public virtual double GetY(int index);
    public virtual double GetZ(int index);
    public virtual double GetM(int index);
    public virtual void SetX(int index, double value);
    public virtual void SetY(int index, double value);
    public virtual void SetZ(int index, double value);
    public virtual void SetM(int index, double value);
    public abstract virtual double GetOrdinate(int index, int ordinateIndex);
    public double GetOrdinate(int index, Ordinate ordinate);
    public Coordinate get_First();
    public Coordinate get_Last();
    [CompilerGeneratedAttribute]
public int get_Count();
    public abstract virtual void SetOrdinate(int index, int ordinateIndex, double value);
    public void SetOrdinate(int index, Ordinate ordinate, double value);
    public virtual Coordinate[] ToCoordinateArray();
    public virtual Envelope ExpandEnvelope(Envelope env);
    public abstract virtual CoordinateSequence Copy();
    public virtual CoordinateSequence Reversed();
    public bool TryGetOrdinateIndex(Ordinate ordinate, Int32& ordinateIndex);
}
public class NetTopologySuite.Geometries.CoordinateSequenceComparator : object {
    protected int DimensionLimit;
    public CoordinateSequenceComparator(int dimensionLimit);
    public static int Compare(double a, double b);
    public int Compare(object o1, object o2);
    protected int CompareCoordinate(CoordinateSequence s1, CoordinateSequence s2, int i, int dimension);
    public sealed virtual int Compare(CoordinateSequence s1, CoordinateSequence s2);
}
[ExtensionAttribute]
public static class NetTopologySuite.Geometries.CoordinateSequenceEx : object {
    [ExtensionAttribute]
public static int GetHashCode(CoordinateSequence sequence, int baseValue, Func`2<int, int> operation);
}
public abstract class NetTopologySuite.Geometries.CoordinateSequenceFactory : object {
    [CompilerGeneratedAttribute]
private Ordinates <Ordinates>k__BackingField;
    public Ordinates Ordinates { get; }
    protected CoordinateSequenceFactory(Ordinates ordinates);
    [CompilerGeneratedAttribute]
public Ordinates get_Ordinates();
    public virtual CoordinateSequence Create(Coordinate[] coordinates);
    public virtual CoordinateSequence Create(CoordinateSequence coordSeq);
    [ObsoleteAttribute("Use an overload that accepts measures.  This overload will be removed in a future release.")]
public CoordinateSequence Create(int size, int dimension);
    public abstract virtual CoordinateSequence Create(int size, int dimension, int measures);
    public virtual CoordinateSequence Create(int size, Ordinates ordinates);
    public static ValueTuple`3<int, int, int> GetCommonSequenceParameters(Coordinate[] coordinates);
}
public static class NetTopologySuite.Geometries.CoordinateSequences : object {
    public static void Reverse(CoordinateSequence seq);
    public static void Swap(CoordinateSequence seq, int i, int j);
    public static void Copy(CoordinateSequence src, int srcPos, CoordinateSequence dest, int destPos, int length);
    private static bool TryRawCopy(PackedDoubleCoordinateSequence src, int srcPos, PackedDoubleCoordinateSequence dest, int destPos, int length);
    public static bool TryRawCopy(PackedFloatCoordinateSequence src, int srcPos, PackedFloatCoordinateSequence dest, int destPos, int length);
    private static bool TryRawCopy(DotSpatialAffineCoordinateSequence src, int srcPos, DotSpatialAffineCoordinateSequence dest, int destPos, int length);
    public static void CopyCoord(CoordinateSequence src, int srcPos, CoordinateSequence dest, int destPos);
    private static void CopyCoord(CoordinateSequence src, int srcPos, CoordinateSequence dest, int destPos, int numSpatial, int numMeasures);
    public static bool IsRing(CoordinateSequence seq);
    public static CoordinateSequence EnsureValidRing(CoordinateSequenceFactory fact, CoordinateSequence seq);
    private static CoordinateSequence CreateClosedRing(CoordinateSequenceFactory fact, CoordinateSequence seq, int size);
    public static CoordinateSequence Extend(CoordinateSequenceFactory fact, CoordinateSequence seq, int size);
    public static bool IsEqual(CoordinateSequence seq1, CoordinateSequence seq2);
    public static bool IsEqualAt(CoordinateSequence seq1, int pos1, CoordinateSequence seq2, int pos2);
    private static bool IsEqualAt(CoordinateSequence seq1, int pos1, CoordinateSequence seq2, int pos2, int numSpatial, int numMeasures);
    public static string ToString(CoordinateSequence cs);
    public static Coordinate MinCoordinate(CoordinateSequence seq);
    public static int MinCoordinateIndex(CoordinateSequence seq);
    public static int MinCoordinateIndex(CoordinateSequence seq, int from, int to);
    public static void Scroll(CoordinateSequence seq, Coordinate firstCoordinate);
    public static void Scroll(CoordinateSequence seq, int indexOfFirstCoordinate);
    public static void Scroll(CoordinateSequence seq, int indexOfFirstCoordinate, bool ensureRing);
    public static int IndexOf(Coordinate coordinate, CoordinateSequence seq);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.CoordinateZ : Coordinate {
    [CompilerGeneratedAttribute]
private double <Z>k__BackingField;
    public double Z { get; public set; }
    public double Item { get; public set; }
    public Coordinate CoordinateValue { get; public set; }
    public CoordinateZ(double x, double y, double z);
    public CoordinateZ(Coordinate c);
    public CoordinateZ(double x, double y);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Z();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Z(double value);
    public virtual double get_Item(int ordinateIndex);
    public virtual void set_Item(int ordinateIndex, double value);
    public virtual Coordinate get_CoordinateValue();
    public virtual void set_CoordinateValue(Coordinate value);
    public virtual Coordinate Create(double x, double y, double z, double m);
    public bool Equals3D(CoordinateZ other);
    public bool EqualInZ(CoordinateZ c, double tolerance);
    public virtual string ToString();
    public double Distance3D(CoordinateZ c);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.CoordinateZM : CoordinateZ {
    [CompilerGeneratedAttribute]
private double <M>k__BackingField;
    public double M { get; public set; }
    public double Item { get; public set; }
    public Coordinate CoordinateValue { get; public set; }
    public CoordinateZM(double x, double y, double z, double m);
    public CoordinateZM(Coordinate c);
    public CoordinateZM(double x, double y);
    [CompilerGeneratedAttribute]
public virtual double get_M();
    [CompilerGeneratedAttribute]
public virtual void set_M(double value);
    public virtual double get_Item(int ordinateIndex);
    public virtual void set_Item(int ordinateIndex, double value);
    public virtual Coordinate get_CoordinateValue();
    public virtual void set_CoordinateValue(Coordinate value);
    public virtual Coordinate Create(double x, double y, double z, double m);
    public virtual string ToString();
}
public enum NetTopologySuite.Geometries.Dimension : Enum {
    public int value__;
    public static Dimension Point;
    public static Dimension P;
    public static Dimension Curve;
    public static Dimension L;
    public static Dimension Surface;
    public static Dimension A;
    public static Dimension False;
    public static Dimension True;
    public static Dimension Dontcare;
    public static Dimension Unknown;
    public static Dimension Collapse;
}
public class NetTopologySuite.Geometries.DimensionUtility : object {
    public static char SymFalse;
    public static char SymTrue;
    public static char SymDontcare;
    public static char SymP;
    public static char SymL;
    public static char SymA;
    public static char ToDimensionSymbol(Dimension dimensionValue);
    public static Dimension ToDimensionValue(char dimensionSymbol);
}
public class NetTopologySuite.Geometries.Envelope : object {
    private double _minX;
    private double _maxX;
    private double _minY;
    private double _maxY;
    public bool IsNull { get; }
    public double Width { get; }
    public double Height { get; }
    public double Diameter { get; }
    public double MinX { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public double MaxY { get; }
    public double Area { get; }
    public double MinExtent { get; }
    public double MaxExtent { get; }
    public Coordinate Centre { get; }
    public Envelope(double x1, double x2, double y1, double y2);
    public Envelope(Coordinate p1, Coordinate p2);
    public Envelope(Coordinate p);
    public Envelope(IEnumerable`1<Coordinate> pts);
    public Envelope(CoordinateSequence sequence);
    public Envelope(Envelope env);
    public static bool Intersects(Coordinate p1, Coordinate p2, Coordinate q);
    public static bool Intersects(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2);
    public void Init();
    public void Init(double x1, double x2, double y1, double y2);
    public void Init(Coordinate p1, Coordinate p2);
    public void Init(Coordinate p);
    public void Init(Envelope env);
    public void SetToNull();
    public bool get_IsNull();
    public double get_Width();
    public double get_Height();
    public double get_Diameter();
    public double get_MinX();
    public double get_MaxX();
    public double get_MinY();
    public double get_MaxY();
    public double get_Area();
    public void ExpandBy(double distance);
    public void ExpandBy(double deltaX, double deltaY);
    public double get_MinExtent();
    public double get_MaxExtent();
    public void ExpandToInclude(Coordinate p);
    public void ExpandToInclude(double x, double y);
    public sealed virtual void ExpandToInclude(Envelope other);
    public sealed virtual Envelope ExpandedBy(Envelope other);
    public void Translate(double transX, double transY);
    public Coordinate get_Centre();
    public Envelope Intersection(Envelope env);
    public sealed virtual bool Intersects(Envelope other);
    public bool Intersects(Coordinate p);
    public bool Intersects(double x, double y);
    public bool Intersects(Coordinate a, Coordinate b);
    public bool Disjoint(Envelope other);
    public bool Contains(Envelope other);
    public bool Contains(Coordinate p);
    public bool Contains(double x, double y);
    public bool Covers(double x, double y);
    public bool Covers(Coordinate p);
    public bool Covers(Envelope other);
    public double Distance(Envelope env);
    public virtual bool Equals(object o);
    public bool Equals(Envelope other);
    public int CompareTo(object o);
    public sealed virtual int CompareTo(Envelope env);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Envelope Copy();
    public static Envelope Parse(string envelope);
}
[DefaultMemberAttribute("Item")]
internal class NetTopologySuite.Geometries.ExtraDimensionalCoordinate : Coordinate {
    private Double[] _extraValues;
    [CompilerGeneratedAttribute]
private int <Measures>k__BackingField;
    public int Dimension { get; }
    public int Measures { get; }
    public double Z { get; public set; }
    public double M { get; public set; }
    public double Item { get; public set; }
    public double Item { get; public set; }
    public Coordinate CoordinateValue { get; public set; }
    public ExtraDimensionalCoordinate(int dimension, int measures);
    private ExtraDimensionalCoordinate(double x, double y, Double[] extraValues, int measures);
    public int get_Dimension();
    [CompilerGeneratedAttribute]
public int get_Measures();
    public virtual double get_Z();
    public virtual void set_Z(double value);
    public virtual double get_M();
    public virtual void set_M(double value);
    public virtual double get_Item(int ordinateIndex);
    public virtual void set_Item(int ordinateIndex, double value);
    public virtual double get_Item(Ordinate ordinate);
    public virtual void set_Item(Ordinate ordinate, double value);
    public virtual Coordinate get_CoordinateValue();
    public virtual void set_CoordinateValue(Coordinate value);
    public virtual Coordinate Copy();
}
public class NetTopologySuite.Geometries.FilterMethod : MulticastDelegate {
    public FilterMethod(object object, IntPtr method);
    public virtual void Invoke(Geometry geom);
    public virtual IAsyncResult BeginInvoke(Geometry geom, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class NetTopologySuite.Geometries.Geometry : object {
    public static string TypeNamePoint;
    public static string TypeNameMultiPoint;
    public static string TypeNameLineString;
    public static string TypeNameLinearRing;
    public static string TypeNameMultiLineString;
    public static string TypeNamePolygon;
    public static string TypeNameMultiPolygon;
    public static string TypeNameGeometryCollection;
    private GeometryFactory _factory;
    private object _userData;
    private Envelope _envelope;
    public static GeometryFactory DefaultFactory;
    public GeometryFactory Factory { get; }
    public object UserData { get; public set; }
    public int SRID { get; public set; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public PrecisionModel PrecisionModel { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public int NumPoints { get; }
    public int NumGeometries { get; }
    public bool IsSimple { get; }
    public bool IsValid { get; }
    public bool IsEmpty { get; }
    public double Area { get; }
    public double Length { get; }
    public Point Centroid { get; }
    public Point InteriorPoint { get; }
    public Point PointOnSurface { get; }
    public Dimension Dimension { get; }
    public Geometry Boundary { get; }
    public Dimension BoundaryDimension { get; }
    public Geometry Envelope { get; }
    public Envelope EnvelopeInternal { get; }
    protected bool IsGeometryCollection { get; }
    protected SortIndexValue SortIndex { get; }
    public bool IsRectangle { get; }
    protected Geometry(GeometryFactory factory);
    private static Geometry();
    public GeometryFactory get_Factory();
    public object get_UserData();
    public void set_UserData(object value);
    public int get_SRID();
    public void set_SRID(int value);
    public abstract virtual string get_GeometryType();
    public abstract virtual OgcGeometryType get_OgcGeometryType();
    protected static bool HasNonEmptyElements(Geometry[] geometries);
    [ObsoleteAttribute("Use HasNullElements<T>")]
public static bool HasNullElements(Object[] array);
    public static bool HasNullElements(IEnumerable`1<T> array);
    public PrecisionModel get_PrecisionModel();
    public abstract virtual Coordinate get_Coordinate();
    public abstract virtual Coordinate[] get_Coordinates();
    public abstract virtual Double[] GetOrdinates(Ordinate ordinate);
    public abstract virtual int get_NumPoints();
    public virtual int get_NumGeometries();
    public virtual Geometry GetGeometryN(int n);
    public virtual bool get_IsSimple();
    public virtual bool get_IsValid();
    public abstract virtual bool get_IsEmpty();
    public virtual double Distance(Geometry g);
    public virtual bool IsWithinDistance(Geometry geom, double distance);
    public virtual double get_Area();
    public virtual double get_Length();
    public virtual Point get_Centroid();
    public virtual Point get_InteriorPoint();
    public Point get_PointOnSurface();
    public abstract virtual Dimension get_Dimension();
    public abstract virtual Geometry get_Boundary();
    public abstract virtual Dimension get_BoundaryDimension();
    public Geometry get_Envelope();
    public Envelope get_EnvelopeInternal();
    public void GeometryChanged();
    public void GeometryChangedAction();
    public bool Disjoint(Geometry g);
    public virtual bool Touches(Geometry g);
    public virtual bool Intersects(Geometry g);
    public virtual bool Crosses(Geometry g);
    public bool Within(Geometry g);
    public virtual bool Contains(Geometry g);
    public virtual bool Overlaps(Geometry g);
    public virtual bool Covers(Geometry g);
    public bool CoveredBy(Geometry g);
    public virtual bool Relate(Geometry g, string intersectionPattern);
    public virtual IntersectionMatrix Relate(Geometry g);
    public bool Equals(Geometry g);
    public virtual bool EqualsTopologically(Geometry g);
    public virtual bool Equals(object o);
    private static bool CompareGeometryCollections(Geometry obj1, Geometry obj2);
    public static bool op_Equality(Geometry obj1, Geometry obj2);
    public static bool op_Inequality(Geometry obj1, Geometry obj2);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToText();
    public string AsText();
    public Byte[] ToBinary();
    public Byte[] AsBinary();
    public XmlReader ToGMLFeature();
    public Geometry Buffer(double distance);
    public Geometry Buffer(double distance, EndCapStyle endCapStyle);
    public Geometry Buffer(double distance, int quadrantSegments);
    public Geometry Buffer(double distance, int quadrantSegments, EndCapStyle endCapStyle);
    public Geometry Buffer(double distance, BufferParameters bufferParameters);
    public virtual Geometry ConvexHull();
    public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
    public Geometry Intersection(Geometry other);
    public Geometry Union(Geometry other);
    public Geometry Difference(Geometry other);
    public Geometry SymmetricDifference(Geometry other);
    public Geometry Union();
    public abstract virtual bool EqualsExact(Geometry other, double tolerance);
    public bool EqualsExact(Geometry other);
    public bool EqualsNormalized(Geometry g);
    public abstract virtual void Apply(ICoordinateFilter filter);
    public abstract virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IEntireCoordinateSequenceFilter filter);
    public abstract virtual void Apply(IGeometryFilter filter);
    public abstract virtual void Apply(IGeometryComponentFilter filter);
    public Geometry Copy();
    protected abstract virtual Geometry CopyInternal();
    public abstract virtual void Normalize();
    public Geometry Normalized();
    public sealed virtual int CompareTo(object o);
    public sealed virtual int CompareTo(Geometry geom);
    public int CompareTo(object o, IComparer`1<CoordinateSequence> comp);
    protected virtual bool IsEquivalentClass(Geometry other);
    protected static void CheckNotGeometryCollection(Geometry g);
    protected bool get_IsGeometryCollection();
    protected abstract virtual Envelope ComputeEnvelopeInternal();
    protected internal abstract virtual int CompareToSameClass(object o);
    protected internal abstract virtual int CompareToSameClass(object o, IComparer`1<CoordinateSequence> comp);
    protected static int Compare(List`1<Geometry> a, List`1<Geometry> b);
    [ObsoleteAttribute("Will be removed in a future version")]
protected static bool Equal(Coordinate a, Coordinate b, double tolerance);
    protected abstract virtual SortIndexValue get_SortIndex();
    private static Point CreatePointFromInternalCoord(Coordinate coord, Geometry exemplar);
    public virtual bool get_IsRectangle();
    protected static Double[] CreateArray(int size, double value);
    protected static Double[] CreateArray(CoordinateSequence sequence, Ordinate ordinate);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.GeometryCollection : Geometry {
    public static GeometryCollection Empty;
    private Geometry[] _geometries;
    protected SortIndexValue SortIndex { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public bool IsEmpty { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public int NumGeometries { get; }
    public Geometry[] Geometries { get; protected set; }
    public int NumPoints { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public Geometry Boundary { get; }
    public double Area { get; }
    public double Length { get; }
    public bool IsHomogeneous { get; }
    public Geometry Item { get; }
    public int Count { get; }
    public GeometryCollection(Geometry[] geometries);
    public GeometryCollection(Geometry[] geometries, GeometryFactory factory);
    private static GeometryCollection();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Coordinate get_Coordinate();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public virtual bool get_IsEmpty();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual int get_NumGeometries();
    public virtual Geometry GetGeometryN(int n);
    public Geometry[] get_Geometries();
    protected void set_Geometries(Geometry[] value);
    public virtual int get_NumPoints();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual Geometry get_Boundary();
    public virtual double get_Area();
    public virtual double get_Length();
    public virtual bool EqualsExact(Geometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IEntireCoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    protected virtual Geometry CopyInternal();
    public virtual void Normalize();
    protected virtual Envelope ComputeEnvelopeInternal();
    protected internal virtual int CompareToSameClass(object o);
    protected internal virtual int CompareToSameClass(object o, IComparer`1<CoordinateSequence> comp);
    public bool get_IsHomogeneous();
    public sealed virtual IEnumerator`1<Geometry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Geometry get_Item(int i);
    [ObsoleteAttribute("Call Geometry.Reverse()")]
public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
    public int get_Count();
}
public class NetTopologySuite.Geometries.GeometryCollectionEnumerator : object {
    private Geometry _parent;
    private bool _atStart;
    private int _max;
    private int _index;
    private GeometryCollectionEnumerator _subcollectionEnumerator;
    private Geometry _current;
    private object System.Collections.IEnumerator.Current { get; }
    public Geometry Current { get; }
    public GeometryCollectionEnumerator(Geometry parent);
    private bool HasNext();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
    public sealed virtual Geometry get_Current();
    private static bool IsAtomic(Geometry geom);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<Geometry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NetTopologySuite.Geometries.GeometryComponentFilter : object {
    private FilterMethod _do;
    public GeometryComponentFilter(FilterMethod filterMethod);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Geometries.GeometryFactory : object {
    public static GeometryFactory Default;
    public static GeometryFactory Floating;
    public static GeometryFactory FloatingSingle;
    public static GeometryFactory Fixed;
    private PrecisionModel _precisionModel;
    private CoordinateSequenceFactory _coordinateSequenceFactory;
    private int _srid;
    private NtsGeometryServices _services;
    public PrecisionModel PrecisionModel { get; }
    public CoordinateSequenceFactory CoordinateSequenceFactory { get; }
    public int SRID { get; }
    internal GeometryOverlay GeometryOverlay { get; }
    internal CoordinateEqualityComparer CoordinateEqualityComparer { get; }
    public NtsGeometryServices GeometryServices { get; }
    public GeometryFactory(PrecisionModel precisionModel, int srid, CoordinateSequenceFactory coordinateSequenceFactory, NtsGeometryServices services);
    public GeometryFactory(PrecisionModel precisionModel, int srid, CoordinateSequenceFactory coordinateSequenceFactory);
    public GeometryFactory(CoordinateSequenceFactory coordinateSequenceFactory);
    public GeometryFactory(PrecisionModel precisionModel);
    public GeometryFactory(PrecisionModel precisionModel, int srid);
    private static GeometryFactory();
    public PrecisionModel get_PrecisionModel();
    public CoordinateSequenceFactory get_CoordinateSequenceFactory();
    public int get_SRID();
    internal GeometryOverlay get_GeometryOverlay();
    internal CoordinateEqualityComparer get_CoordinateEqualityComparer();
    public NtsGeometryServices get_GeometryServices();
    public static Point CreatePointFromInternalCoord(Coordinate coord, Geometry exemplar);
    public static Point[] ToPointArray(IEnumerable`1<Geometry> points);
    public static Geometry[] ToGeometryArray(IEnumerable`1<Geometry> geometries);
    public static LineString[] ToLineStringArray(IEnumerable`1<Geometry> lineStrings);
    public static LinearRing[] ToLinearRingArray(IEnumerable`1<Geometry> linearRings);
    public static Polygon[] ToPolygonArray(IEnumerable`1<Geometry> polygons);
    public static MultiPoint[] ToMultiPointArray(IEnumerable`1<Geometry> multiPoints);
    public static MultiLineString[] ToMultiLineStringArray(IEnumerable`1<Geometry> multiLineStrings);
    public static MultiPolygon[] ToMultiPolygonArray(IEnumerable`1<Geometry> multiPolygons);
    public virtual Geometry ToGeometry(Envelope envelope);
    public Point CreatePoint();
    public Point CreatePoint(Coordinate coordinate);
    public virtual Point CreatePoint(CoordinateSequence coordinates);
    public LineString CreateLineString();
    public LineString CreateLineString(Coordinate[] coordinates);
    public virtual LineString CreateLineString(CoordinateSequence coordinates);
    public LinearRing CreateLinearRing();
    public LinearRing CreateLinearRing(Coordinate[] coordinates);
    public virtual LinearRing CreateLinearRing(CoordinateSequence coordinates);
    public Polygon CreatePolygon();
    public virtual Polygon CreatePolygon(LinearRing shell, LinearRing[] holes);
    public virtual Polygon CreatePolygon(CoordinateSequence coordinates);
    public virtual Polygon CreatePolygon(Coordinate[] coordinates);
    public virtual Polygon CreatePolygon(LinearRing shell);
    public MultiPoint CreateMultiPoint();
    public virtual MultiPoint CreateMultiPoint(Point[] point);
    public MultiPoint CreateMultiPointFromCoords(Coordinate[] coordinates);
    public MultiPoint CreateMultiPoint(CoordinateSequence coordinates);
    public MultiLineString CreateMultiLineString();
    public virtual MultiLineString CreateMultiLineString(LineString[] lineStrings);
    public MultiPolygon CreateMultiPolygon();
    public virtual MultiPolygon CreateMultiPolygon(Polygon[] polygons);
    public GeometryCollection CreateGeometryCollection();
    public virtual GeometryCollection CreateGeometryCollection(Geometry[] geometries);
    public virtual Geometry BuildGeometry(IEnumerable`1<Geometry> geomList);
    public Geometry CreateEmpty(Dimension dimension);
    public virtual Geometry CreateGeometry(Geometry g);
    public virtual GeometryFactory WithSRID(int srid);
    public virtual string ToString();
    [OnDeserializedAttribute]
protected void OnDeserialized(StreamingContext context);
    [CompilerGeneratedAttribute]
private CoordinateSequence <CreateGeometry>b__62_0(CoordinateSequence x, Geometry y);
}
public class NetTopologySuite.Geometries.GeometryFactoryEx : GeometryFactory {
    [CompilerGeneratedAttribute]
private static LinearRingOrientation <DefaultShellRingOrientation>k__BackingField;
    private static PrecisionModel FloatingPrecisionModel;
    private static CoordinateSequenceFactory _defaultCoordinateSequenceFactory;
    private static PrecisionModel _defaultPrecisionModel;
    [CompilerGeneratedAttribute]
private static int <DefaultSRID>k__BackingField;
    private Lazy`1<LinearRingOrientation> _polygonShellRingOrientation;
    private static LinearRingOrientation DefaultShellRingOrientation { get; private set; }
    public static PrecisionModel DefaultPrecisionModel { get; public set; }
    public static CoordinateSequenceFactory DefaultCoordinateSequenceFactory { get; public set; }
    public static int DefaultSRID { get; public set; }
    public LinearRingOrientation OrientationOfExteriorRing { get; public set; }
    private LinearRingOrientation OrientationOfInteriorRings { get; }
    public GeometryFactoryEx(PrecisionModel precisionModel, int srid, CoordinateSequenceFactory coordinateSequenceFactory, NtsGeometryServices services);
    public GeometryFactoryEx(PrecisionModel precisionModel, int srid, CoordinateSequenceFactory coordinateSequenceFactory);
    public GeometryFactoryEx(CoordinateSequenceFactory coordinateSequenceFactory);
    public GeometryFactoryEx(PrecisionModel precisionModel);
    public GeometryFactoryEx(PrecisionModel precisionModel, int srid);
    private static GeometryFactoryEx();
    [CompilerGeneratedAttribute]
private static LinearRingOrientation get_DefaultShellRingOrientation();
    [CompilerGeneratedAttribute]
private static void set_DefaultShellRingOrientation(LinearRingOrientation value);
    public static PrecisionModel get_DefaultPrecisionModel();
    public static void set_DefaultPrecisionModel(PrecisionModel value);
    public static CoordinateSequenceFactory get_DefaultCoordinateSequenceFactory();
    public static void set_DefaultCoordinateSequenceFactory(CoordinateSequenceFactory value);
    [CompilerGeneratedAttribute]
public static int get_DefaultSRID();
    [CompilerGeneratedAttribute]
public static void set_DefaultSRID(int value);
    public LinearRingOrientation get_OrientationOfExteriorRing();
    public void set_OrientationOfExteriorRing(LinearRingOrientation value);
    private LinearRingOrientation get_OrientationOfInteriorRings();
    public virtual Polygon CreatePolygon(LinearRing shell, LinearRing[] holes);
    public virtual MultiPolygon CreateMultiPolygon(Polygon[] polygons);
    public virtual GeometryFactory WithSRID(int srid);
    private static LinearRing EnsureOrientation(LinearRing ring, LinearRingOrientation ringOrientation);
}
public abstract class NetTopologySuite.Geometries.GeometryOverlay : object {
    public static GeometryOverlay Legacy { get; }
    public static GeometryOverlay NG { get; }
    public static GeometryOverlay get_Legacy();
    public static GeometryOverlay get_NG();
    protected abstract virtual Geometry Overlay(Geometry a, Geometry b, SpatialFunction opCode);
    public virtual Geometry Intersection(Geometry a, Geometry b);
    public virtual Geometry Union(Geometry a, Geometry b);
    public virtual Geometry Difference(Geometry a, Geometry b);
    public virtual Geometry SymmetricDifference(Geometry a, Geometry b);
    public abstract virtual Geometry Union(Geometry a);
    private static void CheckNotGeometryCollection(Geometry a, Geometry b);
}
public interface NetTopologySuite.Geometries.IBoundable`2 {
    public T Bounds { get; }
    public TItem Item { get; }
    public abstract virtual T get_Bounds();
    public abstract virtual TItem get_Item();
}
public interface NetTopologySuite.Geometries.ICoordinateFilter {
    public abstract virtual void Filter(Coordinate coord);
}
public interface NetTopologySuite.Geometries.ICoordinateSequenceFilter {
    public bool Done { get; }
    public bool GeometryChanged { get; }
    public abstract virtual void Filter(CoordinateSequence seq, int i);
    public abstract virtual bool get_Done();
    public abstract virtual bool get_GeometryChanged();
}
public interface NetTopologySuite.Geometries.IEntireCoordinateSequenceFilter {
    public bool Done { get; }
    public bool GeometryChanged { get; }
    public abstract virtual bool get_Done();
    public abstract virtual bool get_GeometryChanged();
    public abstract virtual void Filter(CoordinateSequence seq);
}
public interface NetTopologySuite.Geometries.IExpandable`1 {
    public abstract virtual void ExpandToInclude(T other);
    public abstract virtual T ExpandedBy(T other);
}
public interface NetTopologySuite.Geometries.IGeometryComponentFilter {
    public abstract virtual void Filter(Geometry geom);
}
public interface NetTopologySuite.Geometries.IGeometryFilter {
    public abstract virtual void Filter(Geometry geom);
}
public interface NetTopologySuite.Geometries.IIntersectable`1 {
    public abstract virtual bool Intersects(T other);
}
public interface NetTopologySuite.Geometries.ILineal {
}
public class NetTopologySuite.Geometries.Implementation.CoordinateArraySequence : CoordinateSequence {
    protected Coordinate[] Coordinates;
    public CoordinateArraySequence(Coordinate[] coordinates);
    [ObsoleteAttribute("Use an overload that accepts measures.  This overload will be removed in a future release.")]
public CoordinateArraySequence(Coordinate[] coordinates, int dimension);
    public CoordinateArraySequence(Coordinate[] coordinates, int dimension, int measures);
    public CoordinateArraySequence(int size);
    [ObsoleteAttribute("Use an overload that accepts measures.  This overload will be removed in a future release.")]
public CoordinateArraySequence(int size, int dimension);
    public CoordinateArraySequence(int size, int dimension, int measures);
    public CoordinateArraySequence(CoordinateSequence coordSeq);
    [ObsoleteAttribute("It is the clients responsibility to provide consistent arrays")]
protected Coordinate[] EnforceArrayConsistency(Coordinate[] array);
    public virtual Coordinate GetCoordinate(int i);
    public virtual Coordinate GetCoordinateCopy(int i);
    public virtual void GetCoordinate(int index, Coordinate coord);
    public virtual double GetX(int index);
    public virtual double GetY(int index);
    public virtual double GetZ(int index);
    public virtual double GetM(int index);
    public virtual double GetOrdinate(int index, int ordinateIndex);
    public virtual CoordinateSequence Copy();
    protected Coordinate[] GetClonedCoordinates();
    public virtual void SetOrdinate(int index, int ordinateIndex, double value);
    public virtual Coordinate[] ToCoordinateArray();
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual CoordinateSequence Reversed();
    public virtual string ToString();
    private static int GetDimensionAndMeasures(Coordinate[] coords, Int32& measures);
}
public class NetTopologySuite.Geometries.Implementation.CoordinateArraySequenceFactory : CoordinateSequenceFactory {
    [CompilerGeneratedAttribute]
private static CoordinateArraySequenceFactory <Instance>k__BackingField;
    public static CoordinateArraySequenceFactory Instance { get; }
    private static CoordinateArraySequenceFactory();
    [CompilerGeneratedAttribute]
public static CoordinateArraySequenceFactory get_Instance();
    public virtual CoordinateSequence Create(Coordinate[] coordinates);
    public virtual CoordinateSequence Create(CoordinateSequence coordSeq);
    public virtual CoordinateSequence Create(int size, int dimension, int measures);
}
public class NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequence : CoordinateSequence {
    private Double[] _xy;
    private Double[] _z;
    private Double[] _m;
    private WeakReference`1<Coordinate[]> _coordinateArrayRef;
    public Double[] XY { get; }
    public Double[] Z { get; }
    public Double[] M { get; }
    public DotSpatialAffineCoordinateSequence(IReadOnlyCollection`1<Coordinate> coordinates, Ordinates ordinates);
    public DotSpatialAffineCoordinateSequence(int size, int dimension, int measures);
    public DotSpatialAffineCoordinateSequence(int size, Ordinates ordinates);
    public DotSpatialAffineCoordinateSequence(CoordinateSequence coordSeq, Ordinates ordinates);
    public DotSpatialAffineCoordinateSequence(Double[] xy, Double[] z, Double[] m);
    private static Double[] NullOrdinateArray(int size);
    public virtual CoordinateSequence Copy();
    public virtual Coordinate GetCoordinateCopy(int i);
    public virtual void GetCoordinate(int index, Coordinate coord);
    public virtual double GetX(int index);
    public virtual double GetY(int index);
    public virtual double GetZ(int index);
    public virtual double GetM(int index);
    public virtual void SetX(int index, double value);
    public virtual void SetY(int index, double value);
    public virtual void SetZ(int index, double value);
    public virtual void SetM(int index, double value);
    public virtual double GetOrdinate(int index, int ordinateIndex);
    public virtual void SetOrdinate(int index, int ordinateIndex, double value);
    private Coordinate[] GetCachedCoords();
    public virtual Coordinate[] ToCoordinateArray();
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual CoordinateSequence Reversed();
    public Double[] get_XY();
    public Double[] get_Z();
    public Double[] get_M();
    public void ReleaseCoordinateArray();
    private static int ClipDimension(int dimension, int measures);
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__ThrowForInconsistentCount|4_0();
}
public class NetTopologySuite.Geometries.Implementation.DotSpatialAffineCoordinateSequenceFactory : CoordinateSequenceFactory {
    [CompilerGeneratedAttribute]
private static DotSpatialAffineCoordinateSequenceFactory <Instance>k__BackingField;
    public static DotSpatialAffineCoordinateSequenceFactory Instance { get; }
    public DotSpatialAffineCoordinateSequenceFactory(Ordinates ordinates);
    private static DotSpatialAffineCoordinateSequenceFactory();
    [CompilerGeneratedAttribute]
public static DotSpatialAffineCoordinateSequenceFactory get_Instance();
    public virtual CoordinateSequence Create(Coordinate[] coordinates);
    public virtual CoordinateSequence Create(CoordinateSequence coordSeq);
    public virtual CoordinateSequence Create(int size, int dimension, int measures);
    public virtual CoordinateSequence Create(int size, Ordinates ordinates);
    public CoordinateSequence Create(Double[] xy);
    public CoordinateSequence Create(Double[] xy, Double[] zm, bool isMeasure);
    public CoordinateSequence Create(Double[] xy, Double[] z, Double[] m);
}
public abstract class NetTopologySuite.Geometries.Implementation.PackedCoordinateSequence : CoordinateSequence {
    protected WeakReference CoordRef;
    protected PackedCoordinateSequence(int count, int dimension, int measures);
    public sealed virtual Coordinate GetCoordinate(int i);
    public sealed virtual Coordinate[] ToCoordinateArray();
    public void ReleaseCoordinateArray();
    private Coordinate[] GetCachedCoords();
    public virtual string ToString();
    [ObsoleteAttribute("Unused.  This will be removed in a future release.")]
protected virtual Coordinate GetCoordinateInternal(int index);
    private protected static int GetDimensionAndMeasures(Coordinate[] coords, Int32& measures);
    [OnDeserializedAttribute]
private void OnDeserialization(StreamingContext context);
}
public class NetTopologySuite.Geometries.Implementation.PackedCoordinateSequenceFactory : CoordinateSequenceFactory {
    public static PackedCoordinateSequenceFactory DoubleFactory;
    public static PackedCoordinateSequenceFactory FloatFactory;
    private PackedType _type;
    public PackedType Type { get; public set; }
    public PackedCoordinateSequenceFactory(PackedType type);
    private static PackedCoordinateSequenceFactory();
    public PackedType get_Type();
    public void set_Type(PackedType value);
    public virtual CoordinateSequence Create(Coordinate[] coordinates);
    public virtual CoordinateSequence Create(CoordinateSequence coordSeq);
    [ObsoleteAttribute("Use an overload that accepts measures.  This overload will be removed in a future release.")]
public CoordinateSequence Create(Double[] packedCoordinates, int dimension);
    public CoordinateSequence Create(Double[] packedCoordinates, int dimension, int measures);
    [ObsoleteAttribute("Use an overload that accepts measures.  This overload will be removed in a future release.")]
public CoordinateSequence Create(Single[] packedCoordinates, int dimension);
    public CoordinateSequence Create(Single[] packedCoordinates, int dimension, int measures);
    public virtual CoordinateSequence Create(int size, int dimension, int measures);
}
public class NetTopologySuite.Geometries.Implementation.PackedDoubleCoordinateSequence : PackedCoordinateSequence {
    private Double[] _coords;
    public PackedDoubleCoordinateSequence(Double[] coords, int dimension, int measures);
    public PackedDoubleCoordinateSequence(Single[] coords, int dimension, int measures);
    public PackedDoubleCoordinateSequence(Coordinate[] coords);
    [ObsoleteAttribute("Use an overload that accepts measures.  This overload will be removed in a future release.")]
public PackedDoubleCoordinateSequence(Coordinate[] coords, int dimension);
    public PackedDoubleCoordinateSequence(Coordinate[] coords, int dimension, int measures);
    public PackedDoubleCoordinateSequence(int size, int dimension, int measures);
    internal PackedDoubleCoordinateSequence(Coordinate[] coords, int dimension, int measures, bool dimensionAndMeasuresCameFromCoords);
    public Double[] GetRawCoordinates();
    public virtual CoordinateSequence Copy();
    public virtual double GetOrdinate(int index, int ordinateIndex);
    public virtual void SetOrdinate(int index, int ordinateIndex, double value);
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual CoordinateSequence Reversed();
}
public class NetTopologySuite.Geometries.Implementation.PackedFloatCoordinateSequence : PackedCoordinateSequence {
    private Single[] _coords;
    public PackedFloatCoordinateSequence(Single[] coords, int dimension, int measures);
    public PackedFloatCoordinateSequence(Double[] coords, int dimension, int measures);
    public PackedFloatCoordinateSequence(Coordinate[] coords);
    [ObsoleteAttribute("Use an overload that accepts measures.  This overload will be removed in a future release.")]
public PackedFloatCoordinateSequence(Coordinate[] coords, int dimension);
    public PackedFloatCoordinateSequence(Coordinate[] coords, int dimension, int measures);
    public PackedFloatCoordinateSequence(int size, int dimension, int measures);
    internal PackedFloatCoordinateSequence(Coordinate[] coords, int dimension, int measures, bool dimensionAndMeasuresCameFromCoords);
    public Single[] GetRawCoordinates();
    public virtual CoordinateSequence Copy();
    public virtual double GetOrdinate(int index, int ordinateIndex);
    public virtual void SetOrdinate(int index, int ordinateIndex, double value);
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual CoordinateSequence Reversed();
}
public class NetTopologySuite.Geometries.Implementation.RawCoordinateSequence : CoordinateSequence {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _rawData;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _dimensionMap;
    public RawCoordinateSequence(Memory`1[] rawData, ValueTuple`2[] dimensionMap, int measures);
    private RawCoordinateSequence(int count, int dimension, int measures, ValueTuple`2[] rawData, ValueTuple`2[] dimensionMap);
    private RawCoordinateSequence(SerializationInfo info, StreamingContext context);
    public ValueTuple`2<Memory`1<double>, int> GetRawCoordinatesAndStride(int ordinateIndex);
    public virtual double GetOrdinate(int index, int ordinateIndex);
    public virtual void SetOrdinate(int index, int ordinateIndex, double value);
    public virtual CoordinateSequence Copy();
    public virtual CoordinateSequence Reversed();
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual Coordinate[] ToCoordinateArray();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private static int GetCountIfValid(Memory`1[] rawData, ValueTuple`2[] dimensionMap);
    private static void ValidateEmpty(Memory`1[] rawData, ValueTuple`2[] dimensionMap);
    private Double& ValueRef(int index, int ordinateIndex);
}
public class NetTopologySuite.Geometries.Implementation.RawCoordinateSequenceFactory : CoordinateSequenceFactory {
    private Ordinates _ordinatesInGroups;
    private Ordinates[] _ordinateGroups;
    public RawCoordinateSequenceFactory(IEnumerable`1<Ordinates> ordinateGroups);
    public static RawCoordinateSequence CreateXY(Memory`1<double> x, Memory`1<double> y);
    public static RawCoordinateSequence CreateXY(Memory`1<double> xy);
    public static RawCoordinateSequence CreateXYZ(Memory`1<double> x, Memory`1<double> y, Memory`1<double> z);
    public static RawCoordinateSequence CreateXYZ(Memory`1<double> xy, Memory`1<double> z);
    public static RawCoordinateSequence CreateXYZ(Memory`1<double> xyz);
    public static RawCoordinateSequence CreateXYM(Memory`1<double> x, Memory`1<double> y, Memory`1<double> m);
    public static RawCoordinateSequence CreateXYM(Memory`1<double> xy, Memory`1<double> m);
    public static RawCoordinateSequence CreateXYM(Memory`1<double> xym);
    public static RawCoordinateSequence CreateXYZM(Memory`1<double> x, Memory`1<double> y, Memory`1<double> z, Memory`1<double> m);
    public static RawCoordinateSequence CreateXYZM(Memory`1<double> xy, Memory`1<double> z, Memory`1<double> m);
    public static RawCoordinateSequence CreateXYZM(Memory`1<double> xyzm);
    public virtual CoordinateSequence Create(int size, int dimension, int measures);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.IntersectionMatrix : object {
    private Dimension[0...,0...] _matrix;
    public Dimension Item { get; public set; }
    public IntersectionMatrix(string elements);
    public IntersectionMatrix(IntersectionMatrix other);
    public void Add(IntersectionMatrix im);
    public static bool IsTrue(Dimension actualDimensionValue);
    public static bool Matches(Dimension actualDimensionValue, char requiredDimensionSymbol);
    public static bool Matches(string actualDimensionSymbols, string requiredDimensionSymbols);
    public void Set(Location row, Location column, Dimension dimensionValue);
    public void Set(string dimensionSymbols);
    public void SetAtLeast(Location row, Location column, Dimension minimumDimensionValue);
    public void SetAtLeastIfValid(Location row, Location column, Dimension minimumDimensionValue);
    public void SetAtLeast(string minimumDimensionSymbols);
    public void SetAll(Dimension dimensionValue);
    public Dimension Get(Location row, Location column);
    public Dimension get_Item(Location row, Location column);
    public void set_Item(Location row, Location column, Dimension value);
    public bool IsDisjoint();
    public bool IsIntersects();
    public bool IsTouches(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool IsCrosses(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool IsWithin();
    public bool IsContains();
    public bool IsCovers();
    public bool IsCoveredBy();
    public bool IsEquals(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool IsOverlaps(Dimension dimensionOfGeometryA, Dimension dimensionOfGeometryB);
    public bool Matches(string pattern);
    public IntersectionMatrix Transpose();
    public virtual string ToString();
}
public interface NetTopologySuite.Geometries.IPolygonal {
}
public interface NetTopologySuite.Geometries.IPuntal {
}
public class NetTopologySuite.Geometries.LinearRing : LineString {
    public static int MinimumValidSize;
    protected SortIndexValue SortIndex { get; }
    public Dimension BoundaryDimension { get; }
    public bool IsClosed { get; }
    public string GeometryType { get; }
    public bool IsCCW { get; }
    public LinearRing(CoordinateSequence points, GeometryFactory factory);
    public LinearRing(Coordinate[] points);
    private void ValidateConstruction();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_BoundaryDimension();
    public virtual bool get_IsClosed();
    public virtual string get_GeometryType();
    protected virtual Geometry CopyInternal();
    [ObsoleteAttribute("Call Geometry.Reverse()")]
public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
    public bool get_IsCCW();
}
public enum NetTopologySuite.Geometries.LinearRingOrientation : Enum {
    public int value__;
    public static LinearRingOrientation CounterClockwise;
    public static LinearRingOrientation LeftHandRule;
    public static LinearRingOrientation CCW;
    public static LinearRingOrientation DontCare;
    public static LinearRingOrientation Default;
    public static LinearRingOrientation Clockwise;
    public static LinearRingOrientation RightHandRule;
    public static LinearRingOrientation CW;
}
public class NetTopologySuite.Geometries.LineSegment : object {
    private Coordinate _p0;
    private Coordinate _p1;
    private static CultureInfo _cultureInfo;
    public Coordinate P1 { get; public set; }
    public Coordinate P0 { get; public set; }
    public double MinX { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public double MaxY { get; }
    public double Length { get; }
    public bool IsHorizontal { get; }
    public bool IsVertical { get; }
    public double Angle { get; }
    public Coordinate MidPoint { get; }
    public LineSegment(Coordinate p0, Coordinate p1);
    public LineSegment(LineSegment ls);
    public LineSegment(double x0, double y0, double x1, double y1);
    private static LineSegment();
    public Coordinate get_P1();
    public void set_P1(Coordinate value);
    public Coordinate get_P0();
    public void set_P0(Coordinate value);
    public Coordinate GetCoordinate(int i);
    public void SetCoordinates(LineSegment ls);
    public void SetCoordinates(Coordinate p0, Coordinate p1);
    public double get_MinX();
    public double get_MaxX();
    public double get_MinY();
    public double get_MaxY();
    public double get_Length();
    public bool get_IsHorizontal();
    public bool get_IsVertical();
    public int OrientationIndex(LineSegment seg);
    public int OrientationIndex(Coordinate p);
    public void Reverse();
    public void Normalize();
    public double get_Angle();
    public Coordinate get_MidPoint();
    public double Distance(LineSegment ls);
    public double Distance(Coordinate p);
    public double DistancePerpendicular(Coordinate p);
    public Coordinate PointAlong(double segmentLengthFraction);
    public Coordinate PointAlongOffset(double segmentLengthFraction, double offsetDistance);
    public double ProjectionFactor(Coordinate p);
    public double SegmentFraction(Coordinate inputPt);
    public Coordinate Project(Coordinate p);
    public LineSegment Project(LineSegment seg);
    public LineSegment Offset(double offsetDistance);
    public Coordinate ClosestPoint(Coordinate p);
    public Coordinate[] ClosestPoints(LineSegment line);
    public Coordinate Reflect(Coordinate p);
    public Coordinate Intersection(LineSegment line);
    public Coordinate LineIntersection(LineSegment line);
    public LineString ToGeometry(GeometryFactory geomFactory);
    public virtual bool Equals(object o);
    public static bool op_Equality(LineSegment obj1, LineSegment obj2);
    public static bool op_Inequality(LineSegment obj1, LineSegment obj2);
    public sealed virtual int CompareTo(LineSegment other);
    public bool EqualsTopologically(LineSegment other);
    public virtual string ToString();
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Geometries.LineString : Geometry {
    public static int MinimumValidSize;
    public static LineString Empty;
    private CoordinateSequence _points;
    protected SortIndexValue SortIndex { get; }
    public Coordinate[] Coordinates { get; }
    public CoordinateSequence CoordinateSequence { get; }
    public Coordinate Coordinate { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public bool IsEmpty { get; }
    public int NumPoints { get; }
    public Point StartPoint { get; }
    public Point EndPoint { get; }
    public bool IsClosed { get; }
    public bool IsRing { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public double Length { get; }
    public Geometry Boundary { get; }
    public Coordinate Item { get; public set; }
    public int Count { get; }
    public LineString(Coordinate[] points);
    public LineString(CoordinateSequence points, GeometryFactory factory);
    private static LineString();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public CoordinateSequence get_CoordinateSequence();
    public Coordinate GetCoordinateN(int n);
    public virtual Coordinate get_Coordinate();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual bool get_IsEmpty();
    public virtual int get_NumPoints();
    public Point GetPointN(int n);
    public Point get_StartPoint();
    public Point get_EndPoint();
    public virtual bool get_IsClosed();
    public bool get_IsRing();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual double get_Length();
    public virtual Geometry get_Boundary();
    [ObsoleteAttribute("Call Geometry.Reverse()")]
public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
    public virtual bool IsCoordinate(Coordinate pt);
    protected virtual Envelope ComputeEnvelopeInternal();
    public virtual bool EqualsExact(Geometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IEntireCoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    protected virtual Geometry CopyInternal();
    public virtual void Normalize();
    protected virtual bool IsEquivalentClass(Geometry other);
    protected internal virtual int CompareToSameClass(object o);
    protected internal virtual int CompareToSameClass(object o, IComparer`1<CoordinateSequence> comp);
    public Coordinate get_Item(int n);
    public void set_Item(int n, Coordinate value);
    public int get_Count();
}
public enum NetTopologySuite.Geometries.Location : Enum {
    public int value__;
    public static Location Interior;
    public static Location Boundary;
    public static Location Exterior;
    public static Location Null;
}
public class NetTopologySuite.Geometries.LocationUtility : object {
    public static char ToLocationSymbol(Location locationValue);
}
public class NetTopologySuite.Geometries.MultiLineString : GeometryCollection {
    public static MultiLineString Empty;
    protected SortIndexValue SortIndex { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public bool IsClosed { get; }
    public Geometry Boundary { get; }
    public MultiLineString(LineString[] lineStrings, GeometryFactory factory);
    public MultiLineString(LineString[] lineStrings);
    private static MultiLineString();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public bool get_IsClosed();
    public virtual Geometry get_Boundary();
    [ObsoleteAttribute("Call Geometry.Reverse()")]
public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
    protected virtual Geometry CopyInternal();
    public virtual bool EqualsExact(Geometry other, double tolerance);
}
public class NetTopologySuite.Geometries.MultiPoint : GeometryCollection {
    public static MultiPoint Empty;
    protected SortIndexValue SortIndex { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public Geometry Boundary { get; }
    public bool IsValid { get; }
    public MultiPoint(Point[] points, GeometryFactory factory);
    public MultiPoint(Point[] points);
    private static MultiPoint();
    protected virtual Geometry CopyInternal();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual Geometry get_Boundary();
    protected virtual Geometry ReverseInternal();
    public virtual bool get_IsValid();
    public virtual bool EqualsExact(Geometry other, double tolerance);
    protected Coordinate GetCoordinate(int n);
}
public class NetTopologySuite.Geometries.MultiPolygon : GeometryCollection {
    public static MultiPolygon Empty;
    protected SortIndexValue SortIndex { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public Geometry Boundary { get; }
    public MultiPolygon(Polygon[] polygons);
    public MultiPolygon(Polygon[] polygons, GeometryFactory factory);
    private static MultiPolygon();
    protected virtual Geometry CopyInternal();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual Geometry get_Boundary();
    public virtual bool EqualsExact(Geometry other, double tolerance);
    [ObsoleteAttribute("Call Geometry.Reverse()")]
public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
}
public class NetTopologySuite.Geometries.OctagonalEnvelope : object {
    private static double SQRT2;
    private double _minX;
    private double _maxX;
    private double _minY;
    private double _maxY;
    private double _minA;
    private double _maxA;
    private double _minB;
    private double _maxB;
    public double MinX { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public double MaxY { get; }
    public double MinA { get; }
    public double MaxA { get; }
    public double MinB { get; }
    public double MaxB { get; }
    public bool IsNull { get; private set; }
    private bool IsValid { get; }
    public OctagonalEnvelope(Coordinate p);
    public OctagonalEnvelope(Coordinate p0, Coordinate p1);
    public OctagonalEnvelope(Envelope env);
    public OctagonalEnvelope(OctagonalEnvelope oct);
    public OctagonalEnvelope(Geometry geom);
    private static OctagonalEnvelope();
    public static Geometry GetOctagonalEnvelope(Geometry geom);
    private static double ComputeA(double x, double y);
    private static double ComputeB(double x, double y);
    public double get_MinX();
    public double get_MaxX();
    public double get_MinY();
    public double get_MaxY();
    public double get_MinA();
    public double get_MaxA();
    public double get_MinB();
    public double get_MaxB();
    public bool get_IsNull();
    private void set_IsNull(bool value);
    public void ExpandToInclude(Geometry g);
    public OctagonalEnvelope ExpandToInclude(CoordinateSequence seq);
    public OctagonalEnvelope ExpandToInclude(OctagonalEnvelope oct);
    public OctagonalEnvelope ExpandToInclude(Coordinate p);
    public OctagonalEnvelope ExpandToInclude(Envelope env);
    public OctagonalEnvelope ExpandToInclude(double x, double y);
    public void ExpandBy(double distance);
    private bool get_IsValid();
    public bool Intersects(OctagonalEnvelope other);
    public bool Intersects(Coordinate p);
    public bool Contains(OctagonalEnvelope other);
    public Geometry ToGeometry(GeometryFactory geomFactory);
}
[ObsoleteAttribute("Use GeometryFactoryEx with OrientationOfExteriorRing = CCW")]
public class NetTopologySuite.Geometries.OgcCompliantGeometryFactory : GeometryFactory {
    public OgcCompliantGeometryFactory(CoordinateSequenceFactory factory);
    public OgcCompliantGeometryFactory(PrecisionModel pm);
    public OgcCompliantGeometryFactory(PrecisionModel pm, int srid);
    public OgcCompliantGeometryFactory(PrecisionModel pm, int srid, CoordinateSequenceFactory factory);
    private static LinearRing ReverseRing(LinearRing ring);
    private LinearRing CreateLinearRing(Coordinate[] coordinates, bool ccw);
    private LinearRing CreateLinearRing(CoordinateSequence coordinates, bool ccw);
    public virtual Geometry ToGeometry(Envelope envelope);
    public virtual Polygon CreatePolygon(Coordinate[] coordinates);
    public virtual Polygon CreatePolygon(CoordinateSequence coordinates);
    public virtual Polygon CreatePolygon(LinearRing shell);
    public virtual Polygon CreatePolygon(LinearRing shell, LinearRing[] holes);
}
public enum NetTopologySuite.Geometries.OgcGeometryType : Enum {
    public int value__;
    public static OgcGeometryType Point;
    public static OgcGeometryType LineString;
    public static OgcGeometryType Polygon;
    public static OgcGeometryType MultiPoint;
    public static OgcGeometryType MultiLineString;
    public static OgcGeometryType MultiPolygon;
    public static OgcGeometryType GeometryCollection;
    public static OgcGeometryType CircularString;
    public static OgcGeometryType CompoundCurve;
    public static OgcGeometryType CurvePolygon;
    public static OgcGeometryType MultiCurve;
    public static OgcGeometryType MultiSurface;
    public static OgcGeometryType Curve;
    public static OgcGeometryType Surface;
    public static OgcGeometryType PolyhedralSurface;
    public static OgcGeometryType TIN;
}
public enum NetTopologySuite.Geometries.Ordinate : Enum {
    public int value__;
    public static Ordinate Spatial1;
    public static Ordinate X;
    public static Ordinate Spatial2;
    public static Ordinate Y;
    public static Ordinate Spatial3;
    public static Ordinate Z;
    public static Ordinate Spatial4;
    public static Ordinate Spatial5;
    public static Ordinate Spatial6;
    public static Ordinate Spatial7;
    public static Ordinate Spatial8;
    public static Ordinate Spatial9;
    public static Ordinate Spatial10;
    public static Ordinate Spatial11;
    public static Ordinate Spatial12;
    public static Ordinate Spatial13;
    public static Ordinate Spatial14;
    public static Ordinate Spatial15;
    public static Ordinate Spatial16;
    public static Ordinate Measure1;
    public static Ordinate M;
    public static Ordinate Measure2;
    public static Ordinate Measure3;
    public static Ordinate Measure4;
    public static Ordinate Measure5;
    public static Ordinate Measure6;
    public static Ordinate Measure7;
    public static Ordinate Measure8;
    public static Ordinate Measure9;
    public static Ordinate Measure10;
    public static Ordinate Measure11;
    public static Ordinate Measure12;
    public static Ordinate Measure13;
    public static Ordinate Measure14;
    public static Ordinate Measure15;
    public static Ordinate Measure16;
}
[FlagsAttribute]
public enum NetTopologySuite.Geometries.Ordinates : Enum {
    public int value__;
    public static Ordinates None;
    public static Ordinates X;
    public static Ordinates Y;
    public static Ordinates Z;
    public static Ordinates M;
    public static Ordinates XY;
    public static Ordinates XYZ;
    public static Ordinates XYM;
    public static Ordinates XYZM;
    public static Ordinates Spatial1;
    public static Ordinates Spatial2;
    public static Ordinates Spatial3;
    public static Ordinates Spatial4;
    public static Ordinates Spatial5;
    public static Ordinates Spatial6;
    public static Ordinates Spatial7;
    public static Ordinates Spatial8;
    public static Ordinates Spatial9;
    public static Ordinates Spatial10;
    public static Ordinates Spatial11;
    public static Ordinates Spatial12;
    public static Ordinates Spatial13;
    public static Ordinates Spatial14;
    public static Ordinates Spatial15;
    public static Ordinates Spatial16;
    public static Ordinates AllSpatialOrdinates;
    public static Ordinates Measure1;
    public static Ordinates Measure2;
    public static Ordinates Measure3;
    public static Ordinates Measure4;
    public static Ordinates Measure5;
    public static Ordinates Measure6;
    public static Ordinates Measure7;
    public static Ordinates Measure8;
    public static Ordinates Measure9;
    public static Ordinates Measure10;
    public static Ordinates Measure11;
    public static Ordinates Measure12;
    public static Ordinates Measure13;
    public static Ordinates Measure14;
    public static Ordinates Measure15;
    public static Ordinates Measure16;
    public static Ordinates AllMeasureOrdinates;
    public static Ordinates AllOrdinates;
}
public static class NetTopologySuite.Geometries.OrdinatesUtility : object {
    public static int OrdinatesToDimension(Ordinates ordinates);
    public static int OrdinatesToMeasures(Ordinates ordinates);
}
public class NetTopologySuite.Geometries.PerOrdinateEqualityComparer : CoordinateEqualityComparer {
    protected virtual bool AreEqual(Coordinate a, Coordinate b, double tolerance);
    private static double Distance(double a, double b);
}
public class NetTopologySuite.Geometries.Point : Geometry {
    private static Coordinate EmptyCoordinate;
    public static Point Empty;
    private CoordinateSequence _coordinates;
    protected SortIndexValue SortIndex { get; }
    public CoordinateSequence CoordinateSequence { get; }
    public Coordinate[] Coordinates { get; }
    public int NumPoints { get; }
    public bool IsEmpty { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public Coordinate Coordinate { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public Geometry Boundary { get; }
    public double Z { get; public set; }
    public double M { get; public set; }
    public Point(Coordinate coordinate);
    public Point(CoordinateSequence coordinates, GeometryFactory factory);
    public Point(double x, double y, double z);
    public Point(double x, double y);
    private static Point();
    protected virtual SortIndexValue get_SortIndex();
    public CoordinateSequence get_CoordinateSequence();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public virtual int get_NumPoints();
    public virtual bool get_IsEmpty();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual Coordinate get_Coordinate();
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual Geometry get_Boundary();
    protected virtual Envelope ComputeEnvelopeInternal();
    public virtual bool EqualsExact(Geometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IEntireCoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    protected virtual Geometry CopyInternal();
    [ObsoleteAttribute("Call Geometry.Reverse()")]
public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
    public virtual void Normalize();
    protected internal virtual int CompareToSameClass(object other);
    protected internal virtual int CompareToSameClass(object other, IComparer`1<CoordinateSequence> comparer);
    public double get_Z();
    public void set_Z(double value);
    public double get_M();
    public void set_M(double value);
}
public class NetTopologySuite.Geometries.Polygon : Geometry {
    public static Polygon Empty;
    private LinearRing _shell;
    private LinearRing[] _holes;
    protected SortIndexValue SortIndex { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public int NumPoints { get; }
    public Dimension Dimension { get; }
    public Dimension BoundaryDimension { get; }
    public bool IsEmpty { get; }
    public LineString ExteriorRing { get; }
    public int NumInteriorRings { get; }
    public LineString[] InteriorRings { get; }
    public string GeometryType { get; }
    public OgcGeometryType OgcGeometryType { get; }
    public double Area { get; }
    public double Length { get; }
    public Geometry Boundary { get; }
    public bool IsRectangle { get; }
    public LinearRing Shell { get; private set; }
    public LinearRing[] Holes { get; private set; }
    public Polygon(LinearRing shell, LinearRing[] holes);
    public Polygon(LinearRing shell, LinearRing[] holes, GeometryFactory factory);
    public Polygon(LinearRing shell, GeometryFactory factory);
    public Polygon(LinearRing shell);
    private static Polygon();
    protected virtual SortIndexValue get_SortIndex();
    public virtual Coordinate get_Coordinate();
    public virtual Coordinate[] get_Coordinates();
    public virtual Double[] GetOrdinates(Ordinate ordinate);
    public virtual int get_NumPoints();
    public virtual Dimension get_Dimension();
    public virtual Dimension get_BoundaryDimension();
    public virtual bool get_IsEmpty();
    public LineString get_ExteriorRing();
    public int get_NumInteriorRings();
    public LineString[] get_InteriorRings();
    public LineString GetInteriorRingN(int n);
    public virtual string get_GeometryType();
    public virtual OgcGeometryType get_OgcGeometryType();
    public virtual double get_Area();
    public virtual double get_Length();
    public virtual Geometry get_Boundary();
    protected virtual Envelope ComputeEnvelopeInternal();
    public virtual bool EqualsExact(Geometry other, double tolerance);
    public virtual void Apply(ICoordinateFilter filter);
    public virtual void Apply(ICoordinateSequenceFilter filter);
    public virtual void Apply(IEntireCoordinateSequenceFilter filter);
    public virtual void Apply(IGeometryFilter filter);
    public virtual void Apply(IGeometryComponentFilter filter);
    protected virtual Geometry CopyInternal();
    public virtual Geometry ConvexHull();
    public virtual void Normalize();
    protected internal virtual int CompareToSameClass(object o);
    protected internal virtual int CompareToSameClass(object other, IComparer`1<CoordinateSequence> comparer);
    private static LinearRing Normalized(LinearRing ring, bool clockwise);
    private static void Normalize(LinearRing ring, bool clockwise);
    public virtual bool get_IsRectangle();
    [ObsoleteAttribute("Call Geometry.Reverse()")]
public virtual Geometry Reverse();
    protected virtual Geometry ReverseInternal();
    public LinearRing get_Shell();
    private void set_Shell(LinearRing value);
    public LinearRing[] get_Holes();
    private void set_Holes(LinearRing[] value);
}
[IsReadOnlyAttribute]
public class NetTopologySuite.Geometries.Position : ValueType {
    internal static int IndexOn;
    internal static int IndexLeft;
    internal static int IndexRight;
    private static int IndexParallel;
    public static Position On;
    public static Position Left;
    public static Position Right;
    public static Position Parallel;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    internal int Index { get; }
    public Position Opposite { get; }
    internal Position(int index);
    private static Position();
    [CompilerGeneratedAttribute]
internal int get_Index();
    public Position get_Opposite();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Position lhs, Position rhs);
    public static bool op_Inequality(Position lhs, Position rhs);
    public static int op_Implicit(Position pos);
}
public class NetTopologySuite.Geometries.PrecisionModel : object {
    private static int FloatingPrecisionDigits;
    private static int FloatingSinglePrecisionDigits;
    private static int FixedPrecisionDigits;
    public static double MaximumPreciseValue;
    private PrecisionModels _modelType;
    private double _scale;
    private double _gridSize;
    public static Lazy`1<PrecisionModel> Floating { get; }
    public static Lazy`1<PrecisionModel> FloatingSingle { get; }
    public static Lazy`1<PrecisionModel> Fixed { get; }
    public bool IsFloating { get; }
    public int MaximumSignificantDigits { get; }
    public double Scale { get; public set; }
    public double GridSize { get; }
    public PrecisionModels PrecisionModelType { get; }
    public PrecisionModel(PrecisionModels modelType);
    public PrecisionModel(double scale);
    public PrecisionModel(PrecisionModel pm);
    public static PrecisionModel MostPrecise(PrecisionModel pm1, PrecisionModel pm2);
    public static Lazy`1<PrecisionModel> get_Floating();
    public static Lazy`1<PrecisionModel> get_FloatingSingle();
    public static Lazy`1<PrecisionModel> get_Fixed();
    public bool get_IsFloating();
    public int get_MaximumSignificantDigits();
    public double get_Scale();
    public void set_Scale(double value);
    public double get_GridSize();
    public PrecisionModels get_PrecisionModelType();
    public double MakePrecise(double val);
    public void MakePrecise(Coordinate coord);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public bool Equals(PrecisionModel otherPrecisionModel);
    public static bool op_Equality(PrecisionModel obj1, PrecisionModel obj2);
    public static bool op_Inequality(PrecisionModel obj1, PrecisionModel obj2);
    public sealed virtual int CompareTo(object o);
    public sealed virtual int CompareTo(PrecisionModel other);
}
public enum NetTopologySuite.Geometries.PrecisionModels : Enum {
    public int value__;
    public static PrecisionModels Floating;
    public static PrecisionModels FloatingSingle;
    public static PrecisionModels Fixed;
}
internal abstract class NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains : PreparedPolygonPredicate {
    protected bool RequireSomePointInInterior;
    private bool _hasSegmentIntersection;
    private bool _hasProperIntersection;
    private bool _hasNonProperIntersection;
    protected AbstractPreparedPolygonContains(PreparedPolygon prepPoly);
    protected bool Eval(Geometry geom);
    private bool EvalPoints(Geometry geom);
    private bool IsProperIntersectionImpliesNotContainedSituation(Geometry testGeom);
    private static bool IsSingleShell(Geometry geom);
    private void FindAndClassifyIntersections(Geometry geom);
    protected abstract virtual bool FullTopologicalPredicate(Geometry geom);
}
public class NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry : object {
    private Geometry _baseGeom;
    private List`1<Coordinate> _representativePts;
    public Geometry Geometry { get; }
    public IList`1<Coordinate> RepresentativePoints { get; }
    public BasicPreparedGeometry(Geometry geom);
    public sealed virtual Geometry get_Geometry();
    public IList`1<Coordinate> get_RepresentativePoints();
    public bool IsAnyTargetComponentInTest(Geometry testGeom);
    protected bool EnvelopesIntersect(Geometry g);
    protected bool EnvelopeCovers(Geometry g);
    public virtual bool Contains(Geometry g);
    public virtual bool ContainsProperly(Geometry g);
    public virtual bool CoveredBy(Geometry g);
    public virtual bool Covers(Geometry g);
    public virtual bool Crosses(Geometry g);
    public sealed virtual bool Disjoint(Geometry g);
    public virtual bool Intersects(Geometry g);
    public virtual bool Overlaps(Geometry g);
    public virtual bool Touches(Geometry g);
    public virtual bool Within(Geometry g);
    public virtual string ToString();
}
public interface NetTopologySuite.Geometries.Prepared.IPreparedGeometry {
    public Geometry Geometry { get; }
    public abstract virtual Geometry get_Geometry();
    public abstract virtual bool Contains(Geometry geom);
    public abstract virtual bool ContainsProperly(Geometry geom);
    public abstract virtual bool CoveredBy(Geometry geom);
    public abstract virtual bool Covers(Geometry geom);
    public abstract virtual bool Crosses(Geometry geom);
    public abstract virtual bool Disjoint(Geometry geom);
    public abstract virtual bool Intersects(Geometry geom);
    public abstract virtual bool Overlaps(Geometry geom);
    public abstract virtual bool Touches(Geometry geom);
    public abstract virtual bool Within(Geometry geom);
}
public class NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory : object {
    public static IPreparedGeometry Prepare(Geometry geom);
    public IPreparedGeometry Create(Geometry geom);
}
public class NetTopologySuite.Geometries.Prepared.PreparedLineString : BasicPreparedGeometry {
    private object _lock;
    private FastSegmentSetIntersectionFinder modreq(System.Runtime.CompilerServices.IsVolatile) _segIntFinder;
    public FastSegmentSetIntersectionFinder IntersectionFinder { get; }
    public PreparedLineString(ILineal line);
    public FastSegmentSetIntersectionFinder get_IntersectionFinder();
    public virtual bool Intersects(Geometry g);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects : object {
    protected PreparedLineString prepLine;
    public PreparedLineStringIntersects(PreparedLineString prepLine);
    public static bool Intersects(PreparedLineString prep, Geometry geom);
    public bool Intersects(Geometry geom);
    protected bool IsAnyTestPointInTarget(Geometry testGeom);
}
public class NetTopologySuite.Geometries.Prepared.PreparedPoint : BasicPreparedGeometry {
    public PreparedPoint(IPuntal point);
    public virtual bool Intersects(Geometry g);
}
public class NetTopologySuite.Geometries.Prepared.PreparedPolygon : BasicPreparedGeometry {
    private bool _isRectangle;
    private object _lockSif;
    private object _lockPia;
    private FastSegmentSetIntersectionFinder modreq(System.Runtime.CompilerServices.IsVolatile) _segIntFinder;
    private IPointOnGeometryLocator modreq(System.Runtime.CompilerServices.IsVolatile) _pia;
    public FastSegmentSetIntersectionFinder IntersectionFinder { get; }
    public IPointOnGeometryLocator PointLocator { get; }
    public PreparedPolygon(IPolygonal poly);
    public FastSegmentSetIntersectionFinder get_IntersectionFinder();
    public IPointOnGeometryLocator get_PointLocator();
    public virtual bool Intersects(Geometry g);
    public virtual bool Contains(Geometry g);
    public virtual bool ContainsProperly(Geometry g);
    public virtual bool Covers(Geometry g);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonContains : AbstractPreparedPolygonContains {
    public PreparedPolygonContains(PreparedPolygon prepPoly);
    public static bool Contains(PreparedPolygon prep, Geometry geom);
    public bool Contains(Geometry geom);
    protected virtual bool FullTopologicalPredicate(Geometry geom);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly : PreparedPolygonPredicate {
    public PreparedPolygonContainsProperly(PreparedPolygon prepPoly);
    public static bool ContainsProperly(PreparedPolygon prep, Geometry geom);
    public bool ContainsProperly(Geometry geom);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers : AbstractPreparedPolygonContains {
    public PreparedPolygonCovers(PreparedPolygon prepPoly);
    public static bool Covers(PreparedPolygon prep, Geometry geom);
    public bool Covers(Geometry geom);
    protected virtual bool FullTopologicalPredicate(Geometry geom);
}
internal class NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects : PreparedPolygonPredicate {
    public PreparedPolygonIntersects(PreparedPolygon prepPoly);
    public static bool Intersects(PreparedPolygon prep, Geometry geom);
    public bool Intersects(Geometry geom);
}
internal abstract class NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate : object {
    protected PreparedPolygon prepPoly;
    private IPointOnGeometryLocator _targetPointLocator;
    protected PreparedPolygonPredicate(PreparedPolygon prepPoly);
    protected bool IsAllTestComponentsInTarget(Geometry testGeom);
    protected bool IsAllTestComponentsInTargetInterior(Geometry testGeom);
    protected bool IsAnyTestComponentInTarget(Geometry testGeom);
    protected bool IsAllTestPointsInTarget(Geometry testGeom);
    protected bool IsAnyTestPointInTargetInterior(Geometry testGeom);
    [ObsoleteAttribute]
protected bool IsAnyTestComponentInTargetInterior(Geometry testGeom);
    protected bool IsAllTestPointsInTargetInterior(Geometry testGeom);
    protected bool IsAnyTargetComponentInAreaTest(Geometry testGeom, IList`1<Coordinate> targetRepPts);
}
[IsReadOnlyAttribute]
public class NetTopologySuite.Geometries.Quadrant : ValueType {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public static Quadrant Undefined { get; }
    public static Quadrant NE { get; }
    public static Quadrant NW { get; }
    public static Quadrant SW { get; }
    public static Quadrant SE { get; }
    internal int Value { get; }
    public bool IsNorthern { get; }
    public Quadrant(int value);
    public Quadrant(double dx, double dy);
    public Quadrant(Coordinate p0, Coordinate p1);
    public static Quadrant get_Undefined();
    public static Quadrant get_NE();
    public static Quadrant get_NW();
    public static Quadrant get_SW();
    public static Quadrant get_SE();
    [CompilerGeneratedAttribute]
internal int get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public bool IsOpposite(Quadrant quad);
    public static Quadrant CommonHalfPlane(Quadrant quad1, Quadrant quad2);
    public bool IsInHalfPlane(Quadrant halfPlane);
    public bool get_IsNorthern();
    public static bool op_Equality(Quadrant lhs, Quadrant rhs);
    public static bool op_Inequality(Quadrant lhs, Quadrant rhs);
    public static bool op_GreaterThan(Quadrant lhs, Quadrant rhs);
    public static bool op_LessThan(Quadrant lhs, Quadrant rhs);
}
public class NetTopologySuite.Geometries.TopologyException : ApplicationException {
    private Coordinate pt;
    public Coordinate Coordinate { get; }
    public TopologyException(string msg);
    public TopologyException(string msg, Coordinate pt);
    private static string MsgWithCoord(string msg, Coordinate pt);
    public Coordinate get_Coordinate();
}
public class NetTopologySuite.Geometries.Triangle : object {
    private Coordinate _p0;
    private Coordinate _p1;
    private Coordinate _p2;
    public Coordinate P0 { get; public set; }
    public Coordinate P1 { get; public set; }
    public Coordinate P2 { get; public set; }
    public Triangle(Coordinate p0, Coordinate p1, Coordinate p2);
    public Coordinate get_P0();
    public void set_P0(Coordinate value);
    public Coordinate get_P1();
    public void set_P1(Coordinate value);
    public Coordinate get_P2();
    public void set_P2(Coordinate value);
    public static bool IsAcute(Coordinate a, Coordinate b, Coordinate c);
    public static bool IsCCW(Coordinate a, Coordinate b, Coordinate c);
    public static bool Intersects(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    public static HCoordinate PerpendicularBisector(Coordinate a, Coordinate b);
    public static Coordinate Circumcentre(Coordinate a, Coordinate b, Coordinate c);
    public static Coordinate CircumcentreDD(Coordinate a, Coordinate b, Coordinate c);
    private static double Det(double m00, double m01, double m10, double m11);
    public static Coordinate InCentre(Coordinate a, Coordinate b, Coordinate c);
    public static Coordinate Centroid(Coordinate a, Coordinate b, Coordinate c);
    public static double Length(Coordinate a, Coordinate b, Coordinate c);
    public static double LongestSideLength(Coordinate a, Coordinate b, Coordinate c);
    public static Coordinate AngleBisector(Coordinate a, Coordinate b, Coordinate c);
    public static double Area(Coordinate a, Coordinate b, Coordinate c);
    public static double SignedArea(Coordinate a, Coordinate b, Coordinate c);
    public static double Area3D(Coordinate a, Coordinate b, Coordinate c);
    public static double InterpolateZ(Coordinate p, Coordinate v0, Coordinate v1, Coordinate v2);
    public Coordinate InCentre();
    public bool IsAcute();
    public bool IsCCW();
    public Coordinate Circumcentre();
    public Coordinate Centroid();
    public double Length();
    public double LongestSideLength();
    public double Area();
    public double SignedArea();
    public double Area3D();
    public double InterpolateZ(Coordinate p);
}
public class NetTopologySuite.Geometries.Utilities.AffineTransformation : object {
    private double _m00;
    private double _m01;
    private double _m02;
    private double _m10;
    private double _m11;
    private double _m12;
    public Double[] MatrixEntries { get; }
    public double Determinant { get; }
    public bool GeometryChanged { get; }
    public bool Done { get; }
    public bool IsIdentity { get; }
    public AffineTransformation(Double[] matrix);
    public AffineTransformation(double m00, double m01, double m02, double m10, double m11, double m12);
    public AffineTransformation(AffineTransformation trans);
    public AffineTransformation(Coordinate src0, Coordinate src1, Coordinate src2, Coordinate dest0, Coordinate dest1, Coordinate dest2);
    public static AffineTransformation ReflectionInstance(double x0, double y0, double x1, double y1);
    public static AffineTransformation ReflectionInstance(double x, double y);
    public static AffineTransformation RotationInstance(double theta);
    public static AffineTransformation RotationInstance(double sinTheta, double cosTheta);
    public static AffineTransformation RotationInstance(double theta, double x, double y);
    public static AffineTransformation RotationInstance(double sinTheta, double cosTheta, double x, double y);
    public static AffineTransformation ScaleInstance(double xScale, double yScale);
    public static AffineTransformation ScaleInstance(double xScale, double yScale, double x, double y);
    public static AffineTransformation ShearInstance(double xShear, double yShear);
    public static AffineTransformation TranslationInstance(double x, double y);
    public AffineTransformation SetToIdentity();
    public AffineTransformation SetTransformation(double m00, double m01, double m02, double m10, double m11, double m12);
    public AffineTransformation SetTransformation(AffineTransformation trans);
    public Double[] get_MatrixEntries();
    public double get_Determinant();
    public AffineTransformation GetInverse();
    public AffineTransformation SetToReflectionBasic(double x0, double y0, double x1, double y1);
    public AffineTransformation SetToReflection(double x0, double y0, double x1, double y1);
    public AffineTransformation SetToReflection(double x, double y);
    public AffineTransformation SetToRotation(double theta);
    public AffineTransformation SetToRotation(double sinTheta, double cosTheta);
    public AffineTransformation SetToRotation(double theta, double x, double y);
    public AffineTransformation SetToRotation(double sinTheta, double cosTheta, double x, double y);
    public AffineTransformation SetToScale(double xScale, double yScale);
    public AffineTransformation SetToShear(double xShear, double yShear);
    public AffineTransformation SetToTranslation(double dx, double dy);
    public AffineTransformation Reflect(double x0, double y0, double x1, double y1);
    public AffineTransformation Reflect(double x, double y);
    public AffineTransformation Rotate(double theta);
    public AffineTransformation Rotate(double sinTheta, double cosTheta);
    public AffineTransformation Rotate(double theta, double x, double y);
    public AffineTransformation Rotate(double sinTheta, double cosTheta, double x, double y);
    public AffineTransformation Scale(double xScale, double yScale);
    public AffineTransformation Shear(double xShear, double yShear);
    public AffineTransformation Translate(double x, double y);
    public AffineTransformation Compose(AffineTransformation trans);
    public AffineTransformation ComposeBefore(AffineTransformation trans);
    public Coordinate Transform(Coordinate src, Coordinate dest);
    public Geometry Transform(Geometry g);
    public void Transform(CoordinateSequence seq, int i);
    public sealed virtual void Filter(CoordinateSequence seq, int i);
    public sealed virtual bool get_GeometryChanged();
    public sealed virtual bool get_Done();
    public bool get_IsIdentity();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AffineTransformation trans);
    public virtual string ToString();
    public sealed virtual object Clone();
}
public class NetTopologySuite.Geometries.Utilities.AffineTransformationBuilder : object {
    private Coordinate _src0;
    private Coordinate _src1;
    private Coordinate _src2;
    private Coordinate _dest0;
    private Coordinate _dest1;
    private Coordinate _dest2;
    private double _m00;
    private double _m01;
    private double _m02;
    private double _m10;
    private double _m11;
    private double _m12;
    public AffineTransformationBuilder(Coordinate src0, Coordinate src1, Coordinate src2, Coordinate dest0, Coordinate dest1, Coordinate dest2);
    public AffineTransformation GetTransformation();
    private bool Compute();
    private Double[] Solve(Double[] b);
}
public static class NetTopologySuite.Geometries.Utilities.AffineTransformationFactory : object {
    public static AffineTransformation CreateFromControlVectors(Coordinate src0, Coordinate src1, Coordinate src2, Coordinate dest0, Coordinate dest1, Coordinate dest2);
    public static AffineTransformation CreateFromControlVectors(Coordinate src0, Coordinate src1, Coordinate dest0, Coordinate dest1);
    public static AffineTransformation CreateFromControlVectors(Coordinate src0, Coordinate dest0);
    public static AffineTransformation CreateFromControlVectors(Coordinate[] src, Coordinate[] dest);
    public static AffineTransformation CreateFromBaseLines(Coordinate src0, Coordinate src1, Coordinate dest0, Coordinate dest1);
}
public class NetTopologySuite.Geometries.Utilities.ComponentCoordinateExtracter : object {
    private List`1<Coordinate> _coords;
    public ComponentCoordinateExtracter(List`1<Coordinate> coords);
    public static List`1<Coordinate> GetCoordinates(Geometry geom);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Geometries.Utilities.EnvelopeCombiner : object {
    private Geometry[] _geoms;
    public EnvelopeCombiner(Geometry[] geoms);
    public EnvelopeCombiner(IEnumerable`1<Geometry> geoms);
    public static Envelope Combine(Geometry[] geoms);
    public static Envelope Combine(IEnumerable`1<Geometry> geoms);
    public static Geometry CombineAsGeometry(Geometry[] geoms);
    public static Geometry CombineAsGeometry(IEnumerable`1<Geometry> geoms);
    public Envelope Combine();
    public Geometry CombineAsGeometry();
}
public class NetTopologySuite.Geometries.Utilities.GeometryCollectionMapper : object {
    private Func`2<Geometry, Geometry> _mapOp;
    public GeometryCollectionMapper(Func`2<Geometry, Geometry> mapOp);
    public static GeometryCollection Map(GeometryCollection gc, Func`2<Geometry, Geometry> op);
    public GeometryCollection Map(GeometryCollection gc);
}
public class NetTopologySuite.Geometries.Utilities.GeometryCombiner : object {
    [CompilerGeneratedAttribute]
private static bool <SkipEmpty>k__BackingField;
    private IEnumerable`1<Geometry> _inputGeoms;
    public static bool SkipEmpty { get; public set; }
    public GeometryCombiner(IEnumerable`1<Geometry> geoms);
    public static Geometry Combine(IEnumerable`1<Geometry> geoms);
    public static Geometry Combine(Geometry g0, Geometry g1);
    public static Geometry Combine(Geometry g0, Geometry g1, Geometry g2);
    private static List`1<Geometry> CreateList(Geometry obj0, Geometry obj1);
    private static List`1<Geometry> CreateList(Geometry obj0, Geometry obj1, Geometry obj2);
    [CompilerGeneratedAttribute]
public static bool get_SkipEmpty();
    [CompilerGeneratedAttribute]
public static void set_SkipEmpty(bool value);
    public static GeometryFactory ExtractFactory(IEnumerable`1<Geometry> geoms);
    public Geometry Combine();
    private static void ExtractElements(Geometry geom, List`1<Geometry> elems);
}
public class NetTopologySuite.Geometries.Utilities.GeometryEditor : object {
    private GeometryFactory _factory;
    private bool _isUserDataCopied;
    public bool CopyUserData { get; public set; }
    public GeometryEditor(GeometryFactory factory);
    public bool get_CopyUserData();
    public void set_CopyUserData(bool value);
    public Geometry Edit(Geometry geometry, IGeometryEditorOperation operation);
    private Geometry EditInternal(Geometry geometry, IGeometryEditorOperation operation);
    private Polygon EditPolygon(Polygon polygon, IGeometryEditorOperation operation);
    private GeometryCollection EditGeometryCollection(GeometryCollection collection, IGeometryEditorOperation operation);
}
public static class NetTopologySuite.Geometries.Utilities.GeometryExtracter : object {
    public static IList`1<Geometry> Extract(Geometry geom, IList`1<Geometry> list);
    public static IList`1<Geometry> Extract(Geometry geom);
    public static IList`1<Geometry> Extract(Geometry geom, string geometryType);
    public static IList`1<Geometry> Extract(Geometry geom, string geometryType, IList`1<Geometry> list);
}
public class NetTopologySuite.Geometries.Utilities.GeometryExtracter`1 : object {
    private IList`1<Geometry> _comps;
    public GeometryExtracter`1(IList`1<Geometry> comps);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Geometries.Utilities.GeometryExtracterByTypeName : object {
    private string _geometryType;
    private IList`1<Geometry> _comps;
    public GeometryExtracterByTypeName(string geometryType, IList`1<Geometry> comps);
    protected static bool IsOfType(Geometry geom, string geometryType);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Geometries.Utilities.GeometryFixer : object {
    private static bool DefaultKeepMulti;
    private Geometry _geom;
    private GeometryFactory _factory;
    [CompilerGeneratedAttribute]
private bool <KeepCollapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepMulti>k__BackingField;
    public bool KeepCollapsed { get; public set; }
    public bool KeepMulti { get; public set; }
    public GeometryFixer(Geometry geom);
    public static Geometry Fix(Geometry geom);
    public static Geometry Fix(Geometry geom, bool isKeepMulti);
    [CompilerGeneratedAttribute]
public bool get_KeepCollapsed();
    [CompilerGeneratedAttribute]
public void set_KeepCollapsed(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepMulti();
    [CompilerGeneratedAttribute]
public void set_KeepMulti(bool value);
    public Geometry GetResult();
    private Point FixPoint(Point geom);
    private Point FixPointElement(Point geom);
    private static bool IsValidPoint(Point pt);
    private Geometry FixMultiPoint(MultiPoint geom);
    private Geometry FixLinearRing(LinearRing geom);
    private Geometry FixLinearRingElement(LinearRing geom);
    private Geometry FixLineString(LineString geom);
    private Geometry FixLineStringElement(LineString geom);
    private static Coordinate[] FixCoordinates(Coordinate[] pts);
    private Geometry FixMultiLineString(MultiLineString geom);
    private Geometry FixPolygon(Polygon geom);
    private Geometry FixPolygonElement(Polygon geom);
    private List`1<Geometry> FixHoles(Polygon geom);
    private void ClassifyHoles(Geometry shell, List`1<Geometry> holesFixed, List`1<Geometry> holes, List`1<Geometry> shells);
    private Geometry Difference(Geometry shell, List`1<Geometry> holes);
    private Geometry Union(List`1<Geometry> polys);
    private Geometry FixRing(LinearRing ring);
    private Geometry FixMultiPolygon(MultiPolygon geom);
    private Geometry FixCollection(GeometryCollection geom);
    private static Geometry Fix(Geometry geom, bool isKeepCollapsed, bool isKeepMulti);
}
public class NetTopologySuite.Geometries.Utilities.GeometryMapper : object {
    public static Geometry Map(Geometry geom, Func`2<Geometry, Geometry> op);
    public static Geometry Map(Geometry geom, IMapOp op);
    public static ReadOnlyCollection`1<Geometry> Map(IEnumerable`1<Geometry> geoms, IMapOp op);
    public static Geometry FlatMap(Geometry geom, Dimension emptyDim, IMapOp op);
    private static void FlatMap(Geometry geom, IMapOp op, List`1<Geometry> mapped);
    private static void AddFlat(Geometry geom, List`1<Geometry> geomList);
}
public class NetTopologySuite.Geometries.Utilities.GeometryTransformer : object {
    private Geometry _inputGeom;
    protected GeometryFactory Factory;
    private bool pruneEmptyGeometry;
    private bool preserveGeometryCollectionType;
    private bool _preserveType;
    public Geometry InputGeometry { get; }
    public Geometry get_InputGeometry();
    public Geometry Transform(Geometry inputGeom);
    protected virtual CoordinateSequence CreateCoordinateSequence(Coordinate[] coords);
    protected virtual CoordinateSequence Copy(CoordinateSequence seq);
    protected virtual CoordinateSequence TransformCoordinates(CoordinateSequence coords, Geometry parent);
    protected virtual Geometry TransformPoint(Point geom, Geometry parent);
    protected virtual Geometry TransformMultiPoint(MultiPoint geom, Geometry parent);
    protected virtual Geometry TransformLinearRing(LinearRing geom, Geometry parent);
    protected virtual Geometry TransformLineString(LineString geom, Geometry parent);
    protected virtual Geometry TransformMultiLineString(MultiLineString geom, Geometry parent);
    protected virtual Geometry TransformPolygon(Polygon geom, Geometry parent);
    protected virtual Geometry TransformMultiPolygon(MultiPolygon geom, Geometry parent);
    protected virtual Geometry TransformGeometryCollection(GeometryCollection geom, Geometry parent);
}
public class NetTopologySuite.Geometries.Utilities.LinearComponentExtracter : object {
    private ICollection`1<Geometry> _lines;
    [CompilerGeneratedAttribute]
private bool <IsForcedToLineString>k__BackingField;
    public bool IsForcedToLineString { get; public set; }
    public LinearComponentExtracter(ICollection`1<Geometry> lines);
    public LinearComponentExtracter(ICollection`1<Geometry> lines, bool isForcedToLineString);
    public static TCollection GetLines(IEnumerable`1<Geometry> geoms, TCollection lines);
    public static TCollection GetLines(IEnumerable`1<Geometry> geoms, TCollection lines, bool forceToLineString);
    public static TCollection GetLines(Geometry geom, TCollection lines);
    public static TCollection GetLines(Geometry geom, TCollection lines, bool forceToLineString);
    public static ReadOnlyCollection`1<Geometry> GetLines(Geometry geom);
    public static ReadOnlyCollection`1<Geometry> GetLines(Geometry geom, bool forceToLineString);
    public static Geometry GetGeometry(Geometry geom);
    public static Geometry GetGeometry(Geometry geom, bool forceToLineString);
    [CompilerGeneratedAttribute]
public bool get_IsForcedToLineString();
    [CompilerGeneratedAttribute]
public void set_IsForcedToLineString(bool value);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Geometries.Utilities.LineStringExtracter : object {
    private ICollection`1<Geometry> _comps;
    public LineStringExtracter(ICollection`1<Geometry> comps);
    public static TCollection GetLines(Geometry geom, TCollection lines);
    public static ReadOnlyCollection`1<Geometry> GetLines(Geometry geom);
    public static Geometry GetGeometry(Geometry geom);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Geometries.Utilities.Matrix : object {
    private static void SwapRows(Double[][] m, int i, int j);
    private static void SwapRows(Double[] m, int i, int j);
    public static Double[] Solve(Double[][] a, Double[] b);
}
public class NetTopologySuite.Geometries.Utilities.NoninvertibleTransformationException : Exception {
    public NoninvertibleTransformationException(string transformationIsNonInvertible);
}
public class NetTopologySuite.Geometries.Utilities.PointExtracter : object {
    private ICollection`1<Geometry> _pts;
    public PointExtracter(ICollection`1<Geometry> pts);
    public static TCollection GetPoints(Geometry geom, TCollection list);
    public static ReadOnlyCollection`1<Geometry> GetPoints(Geometry geom);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Geometries.Utilities.PolygonExtracter : object {
    private IList`1<Geometry> _comps;
    public PolygonExtracter(IList`1<Geometry> comps);
    public static IList`1<Geometry> GetPolygons(Geometry geom, IList`1<Geometry> list);
    public static IList`1<Geometry> GetPolygons(Geometry geom);
    public sealed virtual void Filter(Geometry geom);
}
public abstract class NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor : object {
    private bool _isDone;
    public void ApplyTo(Geometry geom);
    protected abstract virtual void Visit(Geometry element);
    protected abstract virtual bool IsDone();
}
public class NetTopologySuite.Geometries.Utilities.SineStarFactory : GeometricShapeFactory {
    [CompilerGeneratedAttribute]
private int <NumArms>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ArmLengthRatio>k__BackingField;
    public int NumArms { get; public set; }
    public double ArmLengthRatio { get; public set; }
    public SineStarFactory(GeometryFactory geomFact);
    public static Geometry Create(Coordinate origin, double size, int nPts, int nArms, double armLengthRatio);
    [CompilerGeneratedAttribute]
public int get_NumArms();
    [CompilerGeneratedAttribute]
public void set_NumArms(int value);
    [CompilerGeneratedAttribute]
public double get_ArmLengthRatio();
    [CompilerGeneratedAttribute]
public void set_ArmLengthRatio(double value);
    public Geometry CreateSineStar();
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.GeometriesGraph.Depth : object {
    private static int null;
    private Int32[0...,0...] _depth;
    [ObsoleteAttribute("Use GetDepth, SetDepth")]
public int Item { get; public set; }
    public static int DepthAtLocation(Location _location);
    [ObsoleteAttribute("Use GetDepth(int, Geometries.Position)")]
public int GetDepth(int geomIndex, Positions posIndex);
    public int GetDepth(int geomIndex, Position posIndex);
    [ObsoleteAttribute("Use SetDepth(int, Geometries.Position, int)")]
public void SetDepth(int geomIndex, Positions posIndex, int depthValue);
    public void SetDepth(int geomIndex, Position posIndex, int depthValue);
    public int get_Item(int geomIndex, Positions posIndex);
    public void set_Item(int geomIndex, Positions posIndex, int value);
    [ObsoleteAttribute("Use GetLocation(int, Geometries.Position)")]
public Location GetLocation(int geomIndex, Positions posIndex);
    public Location GetLocation(int geomIndex, Position posIndex);
    [ObsoleteAttribute("This method is not used and will be removed in a later release.")]
public void Add(int geomIndex, Positions posIndex, Location _location);
    public bool IsNull();
    public bool IsNull(int geomIndex);
    [ObsoleteAttribute("Use IsNull(int, Geometries.Position)")]
public bool IsNull(int geomIndex, Positions posIndex);
    public bool IsNull(int geomIndex, Position posIndex);
    public void Add(Label lbl);
    public int GetDelta(int geomIndex);
    public void Normalize();
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.DirectedEdge : EdgeEnd {
    private bool _isForward;
    private bool _isInResult;
    private bool _isVisited;
    private DirectedEdge _sym;
    private Int32[] _depth;
    [CompilerGeneratedAttribute]
private EdgeRing <EdgeRing>k__BackingField;
    [CompilerGeneratedAttribute]
private EdgeRing <MinEdgeRing>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectedEdge <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectedEdge <NextMin>k__BackingField;
    public bool InResult { get; public set; }
    public bool IsInResult { get; }
    public bool Visited { get; public set; }
    public bool IsVisited { get; }
    public EdgeRing EdgeRing { get; public set; }
    public EdgeRing MinEdgeRing { get; public set; }
    public int DepthDelta { get; }
    public bool VisitedEdge { get; public set; }
    public bool IsForward { get; protected set; }
    public DirectedEdge Sym { get; public set; }
    public DirectedEdge Next { get; public set; }
    public DirectedEdge NextMin { get; public set; }
    public bool IsLineEdge { get; }
    public bool IsInteriorAreaEdge { get; }
    public DirectedEdge(Edge edge, bool isForward);
    public static int DepthFactor(Location currLocation, Location nextLocation);
    public bool get_InResult();
    public void set_InResult(bool value);
    public bool get_IsInResult();
    public bool get_Visited();
    public void set_Visited(bool value);
    public bool get_IsVisited();
    [CompilerGeneratedAttribute]
public EdgeRing get_EdgeRing();
    [CompilerGeneratedAttribute]
public void set_EdgeRing(EdgeRing value);
    [CompilerGeneratedAttribute]
public EdgeRing get_MinEdgeRing();
    [CompilerGeneratedAttribute]
public void set_MinEdgeRing(EdgeRing value);
    [ObsoleteAttribute("Use GetDepth(Geometries.Position)")]
public int GetDepth(Positions position);
    public int GetDepth(Position position);
    [ObsoleteAttribute("Use SetDepth(Geometries.Position, int)")]
public void SetDepth(Positions position, int depthVal);
    public void SetDepth(Position position, int depthVal);
    public int get_DepthDelta();
    public bool get_VisitedEdge();
    public void set_VisitedEdge(bool value);
    public bool get_IsForward();
    protected void set_IsForward(bool value);
    public DirectedEdge get_Sym();
    public void set_Sym(DirectedEdge value);
    [CompilerGeneratedAttribute]
public DirectedEdge get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(DirectedEdge value);
    [CompilerGeneratedAttribute]
public DirectedEdge get_NextMin();
    [CompilerGeneratedAttribute]
public void set_NextMin(DirectedEdge value);
    public bool get_IsLineEdge();
    public bool get_IsInteriorAreaEdge();
    private void ComputeDirectedLabel();
    [ObsoleteAttribute("Use SetEdgeDepths(Topology.Postion, int)")]
public void SetEdgeDepths(Positions position, int depth);
    public void SetEdgeDepths(Position position, int depth);
    public virtual void Write(StreamWriter outstream);
    public void WriteEdge(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.DirectedEdgeStar : EdgeEndStar {
    private IList`1<DirectedEdge> _resultAreaEdgeList;
    private Label _label;
    private static int ScanningForIncoming;
    private static int LinkingToOutgoing;
    public Label Label { get; }
    public virtual void Insert(EdgeEnd ee);
    public Label get_Label();
    public int GetOutgoingDegree();
    public int GetOutgoingDegree(EdgeRing er);
    public DirectedEdge GetRightmostEdge();
    public virtual void ComputeLabelling(GeometryGraph[] geom);
    public void MergeSymLabels();
    public void UpdateLabelling(Label nodeLabel);
    private IList`1<DirectedEdge> GetResultAreaEdges();
    public void LinkResultDirectedEdges();
    public void LinkMinimalDirectedEdges(EdgeRing er);
    public void LinkAllDirectedEdges();
    public void FindCoveredLineEdges();
    public void ComputeDepths(DirectedEdge de);
    private int ComputeDepths(int startIndex, int endIndex, int startDepth);
    public virtual void Write(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.Edge : GraphComponent {
    private Coordinate[] _pts;
    private Envelope _env;
    private EdgeIntersectionList _eiList;
    private string _name;
    private MonotoneChainEdge _mce;
    private bool _isIsolated;
    private Depth _depth;
    private int _depthDelta;
    public Coordinate[] Points { get; public set; }
    public int NumPoints { get; }
    public string Name { get; public set; }
    public Coordinate[] Coordinates { get; }
    public Coordinate Coordinate { get; protected set; }
    public Envelope Envelope { get; }
    public Depth Depth { get; }
    public int DepthDelta { get; public set; }
    public int MaximumSegmentIndex { get; }
    public EdgeIntersectionList EdgeIntersectionList { get; }
    public MonotoneChainEdge MonotoneChainEdge { get; }
    public bool IsClosed { get; }
    public bool IsCollapsed { get; }
    public Edge CollapsedEdge { get; }
    public bool Isolated { get; public set; }
    public bool IsIsolated { get; }
    public Edge(Coordinate[] pts, Label label);
    public Edge(Coordinate[] pts);
    public static void UpdateIM(Label label, IntersectionMatrix im);
    public Coordinate[] get_Points();
    public void set_Points(Coordinate[] value);
    public int get_NumPoints();
    public string get_Name();
    public void set_Name(string value);
    public Coordinate[] get_Coordinates();
    public Coordinate GetCoordinate(int i);
    public virtual Coordinate get_Coordinate();
    protected virtual void set_Coordinate(Coordinate value);
    public Envelope get_Envelope();
    public Depth get_Depth();
    public int get_DepthDelta();
    public void set_DepthDelta(int value);
    public int get_MaximumSegmentIndex();
    public EdgeIntersectionList get_EdgeIntersectionList();
    public MonotoneChainEdge get_MonotoneChainEdge();
    public bool get_IsClosed();
    public bool get_IsCollapsed();
    public Edge get_CollapsedEdge();
    public bool get_Isolated();
    public void set_Isolated(bool value);
    public virtual bool get_IsIsolated();
    public void AddIntersections(LineIntersector li, int segmentIndex, int geomIndex);
    public void AddIntersection(LineIntersector li, int segmentIndex, int geomIndex, int intIndex);
    public virtual void ComputeIM(IntersectionMatrix im);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    protected bool Equals(Edge e);
    public static bool op_Equality(Edge obj1, Edge obj2);
    public static bool op_Inequality(Edge obj1, Edge obj2);
    public bool IsPointwiseEqual(Edge e);
    public virtual string ToString();
    public void Write(TextWriter outstream);
    public void WriteReverse(TextWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.EdgeEnd : object {
    private Label _label;
    private Coordinate _p0;
    private Coordinate _p1;
    private double _dx;
    private double _dy;
    private Quadrant _quadrant;
    [CompilerGeneratedAttribute]
private Edge <Edge>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Node>k__BackingField;
    public Edge Edge { get; protected set; }
    public Label Label { get; protected set; }
    public Coordinate Coordinate { get; }
    public Coordinate DirectedCoordinate { get; }
    [ObsoleteAttribute("Use QuadrantEx")]
public int Quadrant { get; }
    public Quadrant QuadrantEx { get; }
    public double Dx { get; }
    public double Dy { get; }
    public Node Node { get; public set; }
    protected EdgeEnd(Edge edge);
    public EdgeEnd(Edge edge, Coordinate p0, Coordinate p1);
    public EdgeEnd(Edge edge, Coordinate p0, Coordinate p1, Label label);
    protected void Init(Coordinate p0, Coordinate p1);
    [CompilerGeneratedAttribute]
public Edge get_Edge();
    [CompilerGeneratedAttribute]
protected void set_Edge(Edge value);
    public Label get_Label();
    protected void set_Label(Label value);
    public Coordinate get_Coordinate();
    public Coordinate get_DirectedCoordinate();
    public int get_Quadrant();
    public Quadrant get_QuadrantEx();
    public double get_Dx();
    public double get_Dy();
    [CompilerGeneratedAttribute]
public Node get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(Node value);
    public sealed virtual int CompareTo(EdgeEnd e);
    public int CompareDirection(EdgeEnd e);
    public virtual void ComputeLabel(IBoundaryNodeRule boundaryNodeRule);
    public virtual void Write(StreamWriter outstream);
    public virtual string ToString();
}
public abstract class NetTopologySuite.GeometriesGraph.EdgeEndStar : object {
    protected IDictionary`2<EdgeEnd, EdgeEnd> edgeMap;
    protected IList`1<EdgeEnd> edgeList;
    private Location[] _ptInAreaLocation;
    public Coordinate Coordinate { get; }
    public int Degree { get; }
    public IList`1<EdgeEnd> Edges { get; }
    public abstract virtual void Insert(EdgeEnd e);
    protected void InsertEdgeEnd(EdgeEnd e, EdgeEnd obj);
    public Coordinate get_Coordinate();
    public int get_Degree();
    public IEnumerator`1<EdgeEnd> GetEnumerator();
    public IList`1<EdgeEnd> get_Edges();
    public EdgeEnd GetNextCW(EdgeEnd ee);
    public virtual void ComputeLabelling(GeometryGraph[] geomGraph);
    private void ComputeEdgeEndLabels(IBoundaryNodeRule boundaryNodeRule);
    private Location GetLocation(int geomIndex, Coordinate p, GeometryGraph[] geom);
    public bool IsAreaLabelsConsistent(GeometryGraph geometryGraph);
    private bool CheckAreaLabelsConsistent(int geomIndex);
    public void PropagateSideLabels(int geomIndex);
    public int FindIndex(EdgeEnd eSearch);
    public virtual void Write(StreamWriter outstream);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.EdgeIntersection : object {
    private Coordinate _coordinate;
    private int _segmentIndex;
    private double _distance;
    public Coordinate Coordinate { get; }
    public int SegmentIndex { get; }
    public double Distance { get; }
    public EdgeIntersection(Coordinate coord, int segmentIndex, double dist);
    public Coordinate get_Coordinate();
    public int get_SegmentIndex();
    public double get_Distance();
    public sealed virtual int CompareTo(object obj);
    public int Compare(int segmentIndex, double dist);
    public bool IsEndPoint(int maxSegmentIndex);
    public void Write(StreamWriter outstream);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.EdgeIntersectionList : object {
    private IDictionary`2<EdgeIntersection, EdgeIntersection> nodeMap;
    private Edge edge;
    public int Count { get; }
    public EdgeIntersectionList(Edge edge);
    public int get_Count();
    public EdgeIntersection Add(Coordinate intPt, int segmentIndex, double dist);
    public IEnumerator`1<EdgeIntersection> GetEnumerator();
    public bool IsIntersection(Coordinate pt);
    public void AddEndpoints();
    public void AddSplitEdges(IList`1<Edge> edgeList);
    public Edge CreateSplitEdge(EdgeIntersection ei0, EdgeIntersection ei1);
    public void Write(StreamWriter outstream);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.GeometriesGraph.EdgeList : object {
    private List`1<Edge> _edges;
    private IDictionary`2<OrientedCoordinateArray, Edge> _ocaMap;
    public IList`1<Edge> Edges { get; }
    public Edge Item { get; }
    public void Remove(Edge e);
    public void Add(Edge e);
    public void AddAll(IEnumerable`1<Edge> edgeColl);
    public IList`1<Edge> get_Edges();
    public Edge FindEqualEdge(Edge e);
    public IEnumerator`1<Edge> GetEnumerator();
    public Edge get_Item(int index);
    public Edge Get(int i);
    public int FindEdgeIndex(Edge e);
    public void Write(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.EdgeNodingValidator : object {
    private FastNodingValidator _nv;
    public EdgeNodingValidator(IEnumerable`1<Edge> edges);
    public static void CheckValid(IEnumerable`1<Edge> edges);
    public static IEnumerable`1<ISegmentString> ToSegmentStrings(IEnumerable`1<Edge> edges);
    public void CheckValid();
}
public abstract class NetTopologySuite.GeometriesGraph.EdgeRing : object {
    protected DirectedEdge startDe;
    private int _maxNodeDegree;
    private List`1<DirectedEdge> _edges;
    private List`1<Coordinate> _pts;
    private Label _label;
    private LinearRing _ring;
    private bool _isHole;
    private EdgeRing _shell;
    private List`1<EdgeRing> _holes;
    private GeometryFactory _geometryFactory;
    protected GeometryFactory GeometryFactory { get; }
    public bool IsIsolated { get; }
    public bool IsHole { get; }
    public LinearRing LinearRing { get; }
    public Label Label { get; }
    public bool IsShell { get; }
    public EdgeRing Shell { get; public set; }
    public IList`1<DirectedEdge> Edges { get; }
    public int MaxNodeDegree { get; }
    protected EdgeRing(DirectedEdge start, GeometryFactory geometryFactory);
    protected GeometryFactory get_GeometryFactory();
    public bool get_IsIsolated();
    public bool get_IsHole();
    public Coordinate GetCoordinate(int i);
    public LinearRing get_LinearRing();
    public Label get_Label();
    public bool get_IsShell();
    public EdgeRing get_Shell();
    public void set_Shell(EdgeRing value);
    public void AddHole(EdgeRing ring);
    public Polygon ToPolygon(GeometryFactory geometryFactory);
    public void ComputeRing();
    public abstract virtual DirectedEdge GetNext(DirectedEdge de);
    public abstract virtual void SetEdgeRing(DirectedEdge de, EdgeRing er);
    public IList`1<DirectedEdge> get_Edges();
    protected void ComputePoints(DirectedEdge start);
    public int get_MaxNodeDegree();
    private void ComputeMaxNodeDegree();
    public void SetInResult();
    protected void MergeLabel(Label deLabel);
    protected void MergeLabel(Label deLabel, int geomIndex);
    protected void AddPoints(Edge edge, bool isForward, bool isFirstEdge);
    public bool ContainsPoint(Coordinate p);
}
public class NetTopologySuite.GeometriesGraph.GeometryGraph : PlanarGraph {
    private Geometry _parentGeom;
    private IDictionary`2<LineString, Edge> _lineEdgeMap;
    private IBoundaryNodeRule _boundaryNodeRule;
    private bool _useBoundaryDeterminationRule;
    private int _argIndex;
    private IList`1<Node> _boundaryNodes;
    private bool _hasTooFewPoints;
    private Coordinate _invalidPoint;
    private IPointOnGeometryLocator _areaPtLocator;
    private PointLocator _ptLocator;
    public bool HasTooFewPoints { get; }
    public Coordinate InvalidPoint { get; }
    public Geometry Geometry { get; }
    public IBoundaryNodeRule BoundaryNodeRule { get; }
    public IList`1<Node> BoundaryNodes { get; }
    public GeometryGraph(int argIndex, Geometry parentGeom);
    public GeometryGraph(int argIndex, Geometry parentGeom, IBoundaryNodeRule boundaryNodeRule);
    public static Location DetermineBoundary(IBoundaryNodeRule boundaryNodeRule, int boundaryCount);
    private static EdgeSetIntersector CreateEdgeSetIntersector();
    public bool get_HasTooFewPoints();
    public Coordinate get_InvalidPoint();
    public Geometry get_Geometry();
    public IBoundaryNodeRule get_BoundaryNodeRule();
    public IList`1<Node> get_BoundaryNodes();
    public Coordinate[] GetBoundaryPoints();
    public Edge FindEdge(LineString line);
    public void ComputeSplitEdges(IList`1<Edge> edgelist);
    private void Add(Geometry g);
    private void AddCollection(GeometryCollection gc);
    private void AddPoint(Point p);
    private void AddPolygonRing(LinearRing lr, Location cwLeft, Location cwRight);
    private void AddPolygon(Polygon p);
    private void AddLineString(LineString line);
    public void AddEdge(Edge e);
    public void AddPoint(Coordinate pt);
    public SegmentIntersector ComputeSelfNodes(LineIntersector li, bool computeRingSelfNodes);
    [ObsoleteAttribute("Shrot circuiting no longer allowed")]
public SegmentIntersector ComputeSelfNodes(LineIntersector li, bool computeRingSelfNodes, bool isDoneIfProperInt);
    public SegmentIntersector ComputeEdgeIntersections(GeometryGraph g, LineIntersector li, bool includeProper);
    private void InsertPoint(int argIndex, Coordinate coord, Location onLocation);
    private void InsertBoundaryPoint(int argIndex, Coordinate coord);
    private void AddSelfIntersectionNodes(int argIndex);
    private void AddSelfIntersectionNode(int argIndex, Coordinate coord, Location loc);
    public Location Locate(Coordinate pt);
}
public abstract class NetTopologySuite.GeometriesGraph.GraphComponent : object {
    private Label _label;
    private bool _isCovered;
    private bool _isCoveredSet;
    private bool _isVisited;
    [CompilerGeneratedAttribute]
private bool <InResult>k__BackingField;
    public Label Label { get; protected internal set; }
    public bool InResult { get; public set; }
    public bool IsInResult { get; }
    public bool Covered { get; public set; }
    public bool IsCovered { get; }
    public bool IsCoveredSet { get; }
    public bool Visited { get; public set; }
    public bool IsVisited { get; }
    public Coordinate Coordinate { get; protected set; }
    public bool IsIsolated { get; }
    protected GraphComponent(Label label);
    public Label get_Label();
    protected internal void set_Label(Label value);
    [CompilerGeneratedAttribute]
public bool get_InResult();
    [CompilerGeneratedAttribute]
public void set_InResult(bool value);
    public bool get_IsInResult();
    public bool get_Covered();
    public void set_Covered(bool value);
    public bool get_IsCovered();
    public bool get_IsCoveredSet();
    public bool get_Visited();
    public void set_Visited(bool value);
    public bool get_IsVisited();
    public abstract virtual Coordinate get_Coordinate();
    protected abstract virtual void set_Coordinate(Coordinate value);
    public abstract virtual void ComputeIM(IntersectionMatrix im);
    public abstract virtual bool get_IsIsolated();
    public void UpdateIM(IntersectionMatrix im);
}
public abstract class NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector : object {
    public abstract virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public abstract virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.MonotoneChain : object {
    private MonotoneChainEdge mce;
    private int chainIndex;
    public MonotoneChain(MonotoneChainEdge mce, int chainIndex);
    public void ComputeIntersections(MonotoneChain mc, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge : object {
    private Edge e;
    private Coordinate[] pts;
    private Int32[] startIndex;
    public Coordinate[] Coordinates { get; }
    public Int32[] StartIndexes { get; }
    public MonotoneChainEdge(Edge e);
    public Coordinate[] get_Coordinates();
    public Int32[] get_StartIndexes();
    public double GetMinX(int chainIndex);
    public double GetMaxX(int chainIndex);
    public void ComputeIntersects(MonotoneChainEdge mce, SegmentIntersector si);
    public void ComputeIntersectsForChain(int chainIndex0, MonotoneChainEdge mce, int chainIndex1, SegmentIntersector si);
    private void ComputeIntersectsForChain(int start0, int end0, MonotoneChainEdge mce, int start1, int end1, SegmentIntersector ei);
    private bool Overlaps(int start0, int end0, MonotoneChainEdge mce, int start1, int end1);
}
public class NetTopologySuite.GeometriesGraph.Index.MonotoneChainIndexer : object {
    public Int32[] GetChainStartIndices(Coordinate[] pts);
    public Int32[] OLDGetChainStartIndices(Coordinate[] pts);
    private static int FindChainEnd(Coordinate[] pts, int start);
}
public class NetTopologySuite.GeometriesGraph.Index.SegmentIntersector : object {
    private bool _hasIntersection;
    private bool _hasProper;
    private bool _hasProperInterior;
    private Coordinate _properIntersectionPoint;
    private LineIntersector _li;
    private bool _includeProper;
    private bool _recordIsolated;
    public int NumTests;
    private IList`1[] _bdyNodes;
    [ObsoleteAttribute("Not used anymore, will be removed in a later version")]
unknown bool IsDoneIfProperInt {public set; }
    public bool IsDone { get; }
    public Coordinate ProperIntersectionPoint { get; }
    public bool HasIntersection { get; }
    public bool HasProperIntersection { get; }
    public bool HasProperInteriorIntersection { get; }
    public SegmentIntersector(LineIntersector li, bool includeProper, bool recordIsolated);
    public static bool IsAdjacentSegments(int i1, int i2);
    public void SetBoundaryNodes(IList`1<Node> bdyNodes0, IList`1<Node> bdyNodes1);
    public void set_IsDoneIfProperInt(bool value);
    public bool get_IsDone();
    public Coordinate get_ProperIntersectionPoint();
    public bool get_HasIntersection();
    public bool get_HasProperIntersection();
    public bool get_HasProperInteriorIntersection();
    private bool IsTrivialIntersection(Edge e0, int segIndex0, Edge e1, int segIndex1);
    public void AddIntersections(Edge e0, int segIndex0, Edge e1, int segIndex1);
    private static bool IsBoundaryPoint(LineIntersector li, IList`1[] bdyNodes);
    private static bool IsBoundaryPointInternal(LineIntersector li, IEnumerable`1<Node> bdyNodes);
}
public class NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector : EdgeSetIntersector {
    public virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
    private static void ComputeIntersects(Edge e0, Edge e1, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.SimpleMCSweepLineIntersector : EdgeSetIntersector {
    private List`1<SweepLineEvent> _events;
    private int _nOverlaps;
    public virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
    private void AddEdges(IEnumerable`1<Edge> edges);
    private void AddEdges(IEnumerable`1<Edge> edges, object edgeSet);
    private void AddEdge(Edge edge, object edgeSet);
    private void PrepareEvents();
    private void ComputeIntersections(SegmentIntersector si);
    private void ProcessOverlaps(int start, int end, SweepLineEvent ev0, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.SimpleSweepLineIntersector : EdgeSetIntersector {
    private List`1<SweepLineEvent> _events;
    private int _nOverlaps;
    public virtual void ComputeIntersections(IList`1<Edge> edges, SegmentIntersector si, bool testAllSegments);
    public virtual void ComputeIntersections(IList`1<Edge> edges0, IList`1<Edge> edges1, SegmentIntersector si);
    private void Add(IEnumerable`1<Edge> edges);
    private void Add(IEnumerable`1<Edge> edges, object edgeSet);
    private void Add(Edge edge, object edgeSet);
    private void PrepareEvents();
    private void ComputeIntersections(SegmentIntersector si);
    private void ProcessOverlaps(int start, int end, SweepLineEvent ev0, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Index.SweepLineEvent : object {
    private static int Insert;
    private static int Delete;
    private object _label;
    private double _xValue;
    private int _eventType;
    private SweepLineEvent _insertEvent;
    private int _deleteEventIndex;
    private object _obj;
    public bool IsInsert { get; }
    public bool IsDelete { get; }
    public SweepLineEvent InsertEvent { get; }
    public int DeleteEventIndex { get; public set; }
    public object Object { get; }
    public SweepLineEvent(object label, double x, object obj);
    public SweepLineEvent(double x, SweepLineEvent insertEvent);
    public bool get_IsInsert();
    public bool get_IsDelete();
    public SweepLineEvent get_InsertEvent();
    public int get_DeleteEventIndex();
    public void set_DeleteEventIndex(int value);
    public object get_Object();
    public bool IsSameLabel(SweepLineEvent ev);
    public sealed virtual int CompareTo(object o);
}
public class NetTopologySuite.GeometriesGraph.Index.SweepLineSegment : object {
    private Edge edge;
    private Coordinate[] pts;
    private int ptIndex;
    public double MinX { get; }
    public double MaxX { get; }
    public SweepLineSegment(Edge edge, int ptIndex);
    public double get_MinX();
    public double get_MaxX();
    public void ComputeIntersections(SweepLineSegment ss, SegmentIntersector si);
}
public class NetTopologySuite.GeometriesGraph.Label : object {
    private TopologyLocation[] elt;
    public int GeometryCount { get; }
    public Label(Location onLoc);
    public Label(int geomIndex, Location onLoc);
    public Label(Location onLoc, Location leftLoc, Location rightLoc);
    public Label(int geomIndex, Location onLoc, Location leftLoc, Location rightLoc);
    public Label(Label lbl);
    public static Label ToLineLabel(Label label);
    public void Flip();
    [ObsoleteAttribute("Use GetLocation(int, Topology.Location)")]
public Location GetLocation(int geomIndex, Positions posIndex);
    public Location GetLocation(int geomIndex, Position posIndex);
    public Location GetLocation(int geomIndex);
    [ObsoleteAttribute("Use SetLocation(int, Geometries.Position, Location)")]
public void SetLocation(int geomIndex, Positions posIndex, Location _location);
    public void SetLocation(int geomIndex, Position posIndex, Location _location);
    public void SetLocation(int geomIndex, Location _location);
    public void SetAllLocations(int geomIndex, Location _location);
    public void SetAllLocationsIfNull(int geomIndex, Location _location);
    public void SetAllLocationsIfNull(Location _location);
    public void Merge(Label lbl);
    private void SetGeometryLocation(int geomIndex, TopologyLocation tl);
    public int get_GeometryCount();
    public bool IsNull(int geomIndex);
    public bool IsAnyNull(int geomIndex);
    public bool IsArea();
    public bool IsArea(int geomIndex);
    public bool IsLine(int geomIndex);
    public bool IsEqualOnSide(Label lbl, int side);
    public bool AllPositionsEqual(int geomIndex, Location loc);
    public void ToLine(int geomIndex);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.Node : GraphComponent {
    private Coordinate _coord;
    private EdgeEndStar _edges;
    public Coordinate Coordinate { get; protected set; }
    public EdgeEndStar Edges { get; protected set; }
    public bool IsIsolated { get; }
    public Node(Coordinate coord, EdgeEndStar edges);
    public virtual Coordinate get_Coordinate();
    protected virtual void set_Coordinate(Coordinate value);
    public EdgeEndStar get_Edges();
    protected void set_Edges(EdgeEndStar value);
    public bool IsIncidentEdgeInResult();
    public virtual bool get_IsIsolated();
    public virtual void ComputeIM(IntersectionMatrix im);
    public void Add(EdgeEnd e);
    public void MergeLabel(Node n);
    public void MergeLabel(Label label);
    public void SetLabel(int argIndex, Location onLocation);
    public void SetLabelBoundary(int argIndex);
    public Location ComputeMergedLocation(Label label2, int eltIndex);
    public void Write(TextWriter outstream);
    public virtual string ToString();
}
public class NetTopologySuite.GeometriesGraph.NodeFactory : object {
    public virtual Node CreateNode(Coordinate coord);
}
public class NetTopologySuite.GeometriesGraph.NodeMap : object {
    private IDictionary`2<Coordinate, Node> _nodeMap;
    private NodeFactory _nodeFact;
    public IList`1<Node> Values { get; }
    public NodeMap(NodeFactory nodeFact);
    public Node AddNode(Coordinate coord);
    public Node AddNode(Node n);
    public void Add(EdgeEnd e);
    public Node Find(Coordinate coord);
    public IEnumerator`1<Node> GetEnumerator();
    public IList`1<Node> get_Values();
    public IList`1<Node> GetBoundaryNodes(int geomIndex);
    public void Write(StreamWriter outstream);
}
public class NetTopologySuite.GeometriesGraph.PlanarGraph : object {
    private List`1<Edge> _edges;
    private NodeMap _nodes;
    protected IList`1<EdgeEnd> edgeEndList;
    public IList`1<EdgeEnd> EdgeEnds { get; }
    protected internal IList`1<Edge> Edges { get; }
    public IList`1<Node> Nodes { get; }
    protected NodeMap NodeMap { get; }
    public PlanarGraph(NodeFactory nodeFact);
    public static void LinkResultDirectedEdges(IList`1<Node> nodes);
    public IEnumerator`1<Edge> GetEdgeEnumerator();
    public IList`1<EdgeEnd> get_EdgeEnds();
    protected internal IList`1<Edge> get_Edges();
    public bool IsBoundaryNode(int geomIndex, Coordinate coord);
    protected void InsertEdge(Edge e);
    public void Add(EdgeEnd e);
    public IEnumerator`1<Node> GetNodeEnumerator();
    public IList`1<Node> get_Nodes();
    protected NodeMap get_NodeMap();
    public Node AddNode(Node node);
    public Node AddNode(Coordinate coord);
    public Node Find(Coordinate coord);
    public void AddEdges(IList`1<Edge> edgesToAdd);
    public void LinkResultDirectedEdges();
    public void LinkAllDirectedEdges();
    public EdgeEnd FindEdgeEnd(Edge e);
    public Edge FindEdge(Coordinate p0, Coordinate p1);
    public Edge FindEdgeInSameDirection(Coordinate p0, Coordinate p1);
    private static bool MatchInSameDirection(Coordinate p0, Coordinate p1, Coordinate ep0, Coordinate ep1);
    public void WriteEdges(StreamWriter outstream);
}
[ObsoleteAttribute("Use NetTopologySuite.Geometries.PositionExtensions")]
public class NetTopologySuite.GeometriesGraph.Position : object {
    public static Positions Opposite(Positions position);
}
[ObsoleteAttribute("Use NetTopologySuite.Geometries.Position")]
public enum NetTopologySuite.GeometriesGraph.Positions : Enum {
    public int value__;
    public static Positions On;
    public static Positions Left;
    public static Positions Right;
    public static Positions Parallel;
}
[ObsoleteAttribute("Use NetTopologySuite.Geometries.Quadrant")]
public class NetTopologySuite.GeometriesGraph.QuadrantOp : object {
    public static int NE;
    public static int NW;
    public static int SW;
    public static int SE;
    private static QuadrantOp();
    public static int Quadrant(double dx, double dy);
    public static int Quadrant(Coordinate p0, Coordinate p1);
    public static bool IsOpposite(int quad1, int quad2);
    public static int CommonHalfPlane(int quad1, int quad2);
    public static bool IsInHalfPlane(int quad, int halfPlane);
    public static bool IsNorthern(int quad);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.GeometriesGraph.TopologyLocation : object {
    private Location[] _location;
    [ObsoleteAttribute("Use the Geometries.Position indexer instead")]
public Location Item { get; public set; }
    public Location Item { get; public set; }
    public bool IsNull { get; }
    public bool IsAnyNull { get; }
    public bool IsArea { get; }
    public bool IsLine { get; }
    public TopologyLocation(Location[] location);
    public TopologyLocation(Location on, Location left, Location right);
    public TopologyLocation(Location on);
    public TopologyLocation(TopologyLocation gl);
    private void Init(int size);
    [ObsoleteAttribute("Use Get(Geometries.Position)")]
public Location Get(Positions posIndex);
    public Location Get(Position posIndex);
    public Location get_Item(Positions posIndex);
    public void set_Item(Positions posIndex, Location value);
    public Location get_Item(Position posIndex);
    public void set_Item(Position posIndex, Location value);
    public bool get_IsNull();
    public bool get_IsAnyNull();
    public bool IsEqualOnSide(TopologyLocation le, int locIndex);
    public bool get_IsArea();
    public bool get_IsLine();
    public void Flip();
    public void SetAllLocations(Location locValue);
    public void SetAllLocationsIfNull(Location locValue);
    [ObsoleteAttribute("Use SetLocation(Geometries.Position, Location)")]
public void SetLocation(Positions locIndex, Location locValue);
    public void SetLocation(Position locIndex, Location locValue);
    public void SetLocation(Location locValue);
    public Location[] GetLocations();
    public void SetLocations(Location on, Location left, Location right);
    public void SetLocations(TopologyLocation gl);
    public bool AllPositionsEqual(Location loc);
    public void Merge(TopologyLocation gl);
    public virtual string ToString();
}
public class NetTopologySuite.Index.ArrayListVisitor : ArrayListVisitor`1<object> {
}
public class NetTopologySuite.Index.ArrayListVisitor`1 : object {
    private List`1<T> _items;
    public IList`1<T> Items { get; }
    public sealed virtual void VisitItem(T item);
    public IList`1<T> get_Items();
}
public class NetTopologySuite.Index.Bintree.Bintree : Bintree`1<object> {
}
public class NetTopologySuite.Index.Bintree.Bintree`1 : object {
    private Root`1<T> _root;
    private double _minExtent;
    public int Depth { get; }
    public int Count { get; }
    public int NodeSize { get; }
    public static Interval EnsureExtent(Interval itemInterval, double minExtent);
    public int get_Depth();
    public int get_Count();
    public int get_NodeSize();
    public void Insert(Interval itemInterval, T item);
    public bool Remove(Interval itemInterval, T item);
    public IEnumerator`1<T> GetEnumerator();
    public IList`1<T> Query(double x);
    public IList`1<T> Query(Interval interval);
    public void Query(Interval interval, ICollection`1<T> foundItems);
    private void CollectStats(Interval interval);
}
public class NetTopologySuite.Index.Bintree.Interval : object {
    private double _min;
    private double _max;
    public double Min { get; public set; }
    public double Max { get; public set; }
    public double Width { get; }
    public double Centre { get; }
    public Interval(double min, double max);
    public Interval(Interval interval);
    public double get_Min();
    public void set_Min(double value);
    public double get_Max();
    public void set_Max(double value);
    public double get_Width();
    public double get_Centre();
    public void Init(double min, double max);
    public void ExpandToInclude(Interval interval);
    public bool Overlaps(Interval interval);
    public bool Overlaps(double min, double max);
    public bool Contains(Interval interval);
    public bool Contains(double min, double max);
    public bool Contains(double p);
}
public class NetTopologySuite.Index.Bintree.Key : object {
    private double _pt;
    private int _level;
    private Interval _interval;
    public double Point { get; }
    public int Level { get; }
    public Interval Interval { get; }
    public Key(Interval interval);
    public static int ComputeLevel(Interval interval);
    public double get_Point();
    public int get_Level();
    public Interval get_Interval();
    public void ComputeKey(Interval itemInterval);
    private void ComputeInterval(int level, Interval itemInterval);
}
public class NetTopologySuite.Index.Bintree.Node`1 : NodeBase`1<T> {
    private Interval _interval;
    private double _centre;
    private int _level;
    public Interval Interval { get; }
    public Node`1(Interval interval, int level);
    public static Node`1<T> CreateNode(Interval itemInterval);
    public static Node`1<T> CreateExpanded(Node`1<T> node, Interval addInterval);
    public Interval get_Interval();
    protected virtual bool IsSearchMatch(Interval itemInterval);
    public Node`1<T> GetNode(Interval searchInterval);
    public NodeBase`1<T> Find(Interval searchInterval);
    public void Insert(Node`1<T> node);
    private Node`1<T> GetSubnode(int index);
    private Node`1<T> CreateSubnode(int index);
}
public abstract class NetTopologySuite.Index.Bintree.NodeBase`1 : object {
    private IList`1<T> _items;
    protected Node`1[] Subnode;
    public IList`1<T> Items { get; protected set; }
    public bool IsPrunable { get; }
    public bool HasChildren { get; }
    public bool HasItems { get; }
    public int Depth { get; }
    public int Count { get; }
    public int NodeCount { get; }
    public static int GetSubnodeIndex(Interval interval, double centre);
    public IList`1<T> get_Items();
    protected void set_Items(IList`1<T> value);
    public void Add(T item);
    public IList`1<T> AddAllItems(IList`1<T> items);
    protected abstract virtual bool IsSearchMatch(Interval interval);
    public void AddAllItemsFromOverlapping(Interval interval, ICollection`1<T> resultItems);
    public bool Remove(Interval itemInterval, T item);
    public bool get_IsPrunable();
    public bool get_HasChildren();
    public bool get_HasItems();
    public int get_Depth();
    public int get_Count();
    public int get_NodeCount();
}
public class NetTopologySuite.Index.Bintree.Root`1 : NodeBase`1<T> {
    private static double Origin;
    public void Insert(Interval itemInterval, T item);
    private static void InsertContained(Node`1<T> tree, Interval itemInterval, T item);
    protected virtual bool IsSearchMatch(Interval interval);
}
public class NetTopologySuite.Index.Chain.MonotoneChain : object {
    private Coordinate[] _pts;
    private int _start;
    private int _end;
    private Envelope _env;
    private object _context;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    public int Id { get; public set; }
    public double OverlapDistance { get; public set; }
    public object Context { get; }
    public Envelope Envelope { get; }
    public int StartIndex { get; }
    public int EndIndex { get; }
    public Coordinate[] Coordinates { get; }
    public MonotoneChain(Coordinate[] pts, int start, int end, object context);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    public double get_OverlapDistance();
    public void set_OverlapDistance(double value);
    public object get_Context();
    public Envelope get_Envelope();
    public Envelope GetEnvelope(double expansionDistance);
    public int get_StartIndex();
    public int get_EndIndex();
    public void GetLineSegment(int index, LineSegment& ls);
    public Coordinate[] get_Coordinates();
    public void Select(Envelope searchEnv, MonotoneChainSelectAction mcs);
    private void ComputeSelect(Envelope searchEnv, int start0, int end0, MonotoneChainSelectAction mcs);
    public void ComputeOverlaps(MonotoneChain mc, MonotoneChainOverlapAction mco);
    public void ComputeOverlaps(MonotoneChain mc, double overlapTolerance, MonotoneChainOverlapAction mco);
    private void ComputeOverlaps(int start0, int end0, MonotoneChain mc, int start1, int end1, double overlapTolerance, MonotoneChainOverlapAction mco);
    private bool Overlaps(int start0, int end0, MonotoneChain mc, int start1, int end1, double overlapTolerance);
    private static bool Overlaps(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2, double overlapTolerance);
}
public class NetTopologySuite.Index.Chain.MonotoneChainBuilder : object {
    [ObsoleteAttribute]
public static Int32[] ToIntArray(IList`1<int> list);
    public static ReadOnlyCollection`1<MonotoneChain> GetChains(Coordinate[] pts);
    public static ReadOnlyCollection`1<MonotoneChain> GetChains(Coordinate[] pts, object context);
    [ObsoleteAttribute]
public static Int32[] GetChainStartIndices(Coordinate[] pts);
    private static int FindChainEnd(Coordinate[] pts, int start);
}
public class NetTopologySuite.Index.Chain.MonotoneChainOverlapAction : object {
    protected LineSegment overlapSeg1;
    protected LineSegment overlapSeg2;
    public virtual void Overlap(MonotoneChain mc1, int start1, MonotoneChain mc2, int start2);
    public virtual void Overlap(LineSegment seg1, LineSegment seg2);
}
public class NetTopologySuite.Index.Chain.MonotoneChainSelectAction : object {
    public LineSegment SelectedSegment;
    public virtual void Select(MonotoneChain mc, int startIndex);
    public virtual void Select(LineSegment seg);
}
public class NetTopologySuite.Index.HPRtree.HilbertEncoder : object {
    private int _level;
    private double _minx;
    private double _miny;
    private double _strideX;
    private double _strideY;
    public HilbertEncoder(int level, Envelope extent);
    public int Encode(Envelope env);
}
public class NetTopologySuite.Index.HPRtree.HPRtree`1 : object {
    private static int ENV_SIZE;
    private static int HILBERT_LEVEL;
    private static int DEFAULT_NODE_CAPACITY;
    private List`1<Item`1<T>> _items;
    private int _nodeCapacity;
    private Envelope _totalExtent;
    private Int32[] _layerStartIndex;
    private Double[] _nodeBounds;
    private bool _isBuilt;
    public int Count { get; }
    public HPRtree`1(int nodeCapacity);
    private static HPRtree`1();
    public int get_Count();
    public sealed virtual void Insert(Envelope itemEnv, T item);
    public sealed virtual IList`1<T> Query(Envelope searchEnv);
    public sealed virtual void Query(Envelope searchEnv, IItemVisitor`1<T> visitor);
    private void QueryTopLayer(Envelope searchEnv, IItemVisitor`1<T> visitor);
    private void QueryNode(int layerIndex, int nodeOffset, Envelope searchEnv, IItemVisitor`1<T> visitor);
    private bool Intersects(int nodeIndex, Envelope env);
    private void QueryNodeChildren(int layerIndex, int blockOffset, Envelope searchEnv, IItemVisitor`1<T> visitor);
    private void QueryItems(int blockStart, Envelope searchEnv, IItemVisitor`1<T> visitor);
    private static bool Intersects(Envelope env1, Envelope env2);
    private int GetLayerSize(int layerIndex);
    public sealed virtual bool Remove(Envelope itemEnv, T item);
    public void Build();
    private static Double[] CreateBoundsArray(int size);
    private void ComputeLayerNodes(int layerIndex);
    private void ComputeNodeBounds(int nodeIndex, int blockStart, int nodeMaxIndex);
    private void ComputeLeafNodes(int layerSize);
    private void ComputeLeafNodeBounds(int nodeIndex, int blockStart);
    private void UpdateNodeBounds(int nodeIndex, double minX, double minY, double maxX, double maxY);
    private Envelope GetNodeEnvelope(int i);
    private static Int32[] ComputeLayerIndices(int itemSize, int nodeCapacity);
    private static int NumNodesToCover(int nChild, int nodeCapacity);
    public Envelope[] GetBounds();
    private void SortItems();
}
public class NetTopologySuite.Index.HPRtree.Item`1 : object {
    [CompilerGeneratedAttribute]
private Envelope <Envelope>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public Envelope Envelope { get; }
    public T Value { get; }
    public Item`1(Envelope env, T item);
    [CompilerGeneratedAttribute]
public Envelope get_Envelope();
    [CompilerGeneratedAttribute]
public T get_Value();
    public virtual string ToString();
}
public interface NetTopologySuite.Index.IIndexVisitor {
    public abstract virtual void VisitItem(object item);
}
public interface NetTopologySuite.Index.IItemVisitor`1 {
    public abstract virtual void VisitItem(T item);
}
public interface NetTopologySuite.Index.ILimitingItemVisitor`1 {
    public bool IsDone { get; }
    public abstract virtual bool get_IsDone();
}
public class NetTopologySuite.Index.IntervalRTree.IntervalRTreeBranchNode`1 : IntervalRTreeNode`1<T> {
    private IntervalRTreeNode`1<T> _node1;
    private IntervalRTreeNode`1<T> _node2;
    public IntervalRTreeBranchNode`1(IntervalRTreeNode`1<T> n1, IntervalRTreeNode`1<T> n2);
    private void BuildExtent(IntervalRTreeNode`1<T> n1, IntervalRTreeNode`1<T> n2);
    public virtual void Query(double queryMin, double queryMax, IItemVisitor`1<T> visitor);
}
public class NetTopologySuite.Index.IntervalRTree.IntervalRTreeLeafNode`1 : IntervalRTreeNode`1<T> {
    private T _item;
    public IntervalRTreeLeafNode`1(double min, double max, T item);
    public virtual void Query(double queryMin, double queryMax, IItemVisitor`1<T> visitor);
}
public abstract class NetTopologySuite.Index.IntervalRTree.IntervalRTreeNode`1 : object {
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    public double Min { get; protected set; }
    public double Max { get; protected set; }
    protected IntervalRTreeNode`1(double min, double max);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
protected void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
protected void set_Max(double value);
    public abstract virtual void Query(double queryMin, double queryMax, IItemVisitor`1<T> visitor);
    protected bool Intersects(double queryMin, double queryMax);
    public virtual string ToString();
}
public class NetTopologySuite.Index.IntervalRTree.SortedPackedIntervalRTree`1 : object {
    private object _leavesLock;
    private List`1<IntervalRTreeNode`1<T>> _leaves;
    private IntervalRTreeNode`1 modreq(System.Runtime.CompilerServices.IsVolatile) _root;
    public void Insert(double min, double max, T item);
    private void Init();
    private IntervalRTreeNode`1<T> BuildTree();
    private static void BuildLevel(List`1<IntervalRTreeNode`1<T>> src, List`1<IntervalRTreeNode`1<T>> dest, Int32& level);
    public void Query(double min, double max, IItemVisitor`1<T> visitor);
}
public interface NetTopologySuite.Index.ISpatialIndex`1 {
    public abstract virtual void Insert(Envelope itemEnv, T item);
    public abstract virtual IList`1<T> Query(Envelope searchEnv);
    public abstract virtual void Query(Envelope searchEnv, IItemVisitor`1<T> visitor);
    public abstract virtual bool Remove(Envelope itemEnv, T item);
}
public interface NetTopologySuite.Index.ISpatialIndexEx`1 {
    public abstract virtual IEnumerable`1<T> Query(Envelope extent);
    public abstract virtual IEnumerable`1<T> Query(Envelope extent, Func`2<T, bool> predicate);
}
public interface NetTopologySuite.Index.KdTree.IKdNodeVisitor`1 {
    public abstract virtual void Visit(KdNode`1<T> node);
}
public class NetTopologySuite.Index.KdTree.KdNode`1 : object {
    private Coordinate _p;
    private T _data;
    private int _count;
    [CompilerGeneratedAttribute]
private KdNode`1<T> <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private KdNode`1<T> <Right>k__BackingField;
    public double X { get; }
    public double Y { get; }
    public Coordinate Coordinate { get; }
    public T Data { get; }
    public KdNode`1<T> Left { get; public set; }
    public KdNode`1<T> Right { get; public set; }
    public int Count { get; }
    public bool IsRepeated { get; }
    public KdNode`1(double x, double y, T data);
    public KdNode`1(Coordinate p, T data);
    public double get_X();
    public double get_Y();
    public double SplitValue(bool isSplitOnX);
    public Coordinate get_Coordinate();
    public T get_Data();
    [CompilerGeneratedAttribute]
public KdNode`1<T> get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(KdNode`1<T> value);
    [CompilerGeneratedAttribute]
public KdNode`1<T> get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(KdNode`1<T> value);
    internal void Increment();
    public int get_Count();
    public bool get_IsRepeated();
    internal bool IsRangeOverLeft(bool isSplitOnX, Envelope env);
    internal bool IsRangeOverRight(bool isSplitOnX, Envelope env);
    internal bool IsPointOnLeft(bool isSplitOnX, Coordinate pt);
}
public class NetTopologySuite.Index.KdTree.KdTree`1 : object {
    private KdNode`1<T> _root;
    private long _numberOfNodes;
    private double _tolerance;
    public bool IsEmpty { get; }
    public KdNode`1<T> Root { get; }
    public int Depth { get; }
    public int Count { get; }
    public KdTree`1(double tolerance);
    public static Coordinate[] ToCoordinates(IEnumerable`1<KdNode`1<T>> kdnodes);
    public static Coordinate[] ToCoordinates(IEnumerable`1<KdNode`1<T>> kdnodes, bool includeRepeated);
    public bool get_IsEmpty();
    public KdNode`1<T> get_Root();
    public KdNode`1<T> Insert(Coordinate p);
    public KdNode`1<T> Insert(Coordinate p, T data);
    private KdNode`1<T> FindBestMatchNode(Coordinate p);
    public KdNode`1<T> InsertExact(Coordinate p, T data);
    public void Query(Envelope queryEnv, IKdNodeVisitor`1<T> visitor);
    public IList`1<KdNode`1<T>> Query(Envelope queryEnv);
    public void Query(Envelope queryEnv, IList`1<KdNode`1<T>> result);
    public KdNode`1<T> Query(Coordinate queryPt);
    public int get_Depth();
    private int DepthNode(KdNode`1<T> currentNode);
    public int get_Count();
    private static int CountNode(KdNode`1<T> currentNode);
}
[ExtensionAttribute]
public static class NetTopologySuite.Index.KdTree.KdTreeExtensions : object {
    [ExtensionAttribute]
public static KdNode`1<T> NearestNeighbor(KdTree`1<T> self, Coordinate coord);
    private static void NearestNeighbor(KdNode`1<T> currentNode, Coordinate queryCoordinate, KdNode`1& closestNode, Double& closestDistanceSq, bool isOddLevel);
    private static bool NeedsToBeSearched(Coordinate target, KdNode`1<T> node, double closestDistSq, bool left, bool isOddLevel);
}
public class NetTopologySuite.Index.Quadtree.DoubleBits : object {
    public static int ExponentBias;
    private double x;
    private long _xBits;
    public double Double { get; }
    public int BiasedExponent { get; }
    public int Exponent { get; }
    public DoubleBits(double x);
    public static double PowerOf2(int exp);
    public static int GetExponent(double d);
    public static double TruncateToPowerOfTwo(double d);
    public static string ToBinaryString(double d);
    public static double MaximumCommonMantissa(double d1, double d2);
    public double get_Double();
    public int get_BiasedExponent();
    public int get_Exponent();
    public void ZeroLowerBits(int nBits);
    public int GetBit(int i);
    public int NumCommonMantissaBits(DoubleBits db);
    public virtual string ToString();
}
public class NetTopologySuite.Index.Quadtree.ExcludingItemVisitor`1 : object {
    private Envelope _exclude;
    private List`1<T> _items;
    public IList`1<T> Items { get; }
    public ExcludingItemVisitor`1(Envelope exclude);
    public sealed virtual void VisitItem(T item);
    public IList`1<T> get_Items();
}
public class NetTopologySuite.Index.Quadtree.IntervalSize : object {
    public static int MinBinaryExponent;
    public static bool IsZeroWidth(double min, double max);
}
public class NetTopologySuite.Index.Quadtree.Key : object {
    private Coordinate _pt;
    private int _level;
    private Envelope _env;
    public Coordinate Point { get; }
    public int Level { get; }
    public Envelope Envelope { get; }
    public Coordinate Centre { get; }
    public Key(Envelope itemEnv);
    public static int ComputeQuadLevel(Envelope env);
    public Coordinate get_Point();
    public int get_Level();
    public Envelope get_Envelope();
    public Coordinate get_Centre();
    public void ComputeKey(Envelope itemEnv);
    private void ComputeKey(int level, Envelope itemEnv);
}
public class NetTopologySuite.Index.Quadtree.Node`1 : NodeBase`1<T> {
    private Envelope _env;
    private double _centreX;
    private double _centreY;
    private int _level;
    public Envelope Envelope { get; }
    public int Level { get; }
    public Node`1(Envelope env, int level);
    public static Node`1<T> CreateNode(Envelope env);
    public static Node`1<T> CreateExpanded(Node`1<T> node, Envelope addEnv);
    public Envelope get_Envelope();
    protected virtual bool IsSearchMatch(Envelope searchEnv);
    public Node`1<T> GetNode(Envelope searchEnv);
    public NodeBase`1<T> Find(Envelope searchEnv);
    public void InsertNode(Node`1<T> node);
    private Node`1<T> GetSubnode(int index);
    private Node`1<T> CreateSubnode(int index);
    public int get_Level();
}
public abstract class NetTopologySuite.Index.Quadtree.NodeBase`1 : object {
    private SynchonizedList<T> _items;
    protected Node`1[] Subnode;
    public IList`1<T> Items { get; protected set; }
    public bool HasItems { get; }
    public bool IsPrunable { get; }
    public bool HasChildren { get; }
    public bool IsEmpty { get; }
    public int Depth { get; }
    public int Count { get; }
    public int NodeCount { get; }
    public static int GetSubnodeIndex(Envelope env, double centreX, double centreY);
    public IList`1<T> get_Items();
    protected void set_Items(IList`1<T> value);
    public bool get_HasItems();
    public void Add(T item);
    public bool Remove(Envelope itemEnv, T item);
    public bool get_IsPrunable();
    public bool get_HasChildren();
    public bool get_IsEmpty();
    public IList`1<T> AddAllItems(IList`1& resultItems);
    protected abstract virtual bool IsSearchMatch(Envelope searchEnv);
    public void AddAllItemsFromOverlapping(Envelope searchEnv, IList`1& resultItems);
    public void Visit(Envelope searchEnv, IItemVisitor`1<T> visitor);
    private void VisitItems(Envelope searchEnv, IItemVisitor`1<T> visitor);
    [IteratorStateMachineAttribute("NetTopologySuite.Index.Quadtree.NodeBase`1/<Query>d__21")]
public IEnumerable`1<T> Query(Envelope searchEnv, Func`2<T, bool> predicate);
    public int get_Depth();
    public int get_Count();
    public int get_NodeCount();
}
public class NetTopologySuite.Index.Quadtree.Quadtree`1 : object {
    private Root`1<T> _root;
    private double _minExtent;
    public int Depth { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public Root`1<T> Root { get; }
    public static Envelope EnsureExtent(Envelope itemEnv, double minExtent);
    public int get_Depth();
    public bool get_IsEmpty();
    public int get_Count();
    public sealed virtual void Insert(Envelope itemEnv, T item);
    public sealed virtual bool Remove(Envelope itemEnv, T item);
    public sealed virtual IList`1<T> Query(Envelope searchEnv);
    public sealed virtual void Query(Envelope searchEnv, IItemVisitor`1<T> visitor);
    public IList`1<T> QueryAll();
    private void CollectStats(Envelope itemEnv);
    public Root`1<T> get_Root();
}
public class NetTopologySuite.Index.Quadtree.Root`1 : NodeBase`1<T> {
    private static Coordinate Origin;
    private static Root`1();
    public void Insert(Envelope itemEnv, T item);
    private static void InsertContained(Node`1<T> tree, Envelope itemEnv, T item);
    protected virtual bool IsSearchMatch(Envelope searchEnv);
}
public abstract class NetTopologySuite.Index.Strtree.AbstractNode`2 : object {
    private IList`1<IBoundable`2<T, TItem>> _childBoundables;
    private T _bounds;
    private int _level;
    public IList`1<IBoundable`2<T, TItem>> ChildBoundables { get; public set; }
    public T Bounds { get; }
    public TItem Item { get; }
    public int Level { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    protected AbstractNode`2(int level);
    public IList`1<IBoundable`2<T, TItem>> get_ChildBoundables();
    public void set_ChildBoundables(IList`1<IBoundable`2<T, TItem>> value);
    protected abstract virtual T ComputeBounds();
    public sealed virtual T get_Bounds();
    public sealed virtual TItem get_Item();
    public int get_Level();
    public int get_Count();
    public bool get_IsEmpty();
    public void AddChildBoundable(IBoundable`2<T, TItem> childBoundable);
}
public abstract class NetTopologySuite.Index.Strtree.AbstractSTRtree`2 : object {
    private static IEqualityComparer`1<TItem> EqualityComparerForRemoveItem;
    private object _buildLock;
    private AbstractNode`2 modreq(System.Runtime.CompilerServices.IsVolatile) _root;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _built;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _building;
    private IList`1<IBoundable`2<T, TItem>> _itemBoundables;
    private int _nodeCapacity;
    public AbstractNode`2<T, TItem> Root { get; protected set; }
    public int NodeCapacity { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public int Depth { get; }
    protected IIntersectsOp<T, TItem> IntersectsOp { get; }
    public IList`1<IBoundable`2<T, TItem>> ItemBoundables { get; }
    protected AbstractSTRtree`2(int nodeCapacity);
    protected AbstractSTRtree`2(int nodeCapacity, AbstractNode`2<T, TItem> root);
    protected AbstractSTRtree`2(int nodeCapacity, IList`1<IBoundable`2<T, TItem>> itemBoundables);
    private static AbstractSTRtree`2();
    public void Build();
    protected abstract virtual AbstractNode`2<T, TItem> CreateNode(int level);
    protected virtual IList`1<IBoundable`2<T, TItem>> CreateParentBoundables(IList`1<IBoundable`2<T, TItem>> childBoundables, int newLevel);
    protected AbstractNode`2<T, TItem> LastNode(IList`1<IBoundable`2<T, TItem>> nodes);
    protected static int CompareDoubles(double a, double b);
    private AbstractNode`2<T, TItem> CreateHigherLevels(IList`1<IBoundable`2<T, TItem>> boundablesOfALevel, int level);
    public AbstractNode`2<T, TItem> get_Root();
    protected void set_Root(AbstractNode`2<T, TItem> value);
    public int get_NodeCapacity();
    public bool get_IsEmpty();
    public int get_Count();
    protected int GetSize(AbstractNode`2<T, TItem> node);
    public int get_Depth();
    protected int GetDepth(AbstractNode`2<T, TItem> node);
    protected void Insert(T bounds, TItem item);
    protected IList`1<TItem> Query(T searchBounds);
    protected void Query(T searchBounds, IItemVisitor`1<TItem> visitor);
    private void QueryInternal(T searchBounds, AbstractNode`2<T, TItem> node, IList`1<TItem> matches);
    private void QueryInternal(T searchBounds, AbstractNode`2<T, TItem> node, IItemVisitor`1<TItem> visitor);
    public IList`1<object> ItemsTree();
    private static IList`1<object> ItemsTree(AbstractNode`2<T, TItem> node);
    protected abstract virtual IIntersectsOp<T, TItem> get_IntersectsOp();
    protected bool Remove(T searchBounds, TItem item);
    private static bool RemoveItem(AbstractNode`2<T, TItem> node, TItem item);
    private bool Remove(T searchBounds, AbstractNode`2<T, TItem> node, TItem item);
    protected IList`1<IBoundable`2<T, TItem>> BoundablesAtLevel(int level);
    private static void BoundablesAtLevel(int level, AbstractNode`2<T, TItem> top, ICollection`1<IBoundable`2<T, TItem>> boundables);
    protected abstract virtual IComparer`1<IBoundable`2<T, TItem>> GetComparer();
    public IList`1<IBoundable`2<T, TItem>> get_ItemBoundables();
    private static IEqualityComparer`1<TItem> InitializeEqualityComparerForRemoveItem();
}
internal class NetTopologySuite.Index.Strtree.BoundablePair`1 : object {
    private IBoundable`2<Envelope, TItem> _boundable1;
    private IBoundable`2<Envelope, TItem> _boundable2;
    private double _distance;
    private IItemDistance`2<Envelope, TItem> _itemDistance;
    public double Distance { get; }
    public bool IsLeaves { get; }
    public BoundablePair`1(IBoundable`2<Envelope, TItem> boundable1, IBoundable`2<Envelope, TItem> boundable2, IItemDistance`2<Envelope, TItem> itemDistance);
    public IBoundable`2<Envelope, TItem> GetBoundable(int i);
    public double MaximumDistance();
    private double GetDistance();
    public double get_Distance();
    public sealed virtual int CompareTo(BoundablePair`1<TItem> o);
    public bool get_IsLeaves();
    public static bool IsComposite(IBoundable`2<Envelope, TItem> item);
    public void ExpandToQueue(PriorityQueue`1<BoundablePair`1<TItem>> priQ, double minDistance);
    private void Expand(IBoundable`2<Envelope, TItem> bndComposite, IBoundable`2<Envelope, TItem> bndOther, bool isFlipped, PriorityQueue`1<BoundablePair`1<TItem>> priQ, double minDistance);
}
internal class NetTopologySuite.Index.Strtree.BoundablePairDistanceComparer`1 : object {
    private bool _normalOrder;
    public BoundablePairDistanceComparer`1(bool normalOrder);
    public sealed virtual int Compare(BoundablePair`1<TItem> p1, BoundablePair`1<TItem> p2);
}
public class NetTopologySuite.Index.Strtree.EnvelopeDistance : object {
    public static double MaximumDistance(Envelope env1, Envelope env2);
    private static double Distance(double x1, double y1, double x2, double y2);
    public static double MinMaxDistance(Envelope a, Envelope b);
    private static double MaxDistance(double ax1, double ay1, double ax2, double ay2, double bx1, double by1, double bx2, double by2);
}
public class NetTopologySuite.Index.Strtree.GeometryItemDistance : object {
    public sealed virtual double Distance(IBoundable`2<Envelope, Geometry> item1, IBoundable`2<Envelope, Geometry> item2);
}
public interface NetTopologySuite.Index.Strtree.IItemDistance`2 {
    public abstract virtual double Distance(IBoundable`2<T, TItem> item1, IBoundable`2<T, TItem> item2);
}
public class NetTopologySuite.Index.Strtree.Interval : object {
    private double _min;
    private double _max;
    public double Centre { get; }
    public Interval(Interval other);
    public Interval(double min, double max);
    public double get_Centre();
    public sealed virtual void ExpandToInclude(Interval other);
    public sealed virtual Interval ExpandedBy(Interval other);
    public sealed virtual bool Intersects(Interval other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class NetTopologySuite.Index.Strtree.ItemBoundable`2 : object {
    private T _bounds;
    private TItem _item;
    public T Bounds { get; }
    public TItem Item { get; }
    public ItemBoundable`2(T bounds, TItem item);
    public sealed virtual T get_Bounds();
    public sealed virtual TItem get_Item();
}
public class NetTopologySuite.Index.Strtree.SIRtree`1 : AbstractSTRtree`2<Interval, TItem> {
    private static IComparer`1<IBoundable`2<Interval, TItem>> Comparator;
    private static IIntersectsOp<Interval, TItem> IntersectsOperation;
    protected IIntersectsOp<Interval, TItem> IntersectsOp { get; }
    public SIRtree`1(int nodeCapacity);
    private static SIRtree`1();
    protected virtual AbstractNode`2<Interval, TItem> CreateNode(int level);
    public void Insert(double x1, double x2, TItem item);
    public IList`1<TItem> Query(double x);
    public IList`1<TItem> Query(double x1, double x2);
    protected virtual IIntersectsOp<Interval, TItem> get_IntersectsOp();
    protected virtual IComparer`1<IBoundable`2<Interval, TItem>> GetComparer();
}
public class NetTopologySuite.Index.Strtree.STRtree`1 : AbstractSTRtree`2<Envelope, TItem> {
    private static AnonymousXComparerImpl<TItem> XComparer;
    private static AnonymousYComparerImpl<TItem> YComparer;
    private static IIntersectsOp<Envelope, TItem> IntersectsOperation;
    private static int DefaultNodeCapacity;
    protected IIntersectsOp<Envelope, TItem> IntersectsOp { get; }
    public STRtree`1(int nodeCapacity);
    public STRtree`1(int nodeCapacity, AbstractNode`2<Envelope, TItem> root);
    public STRtree`1(int nodeCapacity, IList`1<IBoundable`2<Envelope, TItem>> itemBoundables);
    private static STRtree`1();
    private static double Avg(double a, double b);
    private static double CentreX(Envelope e);
    private static double CentreY(Envelope e);
    protected virtual IList`1<IBoundable`2<Envelope, TItem>> CreateParentBoundables(IList`1<IBoundable`2<Envelope, TItem>> childBoundables, int newLevel);
    private List`1<IBoundable`2<Envelope, TItem>> CreateParentBoundablesFromVerticalSlices(IList`1[] verticalSlices, int newLevel);
    protected IList`1<IBoundable`2<Envelope, TItem>> CreateParentBoundablesFromVerticalSlice(IList`1<IBoundable`2<Envelope, TItem>> childBoundables, int newLevel);
    protected IList`1[] VerticalSlices(IList`1<IBoundable`2<Envelope, TItem>> childBoundables, int sliceCount);
    protected virtual AbstractNode`2<Envelope, TItem> CreateNode(int level);
    protected virtual IIntersectsOp<Envelope, TItem> get_IntersectsOp();
    public sealed virtual void Insert(Envelope itemEnv, TItem item);
    public sealed virtual IList`1<TItem> Query(Envelope searchEnv);
    public sealed virtual void Query(Envelope searchEnv, IItemVisitor`1<TItem> visitor);
    public sealed virtual bool Remove(Envelope itemEnv, TItem item);
    protected virtual IComparer`1<IBoundable`2<Envelope, TItem>> GetComparer();
    public TItem[] NearestNeighbour(IItemDistance`2<Envelope, TItem> itemDist);
    public TItem NearestNeighbour(Envelope env, TItem item, IItemDistance`2<Envelope, TItem> itemDist);
    public TItem[] NearestNeighbour(STRtree`1<TItem> tree, IItemDistance`2<Envelope, TItem> itemDist);
    private static TItem[] NearestNeighbour(BoundablePair`1<TItem> initBndPair);
    public bool IsWithinDistance(STRtree`1<TItem> tree, IItemDistance`2<Envelope, TItem> itemDist, double maxDistance);
    private bool IsWithinDistance(BoundablePair`1<TItem> initBndPair, double maxDistance);
    public TItem[] NearestNeighbour(Envelope env, TItem item, IItemDistance`2<Envelope, TItem> itemDist, int k);
    private TItem[] NearestNeighbourK(BoundablePair`1<TItem> initBndPair, int k);
    private TItem[] NearestNeighbourK(BoundablePair`1<TItem> initBndPair, double maxDistance, int k);
    private static TItem[] GetItems(PriorityQueue`1<BoundablePair`1<TItem>> kNearestNeighbors);
}
public interface NetTopologySuite.Index.Sweepline.ISweepLineOverlapAction {
    public abstract virtual void Overlap(SweepLineInterval s0, SweepLineInterval s1);
}
public class NetTopologySuite.Index.Sweepline.SweepLineEvent : object {
    private double xValue;
    private SweepLineEvents eventType;
    private SweepLineEvent insertEvent;
    private SweepLineInterval sweepInt;
    [CompilerGeneratedAttribute]
private int <DeleteEventIndex>k__BackingField;
    public bool IsInsert { get; }
    public bool IsDelete { get; }
    public SweepLineEvent InsertEvent { get; }
    public int DeleteEventIndex { get; public set; }
    public SweepLineInterval Interval { get; }
    public SweepLineEvent(double x, SweepLineEvent insertEvent, SweepLineInterval sweepInt);
    public bool get_IsInsert();
    public bool get_IsDelete();
    public SweepLineEvent get_InsertEvent();
    [CompilerGeneratedAttribute]
public int get_DeleteEventIndex();
    [CompilerGeneratedAttribute]
public void set_DeleteEventIndex(int value);
    public SweepLineInterval get_Interval();
    public sealed virtual int CompareTo(object o);
}
public enum NetTopologySuite.Index.Sweepline.SweepLineEvents : Enum {
    public int value__;
    public static SweepLineEvents Insert;
    public static SweepLineEvents Delete;
}
public class NetTopologySuite.Index.Sweepline.SweepLineIndex : object {
    private List`1<SweepLineEvent> _events;
    private bool _indexBuilt;
    private int _nOverlaps;
    public void Add(SweepLineInterval sweepInt);
    private void BuildIndex();
    public void ComputeOverlaps(ISweepLineOverlapAction action);
    private void ProcessOverlaps(int start, int end, SweepLineInterval s0, ISweepLineOverlapAction action);
}
public class NetTopologySuite.Index.Sweepline.SweepLineInterval : object {
    private double min;
    private double max;
    private object item;
    public double Min { get; }
    public double Max { get; }
    public object Item { get; }
    public SweepLineInterval(double min, double max);
    public SweepLineInterval(double min, double max, object item);
    public double get_Min();
    public double get_Max();
    public object get_Item();
}
public class NetTopologySuite.Index.VertexSequencePackedRtree : object {
    private static int NodeCapacity;
    private Coordinate[] _items;
    private Int32[] _levelOffset;
    private int _nodeCapacity;
    private Envelope[] _bounds;
    private Boolean[] _isRemoved;
    public VertexSequencePackedRtree(Coordinate[] pts);
    public Envelope[] GetBounds();
    private void Build();
    private Int32[] ComputeLevelOffsets();
    private int LevelNodeCount(int numNodes);
    private Envelope[] CreateBounds();
    private void FillLevelBounds(int lvl, Envelope[] bounds);
    private void FillItemBounds(Envelope[] bounds);
    private static Envelope ComputeNodeEnvelope(Envelope[] bounds, int start, int end);
    private static Envelope ComputeItemEnvelope(Coordinate[] items, int start, int end);
    public Int32[] Query(Envelope queryEnv);
    private void QueryNode(Envelope queryEnv, int level, int nodeIndex, List`1<int> resultList);
    private void QueryNodeRange(Envelope queryEnv, int level, int nodeStartIndex, List`1<int> resultList);
    private int LevelSize(int level);
    private void QueryItemRange(Envelope queryEnv, int itemIndex, List`1<int> resultList);
    public void RemoveAt(int index);
    private bool IsNodeEmpty(int level, int index);
    private bool IsItemsNodeEmpty(int nodeIndex);
}
public class NetTopologySuite.IO.BEBinaryWriter : BinaryWriter {
    public BEBinaryWriter(Stream output);
    public BEBinaryWriter(Stream output, Encoding encoding);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
}
public class NetTopologySuite.IO.BiEndianBinaryReader : BinaryReader {
    [CompilerGeneratedAttribute]
private ByteOrder <Endianess>k__BackingField;
    public ByteOrder Endianess { get; public set; }
    public BiEndianBinaryReader(Stream stream);
    public BiEndianBinaryReader(Stream input, ByteOrder endianess);
    [CompilerGeneratedAttribute]
public ByteOrder get_Endianess();
    [CompilerGeneratedAttribute]
public void set_Endianess(ByteOrder value);
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    public virtual string ReadString();
    public virtual decimal ReadDecimal();
}
public enum NetTopologySuite.IO.ByteOrder : Enum {
    public byte value__;
    public static ByteOrder BigEndian;
    public static ByteOrder LittleEndian;
}
[CLSCompliantAttribute("False")]
public class NetTopologySuite.IO.GeometryType : ValueType {
    private UInt32 _geometrytype;
    private static UInt32 EwkbZFlag;
    private static UInt32 EwkbMFlag;
    private static UInt32 EwkbSridFlag;
    private static UInt32 EwkbFlags;
    public OgcGeometryType BaseGeometryType { get; public set; }
    public int WkbGeometryType { get; }
    public int EwkbWkbGeometryType { get; }
    public bool HasZ { get; }
    public bool HasM { get; }
    public bool HasSrid { get; }
    public bool HasWkbZ { get; public set; }
    public bool HasWkbM { get; public set; }
    public bool HasEwkbZ { get; public set; }
    public bool HasEwkbM { get; public set; }
    public bool HasEwkbSrid { get; public set; }
    public GeometryType(UInt32 geometryType);
    public GeometryType(Geometry geometry, Ordinates ordinates);
    public GeometryType(OgcGeometryType ogcGeometryType);
    public GeometryType(OgcGeometryType ogcGeometryType, bool hasSrid);
    public GeometryType(OgcGeometryType ogcGeometryType, Ordinates ordinates, bool hasSrid);
    public OgcGeometryType get_BaseGeometryType();
    public void set_BaseGeometryType(OgcGeometryType value);
    public int get_WkbGeometryType();
    public int get_EwkbWkbGeometryType();
    public bool get_HasZ();
    public bool get_HasM();
    public bool get_HasSrid();
    public bool get_HasWkbZ();
    public void set_HasWkbZ(bool value);
    public bool get_HasWkbM();
    public void set_HasWkbM(bool value);
    public bool get_HasEwkbZ();
    public void set_HasEwkbZ(bool value);
    public bool get_HasEwkbM();
    public void set_HasEwkbM(bool value);
    public bool get_HasEwkbSrid();
    public void set_HasEwkbSrid(bool value);
}
internal static class NetTopologySuite.IO.GML2.GMLElements : object {
    internal static string gmlPrefix;
    internal static string gmlNS;
    internal static string gmlNSDecl;
}
public class NetTopologySuite.IO.GML2.GMLReader : object {
    private GeometryFactory _factory;
    private static Regex IntSuffixPattern;
    protected GeometryFactory Factory { get; }
    public GMLReader(GeometryFactory factory);
    private static GMLReader();
    protected GeometryFactory get_Factory();
    public Geometry Read(XmlDocument document);
    public Geometry Read(XDocument document);
    public Geometry Read(string xmlText);
    public Geometry Read(StringReader stringReader);
    public Geometry Read(XmlReader reader);
    protected Coordinate ReadCoordinate(XmlReader reader);
    protected Coordinate ReadCoordinates(string value);
    protected Coordinate ReadPosAsCoordinate(String[] value);
    protected IEnumerable`1<Coordinate> ReadPosListAsCoordinates(int numOrdinates, String[] value);
    protected Point ReadPoint(XmlReader reader);
    protected Point ReadPoint(XmlReader reader, GeometryFactory gf);
    protected LineString ReadLineString(XmlReader reader);
    protected LineString ReadLineString(XmlReader reader, GeometryFactory gf);
    protected LinearRing ReadLinearRing(XmlReader reader);
    protected LinearRing ReadLinearRing(XmlReader reader, GeometryFactory gf);
    protected Polygon ReadPolygon(XmlReader reader);
    protected Polygon ReadPolygon(XmlReader reader, GeometryFactory gf);
    protected MultiPoint ReadMultiPoint(XmlReader reader);
    protected MultiLineString ReadMultiLineString(XmlReader reader);
    protected MultiLineString ReadMultiCurve(XmlReader reader);
    protected MultiPolygon ReadMultiPolygon(XmlReader reader);
    protected MultiPolygon ReadMultiSurface(XmlReader reader);
    protected GeometryCollection ReadGeometryCollection(XmlReader reader);
    private static bool IsStartElement(XmlReader reader, string name);
    protected virtual GeometryFactory GetFactory(string srsName, GeometryFactory gfDefault);
    protected static string RemoveUnneccessaryWhitespace(string text);
}
internal enum NetTopologySuite.IO.GML2.GMLVersion : Enum {
    public int value__;
    public static GMLVersion Two;
    public static GMLVersion Three;
}
public class NetTopologySuite.IO.GML2.GMLWriter : object {
    private static int InitValue;
    private static int CoordSize;
    private GMLVersion _gmlVersion;
    private string _gmlNs;
    protected static NumberFormatInfo NumberFormatter { get; }
    internal GMLWriter(GMLVersion gmlVersion);
    protected static NumberFormatInfo get_NumberFormatter();
    public XmlReader Write(Geometry geometry);
    public void Write(Geometry geometry, Stream stream);
    protected void Write(Coordinate coordinate, XmlWriter writer);
    protected void Write(Coordinate[] coordinates, XmlWriter writer);
    [ObsoleteAttribute("Use the overload that accepts a CoordinateSequence instead.")]
protected void WriteCoordinates(Coordinate[] coordinates, XmlWriter writer);
    protected void WriteCoordinates(CoordinateSequence coordinates, XmlWriter writer);
    public void Write(Geometry geometry, XmlWriter writer);
    protected void Write(Point point, XmlWriter writer);
    protected void Write(LineString lineString, XmlWriter writer);
    protected void Write(LinearRing linearRing, XmlWriter writer);
    protected void Write(Polygon polygon, XmlWriter writer);
    protected void Write(MultiPoint multiPoint, XmlWriter writer);
    protected void Write(MultiLineString multiLineString, XmlWriter writer);
    protected void Write(MultiPolygon multiPolygon, XmlWriter writer);
    protected void Write(GeometryCollection geometryCollection, XmlWriter writer);
    protected int SetByteStreamLength(Geometry geometry);
    protected int SetByteStreamLength(GeometryCollection geometryCollection);
    protected int SetByteStreamLength(MultiPolygon multiPolygon);
    protected int SetByteStreamLength(MultiLineString multiLineString);
    protected int SetByteStreamLength(MultiPoint multiPoint);
    protected int SetByteStreamLength(Polygon polygon);
    protected int SetByteStreamLength(LineString lineString);
    protected int SetByteStreamLength(Point point);
    protected virtual string GetEpsgCode(int srid);
}
public class NetTopologySuite.IO.GML3.GML3Writer : GMLWriter {
}
public class NetTopologySuite.IO.KML.KMLReader : object {
    private GeometryFactory geometryFactory;
    private ISet`1<string> attributeNames;
    private Regex whitespaceRegex;
    private static string POINT;
    private static string LINESTRING;
    private static string POLYGON;
    private static string MULTIGEOMETRY;
    private static string COORDINATES;
    private static string OUTER_BOUNDARY_IS;
    private static string INNER_BOUNDARY_IS;
    private static string NO_ELEMENT_ERROR;
    public KMLReader(GeometryFactory geometryFactory);
    public KMLReader(String[] attributeNames);
    public KMLReader(GeometryFactory geometryFactory, String[] attributeNames);
    public Geometry Read(string kmlGeometrystring);
    public Geometry Read(TextReader kmlStreamReader);
    private Coordinate[] ParseKMLCoordinates(XmlReader xmlStreamReader);
    private KMLCoordinatesAndAttributes ParseKMLCoordinatesAndAttributes(XmlReader xmlStreamReader, string objectNodeName);
    private Geometry ParseKMLPoint(XmlReader xmlStreamReader);
    private Geometry ParseKMLLineString(XmlReader xmlStreamReader);
    private Geometry ParseKMLPolygon(XmlReader xmlStreamReader);
    private Geometry ParseKMLMultiGeometry(XmlReader xmlStreamReader);
    private Geometry ParseKML(XmlReader xmlStreamReader);
    private void MoveToElement(XmlReader xmlStreamReader, string elementName, string endElementName);
    private void RaiseParseError(string template, Object[] parameters);
    private static T[] PrepareTypedArray(List`1<Geometry> geometryList, Type geomClass);
}
public class NetTopologySuite.IO.KML.KMLWriter : object {
    public static string AltitudeModeClampToGround;
    public static string AltitudeModeRelativeToGround;
    public static string AltitudeModeAbsolute;
    private static int IndentSize;
    private static string CoordinateSeparator;
    private static string TupleSeparator;
    private string _linePrefix;
    private int _maxCoordinatesPerLine;
    private double _z;
    private bool _extrude;
    private bool _tesselate;
    private string _altitudeMode;
    private OrdinateFormat _ordinateFormat;
    private int _precision;
    public string LinePrefix { get; public set; }
    public int MaxCoordinatesPerLine { get; public set; }
    public double Z { get; public set; }
    public bool Extrude { get; public set; }
    public bool Tesselate { get; public set; }
    public string AltitudeMode { get; public set; }
    public int Precision { get; public set; }
    public static string WriteGeometry(Geometry geometry, double z);
    private void CreateDefaultFormatter();
    public static string WriteGeometry(Geometry geometry, double z, int precision, bool extrude, string altitudeMode);
    public string get_LinePrefix();
    public void set_LinePrefix(string value);
    public int get_MaxCoordinatesPerLine();
    public void set_MaxCoordinatesPerLine(int value);
    public double get_Z();
    public void set_Z(double value);
    public bool get_Extrude();
    public void set_Extrude(bool value);
    public bool get_Tesselate();
    public void set_Tesselate(bool value);
    public string get_AltitudeMode();
    public void set_AltitudeMode(string value);
    public int get_Precision();
    public void set_Precision(int value);
    private void CreateFormatter(int precision);
    public string Write(Geometry geom);
    public void Write(Geometry geom, TextWriter writer);
    public void Write(Geometry geom, StringBuilder sb);
    private void WriteGeometry(Geometry g, int level, StringBuilder sb);
    private void StartLine(string text, int level, StringBuilder sb);
    private string GeometryTag(string geometryName);
    private void WriteModifiers(int level, StringBuilder sb);
    private void WritePoint(Point p, int level, StringBuilder sb);
    private void WriteLineString(LineString ls, int level, StringBuilder sb);
    private void WriteLinearRing(LinearRing lr, int level, StringBuilder sb, bool writeModifiers);
    private void WritePolygon(Polygon p, int level, StringBuilder sb);
    private void WriteGeometryCollection(GeometryCollection gc, int level, StringBuilder sb);
    private void Write(Coordinate[] coords, int level, StringBuilder sb);
    private void Write(Coordinate p, StringBuilder sb);
    private void Write(double d, StringBuilder sb);
}
public class NetTopologySuite.IO.OrdinateFormat : object {
    internal static string REP_POS_INF;
    internal static string REP_NEG_INF;
    internal static string REP_NAN;
    private static int MAX_FRACTION_DIGITS;
    public static OrdinateFormat Default;
    private string _format;
    public OrdinateFormat(int maximumFractionDigits);
    private static OrdinateFormat();
    internal static NumberFormatInfo CreateFormat(int maximumFractionDigits);
    public string Format(double ord);
}
public class NetTopologySuite.IO.ParseException : ApplicationException {
    public ParseException(string message);
    public ParseException(Exception e);
    public ParseException(string message, Exception innerException);
}
public enum NetTopologySuite.IO.WKBGeometryTypes : Enum {
    public int value__;
    public static WKBGeometryTypes WKBPoint;
    public static WKBGeometryTypes WKBLineString;
    public static WKBGeometryTypes WKBPolygon;
    public static WKBGeometryTypes WKBMultiPoint;
    public static WKBGeometryTypes WKBMultiLineString;
    public static WKBGeometryTypes WKBMultiPolygon;
    public static WKBGeometryTypes WKBGeometryCollection;
    public static WKBGeometryTypes WKBPointZ;
    public static WKBGeometryTypes WKBLineStringZ;
    public static WKBGeometryTypes WKBPolygonZ;
    public static WKBGeometryTypes WKBMultiPointZ;
    public static WKBGeometryTypes WKBMultiLineStringZ;
    public static WKBGeometryTypes WKBMultiPolygonZ;
    public static WKBGeometryTypes WKBGeometryCollectionZ;
    public static WKBGeometryTypes WKBPointM;
    public static WKBGeometryTypes WKBLineStringM;
    public static WKBGeometryTypes WKBPolygonM;
    public static WKBGeometryTypes WKBMultiPointM;
    public static WKBGeometryTypes WKBMultiLineStringM;
    public static WKBGeometryTypes WKBMultiPolygonM;
    public static WKBGeometryTypes WKBGeometryCollectionM;
    public static WKBGeometryTypes WKBPointZM;
    public static WKBGeometryTypes WKBLineStringZM;
    public static WKBGeometryTypes WKBPolygonZM;
    public static WKBGeometryTypes WKBMultiPointZM;
    public static WKBGeometryTypes WKBMultiLineStringZM;
    public static WKBGeometryTypes WKBMultiPolygonZM;
    public static WKBGeometryTypes WKBGeometryCollectionZM;
}
public class NetTopologySuite.IO.WKBHexFileReader : object {
    private WKBReader _wkbReader;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Limit { get; public set; }
    public int Offset { get; public set; }
    public WKBHexFileReader(WKBReader wkbReader);
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    public ReadOnlyCollection`1<Geometry> Read(string file);
    public ReadOnlyCollection`1<Geometry> Read(Stream stream);
    private ReadOnlyCollection`1<Geometry> Read(StreamReader streamReader);
    private bool IsAtLimit(List`1<Geometry> geoms);
    private static bool IsAtEndOfFile(StreamReader bufferedReader);
}
public class NetTopologySuite.IO.WKBReader : object {
    private CoordinateSequenceFactory _sequenceFactory;
    private PrecisionModel _precisionModel;
    private NtsGeometryServices _geometryServices;
    private bool _isStrict;
    private int maxNumFieldValue;
    [CompilerGeneratedAttribute]
private bool <HandleSRID>k__BackingField;
    private Ordinates _handleOrdinates;
    public bool HandleSRID { get; public set; }
    public Ordinates AllowedOrdinates { get; }
    public Ordinates HandleOrdinates { get; public set; }
    public bool IsStrict { get; public set; }
    [ObsoleteAttribute("Use !IsStrict")]
public bool RepairRings { get; public set; }
    public WKBReader(NtsGeometryServices services);
    public static Byte[] HexToBytes(string hex);
    private static int HexToInt(char hex);
    public Geometry Read(Byte[] data);
    public virtual Geometry Read(Stream stream);
    protected Geometry Read(BinaryReader reader);
    private void ReadByteOrder(BinaryReader reader);
    private WKBGeometryTypes ReadGeometryType(BinaryReader reader, CoordinateSystem& coordinateSystem, Int32& srid);
    private int ReasonableNumPoints(Stream stream, CoordinateSystem cs);
    private int ReadNumField(BinaryReader reader, string fieldName, int reasonableNumField);
    protected CoordinateSequence ReadCoordinateSequence(BinaryReader reader, int size, CoordinateSystem cs);
    protected CoordinateSequence ReadCoordinateSequenceRing(BinaryReader reader, int size, CoordinateSystem cs);
    protected CoordinateSequence ReadCoordinateSequenceLineString(BinaryReader reader, int size, CoordinateSystem cs);
    private static Ordinates ToOrdinates(CoordinateSystem cs);
    protected Geometry ReadPoint(BinaryReader reader, CoordinateSystem cs, int srid);
    protected Geometry ReadLineString(BinaryReader reader, CoordinateSystem cs, int srid);
    protected LinearRing ReadLinearRing(BinaryReader reader, CoordinateSystem cs, int srid);
    protected Geometry ReadPolygon(BinaryReader reader, CoordinateSystem cs, int srid);
    protected Geometry ReadMultiPoint(BinaryReader reader, CoordinateSystem cs, int srid);
    protected Geometry ReadMultiLineString(BinaryReader reader, CoordinateSystem cs, int srid);
    protected Geometry ReadMultiPolygon(BinaryReader reader, CoordinateSystem cs, int srid);
    protected Geometry ReadGeometryCollection(BinaryReader reader, CoordinateSystem cs, int srid);
    [CompilerGeneratedAttribute]
public bool get_HandleSRID();
    [CompilerGeneratedAttribute]
public void set_HandleSRID(bool value);
    public Ordinates get_AllowedOrdinates();
    public Ordinates get_HandleOrdinates();
    public void set_HandleOrdinates(Ordinates value);
    public bool get_IsStrict();
    public void set_IsStrict(bool value);
    public bool get_RepairRings();
    public void set_RepairRings(bool value);
    private bool HandleOrdinate(Ordinate ordinate);
}
public class NetTopologySuite.IO.WKBWriter : object {
    [CompilerGeneratedAttribute]
private ByteOrder <EncodingType>k__BackingField;
    private int _coordinateSize;
    private bool _strict;
    private bool _handleSRID;
    public static Ordinates AllowedOrdinates;
    private Ordinates _handleOrdinates;
    public ByteOrder EncodingType { get; protected set; }
    [ObsoleteAttribute("Will be removed in a future version")]
protected int InitCount { get; }
    public bool Strict { get; public set; }
    public bool HandleSRID { get; public set; }
    public Ordinates HandleOrdinates { get; public set; }
    public WKBWriter(ByteOrder encodingType);
    public WKBWriter(ByteOrder encodingType, bool handleSRID);
    public WKBWriter(ByteOrder encodingType, bool handleSRID, bool emitZ);
    public WKBWriter(ByteOrder encodingType, bool handleSRID, bool emitZ, bool emitM);
    private static WKBWriter();
    public static string ToHex(Byte[] bytes);
    private static char ToHexDigit(int n);
    private void WriteHeader(BinaryWriter writer, Geometry geom, bool includeSRID);
    [CompilerGeneratedAttribute]
public ByteOrder get_EncodingType();
    [CompilerGeneratedAttribute]
protected void set_EncodingType(ByteOrder value);
    protected int get_InitCount();
    private int GetHeaderSize(bool includeSRID);
    public virtual Byte[] Write(Geometry geometry);
    public virtual void Write(Geometry geometry, Stream stream);
    protected void Write(Geometry geometry, BinaryWriter writer);
    private void Write(Geometry geometry, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be made private in a future version.")]
protected void WriteByteOrder(BinaryWriter writer);
    [ObsoleteAttribute("Will be removed in a future version")]
protected void Write(Coordinate coordinate, BinaryWriter writer);
    [ObsoleteAttribute("Will be made private in a future version.")]
protected void Write(CoordinateSequence sequence, bool emitSize, BinaryWriter writer);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(Point point, BinaryWriter writer);
    private void Write(Point point, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(LineString lineString, BinaryWriter writer);
    private void Write(LineString lineString, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(LinearRing ring, BinaryWriter writer);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(Polygon polygon, BinaryWriter writer);
    private void Write(Polygon polygon, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(MultiPoint multiPoint, BinaryWriter writer);
    private void Write(MultiPoint multiPoint, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(MultiLineString multiLineString, BinaryWriter writer);
    private void Write(MultiLineString multiLineString, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(MultiPolygon multiPolygon, BinaryWriter writer);
    private void Write(MultiPolygon multiPolygon, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected void Write(GeometryCollection geomCollection, BinaryWriter writer);
    private void Write(GeometryCollection geomCollection, BinaryWriter writer, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected Byte[] GetBytes(Geometry geometry);
    private Byte[] GetBuffer(Geometry geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected virtual int SetByteStream(Geometry geometry);
    private int GetRequiredBufferSize(Geometry geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected int SetByteStream(GeometryCollection geometry);
    private int GetRequiredBufferSize(GeometryCollection geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected int SetByteStream(MultiPolygon geometry);
    private int GetRequiredBufferSize(MultiPolygon geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected int SetByteStream(MultiLineString geometry);
    private int GetRequiredBufferSize(MultiLineString geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected int SetByteStream(MultiPoint geometry);
    private int GetRequiredBufferSize(MultiPoint geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected int SetByteStream(Polygon geometry);
    private int GetRequiredBufferSize(Polygon geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected int SetByteStream(LineString geometry);
    private int GetRequiredBufferSize(LineString geometry, bool includeSRID);
    [ObsoleteAttribute("Will be removed in a future version.")]
protected int SetByteStream(Point geometry);
    private int GetRequiredBufferSize(Point geometry, bool includeSRID);
    private void CalcCoordinateSize();
    public bool get_Strict();
    public void set_Strict(bool value);
    public bool get_HandleSRID();
    public void set_HandleSRID(bool value);
    public Ordinates get_HandleOrdinates();
    public void set_HandleOrdinates(Ordinates value);
    private static void WriteNaNs(int numNaNs, BinaryWriter writer);
}
public class NetTopologySuite.IO.WKTConstants : object {
    public static string GEOMETRYCOLLECTION;
    public static string LINEARRING;
    public static string LINESTRING;
    public static string MULTIPOLYGON;
    public static string MULTILINESTRING;
    public static string MULTIPOINT;
    public static string POINT;
    public static string POLYGON;
    public static string EMPTY;
    public static string M;
    public static string Z;
    public static string ZM;
}
public class NetTopologySuite.IO.WKTFileReader : object {
    private static int MaxLookahead;
    private FileInfo _file;
    private StreamReader _reader;
    private WKTReader _wktReader;
    private int _count;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictParsing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Limit { get; public set; }
    public bool StrictParsing { get; public set; }
    public int Offset { get; public set; }
    private WKTFileReader(WKTReader wktReader);
    public WKTFileReader(FileInfo file, WKTReader wktReader);
    public WKTFileReader(string filename, WKTReader wktReader);
    public WKTFileReader(Stream stream, WKTReader wktReader);
    public WKTFileReader(TextReader reader, WKTReader wktReader);
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    [CompilerGeneratedAttribute]
public bool get_StrictParsing();
    [CompilerGeneratedAttribute]
public void set_StrictParsing(bool value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    public IList`1<Geometry> Read();
    private IList`1<Geometry> Read(StreamReader bufferedReader);
    private void Read(StreamReader bufferedReader, ICollection`1<Geometry> geoms);
    private bool IsAtLimit(ICollection`1<Geometry> geoms);
    private static bool IsAtEndOfTokens(Token token);
    private bool IsAtEndOfFile(StreamReader bufferedReader);
}
public class NetTopologySuite.IO.WKTReader : object {
    private static CultureInfo InvariantCulture;
    private static CoordinateSequenceFactory CoordinateSequenceFactoryXYZM;
    private static StreamTokenizerSettings TokenizerSettings;
    private NtsGeometryServices _ntsGeometryServices;
    private Nullable`1<int> _overriddenDefaultSRID;
    private bool _isAllowOldNtsCoordinateSyntax;
    private bool _isAllowOldNtsMultipointSyntax;
    private bool _isStrict;
    [CompilerGeneratedAttribute]
private bool <FixStructure>k__BackingField;
    public bool IsOldNtsCoordinateSyntaxAllowed { get; public set; }
    public bool IsOldNtsMultiPointSyntaxAllowed { get; public set; }
    public bool FixStructure { get; public set; }
    [ObsoleteAttribute("Supply an appropriate NtsGeometryServices instance to the constructor instead.  The ability to set this value after an instance is created may be removed in a future release.")]
public GeometryFactory Factory { get; public set; }
    [ObsoleteAttribute("Supply an appropriate NtsGeometryServices instance to the constructor instead.  The ability to set this value after an instance is created may be removed in a future release.")]
public int DefaultSRID { get; public set; }
    public bool IsStrict { get; public set; }
    public WKTReader(NtsGeometryServices ntsGeometryServices);
    [ObsoleteAttribute("Use a constructor with a configured NtsGeometryServices instance.")]
public WKTReader(GeometryFactory factory);
    private static WKTReader();
    private static StreamTokenizerSettings CreateDefaultStreamTokenizerSettings();
    public bool get_IsOldNtsCoordinateSyntaxAllowed();
    public void set_IsOldNtsCoordinateSyntaxAllowed(bool value);
    public bool get_IsOldNtsMultiPointSyntaxAllowed();
    public void set_IsOldNtsMultiPointSyntaxAllowed(bool value);
    [CompilerGeneratedAttribute]
public bool get_FixStructure();
    [CompilerGeneratedAttribute]
public void set_FixStructure(bool value);
    public GeometryFactory get_Factory();
    public void set_Factory(GeometryFactory value);
    [CompilerGeneratedAttribute]
public int get_DefaultSRID();
    [CompilerGeneratedAttribute]
public void set_DefaultSRID(int value);
    public bool get_IsStrict();
    public void set_IsStrict(bool value);
    public Geometry Read(string wellKnownText);
    public Geometry Read(Stream stream);
    public Geometry Read(TextReader reader);
    internal TokenStream Tokenizer(TextReader reader);
    internal IList`1<Token> Tokenize(TextReader reader);
    private Coordinate GetCoordinate(GeometryFactory factory, TokenStream tokens, Ordinates ordinateFlags, bool tryParen);
    private CoordinateSequence GetCoordinateSequence(GeometryFactory factory, TokenStream tokens, Ordinates ordinateFlags, int minSize, bool isRing);
    private static void DoFixStructure(List`1<Coordinate> coords, int minSize, bool isRing);
    private static bool IsClosed(List`1<Coordinate> coords);
    private CoordinateSequence CreateCoordinateSequenceEmpty(CoordinateSequenceFactory csFactory, Ordinates ordinateFlags);
    private CoordinateSequence GetCoordinateSequenceOldMultiPoint(GeometryFactory factory, TokenStream tokens, Ordinates ordinateFlags);
    private int ToDimension(Ordinates ordinateFlags);
    private static bool IsNumberNext(TokenStream tokens);
    private static bool IsOpenerNext(TokenStream tokens);
    private static double GetNextNumber(TokenStream tokens);
    private static string GetNextEmptyOrOpener(TokenStream tokens);
    private static Ordinates GetNextOrdinateFlags(TokenStream tokens);
    private static string LookAheadWord(TokenStream tokens);
    private static string GetNextCloserOrComma(TokenStream tokens);
    private static string GetNextCloser(TokenStream tokens);
    private static string GetNextWord(TokenStream tokens, bool advance);
    internal Geometry ReadGeometryTaggedText(TokenStream tokens);
    private static bool IsTypeName(TokenStream tokens, string type, string typeName);
    private Point ReadPointText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
    private LineString ReadLineStringText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
    private LinearRing ReadLinearRingText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
    private MultiPoint ReadMultiPointText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
    private Polygon ReadPolygonText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
    private MultiLineString ReadMultiLineStringText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
    private MultiPolygon ReadMultiPolygonText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
    private GeometryCollection ReadGeometryCollectionText(TokenStream tokens, GeometryFactory factory, Ordinates ordinateFlags);
}
public class NetTopologySuite.IO.WKTWriter : object {
    private Ordinates _outputOrdinates;
    private int _outputDimension;
    private PrecisionModel _precisionModel;
    private bool _isFormatted;
    private int _coordsPerLine;
    private string _indentTabStr;
    private bool _skipOrdinateToken;
    private bool _alwaysEmitZWithM;
    private string _missingOrdinateReplacementText;
    public bool Formatted { get; public set; }
    public int MaxCoordinatesPerLine { get; public set; }
    public int Tab { get; public set; }
    public Ordinates OutputOrdinates { get; public set; }
    public PrecisionModel PrecisionModel { get; public set; }
    public WKTWriter(int outputDimension);
    private WKTWriter(int outputDimension, bool mssql);
    public static string ToPoint(Coordinate p0);
    public static string ToLineString(CoordinateSequence seq);
    public static string ToLineString(Coordinate[] coord);
    public static string ToLineString(Coordinate p0, Coordinate p1);
    internal static string Format(Coordinate p);
    internal static string Format(double x, double y);
    [ObsoleteAttribute("Use CreateOrdinateFormat")]
internal static NumberFormatInfo CreateFormatter(PrecisionModel precisionModel);
    internal static OrdinateFormat CreateOrdinateFormat(PrecisionModel precisionModel);
    public bool get_Formatted();
    public void set_Formatted(bool value);
    public int get_MaxCoordinatesPerLine();
    public void set_MaxCoordinatesPerLine(int value);
    public int get_Tab();
    public void set_Tab(int value);
    public Ordinates get_OutputOrdinates();
    public void set_OutputOrdinates(Ordinates value);
    public PrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(PrecisionModel value);
    public static WKTWriter ForMicrosoftSqlServer();
    public virtual string Write(Geometry geometry);
    public void Write(Geometry geometry, Stream stream);
    public virtual void Write(Geometry geometry, TextWriter writer);
    public virtual string WriteFormatted(Geometry geometry);
    public virtual void WriteFormatted(Geometry geometry, TextWriter writer);
    private void WriteFormatted(Geometry geometry, bool useFormatting, TextWriter writer, PrecisionModel precisionModel);
    private void AppendGeometryTaggedText(Geometry geometry, bool useFormatting, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendGeometryTaggedText(Geometry geometry, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendPointTaggedText(Point point, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendLineStringTaggedText(LineString lineString, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendLinearRingTaggedText(LinearRing linearRing, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendPolygonTaggedText(Polygon polygon, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendMultiPointTaggedText(MultiPoint multipoint, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendMultiLineStringTaggedText(MultiLineString multiLineString, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendMultiPolygonTaggedText(MultiPolygon multiPolygon, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendGeometryCollectionTaggedText(GeometryCollection geometryCollection, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendCoordinate(CoordinateSequence seq, Ordinates outputOrdinates, int i, TextWriter writer, OrdinateFormat ordinateFormat);
    private static string WriteNumber(double d, OrdinateFormat ordinateFormat);
    private void AppendOrdinateText(Ordinates outputOrdinates, TextWriter writer);
    private void AppendSequenceText(CoordinateSequence seq, Ordinates outputOrdinates, bool useFormatting, int level, bool indentFirst, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendPolygonText(Polygon polygon, Ordinates outputOrdinates, bool useFormatting, int level, bool indentFirst, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendMultiPointText(MultiPoint multiPoint, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendMultiLineStringText(MultiLineString multiLineString, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendMultiPolygonText(MultiPolygon multiPolygon, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void AppendGeometryCollectionText(GeometryCollection geometryCollection, Ordinates outputOrdinates, bool useFormatting, int level, TextWriter writer, OrdinateFormat ordinateFormat);
    private void IndentCoords(bool useFormatting, int coordIndex, int level, TextWriter writer);
    private void Indent(bool useFormatting, int level, TextWriter writer);
}
public class NetTopologySuite.LinearReferencing.ExtractLineByLocation : object {
    private Geometry _line;
    public ExtractLineByLocation(Geometry line);
    public static Geometry Extract(Geometry line, LinearLocation start, LinearLocation end);
    public Geometry Extract(LinearLocation start, LinearLocation end);
    private static Geometry Reverse(Geometry linear);
    private Geometry ComputeLinear(LinearLocation start, LinearLocation end);
}
public class NetTopologySuite.LinearReferencing.LengthIndexedLine : object {
    private Geometry _linearGeom;
    public double StartIndex { get; }
    public double EndIndex { get; }
    public LengthIndexedLine(Geometry linearGeom);
    public Coordinate ExtractPoint(double index);
    public Coordinate ExtractPoint(double index, double offsetDistance);
    public Geometry ExtractLine(double startIndex, double endIndex);
    private LinearLocation LocationOf(double index);
    private LinearLocation LocationOf(double index, bool resolveLower);
    public double IndexOf(Coordinate pt);
    public double IndexOfAfter(Coordinate pt, double minIndex);
    public Double[] IndicesOf(Geometry subLine);
    public double Project(Coordinate pt);
    public double get_StartIndex();
    public double get_EndIndex();
    public bool IsValidIndex(double index);
    public double ClampIndex(double index);
    private double PositiveIndex(double index);
}
public class NetTopologySuite.LinearReferencing.LengthIndexOfPoint : object {
    private Geometry _linearGeom;
    public LengthIndexOfPoint(Geometry linearGeom);
    public static double IndexOf(Geometry linearGeom, Coordinate inputPt);
    public static double IndexOfAfter(Geometry linearGeom, Coordinate inputPt, double minIndex);
    public double IndexOf(Coordinate inputPt);
    public double IndexOfAfter(Coordinate inputPt, double minIndex);
    private double IndexOfFromStart(Coordinate inputPt, double minIndex);
    private static double SegmentNearestMeasure(LineSegment seg, Coordinate inputPt, double segmentStartMeasure);
}
public class NetTopologySuite.LinearReferencing.LengthLocationMap : object {
    private Geometry _linearGeom;
    public LengthLocationMap(Geometry linearGeom);
    public static LinearLocation GetLocation(Geometry linearGeom, double length);
    public static LinearLocation GetLocation(Geometry linearGeom, double length, bool resolveLower);
    public static double GetLength(Geometry linearGeom, LinearLocation loc);
    public LinearLocation GetLocation(double length);
    public LinearLocation GetLocation(double length, bool resolveLower);
    private LinearLocation GetLocationForward(double length);
    private LinearLocation ResolveHigher(LinearLocation loc);
    public double GetLength(LinearLocation loc);
}
public class NetTopologySuite.LinearReferencing.LinearGeometryBuilder : object {
    private GeometryFactory _geomFact;
    private List`1<Geometry> _lines;
    private CoordinateList _coordList;
    private Coordinate _lastPt;
    [CompilerGeneratedAttribute]
private bool <FixInvalidLines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreInvalidLines>k__BackingField;
    public bool FixInvalidLines { get; public set; }
    public bool IgnoreInvalidLines { get; public set; }
    public Coordinate LastCoordinate { get; }
    public LinearGeometryBuilder(GeometryFactory geomFact);
    [CompilerGeneratedAttribute]
public bool get_FixInvalidLines();
    [CompilerGeneratedAttribute]
public void set_FixInvalidLines(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreInvalidLines();
    [CompilerGeneratedAttribute]
public void set_IgnoreInvalidLines(bool value);
    public void Add(Coordinate pt);
    public void Add(Coordinate pt, bool allowRepeatedPoints);
    public Coordinate get_LastCoordinate();
    public void EndLine();
    private static Coordinate[] ValidCoordinateSequence(Coordinate[] pts);
    public Geometry GetGeometry();
}
public class NetTopologySuite.LinearReferencing.LinearIterator : object {
    private Geometry _linearGeom;
    private int _numLines;
    private LineString _currentLine;
    private int _componentIndex;
    private int _vertexIndex;
    public bool IsEndOfLine { get; }
    public int ComponentIndex { get; }
    public int VertexIndex { get; }
    public LineString Line { get; }
    public Coordinate SegmentStart { get; }
    public Coordinate SegmentEnd { get; }
    public LinearIterator(Geometry linearGeom);
    public LinearIterator(Geometry linearGeom, LinearLocation start);
    public LinearIterator(Geometry linearGeom, int componentIndex, int vertexIndex);
    public static int SegmentEndVertexIndex(LinearLocation loc);
    private void LoadCurrentLine();
    public bool HasNext();
    public void Next();
    public bool get_IsEndOfLine();
    public int get_ComponentIndex();
    public int get_VertexIndex();
    public LineString get_Line();
    public Coordinate get_SegmentStart();
    public Coordinate get_SegmentEnd();
}
public class NetTopologySuite.LinearReferencing.LinearLocation : object {
    private int _componentIndex;
    private int _segmentIndex;
    private double _segmentFraction;
    public int ComponentIndex { get; }
    public int SegmentIndex { get; }
    public double SegmentFraction { get; }
    public bool IsVertex { get; }
    public LinearLocation(int segmentIndex, double segmentFraction);
    public LinearLocation(int componentIndex, int segmentIndex, double segmentFraction);
    private LinearLocation(int componentIndex, int segmentIndex, double segmentFraction, bool normalize);
    public LinearLocation(LinearLocation loc);
    public static LinearLocation GetEndLocation(Geometry linear);
    public static Coordinate PointAlongSegmentByFraction(Coordinate p0, Coordinate p1, double fraction);
    private void Normalize();
    public void Clamp(Geometry linear);
    public void SnapToVertex(Geometry linearGeom, double minDistance);
    public double GetSegmentLength(Geometry linearGeom);
    public void SetToEnd(Geometry linear);
    public int get_ComponentIndex();
    public int get_SegmentIndex();
    public double get_SegmentFraction();
    public bool get_IsVertex();
    public Coordinate GetCoordinate(Geometry linearGeom);
    public LineSegment GetSegment(Geometry linearGeom);
    public bool IsValid(Geometry linearGeom);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LinearLocation other);
    public int CompareLocationValues(int componentIndex1, int segmentIndex1, double segmentFraction1);
    public static int CompareLocationValues(int componentIndex0, int segmentIndex0, double segmentFraction0, int componentIndex1, int segmentIndex1, double segmentFraction1);
    public bool IsOnSameSegment(LinearLocation loc);
    public bool IsEndpoint(Geometry linearGeom);
    public LinearLocation ToLowest(Geometry linearGeom);
    public LinearLocation Copy();
    public virtual string ToString();
    private static int NumSegments(LineString line);
}
public class NetTopologySuite.LinearReferencing.LocationIndexedLine : object {
    private Geometry _linearGeom;
    public LinearLocation StartIndex { get; }
    public LinearLocation EndIndex { get; }
    public LocationIndexedLine(Geometry linearGeom);
    private static bool CheckGeometryType(Geometry linearGeometry);
    public Coordinate ExtractPoint(LinearLocation index);
    public Coordinate ExtractPoint(LinearLocation index, double offsetDistance);
    public Coordinate ExtractPoint(double index, double offsetDistance);
    public Geometry ExtractLine(LinearLocation startIndex, LinearLocation endIndex);
    public LinearLocation IndexOf(Coordinate pt);
    public LinearLocation[] IndicesOf(Geometry subLine);
    public LinearLocation IndexOfAfter(Coordinate pt, LinearLocation minIndex);
    public LinearLocation Project(Coordinate pt);
    public LinearLocation get_StartIndex();
    public LinearLocation get_EndIndex();
    public bool IsValidIndex(LinearLocation index);
    public LinearLocation ClampIndex(LinearLocation index);
}
public class NetTopologySuite.LinearReferencing.LocationIndexOfLine : object {
    private Geometry _linearGeom;
    public LocationIndexOfLine(Geometry linearGeom);
    public static LinearLocation[] IndicesOf(Geometry linearGeom, Geometry subLine);
    public virtual LinearLocation[] IndicesOf(Geometry subLine);
}
public class NetTopologySuite.LinearReferencing.LocationIndexOfPoint : object {
    private Geometry _linearGeom;
    public LocationIndexOfPoint(Geometry linearGeom);
    public static LinearLocation IndexOf(Geometry linearGeom, Coordinate inputPt);
    public static LinearLocation IndexOfAfter(Geometry linearGeom, Coordinate inputPt, LinearLocation minIndex);
    public LinearLocation IndexOf(Coordinate inputPt);
    public LinearLocation IndexOfAfter(Coordinate inputPt, LinearLocation minIndex);
    private LinearLocation IndexOfFromStart(Coordinate inputPt, LinearLocation minIndex);
}
public class NetTopologySuite.Mathematics.DD : ValueType {
    public static DD PI;
    public static DD TwoPi;
    public static DD PiHalf;
    public static DD E;
    public static DD NaN;
    public static double Epsilon;
    private static double Split;
    private double _hi;
    private double _lo;
    private static int MaxPrintDigits;
    private static DD Ten;
    private static DD One;
    private static string SciNotExponentChar;
    private static string SciNotZero;
    public bool IsZero { get; }
    public bool IsNegative { get; }
    public DD(double x);
    public DD(double hi, double lo);
    public DD(DD dd);
    public DD(string str);
    private static DD();
    private static DD CreateNaN();
    public static DD ValueOf(string str);
    public static DD op_Explicit(string val);
    public static DD ValueOf(double x);
    public static DD op_Implicit(double val);
    public static DD Copy(DD dd);
    public object Clone();
    public static DD op_Addition(DD lhs, DD rhs);
    public static DD op_Addition(DD lhs, double rhs);
    public static DD op_Subtraction(DD lhs, DD rhs);
    public static DD op_Subtraction(DD lhs, double rhs);
    public static DD op_UnaryNegation(DD val);
    public static DD op_Multiply(DD lhs, double rhs);
    public static DD op_Multiply(DD lhs, DD rhs);
    public static DD op_Division(DD lhs, double rhs);
    public static DD op_Division(DD lhs, DD rhs);
    public DD Reciprocal();
    public static DD Determinant(double x1, double y1, double x2, double y2);
    public static DD Determinant(DD x1, DD y1, DD x2, DD y2);
    public DD Min(DD x);
    public DD Max(DD x);
    public DD Floor();
    public DD Ceiling();
    public int Signum();
    public DD Rint();
    public DD Truncate();
    public DD Abs();
    public DD Sqr();
    public static DD Sqr(double x);
    public DD Sqrt();
    public static DD Sqrt(double x);
    public DD Pow(int exp);
    public double ToDoubleValue();
    public int ToIntValue();
    public bool get_IsZero();
    public bool get_IsNegative();
    public bool IsPositive();
    public static bool IsNaN(DD value);
    public static bool IsInfinity(DD value);
    public bool Equals(DD y);
    public static bool op_Equality(DD lhs, DD rhs);
    public static bool op_Inequality(DD rhs, DD lhs);
    public bool GreaterThan(DD y);
    public bool GreaterOrEqualThan(DD y);
    public bool LessThan(DD y);
    public bool LessOrEqualThan(DD y);
    public sealed virtual int CompareTo(DD other);
    public sealed virtual int CompareTo(object o);
    public string Dump();
    public virtual string ToString();
    public string ToStandardNotation();
    public string ToSciNotation();
    private string ExtractSignificantDigits(bool insertDecimalPoint, Int32[] magnitudes);
    private string GetSpecialNumberString();
    private static int Magnitude(double x);
    public static DD Parse(string str);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NetTopologySuite.Mathematics.MathUtil : object {
    private static double LOG10;
    public static double PhiInv;
    private static MathUtil();
    public static double Clamp(double x, double min, double max);
    public static int Clamp(int x, int min, int max);
    public static int ClampMax(int x, int max);
    public static int Ceiling(int num, int denom);
    public static double Log10(double x);
    public static int Wrap(int index, int max);
    public static double Average(double x1, double x2);
    public static double Max(double v1, double v2, double v3);
    public static double Max(double v1, double v2, double v3, double v4);
    public static double Min(double v1, double v2, double v3);
    public static double Min(double v1, double v2, double v3, double v4);
    public static double QuasiRandom(double curr);
    public static double QuasiRandom(double curr, double alpha);
}
public class NetTopologySuite.Mathematics.Matrix : object {
    private static void SwapRows(Double[][] m, int i, int j);
    private static void SwapRows(Double[] m, int i, int j);
    public static Double[] Solve(Double[][] a, Double[] b);
}
public enum NetTopologySuite.Mathematics.Plane : Enum {
    public int value__;
    public static Plane Undefined;
    public static Plane XY;
    public static Plane YZ;
    public static Plane XZ;
}
public class NetTopologySuite.Mathematics.Plane3D : object {
    private Vector3D _normal;
    private Coordinate _basePt;
    public Plane3D(Vector3D normal, Coordinate basePt);
    public double OrientedDistance(Coordinate p);
    public Plane ClosestAxisPlane();
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Mathematics.Vector2D : object {
    private double _x;
    private double _y;
    public static Vector2D Zero { get; }
    public double X { get; }
    public double Y { get; }
    public double Item { get; }
    public Vector2D(double x, double y);
    public Vector2D(Vector2D v);
    public Vector2D(Coordinate from, Coordinate to);
    public Vector2D(Coordinate v);
    public static Vector2D get_Zero();
    public static Vector2D Create(double x, double y);
    public static Vector2D Create(Vector2D v);
    public static Vector2D Create(Coordinate coord);
    public static Vector2D Create(Coordinate from, Coordinate to);
    public double get_X();
    public double get_Y();
    public double get_Item(int index);
    public Vector2D Add(Vector2D v);
    public Vector2D Subtract(Vector2D v);
    public Vector2D Multiply(double d);
    public Vector2D Divide(double d);
    public Vector2D Negate();
    public double Length();
    public double LengthSquared();
    public Vector2D Normalize();
    public Vector2D Average(Vector2D v);
    public Vector2D WeightedSum(Vector2D v, double frac);
    public double Distance(Vector2D v);
    public double Dot(Vector2D v);
    public double Angle();
    public double Angle(Vector2D v);
    public double AngleTo(Vector2D v);
    public Vector2D Rotate(double angle);
    public Vector2D RotateByQuarterCircle(int numQuarters);
    public bool IsParallel(Vector2D v);
    public Coordinate Translate(Coordinate coord);
    public Coordinate ToCoordinate();
    public sealed virtual object Clone();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Vector2D op_Addition(Vector2D left, Vector2D right);
    public static Vector2D op_Multiply(Vector2D left, Vector2D right);
    public static Vector2D op_Subtraction(Vector2D left, Vector2D right);
    public static Vector2D op_UnaryNegation(Vector2D value);
    public static Vector2D op_Multiply(double scale, Vector2D value);
    public static Vector2D op_Multiply(Vector2D value, double scale);
    public static Vector2D op_Division(Vector2D value, double scale);
    public static Vector2D op_Division(Vector2D value, Vector2D scale);
    public static bool op_Equality(Vector2D left, Vector2D right);
    public static bool op_Inequality(Vector2D left, Vector2D right);
}
public class NetTopologySuite.Mathematics.Vector3D : object {
    private double _x;
    private double _y;
    private double _z;
    public static Vector3D Zero { get; }
    public double X { get; }
    public double Y { get; }
    public double Z { get; }
    public Vector3D(Coordinate coord);
    public Vector3D(Coordinate from, Coordinate to);
    public Vector3D(double x, double y, double z);
    public Vector3D(Vector2D value, double z);
    public static Vector3D get_Zero();
    public static double Dot(Coordinate A, Coordinate B, Coordinate C, Coordinate D);
    public static Vector3D Cross(Vector3D left, Vector3D right);
    public static Vector3D Create(double x, double y, double z);
    public static Vector3D Create(Coordinate coord);
    public static double Dot(Coordinate v1, Coordinate v2);
    public double get_X();
    public double get_Y();
    public double get_Z();
    public Vector3D Add(Vector3D v);
    public Vector3D Subtract(Vector3D v);
    public Vector3D Divide(double d);
    public double Dot(Vector3D v);
    public Vector3D Cross(Vector3D v);
    public double Length();
    public static double Length(Coordinate v);
    public Vector3D Normalize();
    public static Coordinate Normalize(Coordinate v);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Vector3D op_Addition(Vector3D left, Vector3D right);
    public static Vector3D op_Multiply(Vector3D left, Vector3D right);
    public static Vector3D op_UnaryPlus(Vector3D value);
    public static Vector3D op_Subtraction(Vector3D left, Vector3D right);
    public static Vector3D op_UnaryNegation(Vector3D value);
    public static Vector3D op_Multiply(double scale, Vector3D value);
    public static Vector3D op_Multiply(Vector3D value, double scale);
    public static Vector3D op_Division(Vector3D value, double scale);
    public static Vector3D op_Division(Vector3D value, Vector3D scale);
    public static bool op_Equality(Vector3D left, Vector3D right);
    public static bool op_Inequality(Vector3D left, Vector3D right);
}
public static class NetTopologySuite.Mathematics.VectorMath : object {
    public static Coordinate NormalToTriangle(Coordinate p0, Coordinate p1, Coordinate p2);
    public static void Normalize(Coordinate v);
    public static Coordinate CrossProduct(Coordinate v1, Coordinate v2);
    public static double DotProduct(Coordinate v1, Coordinate v2);
    public static double Det(double a1, double a2, double b1, double b2);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Noding.BasicSegmentString : object {
    private Coordinate[] _pts;
    [CompilerGeneratedAttribute]
private object <Context>k__BackingField;
    public object Context { get; public set; }
    public Coordinate[] Coordinates { get; }
    public bool IsClosed { get; }
    public int Count { get; }
    public LineSegment Item { get; public set; }
    public BasicSegmentString(Coordinate[] pts, object data);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(object value);
    public sealed virtual Coordinate[] get_Coordinates();
    public sealed virtual bool get_IsClosed();
    public sealed virtual int get_Count();
    public Octants GetSegmentOctant(int index);
    public sealed virtual LineSegment get_Item(int index);
    public sealed virtual void set_Item(int index, LineSegment value);
    public virtual string ToString();
}
public class NetTopologySuite.Noding.BoundaryChainNoder : object {
    private List`1<ISegmentString> _chainList;
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    private static void AddSegments(ICollection`1<ISegmentString> segStrings, HashSet`1<Segment> segSet, BoundarySegmentMap[] includedSegs);
    private static void AddSegments(ISegmentString segString, BoundarySegmentMap segInclude, HashSet`1<Segment> segSet);
    private static void MarkBoundarySegments(HashSet`1<Segment> segSet);
    private static List`1<ISegmentString> ExtractChains(BoundarySegmentMap[] sections);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.Noding.BoundarySegmentNoder : object {
    private List`1<ISegmentString> _segList;
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    private static void AddSegments(IEnumerable`1<ISegmentString> segStrings, HashSet`1<Segment> segSet);
    private static void AddSegments(ISegmentString segString, HashSet`1<Segment> segSet);
    private static List`1<ISegmentString> ExtractSegments(HashSet`1<Segment> segSet);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.Noding.FastNodingValidator : object {
    private LineIntersector _li;
    private List`1<ISegmentString> _segStrings;
    private NodingIntersectionFinder _segInt;
    private bool _isValid;
    [CompilerGeneratedAttribute]
private bool <FindAllIntersections>k__BackingField;
    public bool FindAllIntersections { get; public set; }
    public IList`1<Coordinate> Intersections { get; }
    public bool IsValid { get; }
    public FastNodingValidator(IEnumerable`1<ISegmentString> segStrings);
    public static IList`1<Coordinate> ComputeIntersections(IEnumerable`1<ISegmentString> segStrings);
    [CompilerGeneratedAttribute]
public bool get_FindAllIntersections();
    [CompilerGeneratedAttribute]
public void set_FindAllIntersections(bool value);
    public IList`1<Coordinate> get_Intersections();
    public bool get_IsValid();
    public string GetErrorMessage();
    public void CheckValid();
    private void Execute();
    private void CheckInteriorIntersections();
}
public class NetTopologySuite.Noding.FastSegmentSetIntersectionFinder : object {
    private ISegmentSetMutualIntersector _segSetMutInt;
    public ISegmentSetMutualIntersector SegmentSetIntersector { get; }
    public FastSegmentSetIntersectionFinder(IEnumerable`1<ISegmentString> baseSegStrings);
    public ISegmentSetMutualIntersector get_SegmentSetIntersector();
    public bool Intersects(IList`1<ISegmentString> segStrings);
    public bool Intersects(IList`1<ISegmentString> segStrings, SegmentIntersectionDetector intDetector);
}
public interface NetTopologySuite.Noding.INodableSegmentString {
    public abstract virtual void AddIntersection(Coordinate intPt, int segmentIndex);
}
public interface NetTopologySuite.Noding.INoder {
    public abstract virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    public abstract virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.Noding.InteriorIntersectionFinderAdder : object {
    private LineIntersector _li;
    private IList`1<Coordinate> _interiorIntersections;
    public IList`1<Coordinate> InteriorIntersections { get; }
    public bool IsDone { get; }
    public InteriorIntersectionFinderAdder(LineIntersector li);
    public IList`1<Coordinate> get_InteriorIntersections();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
public class NetTopologySuite.Noding.IntersectionAdder : object {
    private bool _hasIntersection;
    private bool _hasProper;
    private bool _hasProperInterior;
    private bool _hasInterior;
    private Coordinate _properIntersectionPoint;
    private LineIntersector _li;
    public int NumIntersections;
    public int NumInteriorIntersections;
    public int NumProperIntersections;
    public int NumTests;
    public LineIntersector LineIntersector { get; }
    public Coordinate ProperIntersectionPoint { get; }
    public bool HasIntersection { get; }
    public bool HasProperIntersection { get; }
    public bool HasProperInteriorIntersection { get; }
    public bool HasInteriorIntersection { get; }
    public bool IsDone { get; }
    public IntersectionAdder(LineIntersector li);
    public static bool IsAdjacentSegments(int i1, int i2);
    public LineIntersector get_LineIntersector();
    public Coordinate get_ProperIntersectionPoint();
    public bool get_HasIntersection();
    public bool get_HasProperIntersection();
    public bool get_HasProperInteriorIntersection();
    public bool get_HasInteriorIntersection();
    private bool IsTrivialIntersection(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
public interface NetTopologySuite.Noding.ISegmentIntersector {
    public bool IsDone { get; }
    public abstract virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public abstract virtual bool get_IsDone();
}
public interface NetTopologySuite.Noding.ISegmentSetMutualIntersector {
    public abstract virtual void Process(IEnumerable`1<ISegmentString> segmentStrings, ISegmentIntersector segmentIntersector);
}
[DefaultMemberAttribute("Item")]
public interface NetTopologySuite.Noding.ISegmentString {
    public object Context { get; public set; }
    public Coordinate[] Coordinates { get; }
    public int Count { get; }
    public bool IsClosed { get; }
    public LineSegment Item { get; public set; }
    public abstract virtual object get_Context();
    public abstract virtual void set_Context(object value);
    public abstract virtual Coordinate[] get_Coordinates();
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsClosed();
    public abstract virtual LineSegment get_Item(int index);
    public abstract virtual void set_Item(int index, LineSegment value);
}
public class NetTopologySuite.Noding.IteratedNoder : object {
    public static int MaxIterations;
    private LineIntersector _li;
    private IList`1<ISegmentString> _nodedSegStrings;
    private int _maxIter;
    public int MaximumIterations { get; public set; }
    public IteratedNoder(PrecisionModel pm);
    public int get_MaximumIterations();
    public void set_MaximumIterations(int value);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    private void Node(IList`1<ISegmentString> segStrings, Int32[] numInteriorIntersections);
}
public class NetTopologySuite.Noding.MCIndexNoder : SinglePassNoder {
    private List`1<MonotoneChain> _monoChains;
    private ISpatialIndex`1<MonotoneChain> _index;
    private int _idCounter;
    private IList`1<ISegmentString> _nodedSegStrings;
    private int _nOverlaps;
    private double _overlapTolerance;
    public IList`1<MonotoneChain> MonotoneChains { get; }
    public ISpatialIndex`1<MonotoneChain> Index { get; }
    public MCIndexNoder(ISegmentIntersector si);
    public MCIndexNoder(ISegmentIntersector si, double overlapTolerance);
    public IList`1<MonotoneChain> get_MonotoneChains();
    public ISpatialIndex`1<MonotoneChain> get_Index();
    public virtual IList`1<ISegmentString> GetNodedSubstrings();
    public virtual void ComputeNodes(IList`1<ISegmentString> inputSegStrings);
    private void IntersectChains();
    private void Add(ISegmentString segStr);
}
public class NetTopologySuite.Noding.MCIndexSegmentSetMutualIntersector : object {
    private STRtree`1<MonotoneChain> _index;
    public ISpatialIndex`1<MonotoneChain> Index { get; }
    public MCIndexSegmentSetMutualIntersector(IEnumerable`1<ISegmentString> baseSegStrings);
    public ISpatialIndex`1<MonotoneChain> get_Index();
    private void InitBaseSegments(IEnumerable`1<ISegmentString> segStrings);
    private void AddToIndex(ISegmentString segStr);
    public sealed virtual void Process(IEnumerable`1<ISegmentString> segStrings, ISegmentIntersector segInt);
    private static void AddToMonoChains(ISegmentString segStr, List`1<MonotoneChain> monotoneChains);
    private void IntersectChains(List`1<MonotoneChain> monoChains, ISegmentIntersector segmentIntersector);
}
[DefaultMemberAttribute("Item")]
public class NetTopologySuite.Noding.NodedSegmentString : object {
    private SegmentNodeList _nodeList;
    private Coordinate[] _pts;
    [CompilerGeneratedAttribute]
private object <Context>k__BackingField;
    public object Context { get; public set; }
    public SegmentNodeList NodeList { get; }
    public int Count { get; }
    public Coordinate[] Coordinates { get; }
    public Coordinate[] NodedCoordinates { get; }
    public bool IsClosed { get; }
    public LineSegment Item { get; public set; }
    public NodedSegmentString(Coordinate[] pts, object context);
    public NodedSegmentString(ISegmentString ss);
    public static ReadOnlyCollection`1<ISegmentString> GetNodedSubstrings(IEnumerable`1<ISegmentString> segStrings);
    public static void GetNodedSubstrings(IEnumerable`1<ISegmentString> segStrings, ICollection`1<ISegmentString> resultEdgelist);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(object value);
    public SegmentNodeList get_NodeList();
    public sealed virtual int get_Count();
    public Coordinate GetCoordinate(int i);
    public sealed virtual Coordinate[] get_Coordinates();
    public Coordinate[] get_NodedCoordinates();
    public sealed virtual bool get_IsClosed();
    public Octants GetSegmentOctant(int index);
    private static Octants SafeOctant(Coordinate p0, Coordinate p1);
    public void AddIntersections(LineIntersector li, int segmentIndex, int geomIndex);
    public void AddIntersection(LineIntersector li, int segmentIndex, int geomIndex, int intIndex);
    public sealed virtual void AddIntersection(Coordinate intPt, int segmentIndex);
    public sealed virtual LineSegment get_Item(int index);
    public sealed virtual void set_Item(int index, LineSegment value);
    public virtual string ToString();
}
internal class NetTopologySuite.Noding.NodeVertexIterator : object {
    private SegmentNodeList _nodeList;
    private ISegmentString _edge;
    private IEnumerator`1<object> _nodeIt;
    private SegmentNode _currNode;
    private SegmentNode _nextNode;
    private int _currSegIndex;
    public object Current { get; }
    private NodeVertexIterator(SegmentNodeList nodeList);
    public sealed virtual void Dispose();
    private void ReadNextNode();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class NetTopologySuite.Noding.NodingIntersectionFinder : object {
    private LineIntersector _li;
    private Coordinate _interiorIntersection;
    private Coordinate[] _intSegments;
    private List`1<Coordinate> _intersections;
    private int intersectionCount;
    private bool _keepIntersections;
    [CompilerGeneratedAttribute]
private bool <FindAllIntersections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InteriorIntersectionsOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckEndSegmentsOnly>k__BackingField;
    public bool FindAllIntersections { get; public set; }
    public bool InteriorIntersectionsOnly { get; public set; }
    public bool KeepIntersections { get; public set; }
    public bool CheckEndSegmentsOnly { get; public set; }
    public bool HasIntersection { get; }
    public ReadOnlyCollection`1<Coordinate> Intersections { get; }
    public int Count { get; }
    [ObsoleteAttribute("Renamed to just Intersection")]
public Coordinate InteriorIntersection { get; }
    public Coordinate Intersection { get; }
    public Coordinate[] IntersectionSegments { get; }
    public bool IsDone { get; }
    public NodingIntersectionFinder(LineIntersector li);
    public static NodingIntersectionFinder CreateAnyIntersectionFinder(LineIntersector li);
    public static NodingIntersectionFinder CreateAllIntersectionsFinder(LineIntersector li);
    public static NodingIntersectionFinder CreateInteriorIntersectionsFinder(LineIntersector li);
    public static NodingIntersectionFinder CreateIntersectionCounter(LineIntersector li);
    public static NodingIntersectionFinder CreateInteriorIntersectionCounter(LineIntersector li);
    [CompilerGeneratedAttribute]
public bool get_FindAllIntersections();
    [CompilerGeneratedAttribute]
public void set_FindAllIntersections(bool value);
    [CompilerGeneratedAttribute]
public bool get_InteriorIntersectionsOnly();
    [CompilerGeneratedAttribute]
public void set_InteriorIntersectionsOnly(bool value);
    public bool get_KeepIntersections();
    public void set_KeepIntersections(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckEndSegmentsOnly();
    [CompilerGeneratedAttribute]
public void set_CheckEndSegmentsOnly(bool value);
    public bool get_HasIntersection();
    public ReadOnlyCollection`1<Coordinate> get_Intersections();
    public int get_Count();
    public Coordinate get_InteriorIntersection();
    public Coordinate get_Intersection();
    public Coordinate[] get_IntersectionSegments();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    private static bool IsInteriorVertexIntersection(Coordinate p00, Coordinate p01, Coordinate p10, Coordinate p11, bool isEnd00, bool isEnd01, bool isEnd10, bool isEnd11);
    private static bool IsInteriorVertexIntersection(Coordinate p0, Coordinate p1, bool isEnd0, bool isEnd1);
    private static bool IsEndSegment(ISegmentString segStr, int index);
    public sealed virtual bool get_IsDone();
}
public class NetTopologySuite.Noding.NodingValidator : object {
    private static GeometryFactory Factory;
    private LineIntersector _li;
    private IList`1<ISegmentString> _segStrings;
    public NodingValidator(IList`1<ISegmentString> segStrings);
    private static NodingValidator();
    public void CheckValid();
    private void CheckCollapses();
    private static void CheckCollapses(ISegmentString ss);
    private static void CheckCollapse(Coordinate p0, Coordinate p1, Coordinate p2);
    private void CheckInteriorIntersections();
    private void CheckInteriorIntersections(ISegmentString ss0, ISegmentString ss1);
    private void CheckInteriorIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    private static bool HasInteriorIntersection(LineIntersector li, Coordinate p0, Coordinate p1);
    private void CheckEndPtVertexIntersections();
    private static void CheckEndPtVertexIntersections(Coordinate testPt, IEnumerable`1<ISegmentString> segStrings);
}
public static class NetTopologySuite.Noding.Octant : object {
    public static Octants GetOctant(double dx, double dy);
    public static Octants GetOctant(Coordinate p0, Coordinate p1);
}
public enum NetTopologySuite.Noding.Octants : Enum {
    public int value__;
    public static Octants Null;
    public static Octants Zero;
    public static Octants One;
    public static Octants Two;
    public static Octants Three;
    public static Octants Four;
    public static Octants Five;
    public static Octants Six;
    public static Octants Seven;
}
public class NetTopologySuite.Noding.OrientedCoordinateArray : object {
    private Coordinate[] _pts;
    private bool _orientation;
    public OrientedCoordinateArray(Coordinate[] pts);
    private static bool Orientation(Coordinate[] pts);
    public sealed virtual int CompareTo(object o1);
    private static int CompareOriented(Coordinate[] pts1, bool orientation1, Coordinate[] pts2, bool orientation2);
}
public class NetTopologySuite.Noding.ScaledNoder : object {
    private INoder _noder;
    private double _scaleFactor;
    private bool _isScaled;
    public bool IsIntegerPrecision { get; }
    public ScaledNoder(INoder noder, double scaleFactor);
    public bool get_IsIntegerPrecision();
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegStrings);
    private IList`1<ISegmentString> Scale(IList`1<ISegmentString> segStrings);
    private Coordinate[] Scale(Coordinate[] pts);
    private void Rescale(IList`1<ISegmentString> segStrings);
    private void Rescale(Coordinate[] pts);
}
public class NetTopologySuite.Noding.SegmentExtractingNoder : object {
    private List`1<ISegmentString> _segList;
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    private static List`1<ISegmentString> ExtractSegments(IEnumerable`1<ISegmentString> segStrings);
    private static void ExtractSegments(ISegmentString ss, List`1<ISegmentString> segList);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.Noding.SegmentIntersectionDetector : object {
    private LineIntersector _li;
    private bool _hasIntersection;
    private bool _hasProperIntersection;
    private bool _hasNonProperIntersection;
    private Coordinate _intPt;
    private Coordinate[] _intSegments;
    [CompilerGeneratedAttribute]
private bool <FindProper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindAllIntersectionTypes>k__BackingField;
    public bool FindProper { get; public set; }
    public bool FindAllIntersectionTypes { get; public set; }
    public bool HasIntersection { get; }
    public bool HasProperIntersection { get; }
    public bool HasNonProperIntersection { get; }
    public Coordinate Intersection { get; }
    public Coordinate[] IntersectionSegments { get; }
    public bool IsDone { get; }
    public SegmentIntersectionDetector(LineIntersector li);
    [CompilerGeneratedAttribute]
public bool get_FindProper();
    [CompilerGeneratedAttribute]
public void set_FindProper(bool value);
    [CompilerGeneratedAttribute]
public bool get_FindAllIntersectionTypes();
    [CompilerGeneratedAttribute]
public void set_FindAllIntersectionTypes(bool value);
    public bool get_HasIntersection();
    public bool get_HasProperIntersection();
    public bool get_HasNonProperIntersection();
    public Coordinate get_Intersection();
    public Coordinate[] get_IntersectionSegments();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
public class NetTopologySuite.Noding.SegmentNode : object {
    public Coordinate Coord;
    public int SegmentIndex;
    private INodableSegmentString _segString;
    private Octants _segmentOctant;
    private bool _isInterior;
    public Coordinate Coordinate { get; }
    public bool IsInterior { get; }
    public SegmentNode(INodableSegmentString segString, Coordinate coord, int segmentIndex, Octants segmentOctant);
    public Coordinate get_Coordinate();
    public bool get_IsInterior();
    public bool IsEndPoint(int maxSegmentIndex);
    public sealed virtual int CompareTo(object obj);
    public void Write(StreamWriter outstream);
    public virtual string ToString();
}
public class NetTopologySuite.Noding.SegmentNodeList : object {
    private SortedDictionary`2<SegmentNode, object> _nodeMap;
    private NodedSegmentString _edge;
    public NodedSegmentString Edge { get; }
    public SegmentNodeList(NodedSegmentString edge);
    public NodedSegmentString get_Edge();
    public SegmentNode Add(Coordinate intPt, int segmentIndex);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void AddEndpoints();
    private void AddCollapsedNodes();
    private void FindCollapsesFromExistingVertices(List`1<int> collapsedVertexIndexes);
    private void FindCollapsesFromInsertedNodes(List`1<int> collapsedVertexIndexes);
    private static bool FindCollapseIndex(SegmentNode ei0, SegmentNode ei1, Int32& collapsedVertexIndex);
    public void AddSplitEdges(ICollection`1<ISegmentString> edgeList);
    private ISegmentString CreateSplitEdge(SegmentNode ei0, SegmentNode ei1);
    private Coordinate[] CreateSplitEdgePts(SegmentNode ei0, SegmentNode ei1);
    public Coordinate[] GetSplitCoordinates();
    private void AddEdgeCoordinates(SegmentNode ei0, SegmentNode ei1, CoordinateList coordList);
    public void Write(StreamWriter outstream);
}
public class NetTopologySuite.Noding.SegmentPointComparator : object {
    public static int Compare(Octants octant, Coordinate p0, Coordinate p1);
    public static int RelativeSign(double x0, double x1);
    private static int CompareValue(int compareSign0, int compareSign1);
}
public class NetTopologySuite.Noding.SegmentStringDissolver : object {
    private ISegmentStringMerger _merger;
    private IDictionary`2<OrientedCoordinateArray, ISegmentString> _ocaMap;
    public ICollection`1<ISegmentString> Dissolved { get; }
    public SegmentStringDissolver(ISegmentStringMerger merger);
    public void Dissolve(IEnumerable`1<ISegmentString> segStrings);
    private void Add(OrientedCoordinateArray oca, ISegmentString segString);
    public void Dissolve(ISegmentString segString);
    private ISegmentString FindMatching(OrientedCoordinateArray oca);
    public ICollection`1<ISegmentString> get_Dissolved();
}
public class NetTopologySuite.Noding.SegmentStringUtil : object {
    public static IList`1<ISegmentString> ExtractSegmentStrings(Geometry geom);
    public static IList`1<ISegmentString> ExtractNodedSegmentStrings(Geometry geom);
    public static IList`1<ISegmentString> ExtractBasicSegmentStrings(Geometry geom);
    public static Geometry ToGeometry(IList`1<ISegmentString> segStrings, GeometryFactory geomFact);
    public static string ToString(IEnumerable`1<ISegmentString> segStrings);
}
public class NetTopologySuite.Noding.SimpleNoder : SinglePassNoder {
    private IList`1<ISegmentString> _nodedSegStrings;
    public SimpleNoder(ISegmentIntersector segInt);
    public virtual IList`1<ISegmentString> GetNodedSubstrings();
    public virtual void ComputeNodes(IList`1<ISegmentString> inputSegStrings);
    private void ComputeIntersects(ISegmentString e0, ISegmentString e1);
}
public class NetTopologySuite.Noding.SimpleSegmentSetMutualIntersector : object {
    private ISegmentString[] _baseBaseSegStrings;
    public SimpleSegmentSetMutualIntersector(IEnumerable`1<ISegmentString> baseSegStrings);
    public sealed virtual void Process(IEnumerable`1<ISegmentString> segmentStrings, ISegmentIntersector segmentIntersector);
    private static void Intersect(ISegmentString ss0, ISegmentString ss1, ISegmentIntersector segInt);
}
public abstract class NetTopologySuite.Noding.SinglePassNoder : object {
    [CompilerGeneratedAttribute]
private ISegmentIntersector <SegmentIntersector>k__BackingField;
    public ISegmentIntersector SegmentIntersector { get; public set; }
    protected SinglePassNoder(ISegmentIntersector segInt);
    [CompilerGeneratedAttribute]
public ISegmentIntersector get_SegmentIntersector();
    [CompilerGeneratedAttribute]
public void set_SegmentIntersector(ISegmentIntersector value);
    public abstract virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    public abstract virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.Noding.Snap.SnappingIntersectionAdder : object {
    private LineIntersector _li;
    private double _snapTolerance;
    private SnappingPointIndex _snapPointIndex;
    public bool IsDone { get; }
    public SnappingIntersectionAdder(double snapTolerance, SnappingPointIndex snapPointIndex);
    public sealed virtual void ProcessIntersections(ISegmentString seg0, int segIndex0, ISegmentString seg1, int segIndex1);
    private void ProcessNearVertex(ISegmentString srcSS, int srcIndex, Coordinate p, ISegmentString ss, int segIndex, Coordinate p0, Coordinate p1);
    private static bool IsAdjacent(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    public sealed virtual bool get_IsDone();
}
public class NetTopologySuite.Noding.Snap.SnappingNoder : object {
    private SnappingPointIndex snapIndex;
    private double _snapTolerance;
    private IList`1<ISegmentString> _nodedResult;
    public SnappingNoder(double snapTolerance);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegmentStrings);
    private IList`1<ISegmentString> SnapVertices(IEnumerable`1<ISegmentString> segStrings);
    private void SeedSnapIndex(IEnumerable`1<ISegmentString> segStrings);
    private NodedSegmentString SnapVertices(ISegmentString ss);
    private Coordinate[] Snap(Coordinate[] coords);
    private IList`1<ISegmentString> ComputeIntersections(IList`1<ISegmentString> inputSS);
}
public class NetTopologySuite.Noding.Snap.SnappingPointIndex : object {
    private KdTree`1<Coordinate> _snapPointIndex;
    [CompilerGeneratedAttribute]
private double <Tolerance>k__BackingField;
    public double Tolerance { get; }
    public int Depth { get; }
    public SnappingPointIndex(double snapTolerance);
    public Coordinate Snap(Coordinate p);
    [CompilerGeneratedAttribute]
public double get_Tolerance();
    public int get_Depth();
}
public class NetTopologySuite.Noding.Snapround.GeometryNoder : object {
    private GeometryFactory _geomFact;
    private PrecisionModel _pm;
    [CompilerGeneratedAttribute]
private bool <IsValidityChecked>k__BackingField;
    public bool IsValidityChecked { get; public set; }
    public GeometryNoder(PrecisionModel pm);
    [CompilerGeneratedAttribute]
public bool get_IsValidityChecked();
    [CompilerGeneratedAttribute]
public void set_IsValidityChecked(bool value);
    public ReadOnlyCollection`1<LineString> Node(IEnumerable`1<Geometry> geoms);
    private ReadOnlyCollection`1<LineString> ToLineStrings(IEnumerable`1<ISegmentString> segStrings);
    private static List`1<ISegmentString> ToSegmentStrings(List`1<Geometry> lines);
}
public class NetTopologySuite.Noding.Snapround.HotPixel : object {
    private static double Tolerance;
    private double _hpx;
    private double _hpy;
    [CompilerGeneratedAttribute]
private Coordinate <Coordinate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ScaleFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNode>k__BackingField;
    public Coordinate Coordinate { get; }
    public double ScaleFactor { get; }
    public double Width { get; }
    public bool IsNode { get; public set; }
    [ObsoleteAttribute("LineIntersector is no longer used.")]
public HotPixel(Coordinate pt, double scaleFactor, LineIntersector li);
    public HotPixel(Coordinate pt, double scaleFactor);
    [CompilerGeneratedAttribute]
public Coordinate get_Coordinate();
    [CompilerGeneratedAttribute]
public double get_ScaleFactor();
    public double get_Width();
    [CompilerGeneratedAttribute]
public bool get_IsNode();
    [CompilerGeneratedAttribute]
public void set_IsNode(bool value);
    private double ScaleRound(double val);
    private double Scale(double val);
    [ObsoleteAttribute("Moved to MCIndexPointSnapper")]
public Envelope GetSafeEnvelope();
    public bool Intersects(Coordinate p);
    public bool Intersects(Coordinate p0, Coordinate p1);
    [ObsoleteAttribute("This method was never intended to be public and will be removed in a future release.")]
public bool IntersectsScaled(Coordinate p0, Coordinate p1);
    private bool IntersectsScaled(double p0x, double p0y, double p1x, double p1y);
    private bool IntersectsPixelClosure(Coordinate p0, Coordinate p1);
    [ObsoleteAttribute("Moved to MCIndexPointSnapper")]
public bool AddSnappedNode(INodableSegmentString segStr, int segIndex);
    public virtual string ToString();
}
internal class NetTopologySuite.Noding.Snapround.HotPixelIndex : object {
    private PrecisionModel _precModel;
    private double _scaleFactor;
    private KdTree`1<HotPixel> _index;
    public HotPixelIndex(PrecisionModel pm);
    public void Add(IEnumerable`1<Coordinate> pts);
    public void AddNodes(IEnumerable`1<Coordinate> pts);
    public HotPixel Add(Coordinate p);
    private HotPixel Find(Coordinate pixelPt);
    private Coordinate Round(Coordinate pt);
    public void Query(Coordinate p0, Coordinate p1, IKdNodeVisitor`1<HotPixel> visitor);
}
public class NetTopologySuite.Noding.Snapround.MCIndexPointSnapper : object {
    private STRtree`1<MonotoneChain> _index;
    private static double SafeEnvExpansionFactor;
    public MCIndexPointSnapper(ISpatialIndex`1<MonotoneChain> index);
    public bool Snap(HotPixel hotPixel, ISegmentString parentEdge, int hotPixelVertexIndex);
    public bool Snap(HotPixel hotPixel);
    private Envelope GetSafeEnvelope(HotPixel hp);
}
[ObsoleteAttribute("Not robust. Use SnapRoundingNoder instead.")]
public class NetTopologySuite.Noding.Snapround.MCIndexSnapRounder : object {
    private LineIntersector _li;
    private double _scaleFactor;
    private MCIndexNoder _noder;
    private MCIndexPointSnapper _pointSnapper;
    private IList`1<ISegmentString> _nodedSegStrings;
    public MCIndexSnapRounder(PrecisionModel pm);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegmentStrings);
    private void SnapRound(IList`1<ISegmentString> segStrings, LineIntersector li);
    private IList`1<Coordinate> FindInteriorIntersections(IList`1<ISegmentString> segStrings, LineIntersector li);
    private void ComputeIntersectionSnaps(IEnumerable`1<Coordinate> snapPts);
    public void ComputeVertexSnaps(IList`1<ISegmentString> edges);
    private void ComputeVertexSnaps(INodableSegmentString e);
}
[ObsoleteAttribute("Use SnapRoundingNoder instead")]
public class NetTopologySuite.Noding.Snapround.SimpleSnapRounder : object {
    private PrecisionModel _pm;
    private double _scaleFactor;
    private IDictionary`2<Coordinate, HotPixel> _hotPixelMap;
    private List`1<HotPixel> _hotPixels;
    private List`1<NodedSegmentString> _snappedResult;
    public SimpleSnapRounder(PrecisionModel pm);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegmentStrings);
    private List`1<NodedSegmentString> SnapRound(IList`1<ISegmentString> segStrings);
    private static List`1<ISegmentString> CreateNodedStrings(IEnumerable`1<ISegmentString> segStrings);
    private void AddVertexPixels(IEnumerable`1<ISegmentString> segStrings);
    private void AddHotPixels(IEnumerable`1<Coordinate> pts);
    private Coordinate Round(Coordinate pt);
    private Coordinate[] Round(IEnumerable`1<Coordinate> pts);
    private HotPixel CreateHotPixel(Coordinate p);
    private IList`1<Coordinate> FindInteriorIntersections(IList`1<ISegmentString> segStrings);
    private List`1<NodedSegmentString> ComputeSnaps(IEnumerable`1<ISegmentString> segStrings);
    private NodedSegmentString ComputeSnaps(NodedSegmentString ss);
    private void SnapSegment(Coordinate p0, Coordinate p1, NodedSegmentString ss, int segIndex);
    [ObsoleteAttribute("This method is no longer supported in the latest version of NetTopologySuite and may cause unexpected behavior.  Strongly favor using MCIndexPointSnapper instead.")]
public void ComputeVertexSnaps(IList`1<ISegmentString> edges);
    private void ComputeVertexSnaps(INodableSegmentString e0, INodableSegmentString e1);
}
public class NetTopologySuite.Noding.Snapround.SnapRoundingIntersectionAdder : object {
    private LineIntersector _li;
    private double _nearnessTol;
    [CompilerGeneratedAttribute]
private Collection`1<Coordinate> <Intersections>k__BackingField;
    public Collection`1<Coordinate> Intersections { get; }
    public bool IsDone { get; }
    [ObsoleteAttribute]
public SnapRoundingIntersectionAdder(PrecisionModel pm);
    public SnapRoundingIntersectionAdder(double nearnessTol);
    [CompilerGeneratedAttribute]
public Collection`1<Coordinate> get_Intersections();
    public sealed virtual void ProcessIntersections(ISegmentString e0, int segIndex0, ISegmentString e1, int segIndex1);
    private void ProcessNearVertex(Coordinate p, ISegmentString edge, int segIndex, Coordinate p0, Coordinate p1);
    public sealed virtual bool get_IsDone();
    [ObsoleteAttribute]
private static double CalculateNearnessTol(PrecisionModel precModel);
}
public class NetTopologySuite.Noding.Snapround.SnapRoundingNoder : object {
    private static int NEARNESS_FACTOR;
    private PrecisionModel _pm;
    private HotPixelIndex _pixelIndex;
    private List`1<NodedSegmentString> _snappedResult;
    public SnapRoundingNoder(PrecisionModel pm);
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> inputSegmentStrings);
    private List`1<NodedSegmentString> SnapRound(IList`1<ISegmentString> segStrings);
    private void AddIntersectionPixels(IList`1<ISegmentString> segStrings);
    private void AddVertexPixels(IEnumerable`1<ISegmentString> segStrings);
    private Coordinate Round(Coordinate pt);
    private Coordinate[] Round(Coordinate[] pts);
    private List`1<NodedSegmentString> ComputeSnaps(IEnumerable`1<ISegmentString> segStrings);
    private NodedSegmentString ComputeSegmentSnaps(NodedSegmentString ss);
    private void SnapSegment(Coordinate p0, Coordinate p1, NodedSegmentString ss, int segIndex);
    private void AddVertexNodeSnaps(NodedSegmentString ss);
    private void SnapVertexNode(Coordinate p0, NodedSegmentString ss, int segIndex);
}
public class NetTopologySuite.Noding.ValidatingNoder : object {
    private INoder _noder;
    private IList`1<ISegmentString> _nodedSs;
    public ValidatingNoder(INoder noder);
    public sealed virtual void ComputeNodes(IList`1<ISegmentString> segStrings);
    private void Validate();
    public sealed virtual IList`1<ISegmentString> GetNodedSubstrings();
}
public class NetTopologySuite.NtsGeometryServices : object {
    private static NtsGeometryServices modreq(System.Runtime.CompilerServices.IsVolatile) s_instance;
    private ConcurrentDictionary`2<GeometryFactoryKey, GeometryFactory> m_factories;
    [CompilerGeneratedAttribute]
private GeometryOverlay <GeometryOverlay>k__BackingField;
    [CompilerGeneratedAttribute]
private CoordinateEqualityComparer <CoordinateEqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultSRID>k__BackingField;
    [CompilerGeneratedAttribute]
private CoordinateSequenceFactory <DefaultCoordinateSequenceFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private PrecisionModel <DefaultPrecisionModel>k__BackingField;
    public static NtsGeometryServices Instance { get; public set; }
    public GeometryOverlay GeometryOverlay { get; }
    public CoordinateEqualityComparer CoordinateEqualityComparer { get; }
    public int DefaultSRID { get; }
    public CoordinateSequenceFactory DefaultCoordinateSequenceFactory { get; }
    public PrecisionModel DefaultPrecisionModel { get; }
    internal int NumFactories { get; }
    public NtsGeometryServices(GeometryOverlay geometryOverlay);
    public NtsGeometryServices(PrecisionModel precisionModel);
    public NtsGeometryServices(PrecisionModel precisionModel, int srid);
    public NtsGeometryServices(CoordinateSequenceFactory coordinateSequenceFactory);
    public NtsGeometryServices(CoordinateSequenceFactory coordinateSequenceFactory, PrecisionModel precisionModel, int srid);
    public NtsGeometryServices(CoordinateSequenceFactory coordinateSequenceFactory, PrecisionModel precisionModel, int srid, GeometryOverlay geometryOverlay, CoordinateEqualityComparer coordinateEqualityComparer);
    private static NtsGeometryServices();
    public static NtsGeometryServices get_Instance();
    public static void set_Instance(NtsGeometryServices value);
    [CompilerGeneratedAttribute]
public GeometryOverlay get_GeometryOverlay();
    [CompilerGeneratedAttribute]
public CoordinateEqualityComparer get_CoordinateEqualityComparer();
    [CompilerGeneratedAttribute]
public int get_DefaultSRID();
    [CompilerGeneratedAttribute]
public CoordinateSequenceFactory get_DefaultCoordinateSequenceFactory();
    [CompilerGeneratedAttribute]
public PrecisionModel get_DefaultPrecisionModel();
    internal int get_NumFactories();
    [ObsoleteAttribute("Will be removed in a future version")]
public PrecisionModel CreatePrecisionModel(PrecisionModels modelType);
    [ObsoleteAttribute("Will be removed in a future version")]
public PrecisionModel CreatePrecisionModel(PrecisionModel precisionModel);
    [ObsoleteAttribute("Will be removed in a future version")]
public PrecisionModel CreatePrecisionModel(double scale);
    public GeometryFactory CreateGeometryFactory();
    public GeometryFactory CreateGeometryFactory(int srid);
    public GeometryFactory CreateGeometryFactory(CoordinateSequenceFactory coordinateSequenceFactory);
    public GeometryFactory CreateGeometryFactory(PrecisionModel precisionModel);
    public GeometryFactory CreateGeometryFactory(PrecisionModel precisionModel, int srid);
    public GeometryFactory CreateGeometryFactory(PrecisionModel precisionModel, int srid, CoordinateSequenceFactory coordinateSequenceFactory);
    protected virtual GeometryFactory CreateGeometryFactoryCore(PrecisionModel precisionModel, int srid, CoordinateSequenceFactory coordinateSequenceFactory);
    [CompilerGeneratedAttribute]
private GeometryFactory <CreateGeometryFactory>b__37_0(GeometryFactoryKey key);
}
public class NetTopologySuite.Operation.BoundaryOp : object {
    private Geometry _geom;
    private GeometryFactory _geomFact;
    private IBoundaryNodeRule _bnRule;
    private IDictionary`2<Coordinate, Counter> _endpointMap;
    public BoundaryOp(Geometry geom);
    public BoundaryOp(Geometry geom, IBoundaryNodeRule bnRule);
    public static Geometry GetBoundary(Geometry g);
    public static Geometry GetBoundary(Geometry g, IBoundaryNodeRule bnRule);
    public static bool HasBoundary(Geometry geom, IBoundaryNodeRule boundaryNodeRule);
    public Geometry GetBoundary();
    private MultiPoint GetEmptyMultiPoint();
    private Geometry BoundaryMultiLineString(MultiLineString mLine);
    private Coordinate[] ComputeBoundaryCoordinates(MultiLineString mLine);
    private void AddEndpoint(Coordinate pt);
    private Geometry BoundaryLineString(LineString line);
}
internal class NetTopologySuite.Operation.Buffer.BufferBuilder : object {
    private BufferParameters _bufParams;
    private PrecisionModel _workingPrecisionModel;
    private INoder _workingNoder;
    private GeometryFactory _geomFact;
    private PlanarGraph _graph;
    private EdgeList _edgeList;
    [CompilerGeneratedAttribute]
private bool <InvertOrientation>k__BackingField;
    public PrecisionModel WorkingPrecisionModel { get; public set; }
    public INoder Noder { get; public set; }
    public bool InvertOrientation { get; public set; }
    public BufferBuilder(BufferParameters bufParams);
    private static int DepthDelta(Label label);
    public PrecisionModel get_WorkingPrecisionModel();
    public void set_WorkingPrecisionModel(PrecisionModel value);
    public INoder get_Noder();
    public void set_Noder(INoder value);
    [CompilerGeneratedAttribute]
public bool get_InvertOrientation();
    [CompilerGeneratedAttribute]
public void set_InvertOrientation(bool value);
    public Geometry Buffer(Geometry g, double distance);
    private INoder GetNoder(PrecisionModel precisionModel);
    private void ComputeNodedEdges(IList`1<ISegmentString> bufferSegStrList, PrecisionModel precisionModel, bool isNodingValidated);
    protected void InsertUniqueEdge(Edge e);
    private static IEnumerable`1<BufferSubgraph> CreateSubgraphs(PlanarGraph graph);
    private static void BuildSubgraphs(IEnumerable`1<BufferSubgraph> subgraphList, PolygonBuilder polyBuilder);
    private static Geometry ConvertSegStrings(IEnumerator`1<ISegmentString> it);
    private Geometry CreateEmptyResultGeometry();
}
public class NetTopologySuite.Operation.Buffer.BufferCurveSetBuilder : object {
    private Geometry _inputGeom;
    private double _distance;
    private OffsetCurveBuilder _curveBuilder;
    private IList`1<ISegmentString> _curveList;
    [CompilerGeneratedAttribute]
private bool <InvertOrientation>k__BackingField;
    private static int MAX_INVERTED_RING_SIZE;
    private static int INVERTED_CURVE_VERTEX_FACTOR;
    private static double NEARNESS_FACTOR;
    public bool InvertOrientation { get; public set; }
    public BufferCurveSetBuilder(Geometry inputGeom, double distance, PrecisionModel precisionModel, BufferParameters parameters);
    [CompilerGeneratedAttribute]
public bool get_InvertOrientation();
    [CompilerGeneratedAttribute]
public void set_InvertOrientation(bool value);
    private bool IsRingCCW(Coordinate[] coord);
    public IList`1<ISegmentString> GetCurves();
    private void AddCurve(Coordinate[] coord, Location leftLoc, Location rightLoc);
    private void Add(Geometry g);
    private void AddCollection(Geometry gc);
    private void AddPoint(Geometry p);
    private void AddLineString(Geometry line);
    private static Coordinate[] Clean(Coordinate[] coords);
    private void AddPolygon(Polygon p);
    private void AddRingBothSides(Coordinate[] coord, double distance);
    private void AddRingSide(Coordinate[] coord, double offsetDistance, Position side, Location cwLeftLoc, Location cwRightLoc);
    private static bool IsRingCurveInverted(Coordinate[] inputPts, double distance, Coordinate[] curvePts);
    private static double MaxDistance(Coordinate[] pts, Coordinate[] line);
    private static bool IsErodedCompletely(Coordinate[] ringCoord, double bufferDistance);
    private static bool IsTriangleErodedCompletely(Coordinate[] triangleCoord, double bufferDistance);
}
public class NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier : object {
    private static int NumPtsToCheck;
    private static int Delete;
    private Coordinate[] _inputLine;
    private double _distanceTol;
    private Byte[] _isDeleted;
    private OrientationIndex _angleOrientation;
    public BufferInputLineSimplifier(Coordinate[] inputLine);
    public static Coordinate[] Simplify(Coordinate[] inputLine, double distanceTol);
    public Coordinate[] Simplify(double distanceTol);
    private bool DeleteShallowConcavities();
    private int FindNextNonDeletedIndex(int index);
    private Coordinate[] CollapseLine();
    private bool IsDeletable(int i0, int i1, int i2, double distanceTol);
    private bool IsShallowSampled(Coordinate p0, Coordinate p2, int i0, int i2, double distanceTol);
    private static bool IsShallow(Coordinate p0, Coordinate p1, Coordinate p2, double distanceTol);
    private bool IsConcave(Coordinate p0, Coordinate p1, Coordinate p2);
}
public class NetTopologySuite.Operation.Buffer.BufferOp : object {
    private static int MaxPrecisionDigits;
    private Geometry _argGeom;
    private double _distance;
    private BufferParameters _bufParams;
    private Geometry _resultGeometry;
    private Exception _saveException;
    [CompilerGeneratedAttribute]
private bool <InvertOrientation>k__BackingField;
    private bool InvertOrientation { get; private set; }
    public int QuadrantSegments { get; public set; }
    public BufferOp(Geometry g);
    public BufferOp(Geometry g, BufferParameters bufParams);
    private static double PrecisionScaleFactor(Geometry g, double distance, int maxPrecisionDigits);
    public static Geometry Buffer(Geometry g, double distance);
    public static Geometry Buffer(Geometry g, double distance, BufferParameters parameters);
    public static Geometry Buffer(Geometry g, double distance, int quadrantSegments);
    internal static Geometry BufferByZero(Geometry geom, bool isBothOrientations);
    private static Geometry Combine(Geometry poly0, Geometry poly1);
    private static void ExtractPolygons(Geometry poly0, ICollection`1<Polygon> polys);
    [CompilerGeneratedAttribute]
private bool get_InvertOrientation();
    [CompilerGeneratedAttribute]
private void set_InvertOrientation(bool value);
    public int get_QuadrantSegments();
    public void set_QuadrantSegments(int value);
    public Geometry GetResultGeometry(double distance);
    private void ComputeGeometry();
    private void BufferReducedPrecision();
    private void BufferReducedPrecision(int precisionDigits);
    private void BufferOriginalPrecision();
    private BufferBuilder CreateBufferBuilder();
    private void BufferFixedPrecision(PrecisionModel fixedPM);
}
public class NetTopologySuite.Operation.Buffer.BufferParameters : object {
    public static int DefaultQuadrantSegments;
    public static JoinStyle DefaultJoinStyle;
    public static double DefaultMitreLimit;
    public static double DefaultSimplifyFactor;
    private int _quadrantSegments;
    private EndCapStyle _endCapStyle;
    private JoinStyle _joinStyle;
    private double _mitreLimit;
    private double _simplifyFactor;
    [CompilerGeneratedAttribute]
private bool <IsSingleSided>k__BackingField;
    public int QuadrantSegments { get; public set; }
    public EndCapStyle EndCapStyle { get; public set; }
    public JoinStyle JoinStyle { get; public set; }
    public double MitreLimit { get; public set; }
    public bool IsSingleSided { get; public set; }
    public double SimplifyFactor { get; public set; }
    public BufferParameters(int quadrantSegments);
    public BufferParameters(int quadrantSegments, EndCapStyle endCapStyle);
    public BufferParameters(int quadrantSegments, EndCapStyle endCapStyle, JoinStyle joinStyle, double mitreLimit);
    public int get_QuadrantSegments();
    public void set_QuadrantSegments(int value);
    public static double BufferDistanceError(int quadSegs);
    public EndCapStyle get_EndCapStyle();
    public void set_EndCapStyle(EndCapStyle value);
    public JoinStyle get_JoinStyle();
    public void set_JoinStyle(JoinStyle value);
    public double get_MitreLimit();
    public void set_MitreLimit(double value);
    [CompilerGeneratedAttribute]
public bool get_IsSingleSided();
    [CompilerGeneratedAttribute]
public void set_IsSingleSided(bool value);
    public double get_SimplifyFactor();
    public void set_SimplifyFactor(double value);
    public BufferParameters Copy();
}
internal class NetTopologySuite.Operation.Buffer.BufferSubgraph : object {
    private RightmostEdgeFinder _finder;
    private List`1<DirectedEdge> _dirEdgeList;
    private List`1<Node> _nodes;
    private Coordinate _rightMostCoord;
    public IList`1<DirectedEdge> DirectedEdges { get; }
    public IList`1<Node> Nodes { get; }
    public Coordinate RightMostCoordinate { get; }
    public IList`1<DirectedEdge> get_DirectedEdges();
    public IList`1<Node> get_Nodes();
    public Coordinate get_RightMostCoordinate();
    public void Create(Node node);
    private void AddReachable(Node startNode);
    private void Add(Node node, Stack`1<Node> nodeStack);
    private void ClearVisitedEdges();
    public void ComputeDepth(int outsideDepth);
    private static void ComputeDepths(DirectedEdge startEdge);
    private static void ComputeNodeDepth(Node n);
    private static void CopySymDepths(DirectedEdge de);
    public void FindResultEdges();
    public sealed virtual int CompareTo(object o);
}
public enum NetTopologySuite.Operation.Buffer.EndCapStyle : Enum {
    public int value__;
    public static EndCapStyle Round;
    public static EndCapStyle Flat;
    public static EndCapStyle Square;
}
public enum NetTopologySuite.Operation.Buffer.JoinStyle : Enum {
    public int value__;
    public static JoinStyle Round;
    public static JoinStyle Mitre;
    public static JoinStyle Bevel;
}
public class NetTopologySuite.Operation.Buffer.OffsetCurve : object {
    private static int NearnessFactor;
    private Geometry _inputGeom;
    private double _distance;
    private BufferParameters _bufferParams;
    private double _matchDistance;
    private GeometryFactory _geomFactory;
    public OffsetCurve(Geometry geom, double distance);
    public OffsetCurve(Geometry geom, double distance, BufferParameters bufParams);
    public static Geometry GetCurve(Geometry geom, double distance);
    public static Geometry GetCurve(Geometry geom, double distance, int quadSegs, JoinStyle joinStyle, double mitreLimit);
    public Geometry GetCurve();
    public static Coordinate[] RawOffset(LineString geom, double distance, BufferParameters bufParams);
    public static Coordinate[] RawOffset(LineString geom, double distance);
    private LineString ComputeCurve(LineString lineGeom, double distance);
    private LineString OffsetSegment(Coordinate[] pts, double distance);
    private static Polygon GetBufferOriented(LineString geom, double distance, BufferParameters bufParams);
    private static Polygon ExtractMaxAreaPolygon(Geometry geom);
    private static LinearRing ExtractLongestHole(Polygon poly);
    private LineString ComputeCurve(Coordinate[] bufferPts, Coordinate[] rawOffset);
    private int MarkMatchingSegments(Coordinate p0, Coordinate p1, SegmentMCIndex segIndex, Coordinate[] bufferPts, Boolean[] isInCurve);
    private static double SubsegmentMatchFrac(Coordinate p0, Coordinate p1, Coordinate seg0, Coordinate seg1, double matchDistance);
    private static Coordinate[] ExtractSection(Coordinate[] ring, int startIndex, Boolean[] isExtracted);
    private static int Next(int i, int size);
}
public class NetTopologySuite.Operation.Buffer.OffsetCurveBuilder : object {
    private double _distance;
    private PrecisionModel _precisionModel;
    private BufferParameters _bufParams;
    public BufferParameters BufferParameters { get; }
    public OffsetCurveBuilder(PrecisionModel precisionModel, BufferParameters bufParams);
    public BufferParameters get_BufferParameters();
    public Coordinate[] GetLineCurve(Coordinate[] inputPts, double distance);
    public bool IsLineOffsetEmpty(double distance);
    [ObsoleteAttribute("Use GetRingCurve(Coordinate[], Geometries.Position, double)")]
public Coordinate[] GetRingCurve(Coordinate[] inputPts, Positions side, double distance);
    public Coordinate[] GetRingCurve(Coordinate[] inputPts, Position side, double distance);
    public Coordinate[] GetOffsetCurve(Coordinate[] inputPts, double distance);
    private static Coordinate[] CopyCoordinates(Coordinate[] pts);
    private OffsetSegmentGenerator GetSegmentGenerator(double distance);
    private double SimplifyTolerance(double bufDistance);
    private void ComputePointCurve(Coordinate pt, OffsetSegmentGenerator segGen);
    private void ComputeLineBufferCurve(Coordinate[] inputPts, OffsetSegmentGenerator segGen);
    private void ComputeSingleSidedBufferCurve(Coordinate[] inputPts, bool isRightSide, OffsetSegmentGenerator segGen);
    private void ComputeOffsetCurve(Coordinate[] inputPts, bool isRightSide, OffsetSegmentGenerator segGen);
    private void ComputeRingBufferCurve(Coordinate[] inputPts, Position side, OffsetSegmentGenerator segGen);
}
[ObsoleteAttribute("Use BufferCurveSetBuilder")]
public class NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder : object {
    private Geometry _inputGeom;
    private double _distance;
    private OffsetCurveBuilder _curveBuilder;
    private IList`1<ISegmentString> _curveList;
    [CompilerGeneratedAttribute]
private bool <InvertOrientation>k__BackingField;
    private static int MAX_INVERTED_RING_SIZE;
    private static double NEARNESS_FACTOR;
    public bool InvertOrientation { get; public set; }
    public OffsetCurveSetBuilder(Geometry inputGeom, double distance, OffsetCurveBuilder curveBuilder);
    [CompilerGeneratedAttribute]
public bool get_InvertOrientation();
    [CompilerGeneratedAttribute]
public void set_InvertOrientation(bool value);
    private bool IsRingCCW(Coordinate[] coord);
    public IList`1<ISegmentString> GetCurves();
    private void AddCurve(Coordinate[] coord, Location leftLoc, Location rightLoc);
    private void Add(Geometry g);
    private void AddCollection(Geometry gc);
    private void AddPoint(Geometry p);
    private void AddLineString(Geometry line);
    private static Coordinate[] Clean(Coordinate[] coords);
    private void AddPolygon(Polygon p);
    private void AddRingBothSides(Coordinate[] coord, double distance);
    private void AddRingSide(Coordinate[] coord, double offsetDistance, Position side, Location cwLeftLoc, Location cwRightLoc);
    private static bool IsRingCurveInverted(Coordinate[] inputPts, double distance, Coordinate[] curvePts);
    private static double MaxDistance(Coordinate[] pts, Coordinate[] line);
    private static bool IsErodedCompletely(Coordinate[] ringCoord, double bufferDistance);
    private static bool IsTriangleErodedCompletely(Coordinate[] triangleCoord, double bufferDistance);
}
public class NetTopologySuite.Operation.Buffer.OffsetCurveVertexList : object {
    private List`1<Coordinate> _ptList;
    private PrecisionModel _precisionModel;
    private double _minimimVertexDistance;
    public PrecisionModel PrecisionModel { get; public set; }
    public double MinimumVertexDistance { get; public set; }
    public Coordinate[] Coordinates { get; }
    public PrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(PrecisionModel value);
    public double get_MinimumVertexDistance();
    public void set_MinimumVertexDistance(double value);
    public void AddPt(Coordinate pt);
    private bool IsDuplicate(Coordinate pt);
    public void CloseRing();
    public Coordinate[] get_Coordinates();
    public virtual string ToString();
}
internal class NetTopologySuite.Operation.Buffer.OffsetSegmentGenerator : object {
    private static double OffsetSegmentSeparationFactor;
    private static double InsideTurnVertexSnapDistanceFactor;
    private static double CurveVertexSnapDistanceFactor;
    private static int MaxClosingSegLenFactor;
    private double _maxCurveSegmentError;
    private double _filletAngleQuantum;
    private int _closingSegLengthFactor;
    private OffsetSegmentString _segList;
    private double _distance;
    private PrecisionModel _precisionModel;
    private BufferParameters _bufParams;
    private LineIntersector _li;
    private Coordinate _s0;
    private Coordinate _s1;
    private Coordinate _s2;
    private LineSegment _seg0;
    private LineSegment _seg1;
    private LineSegment _offset0;
    private LineSegment _offset1;
    private Position _side;
    private bool _hasNarrowConcaveAngle;
    public bool HasNarrowConcaveAngle { get; }
    public OffsetSegmentGenerator(PrecisionModel precisionModel, BufferParameters bufParams, double distance);
    public bool get_HasNarrowConcaveAngle();
    private void Init(double distance);
    [ObsoleteAttribute("Use InitSideSegments(Coordinate, Coordinate, Geometries.Position)")]
public void InitSideSegments(Coordinate s1, Coordinate s2, Positions side);
    public void InitSideSegments(Coordinate s1, Coordinate s2, Position side);
    public Coordinate[] GetCoordinates();
    public void CloseRing();
    public void AddSegments(Coordinate[] pt, bool isForward);
    public void AddFirstSegment();
    public void AddLastSegment();
    public void AddNextSegment(Coordinate p, bool addStartPoint);
    private void AddCollinear(bool addStartPoint);
    private void AddOutsideTurn(OrientationIndex orientation, bool addStartPoint);
    private void AddInsideTurn(OrientationIndex orientation, bool addStartPoint);
    private static void ComputeOffsetSegment(LineSegment seg, Position side, double distance, LineSegment offset);
    public void AddLineEndCap(Coordinate p0, Coordinate p1);
    private void AddMitreJoin(Coordinate cornerPt, LineSegment offset0, LineSegment offset1, double distance);
    private void AddLimitedMitreJoin(LineSegment offset0, LineSegment offset1, double distance, double mitreLimitDistance);
    private static Coordinate Project(Coordinate pt, double d, double dir);
    private void AddBevelJoin(LineSegment offset0, LineSegment offset1);
    private void AddCornerFillet(Coordinate p, Coordinate p0, Coordinate p1, OrientationIndex direction, double radius);
    private void AddDirectedFillet(Coordinate p, double startAngle, double endAngle, OrientationIndex direction, double radius);
    public void CreateCircle(Coordinate p);
    public void CreateSquare(Coordinate p);
}
internal class NetTopologySuite.Operation.Buffer.OffsetSegmentString : object {
    private List`1<Coordinate> _ptList;
    private PrecisionModel _precisionModel;
    private double _minimumVertexDistance;
    public PrecisionModel PrecisionModel { get; public set; }
    public double MinimumVertexDistance { get; public set; }
    public PrecisionModel get_PrecisionModel();
    public void set_PrecisionModel(PrecisionModel value);
    public double get_MinimumVertexDistance();
    public void set_MinimumVertexDistance(double value);
    public void AddPt(Coordinate pt);
    public void AddPts(Coordinate[] pt, bool isForward);
    private bool IsRedundant(Coordinate pt);
    public void CloseRing();
    public void Reverse();
    public Coordinate[] GetCoordinates();
    public virtual string ToString();
}
[ObsoleteAttribute]
public class NetTopologySuite.Operation.Buffer.OldOffsetCurveBuilder : object {
    private double _filletAngleQuantum;
    private double _maxCurveSegmentError;
    private static double CurveVertexSnapDistanceFactor;
    private static double OffsetSegmentSeparationFactor;
    private static double InsideTurnVertexSnapDistanceFactor;
    private static int MaxClosingSegFraction;
    private double _distance;
    private PrecisionModel _precisionModel;
    private BufferParameters _bufParams;
    private int _closingSegFactor;
    private OffsetCurveVertexList _vertexList;
    private LineIntersector _li;
    private static double SimplifyFactor;
    private Coordinate _s0;
    private Coordinate _s1;
    private Coordinate _s2;
    private LineSegment _seg0;
    private LineSegment _seg1;
    private LineSegment _offset0;
    private LineSegment _offset1;
    private Position _side;
    public OldOffsetCurveBuilder(PrecisionModel precisionModel, BufferParameters bufParams);
    public IList`1<Coordinate[]> GetLineCurve(Coordinate[] inputPts, double distance);
    [ObsoleteAttribute("Use GetRingCurve(Coordinate[], Geometries.Position, double)")]
public IList`1<Coordinate[]> GetRingCurve(Coordinate[] inputPts, Positions side, double distance);
    public IList`1<Coordinate[]> GetRingCurve(Coordinate[] inputPts, Position side, double distance);
    private static Coordinate[] CopyCoordinates(Coordinate[] pts);
    private void Init(double distance);
    private static double SimplifyTolerance(double bufDistance);
    private void ComputeLineBufferCurve(Coordinate[] inputPts);
    private void OldcomputeLineBufferCurve(Coordinate[] inputPts);
    private void ComputeRingBufferCurve(Coordinate[] inputPts, Position side);
    private void InitSideSegments(Coordinate s1, Coordinate s2, Position side);
    private void AddNextSegment(Coordinate p, bool addStartPoint);
    private void AddCollinear(bool addStartPoint);
    private void AddOutsideTurn(OrientationIndex orientation, bool addStartPoint);
    private void AddInsideTurn(OrientationIndex orientation, bool addStartPoint);
    private void AddLastSegment();
    private static void ComputeOffsetSegment(LineSegment seg, Position side, double distance, LineSegment offset);
    private void AddLineEndCap(Coordinate p0, Coordinate p1);
    private void AddMitreJoin(Coordinate p, LineSegment offset0, LineSegment offset1, double distance);
    private void AddLimitedMitreJoin(LineSegment offset0, LineSegment offset1, double distance, double mitreLimit);
    private void AddBevelJoin(LineSegment offset0, LineSegment offset1);
    private void AddFillet(Coordinate p, Coordinate p0, Coordinate p1, OrientationIndex direction, double radius);
    private void AddFillet(Coordinate p, double startAngle, double endAngle, OrientationIndex direction, double radius);
    private void AddCircle(Coordinate p, double distance);
    private void AddSquare(Coordinate p, double distance);
}
internal class NetTopologySuite.Operation.Buffer.RightmostEdgeFinder : object {
    private int minIndex;
    private Coordinate minCoord;
    private DirectedEdge minDe;
    private DirectedEdge orientedDe;
    public DirectedEdge Edge { get; }
    public Coordinate Coordinate { get; }
    public DirectedEdge get_Edge();
    public Coordinate get_Coordinate();
    public void FindEdge(IList dirEdgeList);
    private void FindRightmostEdgeAtNode();
    private void FindRightmostEdgeAtVertex();
    private void CheckForRightmostCoordinate(DirectedEdge de);
    private Position GetRightmostSide(DirectedEdge de, int index);
    private Position GetRightmostSideOfSegment(DirectedEdge de, int i);
}
internal class NetTopologySuite.Operation.Buffer.SegmentMCIndex : object {
    private STRtree`1<MonotoneChain> index;
    public SegmentMCIndex(Coordinate[] segs);
    private STRtree`1<MonotoneChain> BuildIndex(Coordinate[] segs);
    public void Query(Envelope env, MonotoneChainSelectAction action);
}
internal class NetTopologySuite.Operation.Buffer.SubgraphDepthLocater : object {
    private IList`1<BufferSubgraph> _subgraphs;
    private LineSegment _seg;
    public SubgraphDepthLocater(IList`1<BufferSubgraph> subgraphs);
    public int GetDepth(Coordinate p);
    private IList`1<DepthSegment> FindStabbedSegments(Coordinate stabbingRayLeftPt);
    private void FindStabbedSegments(Coordinate stabbingRayLeftPt, IEnumerable`1<DirectedEdge> dirEdges, IList`1<DepthSegment> stabbedSegments);
    private void FindStabbedSegments(Coordinate stabbingRayLeftPt, DirectedEdge dirEdge, IList`1<DepthSegment> stabbedSegments);
}
public class NetTopologySuite.Operation.Buffer.Validate.BufferCurveMaximumDistanceFinder : object {
    private Geometry _inputGeom;
    private PointPairDistance _maxPtDist;
    public PointPairDistance DistancePoints { get; }
    public BufferCurveMaximumDistanceFinder(Geometry inputGeom);
    public double FindDistance(Geometry bufferCurve);
    public PointPairDistance get_DistancePoints();
    private void ComputeMaxVertexDistance(Geometry curve);
    private void computeMaxMidpointDistance(Geometry curve);
}
public class NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator : object {
    public static bool Verbose;
    private static double MaxDistanceDiffFrac;
    private Geometry _input;
    private double _bufDistance;
    private Geometry _result;
    private double _minValidDistance;
    private double _maxValidDistance;
    private double _minDistanceFound;
    private double _maxDistanceFound;
    private bool _isValid;
    private string _errMsg;
    private Coordinate _errorLocation;
    private Geometry _errorIndicator;
    public string ErrorMessage { get; }
    public Coordinate ErrorLocation { get; }
    public Geometry ErrorIndicator { get; }
    public BufferDistanceValidator(Geometry input, double bufDistance, Geometry result);
    public bool IsValid();
    public string get_ErrorMessage();
    public Coordinate get_ErrorLocation();
    public Geometry get_ErrorIndicator();
    private void CheckPositiveValid();
    private void CheckNegativeValid();
    private static Geometry GetPolygonLines(Geometry g);
    private void CheckMinimumDistance(Geometry g1, Geometry g2, double minDist);
    private void CheckMaximumDistance(Geometry input, Geometry bufCurve, double maxDist);
}
public class NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator : object {
    public static bool Verbose;
    private static double MaxEnvDiffFrac;
    private Geometry _input;
    private double _distance;
    private Geometry _result;
    private bool _isValid;
    private string _errorMsg;
    private Coordinate _errorLocation;
    private Geometry _errorIndicator;
    public string ErrorMessage { get; }
    public Coordinate ErrorLocation { get; }
    public Geometry ErrorIndicator { get; }
    public BufferResultValidator(Geometry input, double distance, Geometry result);
    public static bool IsValid(Geometry g, double distance, Geometry result);
    public static string IsValidMessage(Geometry g, double distance, Geometry result);
    public bool IsValid();
    public string get_ErrorMessage();
    public Coordinate get_ErrorLocation();
    public Geometry get_ErrorIndicator();
    private void Report(string checkName);
    private void CheckPolygonal();
    private void CheckExpectedEmpty();
    private void CheckEnvelope();
    private void CheckArea();
    private void CheckDistance();
}
public static class NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder : object {
    public static void ComputeDistance(Geometry geom, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(LineString line, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(LineSegment segment, Coordinate pt, PointPairDistance ptDist);
    public static void ComputeDistance(Polygon poly, Coordinate pt, PointPairDistance ptDist);
}
public class NetTopologySuite.Operation.Buffer.Validate.PointPairDistance : object {
    private Coordinate[] _pt;
    private double _distance;
    private bool _isNull;
    public double Distance { get; }
    public Coordinate[] Coordinates { get; }
    public void Initialize();
    public void Initialize(Coordinate p0, Coordinate p1);
    private void Initialize(Coordinate p0, Coordinate p1, double distance);
    public double get_Distance();
    public Coordinate[] get_Coordinates();
    public Coordinate GetCoordinate(int i);
    public void SetMaximum(PointPairDistance ptDist);
    public void SetMaximum(Coordinate p0, Coordinate p1);
    public void SetMinimum(PointPairDistance ptDist);
    public void SetMinimum(Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Operation.Buffer.VariableBuffer : object {
    private LineString _line;
    private Double[] _distance;
    private GeometryFactory _geomFactory;
    private int _quadrantSegs;
    private static double SNAP_TRIG_TOL;
    public VariableBuffer(Geometry line, Double[] distance);
    public static Geometry Buffer(Geometry line, double startDistance, double endDistance);
    public static Geometry Buffer(Geometry line, double startDistance, double midDistance, double endDistance);
    public static Geometry Buffer(Geometry line, Double[] distance);
    private static Double[] Interpolate(LineString line, double startValue, double endValue);
    private static Double[] Interpolate(LineString line, double startValue, double midValue, double endValue);
    private static int IndexAtLength(Coordinate[] pts, double targetLen);
    private static double Length(Coordinate[] pts, int i1, int i2);
    public Geometry GetResult();
    private Polygon SegmentBuffer(Coordinate p0, Coordinate p1, double dist0, double dist1);
    private Polygon Circle(Coordinate center, double radius);
    private void AddCap(Coordinate p, double r, Coordinate t1, Coordinate t2, CoordinateList coords);
    private double CapAngle(int index);
    private int CapAngleIndex(double ang);
    private static LineSegment OuterTangent(Coordinate c1, double r1, Coordinate c2, double r2);
    private static Coordinate ProjectPolar(Coordinate p, double r, double ang);
    private static double SnapTrig(double x);
}
internal class NetTopologySuite.Operation.Counter : object {
    public int Count;
}
public class NetTopologySuite.Operation.Distance.ConnectedElementLocationFilter : object {
    private IList`1<GeometryLocation> _locations;
    private ConnectedElementLocationFilter(IList`1<GeometryLocation> locations);
    public static IList`1<GeometryLocation> GetLocations(Geometry geom);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Operation.Distance.ConnectedElementPointFilter : object {
    private IList`1<Coordinate> _pts;
    private ConnectedElementPointFilter(IList`1<Coordinate> pts);
    public static IList`1<Coordinate> GetCoordinates(Geometry geom);
    public sealed virtual void Filter(Geometry geom);
}
public class NetTopologySuite.Operation.Distance.DistanceOp : object {
    private Geometry[] _geom;
    private double _terminateDistance;
    private PointLocator _ptLocator;
    private GeometryLocation[] _minDistanceLocation;
    private double _minDistance;
    public DistanceOp(Geometry g0, Geometry g1);
    public DistanceOp(Geometry g0, Geometry g1, double terminateDistance);
    public static double Distance(Geometry g0, Geometry g1);
    public static bool IsWithinDistance(Geometry g0, Geometry g1, double distance);
    public static Coordinate[] NearestPoints(Geometry g0, Geometry g1);
    public double Distance();
    public Coordinate[] NearestPoints();
    public GeometryLocation[] NearestLocations();
    private void UpdateMinDistance(double dist);
    private void UpdateMinDistance(GeometryLocation[] locGeom, bool flip);
    private void ComputeMinDistance();
    private void ComputeContainmentDistance();
    private void ComputeContainmentDistance(int polyGeomIndex, GeometryLocation[] locPtPoly);
    private void ComputeContainmentDistance(IList`1<GeometryLocation> locs, ICollection`1<Geometry> polys, GeometryLocation[] locPtPoly);
    private void ComputeContainmentDistance(GeometryLocation ptLoc, Polygon poly, GeometryLocation[] locPtPoly);
    private void ComputeFacetDistance();
    private void ComputeMinDistanceLines(IEnumerable`1<Geometry> lines0, ICollection`1<Geometry> lines1, GeometryLocation[] locGeom);
    private void ComputeMinDistancePoints(IEnumerable`1<Geometry> points0, ICollection`1<Geometry> points1, GeometryLocation[] locGeom);
    private void ComputeMinDistanceLinesPoints(IEnumerable`1<Geometry> lines, ICollection`1<Geometry> points, GeometryLocation[] locGeom);
    private void ComputeMinDistance(LineString line0, LineString line1, GeometryLocation[] locGeom);
    private void ComputeMinDistance(LineString line, Point pt, GeometryLocation[] locGeom);
}
public class NetTopologySuite.Operation.Distance.FacetSequence : object {
    private Geometry _geom;
    private CoordinateSequence _pts;
    private int _start;
    private int _end;
    public Envelope Envelope { get; }
    public int Count { get; }
    public bool IsPoint { get; }
    public FacetSequence(Geometry geom, CoordinateSequence pts, int start, int end);
    public FacetSequence(CoordinateSequence pts, int start, int end);
    public FacetSequence(CoordinateSequence pts, int index);
    public Envelope get_Envelope();
    public int get_Count();
    public Coordinate GetCoordinate(int index);
    public bool get_IsPoint();
    public double Distance(FacetSequence facetSeq);
    public GeometryLocation[] NearestLocations(FacetSequence facetSeq);
    private double ComputeDistanceLineLine(FacetSequence facetSeq, GeometryLocation[] locs);
    private void UpdateNearestLocationsLineLine(int i, Coordinate p0, Coordinate p1, FacetSequence facetSeq, int j, Coordinate q0, Coordinate q1, GeometryLocation[] locs);
    private double ComputeDistancePointLine(Coordinate pt, FacetSequence facetSeq, GeometryLocation[] locs);
    private void UpdateNearestLocationsPointLine(Coordinate pt, FacetSequence facetSeq, int i, Coordinate q0, Coordinate q1, GeometryLocation[] locs);
    public virtual string ToString();
}
public static class NetTopologySuite.Operation.Distance.FacetSequenceTreeBuilder : object {
    private static int FacetSequenceSize;
    private static int STRtreeNodeCapacity;
    public static STRtree`1<FacetSequence> BuildSTRtree(Geometry g);
    private static List`1<FacetSequence> ComputeFacetSequences(Geometry g);
    private static void AddFacetSequences(Geometry geom, CoordinateSequence pts, List`1<FacetSequence> sections);
}
public class NetTopologySuite.Operation.Distance.GeometryLocation : object {
    public static int InsideArea;
    private Geometry _component;
    private int _segIndex;
    private Coordinate _pt;
    public Geometry GeometryComponent { get; }
    public int SegmentIndex { get; }
    public Coordinate Coordinate { get; }
    public bool IsInsideArea { get; }
    public GeometryLocation(Geometry component, int segIndex, Coordinate pt);
    public GeometryLocation(Geometry component, Coordinate pt);
    public Geometry get_GeometryComponent();
    public int get_SegmentIndex();
    public Coordinate get_Coordinate();
    public bool get_IsInsideArea();
    public virtual string ToString();
}
public class NetTopologySuite.Operation.Distance.IndexedFacetDistance : object {
    private static FacetSequenceDistance FacetSeqDist;
    private STRtree`1<FacetSequence> _cachedTree;
    private Geometry _baseGeometry;
    public IndexedFacetDistance(Geometry g1);
    private static IndexedFacetDistance();
    public static double Distance(Geometry g1, Geometry g2);
    public static bool IsWithinDistance(Geometry g1, Geometry g2, double distance);
    public static Coordinate[] NearestPoints(Geometry g1, Geometry g2);
    public double Distance(Geometry g);
    public GeometryLocation[] NearestLocations(Geometry g);
    public Coordinate[] NearestPoints(Geometry g);
    private static Coordinate[] ToPoints(GeometryLocation[] locations);
    public bool IsWithinDistance(Geometry g, double maxDistance);
}
public class NetTopologySuite.Operation.Distance3D.AxisPlaneCoordinateSequence : CoordinateSequence {
    private static Int32[] XYIndex;
    private static Int32[] XZIndex;
    private static Int32[] YZIndex;
    private CoordinateSequence _seq;
    private Int32[] _indexMap;
    private AxisPlaneCoordinateSequence(CoordinateSequence seq, Int32[] indexMap);
    private static AxisPlaneCoordinateSequence();
    public static CoordinateSequence ProjectToXY(CoordinateSequence seq);
    public static CoordinateSequence ProjectToXZ(CoordinateSequence seq);
    public static CoordinateSequence ProjectToYZ(CoordinateSequence seq);
    public virtual Coordinate CreateCoordinate();
    public virtual Coordinate GetCoordinate(int i);
    public virtual Coordinate GetCoordinateCopy(int i);
    public virtual void GetCoordinate(int index, Coordinate coord);
    public virtual double GetX(int index);
    public virtual double GetY(int index);
    public virtual double GetZ(int index);
    public virtual double GetM(int index);
    public virtual double GetOrdinate(int index, int ordinateIndex);
    public virtual void SetOrdinate(int index, int ordinateIndex, double value);
    public virtual Coordinate[] ToCoordinateArray();
    public virtual Envelope ExpandEnvelope(Envelope env);
    public virtual CoordinateSequence Copy();
    public virtual CoordinateSequence Reversed();
}
public class NetTopologySuite.Operation.Distance3D.Distance3DOp : object {
    private Geometry[] _geom;
    private double _terminateDistance;
    private GeometryLocation[] _minDistanceLocation;
    private double _minDistance;
    private bool _isDone;
    public Distance3DOp(Geometry g0, Geometry g1);
    public Distance3DOp(Geometry g0, Geometry g1, double terminateDistance);
    public static double Distance(Geometry g0, Geometry g1);
    public static bool IsWithinDistance(Geometry g0, Geometry g1, double distance);
    public static Coordinate[] NearestPoints(Geometry g0, Geometry g1);
    public double Distance();
    public Coordinate[] NearestPoints();
    public GeometryLocation[] NearestLocations();
    private void UpdateDistance(double dist, GeometryLocation loc0, GeometryLocation loc1, bool flip);
    private void ComputeMinDistance();
    private int MostPolygonalIndex();
    private void ComputeMinDistanceMultiMulti(Geometry g0, Geometry g1, bool flip);
    private void ComputeMinDistanceOneMulti(Geometry g0, Geometry g1, bool flip);
    private void ComputeMinDistanceOneMulti(PlanarPolygon3D poly, Geometry geom, bool flip);
    private static PlanarPolygon3D PolyPlane(Geometry poly);
    private void ComputeMinDistance(Geometry g0, Geometry g1, bool flip);
    private void ComputeMinDistancePolygonPolygon(PlanarPolygon3D poly0, Polygon poly1, bool flip);
    private void ComputeMinDistancePolygonRings(PlanarPolygon3D poly, Polygon ringPoly, bool flip);
    private void ComputeMinDistancePolygonLine(PlanarPolygon3D poly, LineString line, bool flip);
    private static Coordinate Intersection(PlanarPolygon3D poly, LineString line);
    private void ComputeMinDistancePolygonPoint(PlanarPolygon3D polyPlane, Point point, bool flip);
    private void ComputeMinDistanceLineLine(LineString line0, LineString line1, bool flip);
    private void ComputeMinDistanceLinePoint(LineString line, Point point, bool flip);
    private void ComputeMinDistancePointPoint(Point point0, Point point1, bool flip);
    private static Coordinate SegmentPoint(Coordinate p0, Coordinate p1, double d0, double d1);
}
public class NetTopologySuite.Operation.Distance3D.PlanarPolygon3D : object {
    private Plane3D _plane;
    private Polygon _poly;
    private Plane _facingPlane;
    public Plane3D Plane { get; }
    public Polygon Polygon { get; }
    public PlanarPolygon3D(Polygon poly);
    private static Plane3D FindBestFitPlane(Polygon poly);
    private static Vector3D AverageNormal(CoordinateSequence seq);
    private static Coordinate AveragePoint(CoordinateSequence seq);
    public Plane3D get_Plane();
    public Polygon get_Polygon();
    public bool Intersects(Coordinate intPt);
    private Location Locate(Coordinate pt, LineString ring);
    public bool Intersects(Coordinate pt, LineString ring);
    private static CoordinateSequence Project(CoordinateSequence seq, Plane facingPlane);
    private static Coordinate Project(Coordinate p, Plane facingPlane);
}
public class NetTopologySuite.Operation.GeometryGraphOperation : object {
    private LineIntersector _li;
    protected PrecisionModel resultPrecisionModel;
    protected GeometryGraph[] arg;
    protected LineIntersector lineIntersector { get; protected set; }
    protected PrecisionModel ComputationPrecision { get; protected set; }
    public GeometryGraphOperation(Geometry g0, Geometry g1);
    public GeometryGraphOperation(Geometry g0, Geometry g1, IBoundaryNodeRule boundaryNodeRule);
    public GeometryGraphOperation(Geometry g0);
    protected LineIntersector get_lineIntersector();
    protected void set_lineIntersector(LineIntersector value);
    public Geometry GetArgGeometry(int i);
    protected PrecisionModel get_ComputationPrecision();
    protected void set_ComputationPrecision(PrecisionModel value);
}
[ObsoleteAttribute("Replaced by NetTopologySuite.Operation.Valid.IsSimpleOp")]
public class NetTopologySuite.Operation.IsSimpleOp : object {
    private Geometry _inputGeom;
    private bool _isClosedEndpointsInInterior;
    private Coordinate _nonSimpleLocation;
    public Coordinate NonSimpleLocation { get; }
    public IsSimpleOp(Geometry geom);
    public IsSimpleOp(Geometry geom, IBoundaryNodeRule boundaryNodeRule);
    public bool IsSimple();
    private bool ComputeSimple(Geometry geom);
    public Coordinate get_NonSimpleLocation();
    private bool IsSimpleMultiPoint(MultiPoint mp);
    private bool IsSimplePolygonal(Geometry geom);
    private bool IsSimpleGeometryCollection(Geometry geom);
    private bool IsSimpleLinearGeometry(Geometry geom);
    private bool HasNonEndpointIntersection(GeometryGraph graph);
    private bool HasClosedEndpointIntersection(GeometryGraph graph);
    private static void AddEndpoint(IDictionary`2<Coordinate, EndpointInfo> endPoints, Coordinate p, bool isClosed);
}
public class NetTopologySuite.Operation.Linemerge.EdgeString : object {
    private GeometryFactory factory;
    private List`1<LineMergeDirectedEdge> directedEdges;
    private Coordinate[] coordinates;
    private Coordinate[] Coordinates { get; }
    public EdgeString(GeometryFactory factory);
    public void Add(LineMergeDirectedEdge directedEdge);
    private Coordinate[] get_Coordinates();
    public LineString ToLineString();
}
public class NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge : DirectedEdge {
    public LineMergeDirectedEdge Next { get; }
    public LineMergeDirectedEdge(Node from, Node to, Coordinate directionPt, bool edgeDirection);
    public LineMergeDirectedEdge get_Next();
}
public class NetTopologySuite.Operation.Linemerge.LineMergeEdge : Edge {
    private LineString line;
    public LineString Line { get; }
    public LineMergeEdge(LineString line);
    public LineString get_Line();
}
public class NetTopologySuite.Operation.Linemerge.LineMergeGraph : PlanarGraph {
    public void AddEdge(LineString lineString);
    private Node GetNode(Coordinate coordinate);
}
public class NetTopologySuite.Operation.Linemerge.LineMerger : object {
    private LineMergeGraph _graph;
    private List`1<Geometry> _mergedLineStrings;
    private List`1<EdgeString> _edgeStrings;
    private GeometryFactory _factory;
    public void Add(Geometry geometry);
    public void Add(IEnumerable`1<Geometry> geometries);
    private void Add(LineString lineString);
    private void Merge();
    private void BuildEdgeStringsForObviousStartNodes();
    private void BuildEdgeStringsForIsolatedLoops();
    private void BuildEdgeStringsForUnprocessedNodes();
    private void BuildEdgeStringsForNonDegree2Nodes();
    private void BuildEdgeStringsStartingAt(Node node);
    private EdgeString BuildEdgeStringStartingWith(LineMergeDirectedEdge start);
    public IList`1<Geometry> GetMergedLineStrings();
}
public class NetTopologySuite.Operation.Linemerge.LineSequencer : object {
    private LineMergeGraph _graph;
    private GeometryFactory _factory;
    private Geometry _sequencedGeometry;
    private int _lineCount;
    private bool _isRun;
    private bool _isSequenceable;
    public static bool IsSequenced(Geometry geom);
    public void Add(IEnumerable`1<Geometry> geometries);
    public void Add(Geometry geometry);
    internal void AddLine(LineString lineString);
    public bool IsSequenceable();
    public Geometry GetSequencedLineStrings();
    private void ComputeSequence();
    private IList`1<IEnumerable`1<DirectedEdge>> FindSequences();
    private static bool HasSequence(Subgraph graph);
    private static IEnumerable`1<DirectedEdge> FindSequence(Subgraph graph);
    private static DirectedEdge FindUnvisitedBestOrientedDE(Node node);
    private static LinkedListNode`1<DirectedEdge> AddReverseSubpath(DirectedEdge de, LinkedListNode`1<DirectedEdge> pos, LinkedList`1<DirectedEdge> list, bool expectedClosed);
    private static Node FindLowestDegreeNode(Subgraph graph);
    private static List`1<DirectedEdge> Orient(LinkedList`1<DirectedEdge> seq);
    private static List`1<DirectedEdge> Reverse(IEnumerable`1<DirectedEdge> seq);
    private Geometry BuildSequencedGeometry(IEnumerable`1<IEnumerable`1<DirectedEdge>> sequences);
    private static LineString Reverse(LineString line);
}
public class NetTopologySuite.Operation.Overlay.EdgeSetNoder : object {
    private LineIntersector _li;
    private List`1<Edge> _inputEdges;
    public IList`1<Edge> NodedEdges { get; }
    public EdgeSetNoder(LineIntersector li);
    public void AddEdges(IEnumerable`1<Edge> edges);
    public IList`1<Edge> get_NodedEdges();
}
public class NetTopologySuite.Operation.Overlay.LineBuilder : object {
    private OverlayOp _op;
    private GeometryFactory _geometryFactory;
    private PointLocator _ptLocator;
    private List`1<Edge> _lineEdgesList;
    private List`1<Geometry> _resultLineList;
    public LineBuilder(OverlayOp op, GeometryFactory geometryFactory, PointLocator ptLocator);
    public IList`1<Geometry> Build(SpatialFunction opCode);
    private void FindCoveredLineEdges();
    private void CollectLines(SpatialFunction opCode);
    public void CollectLineEdge(DirectedEdge de, SpatialFunction opCode, IList`1<Edge> edges);
    public void CollectBoundaryTouchEdge(DirectedEdge de, SpatialFunction opCode, IList`1<Edge> edges);
    private void BuildLines(SpatialFunction opCode);
    private void LabelIsolatedLines(IEnumerable`1<Edge> edgesList);
    private void LabelIsolatedLine(Edge e, int targetIndex);
}
public class NetTopologySuite.Operation.Overlay.MaximalEdgeRing : EdgeRing {
    public MaximalEdgeRing(DirectedEdge start, GeometryFactory geometryFactory);
    public virtual DirectedEdge GetNext(DirectedEdge de);
    public virtual void SetEdgeRing(DirectedEdge de, EdgeRing er);
    public void LinkDirectedEdgesForMinimalEdgeRings();
    public IList`1<EdgeRing> BuildMinimalRings();
}
public class NetTopologySuite.Operation.Overlay.MinimalEdgeRing : EdgeRing {
    public MinimalEdgeRing(DirectedEdge start, GeometryFactory geometryFactory);
    public virtual DirectedEdge GetNext(DirectedEdge de);
    public virtual void SetEdgeRing(DirectedEdge de, EdgeRing er);
}
public class NetTopologySuite.Operation.Overlay.OverlayNodeFactory : NodeFactory {
    public virtual Node CreateNode(Coordinate coord);
}
public class NetTopologySuite.Operation.Overlay.OverlayOp : GeometryGraphOperation {
    [CompilerGeneratedAttribute]
private static bool <NodingValidatorDisabled>k__BackingField;
    private PointLocator _ptLocator;
    private GeometryFactory _geomFact;
    private Geometry _resultGeom;
    private PlanarGraph _graph;
    private EdgeList _edgeList;
    private IList`1<Geometry> _resultPolyList;
    private IList`1<Geometry> _resultLineList;
    private IList`1<Geometry> _resultPointList;
    public static bool NodingValidatorDisabled { get; public set; }
    public PlanarGraph Graph { get; }
    public OverlayOp(Geometry g0, Geometry g1);
    [CompilerGeneratedAttribute]
public static bool get_NodingValidatorDisabled();
    [CompilerGeneratedAttribute]
public static void set_NodingValidatorDisabled(bool value);
    public static Geometry Overlay(Geometry geom0, Geometry geom1, SpatialFunction opCode);
    public static bool IsResultOfOp(Label label, SpatialFunction overlayOpCode);
    public static bool IsResultOfOp(Location loc0, Location loc1, SpatialFunction overlayOpCode);
    public Geometry GetResultGeometry(SpatialFunction overlayOpCode);
    public PlanarGraph get_Graph();
    private void ComputeOverlay(SpatialFunction opCode);
    private void InsertUniqueEdges(IEnumerable`1<Edge> edges);
    protected void InsertUniqueEdge(Edge e);
    private void ComputeLabelsFromDepths();
    private void ReplaceCollapsedEdges();
    private void CopyPoints(int argIndex);
    private void ComputeLabelling();
    private void MergeSymLabels();
    private void UpdateNodeLabelling();
    private void LabelIncompleteNodes();
    private void LabelIncompleteNode(GraphComponent n, int targetIndex);
    private void FindResultAreaEdges(SpatialFunction opCode);
    private void CancelDuplicateResultEdges();
    public bool IsCoveredByLA(Coordinate coord);
    public bool IsCoveredByA(Coordinate coord);
    private bool IsCovered(Coordinate coord, IEnumerable`1<Geometry> geomList);
    private Geometry ComputeGeometry(IEnumerable`1<Geometry> resultPtList, IEnumerable`1<Geometry> resultLiList, IEnumerable`1<Geometry> resultPlList, SpatialFunction opCode);
    public static Geometry CreateEmptyResult(SpatialFunction overlayOpCode, Geometry a, Geometry b, GeometryFactory geomFact);
    private static Dimension ResultDimension(SpatialFunction opCode, Geometry g0, Geometry g1);
}
public class NetTopologySuite.Operation.Overlay.PointBuilder : object {
    private OverlayOp _op;
    private GeometryFactory _geometryFactory;
    private List`1<Geometry> _resultPointList;
    public PointBuilder(OverlayOp op, GeometryFactory geometryFactory);
    public IList`1<Geometry> Build(SpatialFunction opCode);
    private void ExtractNonCoveredResultNodes(SpatialFunction opCode);
    private void FilterCoveredNodeToPoint(Node n);
}
public class NetTopologySuite.Operation.Overlay.PolygonBuilder : object {
    private GeometryFactory _geometryFactory;
    private List`1<EdgeRing> _shellList;
    public IList`1<Geometry> Polygons { get; }
    public PolygonBuilder(GeometryFactory geometryFactory);
    public void Add(PlanarGraph graph);
    public void Add(IList`1<EdgeEnd> dirEdges, IList`1<Node> nodes);
    public IList`1<Geometry> get_Polygons();
    private List`1<EdgeRing> BuildMaximalEdgeRings(IEnumerable`1<EdgeEnd> dirEdges);
    private List`1<EdgeRing> BuildMinimalEdgeRings(List`1<EdgeRing> maxEdgeRings, IList`1<EdgeRing> shellList, IList`1<EdgeRing> freeHoleList);
    private static EdgeRing FindShell(IEnumerable`1<EdgeRing> minEdgeRings);
    private static void PlacePolygonHoles(EdgeRing shell, IEnumerable`1<EdgeRing> minEdgeRings);
    private static void SortShellsAndHoles(IEnumerable`1<EdgeRing> edgeRings, IList`1<EdgeRing> shellList, IList`1<EdgeRing> freeHoleList);
    private static void PlaceFreeHoles(IList`1<EdgeRing> shellList, IEnumerable`1<EdgeRing> freeHoleList);
    private static EdgeRing FindEdgeRingContaining(EdgeRing testEr, IEnumerable`1<EdgeRing> shellList);
    private IList`1<Geometry> ComputePolygons(IEnumerable`1<EdgeRing> shellList);
}
public class NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper : object {
    private static double SnapPrexisionFactor;
    private Geometry _srcGeom;
    public GeometrySnapper(Geometry g);
    public static double ComputeOverlaySnapTolerance(Geometry g);
    public static double ComputeSizeBasedSnapTolerance(Geometry g);
    public static double ComputeOverlaySnapTolerance(Geometry g0, Geometry g1);
    public static Geometry[] Snap(Geometry g0, Geometry g1, double snapTolerance);
    public static Geometry SnapToSelf(Geometry geom, double snapTolerance, bool cleanResult);
    public Geometry SnapTo(Geometry g, double tolerance);
    public Geometry SnapToSelf(double snapTolerance, bool cleanResult);
    private Coordinate[] ExtractTargetCoordinates(Geometry g);
    private static double ComputeSnapTolerance(Coordinate[] ringPts);
    private static double ComputeMinimumSegmentLength(Coordinate[] pts);
}
public class NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper : object {
    private double _snapTolerance;
    private Coordinate[] _srcPts;
    private LineSegment _seg;
    private bool _allowSnappingToSourceVertices;
    private bool _isClosed;
    public bool AllowSnappingToSourceVertices { get; public set; }
    public LineStringSnapper(LineString srcLine, double snapTolerance);
    public LineStringSnapper(Coordinate[] srcPts, double snapTolerance);
    public bool get_AllowSnappingToSourceVertices();
    public void set_AllowSnappingToSourceVertices(bool value);
    private static bool IsClosed(Coordinate[] pts);
    public Coordinate[] SnapTo(Coordinate[] snapPts);
    private void SnapVertices(CoordinateList srcCoords, Coordinate[] snapPts);
    private Coordinate FindSnapForVertex(Coordinate pt, Coordinate[] snapPts);
    private void SnapSegments(CoordinateList srcCoords, Coordinate[] snapPts);
    private int FindSegmentIndexToSnap(Coordinate snapPt, CoordinateList srcCoords);
}
public class NetTopologySuite.Operation.Overlay.Snap.SnapIfNeededOverlayOp : object {
    private Geometry[] _geom;
    public SnapIfNeededOverlayOp(Geometry g1, Geometry g2);
    public static Geometry Overlay(Geometry g0, Geometry g1, SpatialFunction opCode);
    public static Geometry Intersection(Geometry g0, Geometry g1);
    public static Geometry Union(Geometry g0, Geometry g1);
    public static Geometry Difference(Geometry g0, Geometry g1);
    public static Geometry SymDifference(Geometry g0, Geometry g1);
    public Geometry GetResultGeometry(SpatialFunction opCode);
}
public class NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp : object {
    private Geometry[] _geom;
    private double _snapTolerance;
    private CommonBitsRemover cbr;
    public SnapOverlayOp(Geometry g1, Geometry g2);
    public static Geometry Overlay(Geometry g0, Geometry g1, SpatialFunction opCode);
    public static Geometry Intersection(Geometry g0, Geometry g1);
    public static Geometry Union(Geometry g0, Geometry g1);
    public static Geometry Difference(Geometry g0, Geometry g1);
    public static Geometry SymDifference(Geometry g0, Geometry g1);
    private void ComputeSnapTolerance();
    public Geometry GetResultGeometry(SpatialFunction opCode);
    private Geometry SelfSnap(Geometry geom);
    private Geometry[] Snap(Geometry[] geom);
    private Geometry PrepareResult(Geometry geom);
    private Geometry[] RemoveCommonBits(Geometry[] geom);
}
internal class NetTopologySuite.Operation.Overlay.Snap.SnapTransformer : GeometryTransformer {
    private double _snapTolerance;
    private Coordinate[] _snapPts;
    private bool _isSelfSnap;
    public SnapTransformer(double snapTolerance, Coordinate[] snapPts);
    public SnapTransformer(double snapTolerance, Coordinate[] snapPts, bool isSelfSnap);
    protected virtual CoordinateSequence TransformCoordinates(CoordinateSequence coords, Geometry parent);
    private Coordinate[] SnapLine(Coordinate[] srcPts, Coordinate[] snapPts);
}
public enum NetTopologySuite.Operation.Overlay.SpatialFunction : Enum {
    public int value__;
    public static SpatialFunction Intersection;
    public static SpatialFunction Union;
    public static SpatialFunction Difference;
    public static SpatialFunction SymDifference;
}
public class NetTopologySuite.Operation.Overlay.Validate.FuzzyPointLocator : object {
    private Geometry _g;
    private double _boundaryDistanceTolerance;
    private MultiLineString _linework;
    private PointLocator _ptLocator;
    private LineSegment _seg;
    public FuzzyPointLocator(Geometry g, double boundaryDistanceTolerance);
    public Location GetLocation(Coordinate pt);
    private static MultiLineString ExtractLinework(Geometry g);
    private bool IsWithinToleranceOfBoundary(Coordinate pt);
}
public class NetTopologySuite.Operation.Overlay.Validate.OffsetPointGenerator : object {
    private bool _doLeft;
    private bool _doRight;
    private Geometry _g;
    public OffsetPointGenerator(Geometry g);
    public void SetSidesToGenerate(bool doLeft, bool doRight);
    public List`1<Coordinate> GetPoints(double offsetDistance);
    private void ExtractPoints(LineString line, double offsetDistance, IList`1<Coordinate> offsetPts);
    private void ComputeOffsetPoints(Coordinate p0, Coordinate p1, double offsetDistance, IList`1<Coordinate> offsetPts);
}
public class NetTopologySuite.Operation.Overlay.Validate.OverlayResultValidator : object {
    private static double Tolerance;
    private Geometry[] _geom;
    private FuzzyPointLocator[] _locFinder;
    private Location[] _location;
    private double _boundaryDistanceTolerance;
    private List`1<Coordinate> _testCoords;
    private Coordinate _invalidLocation;
    public Coordinate InvalidLocation { get; }
    public OverlayResultValidator(Geometry a, Geometry b, Geometry result);
    public static bool IsValid(Geometry a, Geometry b, SpatialFunction overlayOp, Geometry result);
    private static double ComputeBoundaryDistanceTolerance(Geometry g0, Geometry g1);
    public bool IsValid(SpatialFunction overlayOp);
    public Coordinate get_InvalidLocation();
    private void AddTestPts(Geometry g);
    private bool CheckValid(SpatialFunction overlayOp);
    private bool CheckValid(SpatialFunction overlayOp, Coordinate pt);
    private static bool HasLocation(Location[] location, Location loc);
    private static bool IsValidResult(SpatialFunction overlayOp, Location[] location);
    private static void ReportResult(SpatialFunction overlayOp, Location[] location, bool expectedInterior);
}
internal class NetTopologySuite.Operation.Overlay.Validate.PolygonalLineworkExtracter : object {
    private List`1<LineString> _linework;
    public List`1<LineString> Linework { get; }
    public sealed virtual void Filter(Geometry g);
    public List`1<LineString> get_Linework();
}
public static class NetTopologySuite.Operation.OverlayNG.CoverageUnion : object {
    public static Geometry Union(Geometry coverage);
}
internal class NetTopologySuite.Operation.OverlayNG.Edge : object {
    private Dimension _aDim;
    private int _aDepthDelta;
    private bool _aIsHole;
    private Dimension _bDim;
    private int _bDepthDelta;
    private bool _bIsHole;
    [CompilerGeneratedAttribute]
private Coordinate[] <Coordinates>k__BackingField;
    public Coordinate[] Coordinates { get; }
    public int Count { get; }
    public bool Direction { get; }
    public Edge(Coordinate[] pts, EdgeSourceInfo info);
    public static bool IsCollapsed(Coordinate[] pts);
    [CompilerGeneratedAttribute]
public Coordinate[] get_Coordinates();
    public Coordinate GetCoordinate(int index);
    public int get_Count();
    public bool get_Direction();
    public bool RelativeDirection(Edge edge);
    public OverlayLabel CreateLabel();
    private static void InitLabel(OverlayLabel lbl, int geomIndex, Dimension dim, int depthDelta, bool isHole);
    private static Dimension LabelDim(Dimension dim, int depthDelta);
    private bool IsShell(int geomIndex);
    private static Location LocationRight(int depthDelta);
    private static Location LocationLeft(int depthDelta);
    private static int DepthDeltaSign(int depthDel);
    private void CopyInfo(EdgeSourceInfo info);
    public void Merge(Edge edge);
    private static bool IsHoleMerged(int geomIndex, Edge edge1, Edge edge2);
    public virtual string ToString();
    public string ToLineString();
    private static string ToStringPts(Coordinate[] pts);
    public static string InfoString(int index, Dimension dim, bool isHole, int depthDelta);
    private static string RingRoleSymbol(Dimension dim, bool isHole);
    private static bool HasAreaParent(Dimension dim);
}
internal class NetTopologySuite.Operation.OverlayNG.EdgeKey : object {
    private double _p0x;
    private double _p0y;
    private double _p1x;
    private double _p1y;
    private EdgeKey(Edge edge);
    public static EdgeKey Create(Edge edge);
    public sealed virtual int CompareTo(EdgeKey ek);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static string Format(double x, double y);
}
internal class NetTopologySuite.Operation.OverlayNG.EdgeMerger : object {
    public static IList`1<Edge> Merge(List`1<Edge> edges);
}
internal class NetTopologySuite.Operation.OverlayNG.EdgeNodingBuilder : object {
    private static int MinLimitPts;
    private static bool IsNodingValidated;
    private PrecisionModel _pm;
    private List`1<ISegmentString> _inputEdges;
    private INoder _customNoder;
    private Envelope _clipEnv;
    private RingClipper _clipper;
    private LineLimiter _limiter;
    private Boolean[] _hasEdges;
    public INoder Noder { get; public set; }
    public Envelope ClipEnvelope { get; public set; }
    public EdgeNodingBuilder(PrecisionModel pm, INoder noder);
    private static INoder CreateFixedPrecisionNoder(PrecisionModel pm);
    private static INoder CreateFloatingPrecisionNoder(bool doValidation);
    public INoder get_Noder();
    public void set_Noder(INoder value);
    public Envelope get_ClipEnvelope();
    public void set_ClipEnvelope(Envelope value);
    public bool HasEdgesFor(int geomIndex);
    public IList`1<Edge> Build(Geometry geom0, Geometry geom1);
    private List`1<Edge> Node(IList`1<ISegmentString> segStrings);
    private List`1<Edge> CreateEdges(IEnumerable`1<ISegmentString> segStrings);
    private void Add(Geometry g, int geomIndex);
    private void AddGeometryCollection(GeometryCollection gc, int geomIndex, Dimension expectedDim);
    private void AddCollection(GeometryCollection gc, int geomIndex);
    private void AddPolygon(Polygon poly, int geomIndex);
    private void AddPolygonRing(LinearRing ring, bool isHole, int index);
    private bool IsClippedCompletely(Envelope env);
    private Coordinate[] Clip(LinearRing ring);
    private static Coordinate[] RemoveRepeatedPoints(LineString line);
    private static int ComputeDepthDelta(LinearRing ring, bool isHole);
    private void AddLine(LineString line, int geomIndex);
    private void AddLine(Coordinate[] pts, int geomIndex);
    private void AddEdge(Coordinate[] pts, EdgeSourceInfo info);
    private bool IsToBeLimited(LineString line);
    private IEnumerable`1<Coordinate[]> Limit(LineString line);
}
internal class NetTopologySuite.Operation.OverlayNG.EdgeSourceInfo : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Dimension <Dimension>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DepthDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHole>k__BackingField;
    public int Index { get; }
    public Dimension Dimension { get; }
    public int DepthDelta { get; }
    public bool IsHole { get; }
    public EdgeSourceInfo(int index, int depthDelta, bool isHole);
    public EdgeSourceInfo(int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Dimension get_Dimension();
    [CompilerGeneratedAttribute]
public int get_DepthDelta();
    [CompilerGeneratedAttribute]
public bool get_IsHole();
    public virtual string ToString();
}
internal class NetTopologySuite.Operation.OverlayNG.ElevationModel : object {
    private static int DEFAULT_CELL_NUM;
    private Envelope _extent;
    private int _numCellX;
    private int _numCellY;
    private double _cellSizeX;
    private double _cellSizeY;
    private ElevationCell[][] _cells;
    private bool _isInitialized;
    private bool _hasZValue;
    private double _averageZ;
    public ElevationModel(Envelope extent, int numCellX, int numCellY);
    public static ElevationModel Create(Geometry geom1, Geometry geom2);
    public void Add(Geometry geom);
    private void Add(double x, double y, double z);
    private void Init();
    public double GetZ(double x, double y);
    public void PopulateZ(Geometry geom);
    private ElevationCell GetCell(double x, double y, bool isCreateIfMissing);
}
internal class NetTopologySuite.Operation.OverlayNG.IndexedPointOnLineLocator : object {
    private Geometry _inputGeom;
    public IndexedPointOnLineLocator(Geometry geomLinear);
    public sealed virtual Location Locate(Coordinate p);
}
internal class NetTopologySuite.Operation.OverlayNG.InputGeometry : object {
    private Geometry[] _geom;
    private IPointOnGeometryLocator _ptLocatorA;
    private IPointOnGeometryLocator _ptLocatorB;
    private Boolean[] _isCollapsed;
    public bool IsSingle { get; }
    public bool IsAllPoints { get; }
    public bool HasPoints { get; }
    public InputGeometry(Geometry geomA, Geometry geomB);
    public bool get_IsSingle();
    public Dimension GetDimension(int index);
    public Geometry GetGeometry(int geomIndex);
    public Envelope GetEnvelope(int geomIndex);
    public bool IsEmpty(int geomIndex);
    public bool IsArea(int geomIndex);
    public int GetAreaIndex();
    public bool IsLine(int geomIndex);
    public bool get_IsAllPoints();
    public bool get_HasPoints();
    public bool HasEdges(int geomIndex);
    public Location LocatePointInArea(int geomIndex, Coordinate pt);
    private IPointOnGeometryLocator GetLocator(int geomIndex);
    public void SetCollapsed(int geomIndex, bool isGeomCollapsed);
}
internal class NetTopologySuite.Operation.OverlayNG.IntersectionPointBuilder : object {
    private GeometryFactory _geometryFactory;
    private OverlayGraph _graph;
    private List`1<Point> _points;
    private bool _isAllowCollapseLines;
    unknown bool StrictMode {public set; }
    public List`1<Point> Points { get; }
    public IntersectionPointBuilder(OverlayGraph graph, GeometryFactory geomFact);
    public void set_StrictMode(bool value);
    public List`1<Point> get_Points();
    private void AddResultPoints();
    private bool IsResultPoint(OverlayEdge nodeEdge);
    private bool IsEdgeOf(OverlayLabel label, int i);
}
internal class NetTopologySuite.Operation.OverlayNG.LineBuilder : object {
    private GeometryFactory _geometryFactory;
    private OverlayGraph _graph;
    private SpatialFunction _opCode;
    private int _inputAreaIndex;
    private bool _hasResultArea;
    private bool _isAllowMixedResult;
    private bool _isAllowCollapseLines;
    private List`1<LineString> _lines;
    unknown bool StrictMode {public set; }
    public LineBuilder(InputGeometry inputGeom, OverlayGraph graph, bool hasResultArea, SpatialFunction opCode, GeometryFactory geomFact);
    public void set_StrictMode(bool value);
    public List`1<LineString> GetLines();
    private void MarkResultLines();
    private bool IsResultLine(OverlayLabel lbl);
    private static Location EffectiveLocation(OverlayLabel lbl, int geomIndex);
    private void AddResultLines();
    private LineString ToLine(OverlayEdge edge);
    private void AddResultLinesMerged();
    private void AddResultLinesForNodes();
    private void AddResultLinesRings();
    private LineString BuildLine(OverlayEdge node);
    private static OverlayEdge NextLineEdgeUnvisited(OverlayEdge node);
    private static int DegreeOfLines(OverlayEdge node);
}
public class NetTopologySuite.Operation.OverlayNG.LineLimiter : object {
    private Envelope _limitEnv;
    private CoordinateList _ptList;
    private Coordinate _lastOutside;
    private List`1<Coordinate[]> _sections;
    public LineLimiter(Envelope env);
    public List`1<Coordinate[]> Limit(IEnumerable`1<Coordinate> pts);
    private void AddPoint(Coordinate p);
    private void AddOutside(Coordinate p);
    private bool IsLastSegmentIntersecting(Coordinate p);
    private bool IsSectionOpen();
    private void StartSection();
    private void FinishSection();
}
internal class NetTopologySuite.Operation.OverlayNG.MaximalEdgeRing : object {
    private static int STATE_FIND_INCOMING;
    private static int STATE_LINK_OUTGOING;
    private OverlayEdge _startEdge;
    private Coordinate[] Coordinates { get; }
    public MaximalEdgeRing(OverlayEdge e);
    public static void LinkResultAreaMaxRingAtNode(OverlayEdge nodeEdge);
    private void AttachEdges(OverlayEdge startEdge);
    public List`1<OverlayEdgeRing> BuildMinimalRings(GeometryFactory geometryFactory);
    private void LinkMinimalRings();
    private static void LinkMinRingEdgesAtNode(OverlayEdge nodeEdge, MaximalEdgeRing maxRing);
    private static bool IsAlreadyLinked(OverlayEdge edge, MaximalEdgeRing maxRing);
    private static OverlayEdge SelectMaxOutEdge(OverlayEdge currOut, MaximalEdgeRing maxEdgeRing);
    private static OverlayEdge LinkMaxInEdge(OverlayEdge currOut, OverlayEdge currMaxRingOut, MaximalEdgeRing maxEdgeRing);
    public virtual string ToString();
    private Coordinate[] get_Coordinates();
}
internal class NetTopologySuite.Operation.OverlayNG.OverlayEdge : HalfEdge {
    [CompilerGeneratedAttribute]
private bool <IsForward>k__BackingField;
    [CompilerGeneratedAttribute]
private Coordinate <DirectionPt>k__BackingField;
    [CompilerGeneratedAttribute]
private OverlayLabel <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Coordinate[] <Coordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInResultArea>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInResultLine>k__BackingField;
    [CompilerGeneratedAttribute]
private OverlayEdge <NextResult>k__BackingField;
    [CompilerGeneratedAttribute]
private OverlayEdge <NextResultMax>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVisited>k__BackingField;
    [CompilerGeneratedAttribute]
private OverlayEdgeRing <EdgeRing>k__BackingField;
    [CompilerGeneratedAttribute]
private MaximalEdgeRing <MaxEdgeRing>k__BackingField;
    public static IComparer`1<OverlayEdge> NodeComparator { get; }
    public bool IsForward { get; }
    protected Coordinate DirectionPt { get; }
    public OverlayLabel Label { get; }
    public Coordinate Coordinate { get; }
    public Coordinate[] Coordinates { get; }
    public Coordinate[] CoordinatesOriented { get; }
    public OverlayEdge SymOE { get; }
    public OverlayEdge ONextOE { get; }
    public bool IsInResultArea { get; private set; }
    public bool IsInResultAreaBoth { get; }
    public bool IsInResultLine { get; private set; }
    public bool IsInResult { get; }
    public bool IsInResultEither { get; }
    public OverlayEdge NextResult { get; public set; }
    public bool IsResultLinked { get; }
    public OverlayEdge NextResultMax { get; public set; }
    public bool IsResultMaxLinked { get; }
    public bool IsVisited { get; public set; }
    public OverlayEdgeRing EdgeRing { get; public set; }
    public MaximalEdgeRing MaxEdgeRing { get; public set; }
    private string ResultSymbol { get; }
    public OverlayEdge(Coordinate orig, Coordinate dirPt, bool direction, OverlayLabel label, Coordinate[] pts);
    public static OverlayEdge CreateEdge(Coordinate[] pts, OverlayLabel lbl, bool direction);
    public static OverlayEdge CreateEdgePair(Coordinate[] pts, OverlayLabel lbl);
    public static IComparer`1<OverlayEdge> get_NodeComparator();
    [CompilerGeneratedAttribute]
public bool get_IsForward();
    [CompilerGeneratedAttribute]
protected virtual Coordinate get_DirectionPt();
    [CompilerGeneratedAttribute]
public OverlayLabel get_Label();
    public Location GetLocation(int index, Position position);
    public Coordinate get_Coordinate();
    [CompilerGeneratedAttribute]
public Coordinate[] get_Coordinates();
    public Coordinate[] get_CoordinatesOriented();
    public void AddCoordinates(CoordinateList coords);
    public OverlayEdge get_SymOE();
    public OverlayEdge get_ONextOE();
    [CompilerGeneratedAttribute]
public bool get_IsInResultArea();
    [CompilerGeneratedAttribute]
private void set_IsInResultArea(bool value);
    public bool get_IsInResultAreaBoth();
    public void UnmarkFromResultAreaBoth();
    public void MarkInResultArea();
    public void MarkInResultAreaBoth();
    [CompilerGeneratedAttribute]
public bool get_IsInResultLine();
    [CompilerGeneratedAttribute]
private void set_IsInResultLine(bool value);
    public void MarkInResultLine();
    public bool get_IsInResult();
    public bool get_IsInResultEither();
    [CompilerGeneratedAttribute]
public OverlayEdge get_NextResult();
    [CompilerGeneratedAttribute]
public void set_NextResult(OverlayEdge value);
    public bool get_IsResultLinked();
    [CompilerGeneratedAttribute]
public OverlayEdge get_NextResultMax();
    [CompilerGeneratedAttribute]
public void set_NextResultMax(OverlayEdge value);
    public bool get_IsResultMaxLinked();
    [CompilerGeneratedAttribute]
public bool get_IsVisited();
    [CompilerGeneratedAttribute]
public void set_IsVisited(bool value);
    public void MarkVisitedBoth();
    [CompilerGeneratedAttribute]
public OverlayEdgeRing get_EdgeRing();
    [CompilerGeneratedAttribute]
public void set_EdgeRing(OverlayEdgeRing value);
    [CompilerGeneratedAttribute]
public MaximalEdgeRing get_MaxEdgeRing();
    [CompilerGeneratedAttribute]
public void set_MaxEdgeRing(MaximalEdgeRing value);
    public virtual string ToString();
    private string get_ResultSymbol();
}
internal class NetTopologySuite.Operation.OverlayNG.OverlayEdgeRing : object {
    private IndexedPointInAreaLocator _locator;
    private OverlayEdgeRing _shell;
    private List`1<OverlayEdgeRing> _holes;
    [CompilerGeneratedAttribute]
private LinearRing <Ring>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHole>k__BackingField;
    [CompilerGeneratedAttribute]
private Coordinate[] <Coordinates>k__BackingField;
    [CompilerGeneratedAttribute]
private OverlayEdge <Edge>k__BackingField;
    public LinearRing Ring { get; private set; }
    public bool IsHole { get; private set; }
    public bool HasShell { get; }
    public OverlayEdgeRing Shell { get; public set; }
    private Coordinate[] Coordinates { get; }
    public Coordinate Coordinate { get; }
    public OverlayEdge Edge { get; }
    public OverlayEdgeRing(OverlayEdge start, GeometryFactory geometryFactory);
    [CompilerGeneratedAttribute]
public LinearRing get_Ring();
    [CompilerGeneratedAttribute]
private void set_Ring(LinearRing value);
    [CompilerGeneratedAttribute]
public bool get_IsHole();
    [CompilerGeneratedAttribute]
private void set_IsHole(bool value);
    public bool get_HasShell();
    public OverlayEdgeRing get_Shell();
    public void set_Shell(OverlayEdgeRing value);
    public void AddHole(OverlayEdgeRing ring);
    private Coordinate[] ComputeRingPts(OverlayEdge start);
    private void ComputeRing(Coordinate[] ringPts, GeometryFactory geometryFactory);
    [CompilerGeneratedAttribute]
private Coordinate[] get_Coordinates();
    public OverlayEdgeRing FindEdgeRingContaining(IEnumerable`1<OverlayEdgeRing> erList);
    private IPointOnGeometryLocator GetLocator();
    public bool IsInRing(Coordinate pt);
    public Coordinate get_Coordinate();
    public Polygon ToPolygon(GeometryFactory factory);
    [CompilerGeneratedAttribute]
public OverlayEdge get_Edge();
}
internal class NetTopologySuite.Operation.OverlayNG.OverlayGraph : object {
    private Dictionary`2<Coordinate, OverlayEdge> _nodeMap;
    [CompilerGeneratedAttribute]
private List`1<OverlayEdge> <Edges>k__BackingField;
    public List`1<OverlayEdge> Edges { get; }
    public IReadOnlyCollection`1<OverlayEdge> NodeEdges { get; }
    [CompilerGeneratedAttribute]
public List`1<OverlayEdge> get_Edges();
    public IReadOnlyCollection`1<OverlayEdge> get_NodeEdges();
    public OverlayEdge GetNodeEdge(Coordinate nodePt);
    public IReadOnlyCollection`1<OverlayEdge> GetResultAreaEdges();
    public OverlayEdge AddEdge(Coordinate[] pts, OverlayLabel label);
    private void Insert(OverlayEdge e);
}
internal class NetTopologySuite.Operation.OverlayNG.OverlayLabel : object {
    private static char SYM_UNKNOWN;
    private static char SYM_BOUNDARY;
    private static char SYM_COLLAPSE;
    private static char SYM_LINE;
    public static Dimension DIM_UNKNOWN;
    public static Dimension DIM_NOT_PART;
    public static Dimension DIM_LINE;
    public static Dimension DIM_BOUNDARY;
    public static Dimension DIM_COLLAPSE;
    public static Location LOC_UNKNOWN;
    private Dimension _aDim;
    private bool _aIsHole;
    private Location _aLocLeft;
    private Location _aLocRight;
    private Location _aLocLine;
    private Dimension _bDim;
    private bool _bIsHole;
    private Location _bLocLeft;
    private Location _bLocRight;
    private Location _bLocLine;
    public bool IsLine { get; }
    public bool IsBoundaryEither { get; }
    public bool IsBoundaryBoth { get; }
    public bool IsBoundaryCollapse { get; }
    public bool IsBoundaryTouch { get; }
    public bool IsBoundarySingleton { get; }
    public bool IsInteriorCollapse { get; }
    public bool IsCollapseAndNotPartInterior { get; }
    public OverlayLabel(int index, Location locLeft, Location locRight, bool isHole);
    public OverlayLabel(int index);
    public OverlayLabel(OverlayLabel lbl);
    public Dimension Dimension(int index);
    public void InitBoundary(int index, Location locLeft, Location locRight, bool isHole);
    public void InitCollapse(int index, bool isHole);
    public void InitLine(int index);
    public void InitNotPart(int index);
    public void SetLocationLine(int index, Location loc);
    public void SetLocationAll(int index, Location loc);
    public void SetLocationCollapse(int index);
    public bool get_IsLine();
    public bool IsLineAt(int index);
    public bool IsLinear(int index);
    public bool IsKnown(int index);
    public bool IsNotPart(int index);
    public bool get_IsBoundaryEither();
    public bool get_IsBoundaryBoth();
    public bool get_IsBoundaryCollapse();
    public bool get_IsBoundaryTouch();
    public bool IsBoundary(int index);
    public bool get_IsBoundarySingleton();
    public bool IsLineLocationUnknown(int index);
    public bool IsLineInArea(int index);
    public bool IsHole(int index);
    public bool IsCollapse(int index);
    public bool get_IsInteriorCollapse();
    public bool get_IsCollapseAndNotPartInterior();
    public Location GetLineLocation(int index);
    public bool IsLineInterior(int index);
    public Location GetLocation(int index, Position position, bool isForward);
    public Location GetLocationBoundaryOrLine(int index, Position position, bool isForward);
    public Location GetLocation(int index);
    public bool HasSides(int index);
    public OverlayLabel Copy();
    public virtual string ToString();
    public string ToString(bool isForward);
    private string LocationString(int index, bool isForward);
    public static char RingRoleSymbol(bool isHole);
    public static char DimensionSymbol(Dimension dim);
}
internal class NetTopologySuite.Operation.OverlayNG.OverlayLabeller : object {
    private OverlayGraph _graph;
    private InputGeometry _inputGeometry;
    private IList`1<OverlayEdge> _edges;
    public OverlayLabeller(OverlayGraph graph, InputGeometry inputGeometry);
    public void ComputeLabelling();
    private void LabelAreaNodeEdges(IEnumerable`1<OverlayEdge> nodes);
    public void PropagateAreaLocations(OverlayEdge nodeEdge, int geomIndex);
    private static OverlayEdge FindPropagationStartEdge(OverlayEdge nodeEdge, int geomIndex);
    private void LabelCollapsedEdges();
    private void LabelCollapsedEdge(OverlayEdge edge, int geomIndex);
    private void LabelConnectedLinearEdges();
    private void PropagateLinearLocations(int geomIndex);
    private static void PropagateLinearLocationAtNode(OverlayEdge eNode, int geomIndex, bool isInputLine, Stack`1<OverlayEdge> edgeStack);
    private static List`1<OverlayEdge> FindLinearEdgesWithLocation(IEnumerable`1<OverlayEdge> edges, int geomIndex);
    private void LabelDisconnectedEdges();
    private void LabelDisconnectedEdge(OverlayEdge edge, int geomIndex);
    private Location LocateEdge(int geomIndex, OverlayEdge edge);
    private Location LocateEdgeBothEnds(int geomIndex, OverlayEdge edge);
    public void MarkResultAreaEdges(SpatialFunction overlayOpCode);
    public void MarkInResultArea(OverlayEdge e, SpatialFunction overlayOpCode);
    public void UnmarkDuplicateEdgesFromResultArea();
    public static string ToString(OverlayEdge nodeEdge);
}
internal class NetTopologySuite.Operation.OverlayNG.OverlayMixedPoints : object {
    private SpatialFunction _opCode;
    private PrecisionModel _pm;
    private Geometry _geomPoint;
    private Geometry _geomNonPointInput;
    private GeometryFactory _geometryFactory;
    private bool _isPointRhs;
    private Geometry _geomNonPoint;
    private Dimension _geomNonPointDim;
    private IPointOnGeometryLocator _locator;
    private Dimension _resultDim;
    public OverlayMixedPoints(SpatialFunction opCode, Geometry geom0, Geometry geom1, PrecisionModel pm);
    public static Geometry Overlay(SpatialFunction opCode, Geometry geom0, Geometry geom1, PrecisionModel pm);
    public Geometry GetResult();
    private IPointOnGeometryLocator CreateLocator(Geometry geomNonPoint);
    private Geometry PrepareNonPoint(Geometry geomInput);
    private Geometry ComputeIntersection(Coordinate[] coords);
    private Geometry ComputeUnion(Coordinate[] coords);
    private Geometry ComputeDifference(Coordinate[] coords);
    private Geometry CreatePointResult(IReadOnlyCollection`1<Point> points);
    private List`1<Point> FindPoints(bool isCovered, IEnumerable`1<Coordinate> coords);
    private List`1<Point> CreatePoints(IEnumerable`1<Coordinate> coords);
    private bool HasLocation(bool isCovered, Coordinate coord);
    private Geometry CopyNonPoint();
    private static Coordinate[] ExtractCoordinates(Geometry points, PrecisionModel pm);
    private static List`1<Polygon> ExtractPolygons(Geometry geom);
    private static List`1<LineString> ExtractLines(Geometry geom);
}
public class NetTopologySuite.Operation.OverlayNG.OverlayNG : object {
    public static SpatialFunction INTERSECTION;
    public static SpatialFunction UNION;
    public static SpatialFunction DIFFERENCE;
    public static SpatialFunction SYMDIFFERENCE;
    internal static bool STRICT_MODE_DEFAULT;
    private SpatialFunction _opCode;
    private InputGeometry _inputGeom;
    private GeometryFactory _geomFact;
    private PrecisionModel _pm;
    private bool _isOutputNodedEdges;
    [CompilerGeneratedAttribute]
private bool <StrictMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Optimized>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreaResultOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputEdges>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputResultEdges>k__BackingField;
    [CompilerGeneratedAttribute]
private INoder <Noder>k__BackingField;
    public bool StrictMode { get; public set; }
    public bool Optimized { get; public set; }
    public bool AreaResultOnly { get; public set; }
    [EditorBrowsableAttribute("2")]
public bool OutputEdges { get; public set; }
    [EditorBrowsableAttribute("2")]
public bool OutputNodedEdges { get; public set; }
    [EditorBrowsableAttribute("2")]
public bool OutputResultEdges { get; public set; }
    public INoder Noder { get; public set; }
    public OverlayNG(Geometry geom0, Geometry geom1, PrecisionModel pm, SpatialFunction opCode);
    public OverlayNG(Geometry geom0, Geometry geom1, SpatialFunction opCode);
    internal OverlayNG(Geometry geom, PrecisionModel pm);
    private static bool IsResultOfOpPoint(OverlayLabel label, SpatialFunction opCode);
    internal static bool IsResultOfOp(SpatialFunction overlayOpCode, Location loc0, Location loc1);
    public static Geometry Overlay(Geometry geom0, Geometry geom1, SpatialFunction opCode, PrecisionModel pm);
    public static Geometry Overlay(Geometry geom0, Geometry geom1, SpatialFunction opCode, PrecisionModel pm, INoder noder);
    public static Geometry Overlay(Geometry geom0, Geometry geom1, SpatialFunction opCode, INoder noder);
    public static Geometry Overlay(Geometry geom0, Geometry geom1, SpatialFunction opCode);
    internal static Geometry Union(Geometry geom, PrecisionModel pm);
    internal static Geometry Union(Geometry geom, PrecisionModel pm, INoder noder);
    [CompilerGeneratedAttribute]
public bool get_StrictMode();
    [CompilerGeneratedAttribute]
public void set_StrictMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_Optimized();
    [CompilerGeneratedAttribute]
public void set_Optimized(bool value);
    [CompilerGeneratedAttribute]
public bool get_AreaResultOnly();
    [CompilerGeneratedAttribute]
public void set_AreaResultOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_OutputEdges();
    [CompilerGeneratedAttribute]
public void set_OutputEdges(bool value);
    public bool get_OutputNodedEdges();
    public void set_OutputNodedEdges(bool value);
    [CompilerGeneratedAttribute]
public bool get_OutputResultEdges();
    [CompilerGeneratedAttribute]
public void set_OutputResultEdges(bool value);
    [CompilerGeneratedAttribute]
public INoder get_Noder();
    [CompilerGeneratedAttribute]
public void set_Noder(INoder value);
    public Geometry GetResult();
    private Geometry ComputeEdgeOverlay();
    private IList`1<Edge> NodeEdges();
    private OverlayGraph BuildGraph(IEnumerable`1<Edge> edges);
    private void LabelGraph(OverlayGraph graph);
    private Geometry ExtractResult(SpatialFunction opCode, OverlayGraph graph);
    private static bool IsEmpty(IReadOnlyCollection`1<T> self);
    private Geometry CreateEmptyResult();
}
public class NetTopologySuite.Operation.OverlayNG.OverlayNGRobust : object {
    private static UnionStrategy OverlayUnionStrategy;
    private static int NUM_SNAP_TRIES;
    private static double SnapTolFactor;
    private static OverlayNGRobust();
    public static Geometry Union(Geometry geom);
    public static Geometry Union(IEnumerable`1<Geometry> geoms);
    public static Geometry Union(IEnumerable`1<Geometry> geoms, GeometryFactory geomFact);
    public static Geometry Overlay(Geometry geom0, Geometry geom1, SpatialFunction opCode);
    private static Geometry OverlaySnapTries(Geometry geom0, Geometry geom1, SpatialFunction opCode);
    private static Geometry OverlaySnapping(Geometry geom0, Geometry geom1, SpatialFunction opCode, double snapTol);
    private static Geometry OverlaySnapBoth(Geometry geom0, Geometry geom1, SpatialFunction opCode, double snapTol);
    private static Geometry SnapSelf(Geometry geom, double snapTol);
    private static Geometry OverlaySnapTol(Geometry geom0, Geometry geom1, SpatialFunction opCode, double snapTol);
    private static double SnapTolerance(Geometry geom0, Geometry geom1);
    private static double SnapTolerance(Geometry geom);
    private static double OrdinateMagnitude(Geometry geom);
    public static Geometry OverlaySR(Geometry geom0, Geometry geom1, SpatialFunction opCode);
}
internal class NetTopologySuite.Operation.OverlayNG.OverlayPoints : object {
    private SpatialFunction _opCode;
    private Geometry _geom0;
    private Geometry _geom1;
    private PrecisionModel _pm;
    private GeometryFactory _geometryFactory;
    private List`1<Point> _resultList;
    public OverlayPoints(SpatialFunction opCode, Geometry geom0, Geometry geom1, PrecisionModel pm);
    public static Geometry Overlay(SpatialFunction opCode, Geometry geom0, Geometry geom1, PrecisionModel pm);
    public Geometry GetResult();
    private void ComputeIntersection(Dictionary`2<Coordinate, Point> map0, Dictionary`2<Coordinate, Point> map1, List`1<Point> resultList);
    private void ComputeDifference(Dictionary`2<Coordinate, Point> map0, Dictionary`2<Coordinate, Point> map1, List`1<Point> resultList);
    private void ComputeUnion(Dictionary`2<Coordinate, Point> map0, Dictionary`2<Coordinate, Point> map1, List`1<Point> resultList);
    private Point CopyPoint(Point pt);
    private Dictionary`2<Coordinate, Point> BuildPointMap(Geometry geom);
    private static Coordinate RoundCoord(Point pt, PrecisionModel pm);
}
internal static class NetTopologySuite.Operation.OverlayNG.OverlayUtility : object {
    private static double SafeEnvBufferFactor;
    private static double SafeEnvGridFactor;
    private static double AreaHeuristicTolerance;
    internal static bool IsFloating(PrecisionModel pm);
    internal static Envelope ClippingEnvelope(SpatialFunction opCode, InputGeometry inputGeom, PrecisionModel pm);
    private static Envelope ResultEnvelope(SpatialFunction opCode, InputGeometry inputGeom, PrecisionModel pm);
    private static Envelope SafeEnv(Envelope env, PrecisionModel pm);
    private static double SafeExpandDistance(Envelope env, PrecisionModel pm);
    internal static bool IsEmptyResult(SpatialFunction opCode, Geometry a, Geometry b, PrecisionModel pm);
    private static bool IsEmpty(Geometry geom);
    private static bool IsEnvDisjoint(Geometry a, Geometry b, PrecisionModel pm);
    private static bool IsDisjoint(Envelope envA, Envelope envB, PrecisionModel pm);
    internal static Geometry CreateEmptyResult(Dimension dim, GeometryFactory geomFact);
    internal static Dimension ResultDimension(SpatialFunction opCode, Dimension dim0, Dimension dim1);
    internal static Geometry CreateResultGeometry(IEnumerable`1<Polygon> resultPolyList, IEnumerable`1<LineString> resultLineList, IEnumerable`1<Point> resultPointList, GeometryFactory geometryFactory);
    internal static Geometry ToLines(OverlayGraph graph, bool isOutputEdges, GeometryFactory geomFact);
    private static string LabelForResult(OverlayEdge edge);
    public static Coordinate Round(Point pt, PrecisionModel pm);
    public static bool IsResultAreaConsistent(Geometry geom0, Geometry geom1, SpatialFunction opCode, Geometry result);
    private static bool IsLess(double v1, double v2, double tol);
    private static bool IsGreater(double v1, double v2, double tol);
}
internal class NetTopologySuite.Operation.OverlayNG.PolygonBuilder : object {
    private GeometryFactory _geometryFactory;
    private List`1<OverlayEdgeRing> _shellList;
    private List`1<OverlayEdgeRing> _freeHoleList;
    private bool _isEnforcePolygonal;
    public PolygonBuilder(IReadOnlyCollection`1<OverlayEdge> resultAreaEdges, GeometryFactory geomFact);
    public PolygonBuilder(IReadOnlyCollection`1<OverlayEdge> resultAreaEdges, GeometryFactory geomFact, bool isEnforcePolygonal);
    public IReadOnlyList`1<Polygon> GetPolygons();
    public IReadOnlyList`1<OverlayEdgeRing> GetShellRings();
    private List`1<Polygon> ComputePolygons(IEnumerable`1<OverlayEdgeRing> shellList);
    private void BuildRings(IReadOnlyCollection`1<OverlayEdge> resultAreaEdges);
    private void LinkResultAreaEdgesMax(IEnumerable`1<OverlayEdge> resultEdges);
    private static List`1<MaximalEdgeRing> BuildMaximalRings(IEnumerable`1<OverlayEdge> edges);
    private void BuildMinimalRings(IEnumerable`1<MaximalEdgeRing> maxRings);
    private void AssignShellsAndHoles(List`1<OverlayEdgeRing> minRings);
    private OverlayEdgeRing FindSingleShell(IEnumerable`1<OverlayEdgeRing> edgeRings);
    private static void AssignHoles(OverlayEdgeRing shell, IEnumerable`1<OverlayEdgeRing> edgeRings);
    private void PlaceFreeHoles(IReadOnlyCollection`1<OverlayEdgeRing> shellList, IEnumerable`1<OverlayEdgeRing> freeHoleList);
}
public static class NetTopologySuite.Operation.OverlayNG.PrecisionReducer : object {
    public static Geometry ReducePrecision(Geometry geom, PrecisionModel pm);
}
public static class NetTopologySuite.Operation.OverlayNG.PrecisionUtility : object {
    public static int MAX_ROBUST_DP_DIGITS;
    private static PrecisionUtility();
    public static double SafeScale(double value);
    public static double SafeScale(Geometry geom);
    public static double SafeScale(Geometry a, Geometry b);
    private static double MaxBoundMagnitude(Envelope env);
    private static double PrecisionScale(double value, int precisionDigits);
    public static double InherentScale(double value);
    public static double InherentScale(Geometry geom);
    public static double InherentScale(Geometry a, Geometry b);
    private static int NumberOfDecimals(double value);
    private static int NumberOfDecimalsSlow(double value);
    public static PrecisionModel RobustPM(Geometry a);
    public static double RobustScale(Geometry a, Geometry b);
    public static double RobustScale(Geometry a);
    private static double RobustScale(double inherentScale, double safeScale);
}
public class NetTopologySuite.Operation.OverlayNG.RingClipper : object {
    private static int BoxLeft;
    private static int BoxTop;
    private static int BoxRight;
    private static int BoxBottom;
    private double _clipEnvMinY;
    private double _clipEnvMaxY;
    private double _clipEnvMinX;
    private double _clipEnvMaxX;
    public RingClipper(Envelope clipEnv);
    public Coordinate[] Clip(Coordinate[] pts);
    private Coordinate[] ClipToBoxEdge(Coordinate[] pts, int edgeIndex, bool closeRing);
    private Coordinate Intersection(Coordinate a, Coordinate b, int edgeIndex);
    private static double IntersectionLineY(Coordinate a, Coordinate b, double y);
    private static double IntersectionLineX(Coordinate a, Coordinate b, double x);
    private bool IsInsideEdge(Coordinate p, int edgeIndex);
}
internal class NetTopologySuite.Operation.OverlayNG.RobustClipEnvelopeComputer : object {
    private Envelope _targetEnv;
    private Envelope _clipEnv;
    public Envelope Envelope { get; }
    public RobustClipEnvelopeComputer(Envelope targetEnv);
    public static Envelope GetEnvelope(Geometry a, Geometry b, Envelope targetEnv);
    public Envelope get_Envelope();
    public void Add(Geometry g);
    private void AddCollection(GeometryCollection gc);
    private void AddPolygon(Polygon poly);
    private void AddPolygonRing(LineString ring);
    private void AddSegment(Coordinate p1, Coordinate p2);
    private static bool IntersectsSegment(Envelope env, Coordinate p1, Coordinate p2);
}
public static class NetTopologySuite.Operation.OverlayNG.UnaryUnionNG : object {
    public static Geometry Union(Geometry geom, PrecisionModel pm);
    public static Geometry Union(IEnumerable`1<Geometry> geoms, PrecisionModel pm);
    public static Geometry Union(IEnumerable`1<Geometry> geoms, GeometryFactory geomFact, PrecisionModel pm);
    private static UnionStrategy CreateUnionStrategy(PrecisionModel pm);
}
public class NetTopologySuite.Operation.Polygonize.EdgeRing : object {
    private GeometryFactory _factory;
    private List`1<DirectedEdge> _deList;
    private LinearRing _ring;
    private IndexedPointInAreaLocator locator;
    private Coordinate[] _ringPts;
    private List`1<LinearRing> _holes;
    private EdgeRing _shell;
    private bool _isHole;
    private bool _isProcessed;
    private bool _isIncludedSet;
    private bool _isIncluded;
    public bool IsHole { get; }
    public Polygon Polygon { get; }
    public bool IsValid { get; }
    public bool IsIncludedSet { get; }
    public bool IsIncluded { get; public set; }
    private IPointOnGeometryLocator Locator { get; }
    private Coordinate[] Coordinates { get; }
    public LineString LineString { get; }
    public LinearRing Ring { get; }
    public EdgeRing Shell { get; private set; }
    public bool HasShell { get; }
    public bool IsOuterHole { get; }
    public bool IsOuterShell { get; }
    public EdgeRing OuterHole { get; }
    public bool IsProcessed { get; public set; }
    public EdgeRing(GeometryFactory factory);
    public static EdgeRing FindEdgeRingContaining(EdgeRing testEr, IList`1<EdgeRing> erList);
    public static List`1<DirectedEdge> FindDirEdgesInRing(PolygonizeDirectedEdge startDE);
    public void Build(PolygonizeDirectedEdge startDE);
    private void Add(DirectedEdge de);
    public bool get_IsHole();
    public void ComputeHole();
    public void AddHole(LinearRing hole);
    public void AddHole(EdgeRing holeER);
    public Polygon get_Polygon();
    public bool get_IsValid();
    public bool get_IsIncludedSet();
    public bool get_IsIncluded();
    public void set_IsIncluded(bool value);
    private IPointOnGeometryLocator get_Locator();
    public bool IsInRing(Coordinate pt);
    private Coordinate[] get_Coordinates();
    public LineString get_LineString();
    public LinearRing get_Ring();
    private static void AddEdge(Coordinate[] coords, bool isForward, CoordinateList coordList);
    public EdgeRing get_Shell();
    private void set_Shell(EdgeRing value);
    public bool get_HasShell();
    public bool get_IsOuterHole();
    public bool get_IsOuterShell();
    public EdgeRing get_OuterHole();
    internal void UpdateIncluded();
    public virtual string ToString();
    public bool get_IsProcessed();
    public void set_IsProcessed(bool value);
}
public class NetTopologySuite.Operation.Polygonize.HoleAssigner : object {
    private ISpatialIndex`1<EdgeRing> _shellIndex;
    public HoleAssigner(IEnumerable`1<EdgeRing> shells);
    public static void AssignHolesToShells(IEnumerable`1<EdgeRing> holes, IEnumerable`1<EdgeRing> shells);
    private static ISpatialIndex`1<EdgeRing> BuildIndex(IEnumerable`1<EdgeRing> shells);
    public void AssignHolesToShells(IEnumerable`1<EdgeRing> holes);
    private void AssignHoleToShell(EdgeRing holeER);
    private IList`1<EdgeRing> QueryOverlappingShells(Envelope ringEnv);
    private EdgeRing FindShellContaining(EdgeRing testER);
}
public class NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge : DirectedEdge {
    private long label;
    [CompilerGeneratedAttribute]
private PolygonizeDirectedEdge <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private EdgeRing <Ring>k__BackingField;
    public long Label { get; public set; }
    public PolygonizeDirectedEdge Next { get; public set; }
    public bool IsInRing { get; }
    public EdgeRing Ring { get; public set; }
    public PolygonizeDirectedEdge(Node from, Node to, Coordinate directionPt, bool edgeDirection);
    public long get_Label();
    public void set_Label(long value);
    [CompilerGeneratedAttribute]
public PolygonizeDirectedEdge get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(PolygonizeDirectedEdge value);
    public bool get_IsInRing();
    [CompilerGeneratedAttribute]
public EdgeRing get_Ring();
    [CompilerGeneratedAttribute]
public void set_Ring(EdgeRing value);
}
public class NetTopologySuite.Operation.Polygonize.PolygonizeEdge : Edge {
    private LineString line;
    public LineString Line { get; }
    public PolygonizeEdge(LineString line);
    public LineString get_Line();
}
public class NetTopologySuite.Operation.Polygonize.PolygonizeGraph : PlanarGraph {
    private GeometryFactory _factory;
    public PolygonizeGraph(GeometryFactory factory);
    private static int GetDegreeNonDeleted(Node node);
    private static int GetDegree(Node node, long label);
    public static void DeleteAllEdges(Node node);
    public void AddEdge(LineString line);
    private Node GetNode(Coordinate pt);
    private void ComputeNextCWEdges();
    private static void ConvertMaximalToMinimalEdgeRings(IEnumerable`1<DirectedEdge> ringEdges);
    private static IEnumerable`1<Node> FindIntersectionNodes(PolygonizeDirectedEdge startDE, long label);
    public IList`1<EdgeRing> GetEdgeRings();
    private static IList`1<DirectedEdge> FindLabeledEdgeRings(IEnumerable`1<DirectedEdge> dirEdges);
    public IList`1<LineString> DeleteCutEdges();
    private static void Label(IEnumerable`1<DirectedEdge> dirEdges, long label);
    private static void ComputeNextCWEdges(Node node);
    private static void ComputeNextCCWEdges(Node node, long label);
    private EdgeRing FindEdgeRing(PolygonizeDirectedEdge startDE);
    public ICollection`1<LineString> DeleteDangles();
    public void ComputeDepthParity();
    private void ComputeDepthParity(PolygonizeDirectedEdge de);
}
public class NetTopologySuite.Operation.Polygonize.Polygonizer : object {
    public static bool AllPolys;
    private LineStringAdder _lineStringAdder;
    private PolygonizeGraph _graph;
    private ICollection`1<LineString> _dangles;
    private ICollection`1<LineString> _cutEdges;
    private IList`1<Geometry> _invalidRingLines;
    private List`1<EdgeRing> _holeList;
    private List`1<EdgeRing> _shellList;
    private ICollection`1<Geometry> _polyList;
    private bool _isCheckingRingsValid;
    private bool _extractOnlyPolygonal;
    private GeometryFactory _geomFactory;
    public bool IsCheckingRingsValid { get; public set; }
    public Polygonizer(bool extractOnlyPolygonal);
    public bool get_IsCheckingRingsValid();
    public void set_IsCheckingRingsValid(bool value);
    public void Add(ICollection`1<Geometry> geomList);
    public void Add(Geometry g);
    private void Add(LineString line);
    public ICollection`1<Geometry> GetPolygons();
    public Geometry GetGeometry();
    public ICollection`1<LineString> GetDangles();
    public ICollection`1<LineString> GetCutEdges();
    public IList`1<Geometry> GetInvalidRingLines();
    private void Polygonize();
    private static void FindValidRings(IEnumerable`1<EdgeRing> edgeRingList, ICollection`1<EdgeRing> validEdgeRingList, ICollection`1<Geometry> invalidRingList);
    private void FindShellsAndHoles(IEnumerable`1<EdgeRing> edgeRingList);
    private static void FindDisjointShells(List`1<EdgeRing> shellList);
    private static void FindOuterShells(List`1<EdgeRing> shellList);
    private static List`1<Geometry> ExtractPolygons(List`1<EdgeRing> shellList, bool includeAll);
}
internal class NetTopologySuite.Operation.Predicate.EnvelopeIntersectsVisitor : ShortCircuitedGeometryVisitor {
    private Envelope _rectEnv;
    [CompilerGeneratedAttribute]
private bool <Intersects>k__BackingField;
    public bool Intersects { get; private set; }
    public EnvelopeIntersectsVisitor(Envelope rectEnv);
    [CompilerGeneratedAttribute]
public bool get_Intersects();
    [CompilerGeneratedAttribute]
private void set_Intersects(bool value);
    protected virtual void Visit(Geometry element);
    protected virtual bool IsDone();
}
internal class NetTopologySuite.Operation.Predicate.GeometryContainsPointVisitor : ShortCircuitedGeometryVisitor {
    private CoordinateSequence _rectSeq;
    private Envelope _rectEnv;
    [CompilerGeneratedAttribute]
private bool <ContainsPoint>k__BackingField;
    public bool ContainsPoint { get; private set; }
    public GeometryContainsPointVisitor(Polygon rectangle);
    [CompilerGeneratedAttribute]
public bool get_ContainsPoint();
    [CompilerGeneratedAttribute]
private void set_ContainsPoint(bool value);
    protected virtual void Visit(Geometry geom);
    protected virtual bool IsDone();
}
public class NetTopologySuite.Operation.Predicate.RectangleContains : object {
    private Polygon rectangle;
    private Envelope rectEnv;
    public RectangleContains(Polygon rectangle);
    public static bool Contains(Polygon rectangle, Geometry b);
    public bool Contains(Geometry geom);
    private bool IsContainedInBoundary(Geometry geom);
    private bool IsPointContainedInBoundary(Point point);
    private bool IsPointContainedInBoundary(Coordinate pt);
    private bool IsLineStringContainedInBoundary(LineString line);
    private bool IsLineSegmentContainedInBoundary(Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Operation.Predicate.RectangleIntersects : object {
    public static int MaximumScanSegmentCount;
    private Polygon _rectangle;
    private Envelope _rectEnv;
    public RectangleIntersects(Polygon rectangle);
    public static bool Intersects(Polygon rectangle, Geometry b);
    public bool Intersects(Geometry geom);
}
internal class NetTopologySuite.Operation.Predicate.RectangleIntersectsSegmentVisitor : ShortCircuitedGeometryVisitor {
    private Envelope _rectEnv;
    private RectangleLineIntersector _rectIntersector;
    [CompilerGeneratedAttribute]
private bool <Intersects>k__BackingField;
    public bool Intersects { get; private set; }
    public RectangleIntersectsSegmentVisitor(Polygon rectangle);
    [CompilerGeneratedAttribute]
public bool get_Intersects();
    [CompilerGeneratedAttribute]
private void set_Intersects(bool value);
    protected virtual void Visit(Geometry geom);
    private void CheckIntersectionWithLineStrings(IEnumerable`1<Geometry> lines);
    private void CheckIntersectionWithSegments(LineString testLine);
    protected virtual bool IsDone();
}
public class NetTopologySuite.Operation.Predicate.SegmentIntersectionTester : object {
    private LineIntersector li;
    private bool _hasIntersection;
    private Coordinate pt00;
    private Coordinate pt01;
    private Coordinate pt10;
    private Coordinate pt11;
    public bool HasIntersectionWithLineStrings(CoordinateSequence seq, ICollection`1<Geometry> lines);
    public bool HasIntersection(CoordinateSequence seq0, CoordinateSequence seq1);
}
public class NetTopologySuite.Operation.Relate.EdgeEndBuilder : object {
    public IList`1<EdgeEnd> ComputeEdgeEnds(IEnumerable`1<Edge> edges);
    public void ComputeEdgeEnds(Edge edge, IList`1<EdgeEnd> l);
    public void CreateEdgeEndForPrev(Edge edge, IList`1<EdgeEnd> l, EdgeIntersection eiCurr, EdgeIntersection eiPrev);
    public void CreateEdgeEndForNext(Edge edge, IList`1<EdgeEnd> l, EdgeIntersection eiCurr, EdgeIntersection eiNext);
}
public class NetTopologySuite.Operation.Relate.EdgeEndBundle : EdgeEnd {
    private IList`1<EdgeEnd> _edgeEnds;
    public IList`1<EdgeEnd> EdgeEnds { get; }
    public EdgeEndBundle(IBoundaryNodeRule boundaryNodeRule, EdgeEnd e);
    public EdgeEndBundle(EdgeEnd e);
    public IEnumerator`1<EdgeEnd> GetEnumerator();
    public IList`1<EdgeEnd> get_EdgeEnds();
    public void Insert(EdgeEnd e);
    public virtual void ComputeLabel(IBoundaryNodeRule boundaryNodeRule);
    private void ComputeLabelOn(int geomIndex, IBoundaryNodeRule boundaryNodeRule);
    private void ComputeLabelSides(int geomIndex);
    private void ComputeLabelSide(int geomIndex, Position side);
    public void UpdateIM(IntersectionMatrix im);
    public virtual void Write(StreamWriter outstream);
}
public class NetTopologySuite.Operation.Relate.EdgeEndBundleStar : EdgeEndStar {
    public virtual void Insert(EdgeEnd e);
    public void UpdateIM(IntersectionMatrix im);
}
public class NetTopologySuite.Operation.Relate.RelateComputer : object {
    private LineIntersector _li;
    private PointLocator _ptLocator;
    private GeometryGraph[] _arg;
    private NodeMap _nodes;
    private List`1<Edge> _isolatedEdges;
    public RelateComputer(GeometryGraph[] arg);
    public IntersectionMatrix ComputeIM();
    private void InsertEdgeEnds(IEnumerable`1<EdgeEnd> ee);
    private void ComputeProperIntersectionIM(SegmentIntersector intersector, IntersectionMatrix im);
    private void CopyNodesAndLabels(int argIndex);
    private void ComputeIntersectionNodes(int argIndex);
    private void LabelIntersectionNodes(int argIndex);
    private void ComputeDisjointIM(IntersectionMatrix im, IBoundaryNodeRule boundaryNodeRule);
    private static Dimension GetBoundaryDim(Geometry geom, IBoundaryNodeRule boundaryNodeRule);
    private void LabelNodeEdges();
    private void UpdateIM(IntersectionMatrix im);
    private void LabelIsolatedEdges(int thisIndex, int targetIndex);
    private void LabelIsolatedEdge(Edge e, int targetIndex, Geometry target);
    private void LabelIsolatedNodes();
    private void LabelIsolatedNode(Node n, int targetIndex);
}
public class NetTopologySuite.Operation.Relate.RelateNode : Node {
    public RelateNode(Coordinate coord, EdgeEndStar edges);
    public virtual void ComputeIM(IntersectionMatrix im);
    public void UpdateIMFromEdges(IntersectionMatrix im);
}
public class NetTopologySuite.Operation.Relate.RelateNodeFactory : NodeFactory {
    public virtual Node CreateNode(Coordinate coord);
}
public class NetTopologySuite.Operation.Relate.RelateNodeGraph : object {
    private NodeMap _nodes;
    public IEnumerator`1<Node> GetNodeEnumerator();
    public void Build(GeometryGraph geomGraph);
    public void ComputeIntersectionNodes(GeometryGraph geomGraph, int argIndex);
    public void CopyNodesAndLabels(GeometryGraph geomGraph, int argIndex);
    public void InsertEdgeEnds(IList`1<EdgeEnd> ee);
}
public class NetTopologySuite.Operation.Relate.RelateOp : GeometryGraphOperation {
    private RelateComputer _relate;
    public IntersectionMatrix IntersectionMatrix { get; }
    public RelateOp(Geometry g0, Geometry g1);
    public RelateOp(Geometry g0, Geometry g1, IBoundaryNodeRule boundaryNodeRule);
    public static IntersectionMatrix Relate(Geometry a, Geometry b);
    public static IntersectionMatrix Relate(Geometry a, Geometry b, IBoundaryNodeRule boundaryNodeRule);
    public IntersectionMatrix get_IntersectionMatrix();
}
public class NetTopologySuite.Operation.Union.CascadedPolygonUnion : object {
    internal static UnionStrategy ClassicUnion;
    private ICollection`1<Geometry> _inputPolys;
    private GeometryFactory _geomFactory;
    private UnionStrategy _unionStrategy;
    private int _countRemainder;
    private int _countInput;
    private static int STRtreeNodeCapacity;
    public CascadedPolygonUnion(ICollection`1<Geometry> polys);
    public CascadedPolygonUnion(ICollection`1<Geometry> polys, UnionStrategy unionStrategy);
    private static CascadedPolygonUnion();
    public static Geometry Union(ICollection`1<Geometry> polys);
    public static Geometry Union(ICollection`1<Geometry> polys, UnionStrategy unionStrategy);
    private GeometryFactory Factory();
    public Geometry Union();
    private Geometry UnionTree(IList`1<object> geomTree);
    private Geometry BinaryUnion(IList`1<Geometry> geoms);
    private Geometry BinaryUnion(IList`1<Geometry> geoms, int start, int end);
    private static Geometry GetGeometry(IList`1<Geometry> list, int index);
    private IList`1<Geometry> ReduceToGeometries(IList`1<object> geomTree);
    private Geometry UnionSafe(Geometry g0, Geometry g1);
    private static Geometry UnionActual(Geometry g0, Geometry g1, UnionStrategy unionStrategy);
    private static Geometry RestrictToPolygons(Geometry g);
}
internal class NetTopologySuite.Operation.Union.InputExtracter : object {
    private GeometryFactory _geomFactory;
    private IList`1<Geometry> _polygons;
    private IList`1<Geometry> _lines;
    private IList`1<Geometry> _points;
    private Dimension _dimension;
    public bool IsEmpty { get; }
    public Dimension Dimension { get; }
    public GeometryFactory Factory { get; }
    public static InputExtracter Extract(IEnumerable`1<Geometry> geoms);
    public static InputExtracter Extract(Geometry geom);
    public bool get_IsEmpty();
    public Dimension get_Dimension();
    public GeometryFactory get_Factory();
    public IList`1<Geometry> GetExtract(Dimension dim);
    private void Add(IEnumerable`1<Geometry> geoms);
    private void Add(Geometry geom);
    public sealed virtual void Filter(Geometry geom);
    private void RecordDimension(Dimension dim);
}
[ObsoleteAttribute("Due to impairing performance")]
public class NetTopologySuite.Operation.Union.OverlapUnion : object {
    private GeometryFactory _geomFactory;
    private Geometry _g0;
    private Geometry _g1;
    private UnionStrategy _unionFun;
    [CompilerGeneratedAttribute]
private bool <IsUnionOptimized>k__BackingField;
    internal bool IsUnionOptimized { get; private set; }
    public OverlapUnion(Geometry g0, Geometry g1);
    public OverlapUnion(Geometry g0, Geometry g1, UnionStrategy unionFun);
    public static Geometry Union(Geometry g0, Geometry g1);
    public static Geometry Union(Geometry g0, Geometry g1, UnionStrategy unionFun);
    public Geometry Union();
    [CompilerGeneratedAttribute]
internal bool get_IsUnionOptimized();
    [CompilerGeneratedAttribute]
private void set_IsUnionOptimized(bool value);
    private static Envelope OverlapEnvelope(Geometry g0, Geometry g1);
    private static Geometry Combine(Geometry unionGeom, List`1<Geometry> disjointPolys);
    private Geometry ExtractByEnvelope(Envelope env, Geometry geom, IList`1<Geometry> disjointGeoms);
    private Geometry UnionFull(Geometry geom0, Geometry geom1);
    private bool IsBorderSegmentsSame(Geometry result, Envelope env);
    private static bool IsEqual(ICollection`1<LineSegment> segs0, ICollection`1<LineSegment> segs1);
    private IList`1<LineSegment> ExtractBorderSegments(Geometry geom0, Geometry geom1, Envelope env);
    private static void ExtractBorderSegments(Geometry geom, Envelope env, ICollection`1<LineSegment> segs);
}
public class NetTopologySuite.Operation.Union.PointGeometryUnion : object {
    private GeometryFactory _geomFact;
    private Geometry _otherGeom;
    private Geometry _pointGeom;
    public PointGeometryUnion(IPuntal pointGeom, Geometry otherGeom);
    public static Geometry Union(IPuntal pointGeom, Geometry otherGeom);
    public Geometry Union();
}
public class NetTopologySuite.Operation.Union.UnaryUnionOp : object {
    private InputExtracter _extracter;
    private GeometryFactory _geomFact;
    private UnionStrategy _unionStrategy;
    public UnionStrategy UnionStrategy { get; public set; }
    public UnaryUnionOp(IEnumerable`1<Geometry> geoms);
    public UnaryUnionOp(IEnumerable`1<Geometry> geoms, GeometryFactory geomFact);
    public UnaryUnionOp(Geometry geom);
    public static Geometry Union(IEnumerable`1<Geometry> geoms);
    public static Geometry Union(IEnumerable`1<Geometry> geoms, GeometryFactory geomFact);
    public static Geometry Union(Geometry geom);
    public UnionStrategy get_UnionStrategy();
    public void set_UnionStrategy(UnionStrategy value);
    private void Extract(IEnumerable`1<Geometry> geoms);
    private void Extract(Geometry geom);
    public Geometry Union();
    private static Geometry UnionWithNull(Geometry g0, Geometry g1);
    private Geometry UnionNoOpt(Geometry g0);
}
public class NetTopologySuite.Operation.Union.UnionInteracting : object {
    private GeometryFactory _geomFactory;
    private Geometry _g0;
    private Geometry _g1;
    private Boolean[] _interacts0;
    private Boolean[] _interacts1;
    public UnionInteracting(Geometry g0, Geometry g1);
    public static Geometry Union(Geometry g0, Geometry g1);
    public Geometry Union();
    private void ComputeInteracting();
    private bool ComputeInteracting(Geometry elem0);
    private Geometry ExtractElements(Geometry geom, Boolean[] interacts, bool isInteracting);
}
public class NetTopologySuite.Operation.Union.UnionStrategy : object {
    private Func`3<Geometry, Geometry, Geometry> _unionFunction;
    [CompilerGeneratedAttribute]
private bool <IsFloatingPrecision>k__BackingField;
    internal bool IsFloatingPrecision { get; }
    internal UnionStrategy(Func`3<Geometry, Geometry, Geometry> func, bool isFloatingPrecision);
    internal Geometry Union(Geometry g0, Geometry g1);
    [CompilerGeneratedAttribute]
internal bool get_IsFloatingPrecision();
}
[ObsoleteAttribute]
public class NetTopologySuite.Operation.Valid.ConnectedInteriorTester : object {
    private GeometryFactory _geometryFactory;
    private GeometryGraph _geomGraph;
    private Coordinate _disconnectedRingcoord;
    public Coordinate Coordinate { get; }
    public ConnectedInteriorTester(GeometryGraph geomGraph);
    public static Coordinate FindDifferentPoint(Coordinate[] coord, Coordinate pt);
    public Coordinate get_Coordinate();
    public bool IsInteriorsConnected();
    private static void SetInteriorEdgesInResult(PlanarGraph graph);
    private IList`1<EdgeRing> BuildEdgeRings(IEnumerable`1<EdgeEnd> dirEdges);
    private void VisitShellInteriors(Geometry g, PlanarGraph graph);
    private void VisitInteriorRing(LineString ring, PlanarGraph graph);
    protected void VisitLinkedDirectedEdges(DirectedEdge start);
    private bool HasUnvisitedShellEdge(IList`1<EdgeRing> edgeRings);
}
[ObsoleteAttribute]
public class NetTopologySuite.Operation.Valid.ConsistentAreaTester : object {
    private LineIntersector li;
    private GeometryGraph geomGraph;
    private RelateNodeGraph nodeGraph;
    private Coordinate invalidPoint;
    public Coordinate InvalidPoint { get; }
    public bool IsNodeConsistentArea { get; }
    private bool IsNodeEdgeAreaLabelsConsistent { get; }
    public bool HasDuplicateRings { get; }
    public ConsistentAreaTester(GeometryGraph geomGraph);
    public Coordinate get_InvalidPoint();
    public bool get_IsNodeConsistentArea();
    private bool get_IsNodeEdgeAreaLabelsConsistent();
    public bool get_HasDuplicateRings();
}
internal class NetTopologySuite.Operation.Valid.IndexedNestedHoleTester : object {
    private Polygon _polygon;
    private ISpatialIndex`1<LinearRing> _index;
    private Coordinate _nestedPt;
    public Coordinate NestedPoint { get; }
    public IndexedNestedHoleTester(Polygon poly);
    private void LoadIndex();
    public Coordinate get_NestedPoint();
    public bool IsNested();
}
internal class NetTopologySuite.Operation.Valid.IndexedNestedPolygonTester : object {
    private MultiPolygon _multiPoly;
    private ISpatialIndex`1<int> _index;
    private IndexedPointInAreaLocator[] _locators;
    private Coordinate _nestedPt;
    public Coordinate NestedPoint { get; }
    public IndexedNestedPolygonTester(MultiPolygon multiPoly);
    private STRtree`1<int> LoadIndex();
    private IndexedPointInAreaLocator GetLocator(int polyIndex);
    public Coordinate get_NestedPoint();
    public bool IsNested();
    private Coordinate FindNestedPoint(LineString shell, Polygon possibleOuterPoly, IndexedPointInAreaLocator locator);
    private static Coordinate FindIncidentSegmentNestedPoint(LineString shell, Polygon poly);
}
[ObsoleteAttribute]
public class NetTopologySuite.Operation.Valid.IndexedNestedRingTester : object {
    private GeometryGraph _graph;
    private IList`1<LineString> _rings;
    private Envelope _totalEnv;
    private ISpatialIndex`1<LineString> _index;
    private Coordinate _nestedPt;
    public Coordinate NestedPoint { get; }
    public IndexedNestedRingTester(GeometryGraph graph);
    public Coordinate get_NestedPoint();
    public void Add(LinearRing ring);
    public bool IsNonNested();
    private void BuildIndex();
}
public class NetTopologySuite.Operation.Valid.IsSimpleOp : object {
    private Geometry _inputGeom;
    private bool _isClosedEndpointsInInterior;
    private bool _isSimple;
    private List`1<Coordinate> _nonSimplePts;
    [CompilerGeneratedAttribute]
private bool <FindAllLocations>k__BackingField;
    public bool FindAllLocations { get; public set; }
    public Coordinate NonSimpleLocation { get; }
    public IList`1<Coordinate> NonSimpleLocations { get; }
    public IsSimpleOp(Geometry geom);
    public IsSimpleOp(Geometry geom, IBoundaryNodeRule boundaryNodeRule);
    public static bool IsSimple(Geometry geom);
    public static Coordinate GetNonSimpleLocation(Geometry geom);
    [CompilerGeneratedAttribute]
public bool get_FindAllLocations();
    [CompilerGeneratedAttribute]
public void set_FindAllLocations(bool value);
    public bool IsSimple();
    public Coordinate get_NonSimpleLocation();
    public IList`1<Coordinate> get_NonSimpleLocations();
    private void Compute();
    private bool ComputeSimple(Geometry geom);
    private bool IsSimpleMultiPoint(MultiPoint mp);
    private bool IsSimplePolygonal(Geometry geom);
    private bool IsSimpleGeometryCollection(Geometry geom);
    private bool IsSimpleLinearGeometry(Geometry geom);
    private static List`1<ISegmentString> ExtractSegmentStrings(Geometry geom);
    private static Coordinate[] TrimRepeatedPoints(Coordinate[] pts);
}
public class NetTopologySuite.Operation.Valid.IsValidOp : object {
    private static int MinSizeLineString;
    private static int MinSizeLinearRing;
    private Geometry _inputGeometry;
    private bool _isInvertedRingValid;
    private TopologyValidationError _validErr;
    public bool SelfTouchingRingFormingHoleValid { get; public set; }
    [ObsoleteAttribute("Use SelfTouchingRingFormingHoleValid")]
public bool IsSelfTouchingRingFormingHoleValid { get; public set; }
    public bool IsValid { get; }
    public TopologyValidationError ValidationError { get; }
    private bool HasInvalidError { get; }
    public IsValidOp(Geometry inputGeometry);
    public static bool CheckValid(Geometry geom);
    [ObsoleteAttribute("Use Coordinate.IsValid")]
public static bool IsValidCoordinate(Coordinate coord);
    public bool get_SelfTouchingRingFormingHoleValid();
    public void set_SelfTouchingRingFormingHoleValid(bool value);
    public bool get_IsSelfTouchingRingFormingHoleValid();
    public void set_IsSelfTouchingRingFormingHoleValid(bool value);
    public bool get_IsValid();
    public TopologyValidationError get_ValidationError();
    private void LogInvalid(TopologyValidationErrors code, Coordinate pt);
    private bool get_HasInvalidError();
    private bool IsValidGeometry(Geometry g);
    private bool IsValidGeometry(Point g);
    private bool IsValidGeometry(MultiPoint g);
    private bool IsValidGeometry(LineString g);
    private bool IsValidGeometry(LinearRing g);
    private bool IsValidGeometry(Polygon g);
    private bool IsValidGeometry(MultiPolygon g);
    private bool IsValidGeometry(GeometryCollection gc);
    private void CheckCoordinatesValid(Coordinate[] coords);
    private void CheckCoordinatesValid(CoordinateSequence sequence);
    private void CheckCoordinatesValid(Polygon poly);
    private void CheckRingClosed(LineString ring);
    private void CheckRingsClosed(Polygon poly);
    private void CheckRingsPointSize(Polygon poly);
    private void CheckRingPointSize(LineString ring);
    private void CheckPointSize(LineString line, int minSize);
    private bool IsNonRepeatedSizeAtLeast(LineString line, int minSize);
    private void CheckAreaIntersections(PolygonTopologyAnalyzer areaAnalyzer);
    private void CheckRingSimple(LinearRing ring);
    private void CheckHolesInShell(Polygon poly);
    private Coordinate FindHoleOutsideShellPoint(LineString hole, LineString shell);
    private void CheckHolesNotNested(Polygon poly);
    private void CheckShellsNotNested(MultiPolygon mp);
    private void CheckInteriorConnected(PolygonTopologyAnalyzer analyzer);
    [ObsoleteAttribute]
public static Coordinate FindPointNotNode(Coordinate[] testCoords, LinearRing searchRing, GeometryGraph graph);
}
internal class NetTopologySuite.Operation.Valid.PolygonIntersectionAnalyzer : object {
    private bool _isInvertedRingValid;
    private LineIntersector _li;
    private TopologyValidationErrors _invalidCode;
    private Coordinate _invalidLocation;
    private bool _hasDoubleTouch;
    private Coordinate _doubleTouchLocation;
    public bool IsDone { get; }
    public bool IsInvalid { get; }
    public TopologyValidationErrors InvalidCode { get; }
    public Coordinate InvalidLocation { get; }
    public bool HasDoubleTouch { get; }
    public Coordinate DoubleTouchLocation { get; }
    public PolygonIntersectionAnalyzer(bool isInvertedRingValid);
    public sealed virtual bool get_IsDone();
    public bool get_IsInvalid();
    public TopologyValidationErrors get_InvalidCode();
    public Coordinate get_InvalidLocation();
    public bool get_HasDoubleTouch();
    public Coordinate get_DoubleTouchLocation();
    public sealed virtual void ProcessIntersections(ISegmentString ss0, int segIndex0, ISegmentString ss1, int segIndex1);
    private TopologyValidationErrors FindInvalidIntersection(ISegmentString ss0, int segIndex0, ISegmentString ss1, int segIndex1);
    private bool AddDoubleTouch(ISegmentString ss0, ISegmentString ss1, Coordinate intPt);
    private void AddSelfTouch(ISegmentString ss, Coordinate intPt, Coordinate e00, Coordinate e01, Coordinate e10, Coordinate e11);
    private static Coordinate PrevCoordinateInRing(ISegmentString ringSS, int segIndex);
    private static bool IsAdjacentInRing(ISegmentString ringSS, int segIndex0, int segIndex1);
}
internal static class NetTopologySuite.Operation.Valid.PolygonNode : object {
    public static bool IsCrossing(Coordinate nodePt, Coordinate a0, Coordinate a1, Coordinate b0, Coordinate b1);
    public static bool IsInteriorSegment(Coordinate nodePt, Coordinate a0, Coordinate a1, Coordinate b);
    private static bool IsBetween(Coordinate origin, Coordinate p, Coordinate e0, Coordinate e1);
    private static bool IsAngleGreater(Coordinate origin, Coordinate p, Coordinate q);
    private static Quadrant Quadrant(Coordinate origin, Coordinate p);
}
internal class NetTopologySuite.Operation.Valid.PolygonRing : object {
    private int _id;
    private PolygonRing _shell;
    private LinearRing _ring;
    private PolygonRing _touchSetRoot;
    private IDictionary`2<int, PolygonRingTouch> _touches;
    private List`1<PolygonRingSelfNode> _selfNodes;
    private bool IsInTouchSet { get; }
    private PolygonRing TouchSetRoot { get; private set; }
    private bool HasTouches { get; }
    private ICollection`1<PolygonRingTouch> Touches { get; }
    public PolygonRing(LinearRing ring);
    public PolygonRing(LinearRing ring, int index, PolygonRing shell);
    public static bool IsShell(PolygonRing polyRing);
    public static bool AddTouch(PolygonRing ring0, PolygonRing ring1, Coordinate pt);
    public static Coordinate FindHoleCycleLocation(IEnumerable`1<PolygonRing> polyRings);
    public static Coordinate FindInteriorSelfNode(IEnumerable`1<PolygonRing> polyRings);
    private bool IsSamePolygon(PolygonRing ring);
    private bool IsShell();
    private bool get_IsInTouchSet();
    private PolygonRing get_TouchSetRoot();
    private void set_TouchSetRoot(PolygonRing value);
    private bool get_HasTouches();
    private ICollection`1<PolygonRingTouch> get_Touches();
    private void AddTouch(PolygonRing ring, Coordinate pt);
    internal void AddSelfTouch(Coordinate origin, Coordinate e00, Coordinate e01, Coordinate e10, Coordinate e11);
    private bool IsOnlyTouch(PolygonRing ring, Coordinate pt);
    private Coordinate FindHoleCycleLocation();
    private static void Init(PolygonRing root, Queue`1<PolygonRingTouch> touchStack);
    private Coordinate ScanForHoleCycle(PolygonRingTouch currentTouch, PolygonRing root, Queue`1<PolygonRingTouch> touchQueue);
    public Coordinate FindInteriorSelfNode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class NetTopologySuite.Operation.Valid.PolygonRingSelfNode : ValueType {
    private Coordinate _nodePt;
    private Coordinate _e00;
    private Coordinate _e01;
    private Coordinate _e10;
    public Coordinate Coordinate { get; }
    public PolygonRingSelfNode(Coordinate nodePt, Coordinate e00, Coordinate e01, Coordinate e10, Coordinate e11);
    public Coordinate get_Coordinate();
    public bool IsExterior(bool isInteriorOnRight);
}
[IsReadOnlyAttribute]
internal class NetTopologySuite.Operation.Valid.PolygonRingTouch : ValueType {
    private PolygonRing _ring;
    private Coordinate _touchPt;
    public Coordinate Coordinate { get; }
    public PolygonRing Ring { get; }
    public PolygonRingTouch(PolygonRing ring, Coordinate pt);
    public Coordinate get_Coordinate();
    public PolygonRing get_Ring();
    public bool IsAtLocation(Coordinate pt);
}
internal class NetTopologySuite.Operation.Valid.PolygonTopologyAnalyzer : object {
    private bool _isInvertedRingValid;
    private PolygonIntersectionAnalyzer _intFinder;
    private List`1<PolygonRing> _polyRings;
    private Coordinate _disconnectionPt;
    public bool HasInvalidIntersection { get; }
    public TopologyValidationErrors InvalidCode { get; }
    public Coordinate InvalidLocation { get; }
    public bool HasDoubleTouch { get; }
    public Coordinate IntersectionLocation { get; }
    public Coordinate DisconnectionLocation { get; }
    public PolygonTopologyAnalyzer(Geometry geom, bool isInvertedRingValid);
    public static bool IsRingNested(LineString test, LineString target);
    private static Coordinate FindNonEqualVertex(LineString ring, Coordinate p);
    private static bool IsIncidentSegmentInRing(Coordinate p0, Coordinate p1, Coordinate[] ringPts);
    private static Coordinate FindRingVertexPrev(Coordinate[] ringPts, int index, Coordinate node);
    private static Coordinate FindRingVertexNext(Coordinate[] ringPts, int index, Coordinate node);
    private static int RingIndexPrev(Coordinate[] ringPts, int index);
    private static int RingIndexNext(Coordinate[] ringPts, int index);
    private static int IntersectingSegIndex(Coordinate[] ringPts, Coordinate pt);
    public static Coordinate FindSelfIntersection(LinearRing ring);
    public bool get_HasInvalidIntersection();
    public TopologyValidationErrors get_InvalidCode();
    public Coordinate get_InvalidLocation();
    public bool get_HasDoubleTouch();
    public Coordinate get_IntersectionLocation();
    public bool IsInteriorDisconnected();
    public Coordinate get_DisconnectionLocation();
    public bool CheckInteriorDisconnectedByHoleCycle();
    public void CheckInteriorDisconnectedBySelfTouch();
    private void Analyze(Geometry geom);
    private PolygonIntersectionAnalyzer AnalyzeIntersections(IList`1<ISegmentString> segStrings);
    private static IList`1<ISegmentString> CreateSegmentStrings(Geometry geom, bool isInvertedRingValid);
    private static List`1<PolygonRing> GetPolygonRings(IList`1<ISegmentString> segStrings);
    private void AddPolygonRing(PolygonRing polyRing);
    private static BasicSegmentString CreateSegString(LinearRing ring, PolygonRing polyRing);
}
public class NetTopologySuite.Operation.Valid.RepeatedPointTester : object {
    private Coordinate _repeatedCoord;
    public Coordinate Coordinate { get; }
    public Coordinate get_Coordinate();
    public bool HasRepeatedPoint(Geometry g);
    public bool HasRepeatedPoint(Coordinate[] coord);
    public bool HasRepeatedPoint(CoordinateSequence sequence);
    private bool HasRepeatedPoint(Polygon p);
    private bool HasRepeatedPoint(GeometryCollection gc);
}
public class NetTopologySuite.Operation.Valid.TopologyValidationError : object {
    private static String[] errMsg;
    private TopologyValidationErrors errorType;
    private Coordinate pt;
    public Coordinate Coordinate { get; }
    public TopologyValidationErrors ErrorType { get; }
    public string Message { get; }
    public TopologyValidationError(TopologyValidationErrors errorType, Coordinate pt);
    public TopologyValidationError(TopologyValidationErrors errorType);
    private static TopologyValidationError();
    public Coordinate get_Coordinate();
    public TopologyValidationErrors get_ErrorType();
    public string get_Message();
    public virtual string ToString();
}
public enum NetTopologySuite.Operation.Valid.TopologyValidationErrors : Enum {
    public int value__;
    public static TopologyValidationErrors NoInvalidIntersection;
    public static TopologyValidationErrors HoleOutsideShell;
    public static TopologyValidationErrors NestedHoles;
    public static TopologyValidationErrors DisconnectedInteriors;
    public static TopologyValidationErrors SelfIntersection;
    public static TopologyValidationErrors RingSelfIntersection;
    public static TopologyValidationErrors NestedShells;
    public static TopologyValidationErrors DuplicateRings;
    public static TopologyValidationErrors TooFewPoints;
    public static TopologyValidationErrors InvalidCoordinate;
    public static TopologyValidationErrors RingNotClosed;
}
public class NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder : object {
    private PlanarGraph graph;
    public ConnectedSubgraphFinder(PlanarGraph graph);
    public IList`1<Subgraph> GetConnectedSubgraphs();
    private Subgraph FindSubgraph(Node node);
    private void AddReachable(Node startNode, Subgraph subgraph);
    private static void AddEdges(Node node, Stack`1<Node> nodeStack, Subgraph subgraph);
}
public class NetTopologySuite.Planargraph.DirectedEdge : GraphComponent {
    protected Edge parentEdge;
    protected Node from;
    protected Node to;
    protected Coordinate p0;
    protected Coordinate p1;
    private DirectedEdge _sym;
    private Quadrant _quadrant;
    private double _angle;
    [CompilerGeneratedAttribute]
private bool <EdgeDirection>k__BackingField;
    public Edge Edge { get; public set; }
    [ObsoleteAttribute("Use QuadrantValue")]
public int Quadrant { get; }
    public Quadrant QuadrantEx { get; }
    public Coordinate DirectionPt { get; }
    public bool EdgeDirection { get; protected set; }
    public Node FromNode { get; }
    public Node ToNode { get; }
    public Coordinate Coordinate { get; }
    public double Angle { get; }
    public DirectedEdge Sym { get; public set; }
    public bool IsRemoved { get; }
    public DirectedEdge(Node from, Node to, Coordinate directionPt, bool edgeDirection);
    public static IList`1<Edge> ToEdges(IList`1<DirectedEdge> dirEdges);
    public Edge get_Edge();
    public void set_Edge(Edge value);
    public int get_Quadrant();
    public Quadrant get_QuadrantEx();
    public Coordinate get_DirectionPt();
    [CompilerGeneratedAttribute]
public bool get_EdgeDirection();
    [CompilerGeneratedAttribute]
protected void set_EdgeDirection(bool value);
    public Node get_FromNode();
    public Node get_ToNode();
    public Coordinate get_Coordinate();
    public double get_Angle();
    public DirectedEdge get_Sym();
    public void set_Sym(DirectedEdge value);
    public sealed virtual int CompareTo(object obj);
    public int CompareDirection(DirectedEdge e);
    public void Write(StreamWriter outstream);
    public virtual bool get_IsRemoved();
    internal void Remove();
    public virtual string ToString();
}
public class NetTopologySuite.Planargraph.DirectedEdgeStar : object {
    private List`1<DirectedEdge> _outEdges;
    private bool _sorted;
    public int Degree { get; }
    public Coordinate Coordinate { get; }
    public IList`1<DirectedEdge> Edges { get; }
    public void Add(DirectedEdge de);
    public void Remove(DirectedEdge de);
    public IEnumerator`1<DirectedEdge> GetEnumerator();
    public int get_Degree();
    public Coordinate get_Coordinate();
    public IList`1<DirectedEdge> get_Edges();
    private void SortEdges();
    public int GetIndex(Edge edge);
    public int GetIndex(DirectedEdge dirEdge);
    public int GetIndex(int i);
    public DirectedEdge GetNextEdge(DirectedEdge dirEdge);
    public DirectedEdge GetNextCWEdge(DirectedEdge dirEdge);
}
public class NetTopologySuite.Planargraph.Edge : GraphComponent {
    protected DirectedEdge[] dirEdge;
    public bool IsRemoved { get; }
    public Edge(DirectedEdge de0, DirectedEdge de1);
    public void SetDirectedEdges(DirectedEdge de0, DirectedEdge de1);
    public DirectedEdge GetDirEdge(int i);
    public DirectedEdge GetDirEdge(Node fromNode);
    public Node GetOppositeNode(Node node);
    internal void Remove();
    public virtual bool get_IsRemoved();
}
public abstract class NetTopologySuite.Planargraph.GraphComponent : object {
    [CompilerGeneratedAttribute]
private bool <Visited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Marked>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public bool IsVisited { get; }
    public bool Visited { get; public set; }
    public bool IsMarked { get; }
    public bool Marked { get; public set; }
    public bool IsRemoved { get; }
    public object Data { get; public set; }
    public static void SetVisited(IEnumerator i, bool visited);
    public static void SetMarked(IEnumerator i, bool marked);
    public static GraphComponent GetComponentWithVisitedState(IEnumerator i, bool visitedState);
    public bool get_IsVisited();
    [CompilerGeneratedAttribute]
public bool get_Visited();
    [CompilerGeneratedAttribute]
public void set_Visited(bool value);
    public bool get_IsMarked();
    [CompilerGeneratedAttribute]
public bool get_Marked();
    [CompilerGeneratedAttribute]
public void set_Marked(bool value);
    public abstract virtual bool get_IsRemoved();
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
}
public class NetTopologySuite.Planargraph.Node : GraphComponent {
    protected Coordinate pt;
    protected DirectedEdgeStar deStar;
    public Coordinate Coordinate { get; }
    public DirectedEdgeStar OutEdges { get; }
    public int Degree { get; }
    public bool IsRemoved { get; }
    public Node(Coordinate pt);
    public Node(Coordinate pt, DirectedEdgeStar deStar);
    public static IList`1<DirectedEdge> GetEdgesBetween(Node node0, Node node1);
    public Coordinate get_Coordinate();
    public void AddOutEdge(DirectedEdge de);
    public DirectedEdgeStar get_OutEdges();
    public int get_Degree();
    public int GetIndex(Edge edge);
    public void Remove(DirectedEdge de);
    internal void Remove();
    public virtual bool get_IsRemoved();
    public virtual string ToString();
}
public class NetTopologySuite.Planargraph.NodeMap : object {
    private IDictionary`2<Coordinate, Node> _nodeMap;
    public ICollection`1<Node> Values { get; }
    public int Count { get; }
    public Node Add(Node n);
    public Node Remove(Coordinate pt);
    public Node Find(Coordinate coord);
    public IEnumerator`1<Node> GetEnumerator();
    public ICollection`1<Node> get_Values();
    public int get_Count();
}
public abstract class NetTopologySuite.Planargraph.PlanarGraph : object {
    private IList`1<Edge> _edges;
    protected IList`1<DirectedEdge> dirEdges;
    protected NodeMap nodeMap;
    public ICollection`1<Node> Nodes { get; }
    public IList`1<Edge> Edges { get; protected set; }
    public Node FindNode(Coordinate pt);
    protected void Add(Node node);
    protected void Add(Edge edge);
    protected void Add(DirectedEdge dirEdge);
    public IEnumerator`1<Node> GetNodeEnumerator();
    public ICollection`1<Node> get_Nodes();
    public IEnumerator`1<DirectedEdge> GetDirEdgeEnumerator();
    public IEnumerator`1<Edge> GetEdgeEnumerator();
    public IList`1<Edge> get_Edges();
    protected void set_Edges(IList`1<Edge> value);
    public void Remove(Edge edge);
    public void Remove(DirectedEdge de);
    public void Remove(Node node);
    public IList`1<Node> FindNodesOfDegree(int degree);
}
public class NetTopologySuite.Planargraph.Subgraph : object {
    protected PlanarGraph parentGraph;
    protected HashSet`1<Edge> edges;
    protected IList`1<DirectedEdge> dirEdges;
    protected NodeMap nodeMap;
    public Subgraph(PlanarGraph parentGraph);
    public PlanarGraph GetParent();
    public void Add(Edge e);
    public IEnumerator`1<DirectedEdge> GetDirEdgeEnumerator();
    public IEnumerator`1<Edge> GetEdgeEnumerator();
    public IEnumerator`1<Node> GetNodeEnumerator();
    public bool Contains(Edge e);
}
public class NetTopologySuite.Precision.CommonBits : object {
    private bool _isFirst;
    private int _commonMantissaBitsCount;
    private long _commonBits;
    private long _commonSignExp;
    public double Common { get; }
    public static long SignExpBits(long num);
    public static int NumCommonMostSigMantissaBits(long num1, long num2);
    public static long ZeroLowerBits(long bits, int nBits);
    public static int GetBit(long bits, int i);
    public void Add(double num);
    public double get_Common();
    public string ToString(long bits);
}
public class NetTopologySuite.Precision.CommonBitsOp : object {
    private bool _returnToOriginalPrecision;
    private CommonBitsRemover _cbr;
    public CommonBitsOp(bool returnToOriginalPrecision);
    public Geometry Intersection(Geometry geom0, Geometry geom1);
    public Geometry Union(Geometry geom0, Geometry geom1);
    public Geometry Difference(Geometry geom0, Geometry geom1);
    public Geometry SymDifference(Geometry geom0, Geometry geom1);
    public Geometry Buffer(Geometry geom0, double distance);
    private Geometry ComputeResultPrecision(Geometry result);
    private Geometry RemoveCommonBits(Geometry geom0);
    private Geometry[] RemoveCommonBits(Geometry geom0, Geometry geom1);
}
public class NetTopologySuite.Precision.CommonBitsRemover : object {
    private Coordinate _commonCoord;
    private CommonCoordinateFilter _ccFilter;
    public Coordinate CommonCoordinate { get; }
    public void Add(Geometry geom);
    public Coordinate get_CommonCoordinate();
    public Geometry RemoveCommonBits(Geometry geom);
    public void AddCommonBits(Geometry geom);
}
public class NetTopologySuite.Precision.CoordinatePrecisionReducerFilter : object {
    private PrecisionModel _precModel;
    public bool Done { get; }
    public bool GeometryChanged { get; }
    public CoordinatePrecisionReducerFilter(PrecisionModel precModel);
    public sealed virtual void Filter(CoordinateSequence seq, int i);
    public sealed virtual bool get_Done();
    public sealed virtual bool get_GeometryChanged();
}
public class NetTopologySuite.Precision.EnhancedPrecisionOp : object {
    public static Geometry Intersection(Geometry geom0, Geometry geom1);
    public static Geometry Union(Geometry geom0, Geometry geom1);
    public static Geometry Difference(Geometry geom0, Geometry geom1);
    public static Geometry SymDifference(Geometry geom0, Geometry geom1);
}
public class NetTopologySuite.Precision.GeometryPrecisionReducer : object {
    private PrecisionModel _targetPM;
    private bool _removeCollapsed;
    private bool _changePrecisionModel;
    private bool _isPointwise;
    public bool RemoveCollapsedComponents { get; public set; }
    public bool ChangePrecisionModel { get; public set; }
    public bool Pointwise { get; public set; }
    public GeometryPrecisionReducer(PrecisionModel pm);
    public static Geometry Reduce(Geometry g, PrecisionModel precModel);
    public static Geometry ReduceKeepCollapsed(Geometry geom, PrecisionModel pm);
    public static Geometry ReducePointwise(Geometry g, PrecisionModel precModel);
    public bool get_RemoveCollapsedComponents();
    public void set_RemoveCollapsedComponents(bool value);
    public bool get_ChangePrecisionModel();
    public void set_ChangePrecisionModel(bool value);
    public bool get_Pointwise();
    public void set_Pointwise(bool value);
    public Geometry Reduce(Geometry geom);
    private static Geometry ChangePM(Geometry geom, PrecisionModel pm);
    private static GeometryEditor CreateEditor(GeometryFactory geomFactory, PrecisionModel newPrecModel);
    private static GeometryFactory CreateFactory(GeometryFactory inputFactory, PrecisionModel pm);
}
public class NetTopologySuite.Precision.MinimumClearance : object {
    private Geometry _inputGeom;
    private double _minClearance;
    private Coordinate[] _minClearancePts;
    public MinimumClearance(Geometry geom);
    public static double GetDistance(Geometry g);
    public static Geometry GetLine(Geometry g);
    public double GetDistance();
    public LineString GetLine();
    private void Compute();
}
internal class NetTopologySuite.Precision.PointwisePrecisionReducerTransformer : GeometryTransformer {
    private PrecisionModel _targetPm;
    private PointwisePrecisionReducerTransformer(PrecisionModel targetPM);
    public static Geometry Reduce(Geometry geom, PrecisionModel targetPM);
    protected virtual CoordinateSequence TransformCoordinates(CoordinateSequence coordinates, Geometry parent);
    private Coordinate[] ReducePointwise(CoordinateSequence coordinates);
}
public class NetTopologySuite.Precision.PrecisionReducerCoordinateOperation : CoordinateOperation {
    private PrecisionModel _targetPrecModel;
    private bool _removeCollapsed;
    public PrecisionReducerCoordinateOperation(PrecisionModel targetPrecModel, bool removeCollapsed);
    public virtual Coordinate[] Edit(Coordinate[] coordinates, Geometry geom);
}
internal class NetTopologySuite.Precision.PrecisionReducerTransformer : GeometryTransformer {
    private PrecisionModel _targetPm;
    private bool _isRemoveCollapsed;
    private PrecisionReducerTransformer(PrecisionModel targetPM, bool isRemoveCollapsed);
    public static Geometry Reduce(Geometry geom, PrecisionModel targetPM, bool isRemoveCollapsed);
    protected virtual CoordinateSequence TransformCoordinates(CoordinateSequence coordinates, Geometry parent);
    private Coordinate[] Extend(Coordinate[] coords, int minLength);
    private Coordinate[] ReduceCompress(CoordinateSequence coordinates);
    protected virtual Geometry TransformPolygon(Polygon geom, Geometry parent);
    protected virtual Geometry TransformMultiPolygon(MultiPolygon geom, Geometry parent);
    private Geometry ReduceArea(Geometry geom);
}
public class NetTopologySuite.Precision.SimpleMinimumClearance : object {
    private Geometry _inputGeom;
    private double _minClearance;
    private Coordinate[] _minClearancePts;
    public SimpleMinimumClearance(Geometry geom);
    public static double GetDistance(Geometry g);
    public static Geometry GetLine(Geometry g);
    public double GetDistance();
    public LineString GetLine();
    private void Compute();
    private void UpdateClearance(double candidateValue, Coordinate p0, Coordinate p1);
    private void UpdateClearance(double candidateValue, Coordinate p, Coordinate seg0, Coordinate seg1);
}
public class NetTopologySuite.Shape.CubicBezierCurve : object {
    private double _minSegmentLength;
    private int _numVerticesPerSegment;
    private Geometry _inputGeom;
    private double _alpha;
    private double _skew;
    private Geometry _controlPoints;
    private GeometryFactory _geomFactory;
    private int _controlPointIndex;
    private Coordinate[] bezierCurvePts;
    private Double[][] interpolationParam;
    private static double CIRCLE_LEN_FACTOR;
    private CubicBezierCurve(Geometry geom, double alpha);
    private CubicBezierCurve(Geometry geom, double alpha, double skew);
    private CubicBezierCurve(Geometry geom, Geometry controlPoints);
    public static Geometry Create(Geometry geom, double alpha);
    public static Geometry Create(Geometry geom, double alpha, double skew);
    public static Geometry Create(Geometry geom, Geometry controlPoints);
    public Geometry GetResult();
    private LineString BezierLine(LineString ls);
    private LinearRing BezierRing(LinearRing ring);
    private Polygon BezierPolygon(Polygon poly);
    private CoordinateList BezierCurve(Coordinate[] coords, bool isRing);
    private Coordinate[] ControlPoints(Coordinate[] coords, bool isRing);
    private void AddCurve(Coordinate p0, Coordinate p1, Coordinate ctrl0, Coordinate crtl1, CoordinateList curvePts);
    private static Coordinate[] ControlPoints(Coordinate[] coords, bool isRing, double alpha, double skew);
    private static void SetLineEndControlPoints(Coordinate[] coords, Coordinate[] ctrl);
    private static Coordinate AimedControlPoint(Coordinate c, Coordinate p1, Coordinate p0);
    private static Coordinate MirrorControlPoint(Coordinate c, Coordinate p0, Coordinate p1);
    private static Coordinate ReflectPointInLine(Coordinate p, Coordinate p0, Coordinate p1);
    private static void CubicBezier(Coordinate p0, Coordinate p1, Coordinate ctrl1, Coordinate ctrl2, Double[][] param, Coordinate[] curve);
    private static Double[][] ComputeIterpolationParameters(int n);
    [CompilerGeneratedAttribute]
private Geometry <GetResult>b__16_0(Geometry geom);
}
public static class NetTopologySuite.Shape.Fractal.HilbertCode : object {
    public static int MaxLevel;
    private static HilbertCode();
    public static int Size(int level);
    public static int MaxOrdinate(int level);
    public static int Level(int numPoints);
    private static void CheckLevel(int level);
    public static int Encode(int level, int x, int y);
    private static int LevelClamp(int level);
    public static Coordinate Decode(int level, int index);
    private static long PrefixScan(long x);
    private static long Deinterleave(int x);
}
public class NetTopologySuite.Shape.Fractal.HilbertCurveBuilder : GeometricShapeBuilder {
    public int Level { get; public set; }
    public HilbertCurveBuilder(GeometryFactory geomFactory);
    public int get_Level();
    public void set_Level(int value);
    public virtual Geometry GetGeometry();
    private static double Transform(double val, double scale, double offset);
}
public class NetTopologySuite.Shape.Fractal.KochSnowflakeBuilder : GeometricShapeBuilder {
    private CoordinateList _coordList;
    private static double HeightFactor;
    private static double OneThird;
    private static double ThirdHeight;
    private static double TwoThirds;
    public KochSnowflakeBuilder(GeometryFactory geomFactory);
    private static KochSnowflakeBuilder();
    private static int RecursionLevelForSize(int numPts);
    public virtual Geometry GetGeometry();
    private Coordinate[] GetBoundary(int level, Coordinate origin, double width);
    private void AddSide(int level, Coordinate p0, Coordinate p1);
    private void AddSegment(Coordinate p0, Coordinate p1);
}
public static class NetTopologySuite.Shape.Fractal.MortonCode : object {
    public static int MaxLevel;
    private static MortonCode();
    public static int Size(int level);
    public static int MaxOrdinate(int level);
    public static int Level(int numPoints);
    private static void CheckLevel(int level);
    public static int Encode(int x, int y);
    private static int Interleave(int x);
    public static Coordinate Decode(int index);
    private static long PrefixScan(long x);
    private static long Deinterleave(int x);
}
public class NetTopologySuite.Shape.Fractal.MortonCurveBuilder : GeometricShapeBuilder {
    public int Level { get; public set; }
    public MortonCurveBuilder(GeometryFactory geomFactory);
    public int get_Level();
    public void set_Level(int value);
    public virtual Geometry GetGeometry();
    private static double Transform(double val, double scale, double offset);
}
public class NetTopologySuite.Shape.Fractal.SierpinskiCarpetBuilder : GeometricShapeBuilder {
    public SierpinskiCarpetBuilder(GeometryFactory geomFactory);
    private static int RecursionLevelForSize(int numPts);
    public virtual Geometry GetGeometry();
    private LinearRing[] GetHoles(int n, double originX, double originY, double width);
    private void AddHoles(int n, double originX, double originY, double width, ICollection`1<Geometry> holeList);
    private LinearRing CreateSquareHole(double x, double y, double width);
}
public abstract class NetTopologySuite.Shape.GeometricShapeBuilder : object {
    private Envelope _extent;
    protected GeometryFactory GeomFactory;
    [CompilerGeneratedAttribute]
private int <NumPoints>k__BackingField;
    public Envelope Extent { get; public set; }
    public Coordinate Centre { get; }
    public double Diameter { get; }
    public double Radius { get; }
    public int NumPoints { get; public set; }
    protected GeometricShapeBuilder(GeometryFactory geomFactory);
    public Envelope get_Extent();
    public void set_Extent(Envelope value);
    public Coordinate get_Centre();
    public double get_Diameter();
    public double get_Radius();
    public LineSegment GetSquareBaseLine();
    public Envelope GetSquareExtent();
    [CompilerGeneratedAttribute]
public int get_NumPoints();
    [CompilerGeneratedAttribute]
public void set_NumPoints(int value);
    public abstract virtual Geometry GetGeometry();
    protected Coordinate CreateCoord(double x, double y);
}
public class NetTopologySuite.Shape.Random.RandomPointsBuilder : GeometricShapeBuilder {
    protected static Random Rnd;
    private Geometry _maskPoly;
    private IPointOnGeometryLocator _extentLocator;
    public RandomPointsBuilder(GeometryFactory geomFact);
    private static RandomPointsBuilder();
    public void SetExtent(Geometry mask);
    public virtual Geometry GetGeometry();
    protected bool IsInExtent(Coordinate p);
    protected Coordinate CreateRandomCoord(Envelope env);
}
public class NetTopologySuite.Shape.Random.RandomPointsInGridBuilder : GeometricShapeBuilder {
    protected static Random Rnd;
    private bool _isConstrainedToCircle;
    [CompilerGeneratedAttribute]
private double <GutterFraction>k__BackingField;
    public bool ConstrainedToCircle { get; public set; }
    public double GutterFraction { get; public set; }
    public RandomPointsInGridBuilder(GeometryFactory geomFact);
    private static RandomPointsInGridBuilder();
    public bool get_ConstrainedToCircle();
    public void set_ConstrainedToCircle(bool value);
    [CompilerGeneratedAttribute]
public double get_GutterFraction();
    [CompilerGeneratedAttribute]
public void set_GutterFraction(double value);
    public virtual Geometry GetGeometry();
    private Coordinate RandomPointInCell(double orgX, double orgY, double xLen, double yLen);
    private Coordinate RandomPointInGridCell(double orgX, double orgY, double xLen, double yLen);
    private static Coordinate RandomPointInCircle(double orgX, double orgY, double width, double height);
}
public class NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier : object {
    private Coordinate[] _pts;
    private Boolean[] _usePt;
    [CompilerGeneratedAttribute]
private double <DistanceTolerance>k__BackingField;
    private LineSegment _seg;
    public double DistanceTolerance { get; public set; }
    public DouglasPeuckerLineSimplifier(Coordinate[] pts);
    public static Coordinate[] Simplify(Coordinate[] pts, double distanceTolerance);
    [CompilerGeneratedAttribute]
public double get_DistanceTolerance();
    [CompilerGeneratedAttribute]
public void set_DistanceTolerance(double value);
    public Coordinate[] Simplify();
    private void SimplifySection(int i, int j);
}
public class NetTopologySuite.Simplify.DouglasPeuckerSimplifier : object {
    private Geometry _inputGeom;
    private double _distanceTolerance;
    private bool _isEnsureValidTopology;
    public double DistanceTolerance { get; public set; }
    public bool EnsureValidTopology { get; public set; }
    public DouglasPeuckerSimplifier(Geometry inputGeom);
    public static Geometry Simplify(Geometry geom, double distanceTolerance);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public bool get_EnsureValidTopology();
    public void set_EnsureValidTopology(bool value);
    public Geometry GetResultGeometry();
}
public class NetTopologySuite.Simplify.LineSegmentIndex : object {
    private ISpatialIndex`1<LineSegment> _index;
    public void Add(TaggedLineString line);
    public void Add(LineSegment seg);
    public void Remove(LineSegment seg);
    public IList`1<LineSegment> Query(LineSegment querySeg);
}
public class NetTopologySuite.Simplify.LineSegmentVisitor : object {
    private LineSegment _querySeg;
    private IList`1<LineSegment> _items;
    public IList`1<LineSegment> Items { get; }
    public LineSegmentVisitor(LineSegment querySeg);
    public sealed virtual void VisitItem(LineSegment item);
    public IList`1<LineSegment> get_Items();
}
internal class NetTopologySuite.Simplify.LinkedRing : object {
    private static int NoCoordIndex;
    private Coordinate[] _coord;
    private Int32[] _next;
    private Int32[] _prev;
    private int _size;
    public int Count { get; }
    public Coordinate[] Coordinates { get; }
    public LinkedRing(Coordinate[] pts);
    private static Int32[] CreateNextLinks(int size);
    private static Int32[] CreatePrevLinks(int size);
    public int get_Count();
    public int Next(int i);
    public int Prev(int i);
    public Coordinate GetCoordinate(int index);
    public Coordinate PrevCoordinate(int index);
    public Coordinate NextCoordinate(int index);
    public bool HasCoordinate(int index);
    public void RemoveAt(int index);
    public Coordinate[] get_Coordinates();
}
public class NetTopologySuite.Simplify.OldVWLineSimplifier : object {
    private Coordinate[] _pts;
    private double _tolerance;
    public OldVWLineSimplifier(Coordinate[] pts, double distanceTolerance);
    public static Coordinate[] Simplify(Coordinate[] pts, double distanceTolerance);
    public Coordinate[] Simplify();
    private double SimplifyVertex(VWVertex vwLine);
}
public class NetTopologySuite.Simplify.PolygonHullSimplifier : object {
    private Geometry _inputGeom;
    private bool _isOuter;
    private double _vertexNumFraction;
    private double _areaDeltaRatio;
    private GeometryFactory _geomFactory;
    public double VertexNumFraction { get; public set; }
    public double AreaDeltaRatio { get; public set; }
    public PolygonHullSimplifier(Geometry inputGeom, bool isOuter);
    public static Geometry Hull(Geometry geom, bool isOuter, double vertexNumFraction);
    public static Geometry HullByAreaDelta(Geometry geom, bool isOuter, double areaDeltaRatio);
    public double get_VertexNumFraction();
    public void set_VertexNumFraction(double value);
    public double get_AreaDeltaRatio();
    public void set_AreaDeltaRatio(double value);
    public Geometry GetResult();
    private Geometry ComputeMultiPolygonAll(MultiPolygon multiPoly);
    private Geometry ComputeMultiPolygonEach(MultiPolygon multiPoly);
    private Polygon ComputePolygon(Polygon poly);
    private List`1<RingHull> InitPolygon(Polygon poly, RingHullIndex hullIndex);
    private static double RingArea(Polygon poly);
    private RingHull CreateRingHull(LinearRing ring, bool isOuter, double areaTotal, RingHullIndex hullIndex);
    private Polygon CreatePolygonHull(Polygon poly, List`1<RingHull> ringHulls, RingHullIndex hullIndex);
}
internal class NetTopologySuite.Simplify.RingHull : object {
    private LinearRing _inputRing;
    private int _targetVertexNum;
    private double _targetAreaDelta;
    private LinkedRing _vertexRing;
    private double _areaDelta;
    private VertexSequencePackedRtree _vertexIndex;
    private PriorityQueue`1<Corner> _cornerQueue;
    public int MinVertexNum { get; public set; }
    public double MaxAreaDelta { get; public set; }
    public Envelope Envelope { get; }
    public VertexSequencePackedRtree VertexIndex { get; }
    public RingHull(LinearRing ring, bool isOuter);
    public int get_MinVertexNum();
    public void set_MinVertexNum(int value);
    public double get_MaxAreaDelta();
    public void set_MaxAreaDelta(double value);
    public Envelope get_Envelope();
    public VertexSequencePackedRtree get_VertexIndex();
    public LinearRing GetHull(RingHullIndex hullIndex);
    private void Init(Coordinate[] ring, bool isOuter);
    private void AddCorner(int i, PriorityQueue`1<Corner> cornerQueue);
    public static bool IsConvex(LinkedRing vertexRing, int index);
    public static double Area(LinkedRing vertexRing, int index);
    public void Compute(RingHullIndex hullIndex);
    private bool IsAtTarget(Corner corner);
    private void RemoveCorner(Corner corner, PriorityQueue`1<Corner> cornerQueue);
    private bool IsRemovable(Corner corner, RingHullIndex hullIndex);
    private bool HasIntersectingVertex(Corner corner, Envelope cornerEnv, RingHull hull);
    private Coordinate GetCoordinate(int index);
    private Int32[] Query(Envelope cornerEnv);
    private void QueryHull(Envelope queryEnv, IList`1<Coordinate> pts);
    public Polygon ToGeometry();
}
internal class NetTopologySuite.Simplify.RingHullIndex : object {
    private List`1<RingHull> _hulls;
    public void Add(RingHull ringHull);
    public List`1<RingHull> Query(Envelope queryEnv);
}
public class NetTopologySuite.Simplify.TaggedLineSegment : LineSegment {
    private Geometry _parent;
    private int _index;
    public Geometry Parent { get; }
    public int Index { get; }
    public TaggedLineSegment(Coordinate p0, Coordinate p1, Geometry parent, int index);
    public TaggedLineSegment(Coordinate p0, Coordinate p1);
    public Geometry get_Parent();
    public int get_Index();
}
public class NetTopologySuite.Simplify.TaggedLinesSimplifier : object {
    private LineSegmentIndex _inputIndex;
    private LineSegmentIndex _outputIndex;
    [CompilerGeneratedAttribute]
private double <DistanceTolerance>k__BackingField;
    public double DistanceTolerance { get; public set; }
    [CompilerGeneratedAttribute]
public double get_DistanceTolerance();
    [CompilerGeneratedAttribute]
public void set_DistanceTolerance(double value);
    public void Simplify(ICollection`1<TaggedLineString> taggedLines);
}
public class NetTopologySuite.Simplify.TaggedLineString : object {
    private LineString _parentLine;
    private TaggedLineSegment[] _segs;
    private IList`1<LineSegment> _resultSegs;
    private int _minimumSize;
    public int MinimumSize { get; }
    public LineString Parent { get; }
    public Coordinate[] ParentCoordinates { get; }
    public Coordinate[] ResultCoordinates { get; }
    public int ResultSize { get; }
    public TaggedLineSegment[] Segments { get; }
    public TaggedLineString(LineString parentLine);
    public TaggedLineString(LineString parentLine, int minimumSize);
    public int get_MinimumSize();
    public LineString get_Parent();
    public Coordinate[] get_ParentCoordinates();
    public Coordinate[] get_ResultCoordinates();
    public int get_ResultSize();
    public TaggedLineSegment GetSegment(int i);
    private void Init();
    public TaggedLineSegment[] get_Segments();
    public void AddToResult(LineSegment seg);
    public LineString AsLineString();
    public LinearRing AsLinearRing();
    private static Coordinate[] ExtractCoordinates(IList`1<LineSegment> segs);
}
public class NetTopologySuite.Simplify.TaggedLineStringSimplifier : object {
    private LineIntersector _li;
    private LineSegmentIndex _inputIndex;
    private LineSegmentIndex _outputIndex;
    private TaggedLineString _line;
    private Coordinate[] _linePts;
    private double _distanceTolerance;
    public double DistanceTolerance { get; public set; }
    public TaggedLineStringSimplifier(LineSegmentIndex inputIndex, LineSegmentIndex outputIndex);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public void Simplify(TaggedLineString line);
    private void SimplifySection(int i, int j, int depth);
    private int FindFurthestPoint(Coordinate[] pts, int i, int j, Double[] maxDistance);
    private LineSegment Flatten(int start, int end);
    private bool HasBadIntersection(TaggedLineString parentLine, Int32[] sectionIndex, LineSegment candidateSeg);
    private bool HasBadOutputIntersection(LineSegment candidateSeg);
    private bool HasBadInputIntersection(TaggedLineString parentLine, Int32[] sectionIndex, LineSegment candidateSeg);
    private static bool IsInLineSection(TaggedLineString line, Int32[] sectionIndex, TaggedLineSegment seg);
    private bool HasInteriorIntersection(LineSegment seg0, LineSegment seg1);
    private void Remove(TaggedLineString line, int start, int end);
}
public class NetTopologySuite.Simplify.TopologyPreservingSimplifier : object {
    private Geometry _inputGeom;
    private TaggedLinesSimplifier _lineSimplifier;
    private Dictionary`2<LineString, TaggedLineString> _lineStringMap;
    public double DistanceTolerance { get; public set; }
    public TopologyPreservingSimplifier(Geometry inputGeom);
    public static Geometry Simplify(Geometry geom, double distanceTolerance);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public Geometry GetResultGeometry();
}
public class NetTopologySuite.Simplify.VWLineSimplifier : object {
    private Coordinate[] _pts;
    private double _tolerance;
    public VWLineSimplifier(Coordinate[] pts, double distanceTolerance);
    public static Coordinate[] Simplify(Coordinate[] pts, double distanceTolerance);
    public Coordinate[] Simplify();
}
public class NetTopologySuite.Simplify.VWSimplifier : object {
    private Geometry _inputGeom;
    private double _distanceTolerance;
    private bool _isEnsureValidTopology;
    public double DistanceTolerance { get; public set; }
    public bool IsEnsureValidTopology { get; public set; }
    public VWSimplifier(Geometry inputGeom);
    public static Geometry Simplify(Geometry geom, double distanceTolerance);
    public double get_DistanceTolerance();
    public void set_DistanceTolerance(double value);
    public bool get_IsEnsureValidTopology();
    public void set_IsEnsureValidTopology(bool value);
    public Geometry GetResultGeometry();
}
public class NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder : object {
    private ICollection`1<Coordinate> _siteCoords;
    private Geometry _constraintLines;
    private double _tolerance;
    private QuadEdgeSubdivision _subdiv;
    private IDictionary`2<Coordinate, Vertex> _constraintVertexMap;
    unknown Geometry Constraints {public set; }
    public double Tolerance { get; public set; }
    public void SetSites(Geometry sites);
    public void set_Constraints(Geometry value);
    public double get_Tolerance();
    public void set_Tolerance(double value);
    private void Create();
    private IEnumerable`1<Vertex> CreateSiteVertices(IEnumerable`1<Coordinate> coords);
    private void CreateVertices(Geometry geom);
    private static List`1<Segment> CreateConstraintSegments(Geometry geom);
    private static void CreateConstraintSegments(LineString line, IList`1<Segment> constraintSegs);
    public QuadEdgeSubdivision GetSubdivision();
    public MultiLineString GetEdges(GeometryFactory geomFact);
    public GeometryCollection GetTriangles(GeometryFactory geomFact);
}
public class NetTopologySuite.Triangulate.ConformingDelaunayTriangulator : object {
    private IList`1<Vertex> _initialVertices;
    private IList`1<Vertex> _segVertices;
    private IList`1<Segment> _segments;
    private QuadEdgeSubdivision _subdiv;
    private IncrementalDelaunayTriangulator _incDel;
    private Geometry _convexHull;
    private IConstraintSplitPointFinder _splitFinder;
    private KdTree`1<Vertex> _kdt;
    private ConstraintVertexFactory _vertexFactory;
    private Envelope _computeAreaEnv;
    private Coordinate _splitPt;
    private double _tolerance;
    private static int MaxSplitIteration;
    public IConstraintSplitPointFinder SplitPointFinder { get; public set; }
    public double Tolerance { get; }
    public ConstraintVertexFactory VertexFactory { get; public set; }
    public QuadEdgeSubdivision Subdivision { get; }
    public KdTree`1<Vertex> KDT { get; }
    public IList`1<Vertex> InitialVertices { get; }
    public ICollection`1<Segment> ConstraintSegments { get; }
    public Geometry ConvexHull { get; }
    public ConformingDelaunayTriangulator(IEnumerable`1<Vertex> initialVertices, double tolerance);
    private static Envelope ComputeVertexEnvelope(IEnumerable`1<Vertex> vertices);
    public void SetConstraints(IList`1<Segment> segments, IList`1<Vertex> segVertices);
    public IConstraintSplitPointFinder get_SplitPointFinder();
    public void set_SplitPointFinder(IConstraintSplitPointFinder value);
    public double get_Tolerance();
    public ConstraintVertexFactory get_VertexFactory();
    public void set_VertexFactory(ConstraintVertexFactory value);
    public QuadEdgeSubdivision get_Subdivision();
    public KdTree`1<Vertex> get_KDT();
    public IList`1<Vertex> get_InitialVertices();
    public ICollection`1<Segment> get_ConstraintSegments();
    public Geometry get_ConvexHull();
    private void ComputeBoundingBox();
    private void ComputeConvexHull();
    private Coordinate[] GetPointArray();
    private ConstraintVertex CreateVertex(Coordinate p);
    private ConstraintVertex CreateVertex(Coordinate p, Segment seg);
    private void InsertSites(ICollection`1<Vertex> vertices);
    private ConstraintVertex InsertSite(ConstraintVertex v);
    public void InsertSite(Coordinate p);
    public void FormInitialDelaunay();
    public void EnforceConstraints();
    private void AddConstraintVertices();
    private int EnforceGabriel(ICollection`1<Segment> segsToInsert);
    private Coordinate FindNonGabrielPoint(Segment seg);
}
public class NetTopologySuite.Triangulate.ConstraintEnforcementException : Exception {
    private Coordinate _pt;
    public Coordinate Coordinate { get; }
    public ConstraintEnforcementException(string msg);
    public ConstraintEnforcementException(string msg, Coordinate pt);
    private static string MsgWithCoord(string msg, Coordinate pt);
    public Coordinate get_Coordinate();
}
public class NetTopologySuite.Triangulate.ConstraintVertex : Vertex {
    private bool isOnConstraint;
    private object constraint;
    public bool IsOnConstraint { get; public set; }
    public object Constraint { get; public set; }
    public ConstraintVertex(Coordinate p);
    public bool get_IsOnConstraint();
    public void set_IsOnConstraint(bool value);
    public object get_Constraint();
    public void set_Constraint(object value);
    protected internal void Merge(ConstraintVertex other);
}
public interface NetTopologySuite.Triangulate.ConstraintVertexFactory {
    public abstract virtual ConstraintVertex CreateVertex(Coordinate p, Segment constraintSeg);
}
public class NetTopologySuite.Triangulate.DelaunayTriangulationBuilder : object {
    private ICollection`1<Coordinate> _siteCoords;
    private double _tolerance;
    private QuadEdgeSubdivision _subdiv;
    unknown double Tolerance {public set; }
    public static CoordinateList ExtractUniqueCoordinates(Geometry geom);
    public static CoordinateList Unique(Coordinate[] coords);
    public static IList`1<Vertex> ToVertices(ICollection`1<Coordinate> coords);
    public static Envelope Envelope(ICollection`1<Coordinate> coords);
    public void SetSites(Geometry geom);
    public void SetSites(ICollection`1<Coordinate> coords);
    public void set_Tolerance(double value);
    private void Create();
    public QuadEdgeSubdivision GetSubdivision();
    public MultiLineString GetEdges(GeometryFactory geomFact);
    public GeometryCollection GetTriangles(GeometryFactory geomFact);
}
public interface NetTopologySuite.Triangulate.IConstraintSplitPointFinder {
    public abstract virtual Coordinate FindSplitPoint(Segment seg, Coordinate encroachPt);
}
public class NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator : object {
    private QuadEdgeSubdivision _subdiv;
    private bool _isUsingTolerance;
    public IncrementalDelaunayTriangulator(QuadEdgeSubdivision subdiv);
    public void InsertSites(ICollection`1<Vertex> vertices);
    public QuadEdge InsertSite(Vertex v);
}
public class NetTopologySuite.Triangulate.MidpointSplitPointFinder : object {
    public sealed virtual Coordinate FindSplitPoint(Segment seg, Coordinate encroachPt);
}
public class NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder : object {
    public sealed virtual Coordinate FindSplitPoint(Segment seg, Coordinate encroachPt);
    public static Coordinate ProjectedSplitPoint(Segment seg, Coordinate encroachPt);
}
public class NetTopologySuite.Triangulate.Polygon.ConstrainedDelaunayTriangulator : object {
    private GeometryFactory _geomFact;
    private Geometry _inputGeom;
    private List`1<Tri> _triList;
    public ConstrainedDelaunayTriangulator(Geometry inputGeom);
    public static Geometry Triangulate(Geometry geom);
    public Geometry GetResult();
    public IList`1<Tri> GetTriangles();
    private void Compute();
    private IList`1<Tri> TriangulatePolygon(Polygon poly);
}
internal class NetTopologySuite.Triangulate.Polygon.PolygonEarClipper : object {
    private static int NoVertexIndex;
    private bool _isFlatCornersSkipped;
    private Coordinate[] _vertex;
    private Int32[] _vertexNext;
    private int _vertexSize;
    private int _vertexFirst;
    private Int32[] _cornerIndex;
    private VertexSequencePackedRtree _vertexCoordIndex;
    public bool SkipFlatCorners { get; public set; }
    public PolygonEarClipper(Coordinate[] polyShell);
    public static IList`1<Tri> Triangulate(Coordinate[] polyShell);
    private static Int32[] CreateNextLinks(int size);
    public bool get_SkipFlatCorners();
    public void set_SkipFlatCorners(bool value);
    public IList`1<Tri> Compute();
    private bool IsValidEar(int cornerIndex, Coordinate[] corner);
    private int FindIntersectingVertex(int cornerIndex, Coordinate[] corner);
    private bool IsValidEarScan(int cornerIndex, Coordinate[] corner);
    private static Envelope Envelope(Coordinate[] corner);
    private void RemoveCorner();
    private bool IsRemoved(int vertexIndex);
    private void InitCornerIndex();
    private void FetchCorner(Coordinate[] cornerVertex);
    private void NextCorner(Coordinate[] cornerVertex);
    private int NextIndex(int index);
    private static bool IsConvex(Coordinate[] pts);
    private static bool IsFlat(Coordinate[] pts);
    private static bool IsCornerInvalid(Coordinate[] pts);
    public Polygon ToGeometry();
}
public class NetTopologySuite.Triangulate.Polygon.PolygonHoleJoiner : object {
    private static IComparer`1<Coordinate> _comparer;
    private static double EPS;
    private List`1<Coordinate> _shellCoords;
    private HashSet`1<Coordinate> _shellCoordsSorted;
    private Coordinate[] _shellCoordsSortedArray;
    private Dictionary`2<Coordinate, List`1<Coordinate>> _cutMap;
    private ISegmentSetMutualIntersector _polygonIntersector;
    private Polygon _inputPolygon;
    private Coordinate Min { get; }
    public PolygonHoleJoiner(Polygon inputPolygon);
    private static PolygonHoleJoiner();
    public static Polygon JoinAsPolygon(Polygon inputPolygon);
    public static Coordinate[] Join(Polygon inputPolygon);
    public Coordinate[] Compute();
    private static List`1<Coordinate> RingCoordinates(LineString ring);
    private void JoinHoles();
    private void AddOrderedCoord(Coordinate coord);
    private void JoinHole(LinearRing hole);
    private int GetShellCoordIndex(Coordinate shellVertex, Coordinate holeVertex);
    private int GetShellCoordIndexSkip(Coordinate coord, int numSkip);
    private List`1<Coordinate> FindLeftShellVertices(Coordinate holeCoord);
    private bool IsJoinable(Coordinate holeCoord, Coordinate shellCoord);
    private bool CrossesPolygon(Coordinate p0, Coordinate p1);
    private void AddHoleToShell(int shellJoinIndex, Coordinate[] holeCoords, int holeJoinIndex);
    private static List`1<LinearRing> SortHoles(Polygon poly);
    private static List`1<int> FindLeftVertices(LinearRing ring);
    private static ISegmentSetMutualIntersector CreatePolygonIntersector(Polygon polygon);
    private Coordinate Above(Coordinate coordinate);
    private Coordinate Below(Coordinate coordinate);
    private Coordinate get_Min();
}
public class NetTopologySuite.Triangulate.Polygon.PolygonTriangulator : object {
    private GeometryFactory _geomFact;
    private Geometry _inputGeom;
    private List`1<Tri> _triList;
    public PolygonTriangulator(Geometry inputGeom);
    public static Geometry Triangulate(Geometry geom);
    public Geometry GetResult();
    public List`1<Tri> GetTriangles();
    private void Compute();
    private IList`1<Tri> TriangulatePolygon(Polygon poly);
}
internal class NetTopologySuite.Triangulate.Polygon.TriDelaunayImprover : object {
    private static int MaxIteration;
    private IList`1<Tri> _triList;
    private TriDelaunayImprover(IList`1<Tri> triList);
    public static void Improve(IList`1<Tri> triList);
    private void Improve();
    private int ImproveScan(IList`1<Tri> triList);
    private bool ImproveNonDelaunay(Tri tri, int index);
    private static bool IsConvex(Coordinate adj0, Coordinate adj1, Coordinate opp0, Coordinate opp1);
    private static bool IsDelaunay(Coordinate adj0, Coordinate adj1, Coordinate opp0, Coordinate opp1);
    private static bool IsInCircle(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
}
public class NetTopologySuite.Triangulate.QuadEdge.EdgeConnectedTriangleTraversal : object {
    private LinkedList`1<QuadEdgeTriangle> _triQueue;
    public void Init(QuadEdgeTriangle tri);
    public void Init(IEnumerable`1<QuadEdgeTriangle> tris);
    public void VisitAll(ITraversalVisitor visitor);
    private void Process(QuadEdgeTriangle currTri, ITraversalVisitor visitor);
}
public interface NetTopologySuite.Triangulate.QuadEdge.IQuadEdgeLocator {
    public abstract virtual QuadEdge Locate(Vertex v);
}
public interface NetTopologySuite.Triangulate.QuadEdge.ITraversalVisitor {
    public abstract virtual bool Visit(QuadEdgeTriangle currTri, int edgeIndex, QuadEdgeTriangle neighbTri);
}
public interface NetTopologySuite.Triangulate.QuadEdge.ITriangleVisitor {
    public abstract virtual void Visit(QuadEdge[] triEdges);
}
public class NetTopologySuite.Triangulate.QuadEdge.LastFoundQuadEdgeLocator : object {
    private QuadEdgeSubdivision _subdiv;
    private QuadEdge _lastEdge;
    public LastFoundQuadEdgeLocator(QuadEdgeSubdivision subdiv);
    private void Init();
    private QuadEdge FindEdge();
    public sealed virtual QuadEdge Locate(Vertex v);
}
public class NetTopologySuite.Triangulate.QuadEdge.LocateFailureException : Exception {
    [CompilerGeneratedAttribute]
private LineSegment <Segment>k__BackingField;
    public LineSegment Segment { get; private set; }
    public LocateFailureException(string msg);
    public LocateFailureException(string msg, LineSegment seg);
    public LocateFailureException(LineSegment seg);
    private static string MsgWithSpatial(string msg, LineSegment seg);
    [CompilerGeneratedAttribute]
public LineSegment get_Segment();
    [CompilerGeneratedAttribute]
private void set_Segment(LineSegment value);
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdge : object {
    private Vertex _vertex;
    private QuadEdge _next;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private QuadEdge <Rot>k__BackingField;
    public object Data { get; public set; }
    public bool IsLive { get; }
    public QuadEdge Rot { get; private set; }
    public QuadEdge InvRot { get; }
    public QuadEdge Sym { get; }
    public QuadEdge ONext { get; }
    public QuadEdge OPrev { get; }
    public QuadEdge DNext { get; }
    public QuadEdge DPrev { get; }
    public QuadEdge LNext { get; }
    public QuadEdge LPrev { get; }
    public QuadEdge RNext { get; }
    public QuadEdge RPrev { get; }
    public Vertex Orig { get; internal set; }
    public Vertex Dest { get; internal set; }
    public double Length { get; }
    public static QuadEdge MakeEdge(Vertex o, Vertex d);
    public static QuadEdge Connect(QuadEdge a, QuadEdge b);
    public static void Splice(QuadEdge a, QuadEdge b);
    public static void Swap(QuadEdge e);
    public QuadEdge GetPrimary();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    [CompilerGeneratedAttribute]
public object get_Data();
    public void Delete();
    public bool get_IsLive();
    public void SetNext(QuadEdge next);
    [CompilerGeneratedAttribute]
public QuadEdge get_Rot();
    [CompilerGeneratedAttribute]
private void set_Rot(QuadEdge value);
    public QuadEdge get_InvRot();
    public QuadEdge get_Sym();
    public QuadEdge get_ONext();
    public QuadEdge get_OPrev();
    public QuadEdge get_DNext();
    public QuadEdge get_DPrev();
    public QuadEdge get_LNext();
    public QuadEdge get_LPrev();
    public QuadEdge get_RNext();
    public QuadEdge get_RPrev();
    public Vertex get_Orig();
    internal void set_Orig(Vertex value);
    public Vertex get_Dest();
    internal void set_Dest(Vertex value);
    public double get_Length();
    public bool EqualsNonOriented(QuadEdge qe);
    public bool EqualsOriented(QuadEdge qe);
    public LineSegment ToLineSegment();
    public virtual string ToString();
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdgeSubdivision : object {
    private static double EdgeCoincidenceToleranceFactor;
    private int _visitedKey;
    private List`1<QuadEdge> _quadEdges;
    private QuadEdge _startingEdge;
    private double _tolerance;
    private double _edgeCoincidenceTolerance;
    private Vertex[] _frameVertex;
    private Envelope _frameEnv;
    private IQuadEdgeLocator _locator;
    private LineSegment seg;
    private QuadEdge[] _triEdges;
    public double Tolerance { get; }
    public Envelope Envelope { get; }
    public QuadEdgeSubdivision(Envelope env, double tolerance);
    public static void GetTriangleEdges(QuadEdge startQE, QuadEdge[] triEdge);
    private void CreateFrame(Envelope env);
    private QuadEdge InitSubdiv();
    public double get_Tolerance();
    public Envelope get_Envelope();
    public IList`1<QuadEdge> GetEdges();
    public void SetLocator(IQuadEdgeLocator locator);
    public QuadEdge MakeEdge(Vertex o, Vertex d);
    public QuadEdge Connect(QuadEdge a, QuadEdge b);
    public void Delete(QuadEdge e);
    public QuadEdge LocateFromEdge(Vertex v, QuadEdge startEdge);
    public QuadEdge Locate(Vertex v);
    public QuadEdge Locate(Coordinate p);
    public QuadEdge Locate(Coordinate p0, Coordinate p1);
    public QuadEdge InsertSite(Vertex v);
    public bool IsFrameEdge(QuadEdge e);
    public bool IsFrameBorderEdge(QuadEdge e);
    public bool IsFrameVertex(Vertex v);
    public bool IsOnEdge(QuadEdge e, Coordinate p);
    public bool IsVertexOfEdge(QuadEdge e, Vertex v);
    public IEnumerable`1<Vertex> GetVertices(bool includeFrame);
    public IList`1<QuadEdge> GetVertexUniqueEdges(bool includeFrame);
    public IList`1<QuadEdge> GetPrimaryEdges(bool includeFrame);
    public void VisitTriangles(ITriangleVisitor triVisitor, bool includeFrame);
    private QuadEdge[] FetchTriangleToVisit(QuadEdge edge, Stack`1<QuadEdge> edgeStack, bool includeFrame, HashSet`1<QuadEdge> visitedEdges);
    public IList`1<QuadEdge[]> GetTriangleEdges(bool includeFrame);
    public IList`1<Vertex[]> GetTriangleVertices(bool includeFrame);
    public IList`1<Coordinate[]> GetTriangleCoordinates(bool includeFrame);
    public MultiLineString GetEdges(GeometryFactory geomFact);
    public GeometryCollection GetTriangles(GeometryFactory geomFact);
    public GeometryCollection GetVoronoiDiagram(GeometryFactory geomFact);
    public IList`1<Geometry> GetVoronoiCellPolygons(GeometryFactory geomFact);
    public Polygon GetVoronoiCellPolygon(QuadEdge qe, GeometryFactory geomFact);
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdgeTriangle : object {
    private QuadEdge[] _edge;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public object Data { get; public set; }
    public QuadEdgeTriangle(QuadEdge[] edge);
    public static IList`1<QuadEdgeTriangle> CreateOn(QuadEdgeSubdivision subdiv);
    public static bool Contains(Vertex[] tri, Coordinate pt);
    public static bool Contains(QuadEdge[] tri, Coordinate pt);
    public static Geometry ToPolygon(Vertex[] v);
    public static Geometry ToPolygon(QuadEdge[] e);
    private static QuadEdge[] CopyOf(QuadEdge[] edge);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    public void Kill();
    public bool IsLive();
    public QuadEdge[] GetEdges();
    public QuadEdge GetEdge(int i);
    public Vertex GetVertex(int i);
    public Vertex[] GetVertices();
    public Coordinate GetCoordinate(int i);
    public int GetEdgeIndex(QuadEdge e);
    public int GetEdgeIndex(Vertex v);
    public void GetEdgeSegment(int i, LineSegment seg);
    public Coordinate[] GetCoordinates();
    public bool Contains(Coordinate pt);
    public Geometry GetGeometry(GeometryFactory fact);
    public virtual string ToString();
    public bool IsBorder();
    public bool IsBorder(int i);
    public QuadEdgeTriangle GetAdjacentTriangleAcrossEdge(int edgeIndex);
    public int GetAdjacentTriangleEdgeIndex(int i);
    public IList`1<QuadEdgeTriangle> GetTrianglesAdjacentToVertex(int vertexIndex);
    public QuadEdgeTriangle[] GetNeighbours();
}
public class NetTopologySuite.Triangulate.QuadEdge.QuadEdgeUtil : object {
    public static IList`1<QuadEdge> FindEdgesIncidentOnOrigin(QuadEdge start);
}
public static class NetTopologySuite.Triangulate.QuadEdge.TrianglePredicate : object {
    public static bool IsInCircleNonRobust(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    public static bool IsInCircleNormalized(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    private static double TriArea(Coordinate a, Coordinate b, Coordinate c);
    public static bool IsInCircleRobust(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    public static bool IsInCircleDDFast(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    private static DD TriAreaDDFast(Coordinate a, Coordinate b, Coordinate c);
    public static bool IsInCircleDDNormalized(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
    public static bool IsInCircleCC(Coordinate a, Coordinate b, Coordinate c, Coordinate p);
}
public class NetTopologySuite.Triangulate.QuadEdge.Vertex : object {
    private static int LEFT;
    private static int RIGHT;
    private static int BEYOND;
    private static int BEHIND;
    private static int BETWEEN;
    private static int ORIGIN;
    private static int DESTINATION;
    private Coordinate _p;
    public double X { get; }
    public double Y { get; }
    public double Z { get; public set; }
    public Coordinate Coordinate { get; }
    public Vertex(double x, double y);
    public Vertex(double x, double y, double z);
    public Vertex(Coordinate p);
    public double get_X();
    public double get_Y();
    public double get_Z();
    public void set_Z(double value);
    public Coordinate get_Coordinate();
    public virtual string ToString();
    public sealed virtual bool Equals(Vertex x);
    public bool Equals(Vertex x, double tolerance);
    public int Classify(Vertex p0, Vertex p1);
    private double CrossProduct(Vertex v);
    private double Dot(Vertex v);
    private Vertex Times(double c);
    private Vertex Sum(Vertex v);
    private Vertex Sub(Vertex v);
    private double Magnitude();
    private Vertex Cross();
    public bool IsInCircle(Vertex a, Vertex b, Vertex c);
    private bool IsCcw(Vertex b, Vertex c);
    internal bool RightOf(QuadEdge e);
    private bool LeftOf(QuadEdge e);
    private static HCoordinate Bisector(Vertex a, Vertex b);
    private static double Distance(Vertex v1, Vertex v2);
    public double CircumRadiusRatio(Vertex b, Vertex c);
    public Vertex MidPoint(Vertex a);
    public Vertex CircleCenter(Vertex b, Vertex c);
    public double InterpolateZValue(Vertex v0, Vertex v1, Vertex v2);
    public static double InterpolateZ(Coordinate p, Coordinate v0, Coordinate v1, Coordinate v2);
    public static double InterpolateZ(Coordinate p, Coordinate p0, Coordinate p1);
}
public class NetTopologySuite.Triangulate.Segment : object {
    private LineSegment _ls;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public Coordinate Start { get; }
    public Coordinate End { get; }
    public double StartX { get; }
    public double StartY { get; }
    public double StartZ { get; }
    public double EndX { get; }
    public double EndY { get; }
    public double EndZ { get; }
    public LineSegment LineSegment { get; }
    public object Data { get; public set; }
    public Segment(double x1, double y1, double z1, double x2, double y2, double z2);
    public Segment(double x1, double y1, double z1, double x2, double y2, double z2, object data);
    public Segment(Coordinate p0, Coordinate p1, object data);
    public Segment(Coordinate p0, Coordinate p1);
    public Coordinate get_Start();
    public Coordinate get_End();
    public double get_StartX();
    public double get_StartY();
    public double get_StartZ();
    public double get_EndX();
    public double get_EndY();
    public double get_EndZ();
    public LineSegment get_LineSegment();
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
    public bool EqualsTopologically(Segment s);
    public Coordinate Intersection(Segment s);
    public virtual string ToString();
}
public class NetTopologySuite.Triangulate.SplitSegment : object {
    private LineSegment _seg;
    private double _segLen;
    private Coordinate _splitPt;
    private double _minimumLen;
    public double MinimumLength { get; public set; }
    public Coordinate SplitPoint { get; }
    public SplitSegment(LineSegment seg);
    private static Coordinate PointAlongReverse(LineSegment seg, double segmentLengthFraction);
    public double get_MinimumLength();
    public void set_MinimumLength(double value);
    public Coordinate get_SplitPoint();
    public void SplitAt(double length, Coordinate endPt);
    public void SplitAt(Coordinate pt);
    private double GetConstrainedLength(double len);
}
public class NetTopologySuite.Triangulate.Tri.Tri : object {
    private Coordinate _p0;
    private Coordinate _p1;
    private Coordinate _p2;
    private Tri _tri0;
    private Tri _tri1;
    private Tri _tri2;
    protected Coordinate P0 { get; }
    protected Coordinate P1 { get; }
    protected Coordinate P2 { get; }
    protected Tri Tri0 { get; }
    protected Tri Tri1 { get; }
    protected Tri Tri2 { get; }
    public int NumAdjacent { get; }
    public double Area { get; }
    public double Length { get; }
    public Tri(Coordinate p0, Coordinate p1, Coordinate p2);
    public static Geometry ToGeometry(ICollection`1<Tri> tris, GeometryFactory geomFact);
    public static double AreaOf(IEnumerable`1<Tri> triList);
    public static void Validate(IEnumerable`1<Tri> triList);
    public static Tri Create(Coordinate p0, Coordinate p1, Coordinate p2);
    public static Tri Create(Coordinate[] pts);
    protected Coordinate get_P0();
    protected Coordinate get_P1();
    protected Coordinate get_P2();
    protected Tri get_Tri0();
    protected Tri get_Tri1();
    protected Tri get_Tri2();
    public void SetAdjacent(Tri tri0, Tri tri1, Tri tri2);
    public void SetAdjacent(Coordinate pt, Tri tri);
    public void SetTri(int edgeIndex, Tri tri);
    private void SetCoordinates(Coordinate p0, Coordinate p1, Coordinate p2);
    public Tri Split(Coordinate p);
    public void Flip(int index);
    private void Flip(Tri tri, int index0, int index1, Coordinate adj0, Coordinate adj1, Coordinate opp0, Coordinate opp1);
    private void Replace(Tri triOld, Tri triNew);
    public int Degree(int index, IList`1<Tri> triList);
    public void Remove(IList`1<Tri> triList);
    public void Remove();
    private void Remove(int index);
    private Tri[] GetAdjacentTris(Tri triAdj, int index, int indexAdj);
    public void Validate();
    public void ValidateAdjacent(int index);
    public Coordinate GetCoordinate(int index);
    public int GetIndex(Coordinate p);
    public int GetIndex(Tri tri);
    public Tri GetAdjacent(int index);
    public bool HasAdjacent();
    public bool HasAdjacent(int index);
    public bool IsAdjacent(Tri tri);
    public int get_NumAdjacent();
    public bool IsInteriorVertex(int index);
    public bool IsBorder();
    public bool IsBoundary(int index);
    public static int Next(int index);
    public static int Prev(int index);
    public static int OppVertex(int edgeIndex);
    public static int OppEdge(int vertexIndex);
    public Coordinate MidPoint(int edgeIndex);
    public double get_Area();
    public double get_Length();
    public double GetLength(int edgeIndex);
    public Polygon ToPolygon(GeometryFactory geomFact);
    public virtual string ToString();
}
public class NetTopologySuite.Triangulate.Tri.TriangulationBuilder : object {
    private Dictionary`2<TriEdge, Tri> _triMap;
    private TriangulationBuilder(IEnumerable`1<Tri> triList);
    public static void Build(IEnumerable`1<Tri> triList);
    private Tri Find(Coordinate p0, Coordinate p1);
    private void Add(Tri tri);
    private void AddAdjacent(Tri tri, Tri adj, Coordinate p0, Coordinate p1);
}
internal class NetTopologySuite.Triangulate.Tri.TriEdge : object {
    [CompilerGeneratedAttribute]
private Coordinate <P0>k__BackingField;
    [CompilerGeneratedAttribute]
private Coordinate <P1>k__BackingField;
    public Coordinate P0 { get; private set; }
    public Coordinate P1 { get; private set; }
    public TriEdge(Coordinate a, Coordinate b);
    [CompilerGeneratedAttribute]
public Coordinate get_P0();
    [CompilerGeneratedAttribute]
private void set_P0(Coordinate value);
    [CompilerGeneratedAttribute]
public Coordinate get_P1();
    [CompilerGeneratedAttribute]
private void set_P1(Coordinate value);
    private void Normalize();
    public virtual int GetHashCode();
    public virtual bool Equals(object arg);
    public virtual string ToString();
}
public class NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper : object {
    private IDictionary`2<Coordinate, object> _coordDataMap;
    public IList`1<Coordinate> Coordinates { get; }
    public void LoadSourceGeometries(Geometry geoms);
    public void LoadSourceGeometries(ICollection`1<Geometry> geoms);
    public void LoadSourceGeometries(GeometryCollection geomColl);
    private void LoadVertices(Coordinate[] pts, object data);
    public IList`1<Coordinate> get_Coordinates();
    public void TransferData(Geometry targetGeom);
}
public class NetTopologySuite.Triangulate.VoronoiDiagramBuilder : object {
    private ICollection`1<Coordinate> _siteCoords;
    private double _tolerance;
    private QuadEdgeSubdivision _subdiv;
    private Envelope _clipEnv;
    private Envelope _diagramEnv;
    unknown Envelope ClipEnvelope {public set; }
    unknown double Tolerance {public set; }
    public void SetSites(Geometry geom);
    public void SetSites(ICollection`1<Coordinate> coords);
    public void set_ClipEnvelope(Envelope value);
    public void set_Tolerance(double value);
    private void Create();
    public QuadEdgeSubdivision GetSubdivision();
    public GeometryCollection GetDiagram(GeometryFactory geomFact);
    private static GeometryCollection ClipGeometryCollection(GeometryCollection geom, Envelope clipEnv);
}
public class NetTopologySuite.Utilities.AlternativePriorityQueue`2 : object {
    private static int DefaultCapacity;
    private List`1<PriorityQueueNode`2<TPriority, TData>> nodes;
    private IComparer`1<TPriority> priorityComparer;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public PriorityQueueNode`2<TPriority, TData> Head { get; }
    public AlternativePriorityQueue`2(int capacity);
    public AlternativePriorityQueue`2(IComparer`1<TPriority> priorityComparer);
    public AlternativePriorityQueue`2(int capacity, IComparer`1<TPriority> priorityComparer);
    public AlternativePriorityQueue`2(AlternativePriorityQueue`2<TPriority, TData> copyFrom);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public PriorityQueueNode`2<TPriority, TData> get_Head();
    public void Clear();
    public bool Contains(PriorityQueueNode`2<TPriority, TData> node);
    public void Enqueue(PriorityQueueNode`2<TPriority, TData> node, TPriority priority);
    public PriorityQueueNode`2<TPriority, TData> Dequeue();
    public void ChangePriority(PriorityQueueNode`2<TPriority, TData> node, TPriority priority);
    public bool Remove(PriorityQueueNode`2<TPriority, TData> node);
    public sealed virtual IEnumerator`1<PriorityQueueNode`2<TPriority, TData>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void HeapifyUp(PriorityQueueNode`2<TPriority, TData> node);
    private void HeapifyDown(PriorityQueueNode`2<TPriority, TData> node);
    private void OnNodeUpdated(PriorityQueueNode`2<TPriority, TData> node);
    private void Swap(PriorityQueueNode`2<TPriority, TData> node1, PriorityQueueNode`2<TPriority, TData> node2);
    private bool HasHigherPriority(PriorityQueueNode`2<TPriority, TData> higher, PriorityQueueNode`2<TPriority, TData> lower);
}
public static class NetTopologySuite.Utilities.Assert : object {
    public static void IsTrue(bool assertion);
    public static void IsTrue(bool assertion, string message);
    public static void IsEquals(object expectedValue, object actualValue);
    public static void IsEquals(object expectedValue, object actualValue, string message);
    public static void ShouldNeverReachHere();
    public static void ShouldNeverReachHere(string message);
}
public class NetTopologySuite.Utilities.AssertionFailedException : ApplicationException {
    public AssertionFailedException(string message);
}
internal static class NetTopologySuite.Utilities.BitTweaks : object {
    internal static short ReverseByteOrder(short value);
    internal static int ReverseByteOrder(int value);
    internal static long ReverseByteOrder(long value);
    internal static float ReverseByteOrder(float value);
    internal static double ReverseByteOrder(double value);
    internal static ushort ReverseByteOrder(ushort value);
    internal static UInt32 ReverseByteOrder(UInt32 value);
    internal static ulong ReverseByteOrder(ulong value);
}
public class NetTopologySuite.Utilities.CoordinateArrayFilter : object {
    private Coordinate[] _pts;
    private int _n;
    public Coordinate[] Coordinates { get; }
    public CoordinateArrayFilter(int size);
    public Coordinate[] get_Coordinates();
    public sealed virtual void Filter(Coordinate coord);
}
public class NetTopologySuite.Utilities.CoordinateCompare : object {
    public sealed virtual int Compare(object x, object y);
}
public class NetTopologySuite.Utilities.CoordinateCountFilter : object {
    private int _n;
    public int Count { get; }
    public int get_Count();
    public sealed virtual void Filter(Coordinate coord);
}
public class NetTopologySuite.Utilities.Degrees : object {
    public static double ToRadians(double degrees);
}
[ObsoleteAttribute]
public static class NetTopologySuite.Utilities.EnumUtility : object {
    public static object Parse(Type type, string value);
    public static string Format(Type type, object value, string formatString);
}
public class NetTopologySuite.Utilities.FunctionsUtil : object {
    public static Envelope DefaultEnvelope;
    private static GeometryFactory Factory;
    private static FunctionsUtil();
    public static Envelope GetEnvelopeOrDefault(Geometry g);
    public static GeometryFactory GetFactoryOrDefault(Geometry g);
    public static GeometryFactory GetFactoryOrDefault(IEnumerable`1<Geometry> gs);
    [ObsoleteAttribute]
public static Geometry BuildGeometry(List`1<Geometry> geoms, Geometry parentGeom);
    public static Geometry BuildGeometry(IList`1<Geometry> geoms, Geometry parentGeom);
    public static Geometry BuildGeometry(Geometry[] geoms);
    public static Geometry BuildGeometry(Geometry a, Geometry b);
}
public class NetTopologySuite.Utilities.GeometricShapeFactory : object {
    protected GeometryFactory GeomFact;
    protected PrecisionModel PrecModel;
    private Dimensions _dim;
    private int _nPts;
    private double _rotationAngle;
    unknown Coordinate Base {public set; }
    unknown Coordinate Centre {public set; }
    public Envelope Envelope { get; public set; }
    public int NumPoints { get; public set; }
    unknown double Size {public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Rotation { get; public set; }
    public GeometricShapeFactory(GeometryFactory geomFact);
    public void set_Base(Coordinate value);
    public void set_Centre(Coordinate value);
    public Envelope get_Envelope();
    public void set_Envelope(Envelope value);
    public int get_NumPoints();
    public void set_NumPoints(int value);
    public void set_Size(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Rotation();
    public void set_Rotation(double value);
    protected Geometry Rotate(Geometry geom);
    protected Coordinate CreateCoord(double x, double y);
    protected Coordinate CreateCoordTrans(double x, double y, Coordinate trans);
    public Polygon CreateRectangle();
    public Polygon CreateCircle();
    public Polygon CreateEllipse();
    public Polygon CreateSquircle();
    public Polygon CreateSupercircle(double power);
    public LineString CreateArc(double startAng, double angExtent);
    public Polygon CreateArcPolygon(double startAng, double angExtent);
}
public class NetTopologySuite.Utilities.Global : object {
    private NumberFormatInfo _nfi;
    private static Global global;
    private static Global();
    public static NumberFormatInfo GetNfi();
}
[ObsoleteAttribute]
public static class NetTopologySuite.Utilities.Guard : object {
    public static void IsNotNull(object candidate, string propertyName);
}
public class NetTopologySuite.Utilities.HexConverter : object {
    public static string ConvertAny2Any(string valueIn, int baseIn, int baseOut);
}
public class NetTopologySuite.Utilities.Memory : object {
    public static double KB;
    public static double MB;
    public static double GB;
    public static long Total { get; }
    public static string TotalString { get; }
    public static long get_Total();
    public static string get_TotalString();
    public static string Format(long mem);
    public static double Round(double d);
}
public class NetTopologySuite.Utilities.PriorityQueue`1 : object {
    private AlternativePriorityQueue`2<T, T> _queue;
    public int Size { get; }
    public PriorityQueue`1(int capacity, IComparer`1<T> comparer);
    public void Add(T x);
    public bool IsEmpty();
    public int get_Size();
    public void Clear();
    public T Poll();
    public T Peek();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NetTopologySuite.Utilities.PriorityQueueNode`2 : object {
    private TData data;
    [CompilerGeneratedAttribute]
private TPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueueIndex>k__BackingField;
    public TData Data { get; }
    public TPriority Priority { get; internal set; }
    internal int QueueIndex { get; internal set; }
    public PriorityQueueNode`2(TData data);
    internal PriorityQueueNode`2(PriorityQueueNode`2<TPriority, TData> copyFrom);
    public TData get_Data();
    [CompilerGeneratedAttribute]
public TPriority get_Priority();
    [CompilerGeneratedAttribute]
internal void set_Priority(TPriority value);
    [CompilerGeneratedAttribute]
internal int get_QueueIndex();
    [CompilerGeneratedAttribute]
internal void set_QueueIndex(int value);
}
public class NetTopologySuite.Utilities.Radians : object {
    public static double ToDegrees(double radians);
}
internal class NetTopologySuite.Utilities.ReverseOrder : object {
    public sealed virtual int Compare(object x, object y);
}
internal class NetTopologySuite.Utilities.TokenStream : object {
    private Nullable`1<bool> prevMoveNextResult;
    private Token nextToken;
    [CompilerGeneratedAttribute]
private IEnumerator`1<Token> <Enumerator>k__BackingField;
    public IEnumerator`1<Token> Enumerator { get; }
    public TokenStream(IEnumerator`1<Token> enumerator);
    [CompilerGeneratedAttribute]
public IEnumerator`1<Token> get_Enumerator();
    public Token NextToken(bool advance);
    private void ReadNextToken();
}
public class NetTopologySuite.Utilities.UniqueCoordinateArrayFilter : object {
    private ISet`1<Coordinate> _coordSet;
    private List`1<Coordinate> _list;
    public Coordinate[] Coordinates { get; }
    public static Coordinate[] FilterCoordinates(Coordinate[] coords);
    public Coordinate[] get_Coordinates();
    public sealed virtual void Filter(Coordinate coord);
}
[DefaultMemberAttribute("Item")]
public class RTools_NTS.Util.CharBuffer : object {
    private int capacity;
    private Char[] buffer;
    private int headIndex;
    private int tailIndex;
    public int Length { get; public set; }
    public int Capacity { get; }
    public char Item { get; public set; }
    public CharBuffer(int capacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    protected void Grow(int requestedLen);
    protected void CheckCapacity(int requestedLength);
    protected void ShiftToZero();
    public void SetBuffer(Char[] b, int len);
    public void Append(char c);
    public void Append(string s);
    public void Append(CharBuffer s);
    public void Remove(int i);
    public void Remove(int i, int n);
    public int IndexOf(char c);
    public void Clear();
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public virtual string ToString();
}
public class RTools_NTS.Util.CharToken : Token {
    public string StringValue { get; }
    public CharToken(string s, int line);
    public CharToken(char c);
    public CharToken(char c, int line);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public virtual bool Equals(object other);
}
[FlagsAttribute]
public enum RTools_NTS.Util.CharTypeBits : Enum {
    public byte value__;
    public static CharTypeBits Word;
    public static CharTypeBits Comment;
    public static CharTypeBits Whitespace;
    public static CharTypeBits Quote;
    public static CharTypeBits Digit;
    public static CharTypeBits HexDigit;
    public static CharTypeBits Eof;
}
public class RTools_NTS.Util.CommentToken : StringToken {
    public CommentToken(string s);
    public CommentToken(string s, int line);
}
public class RTools_NTS.Util.EofToken : Token {
    public string StringValue { get; }
    public EofToken(int line);
    public virtual string ToString();
    public virtual string ToDebugString();
    public virtual bool Equals(object other);
    public virtual string get_StringValue();
    public virtual int GetHashCode();
}
public class RTools_NTS.Util.EolToken : Token {
    public string StringValue { get; }
    public EolToken(int line);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string get_StringValue();
    public virtual int GetHashCode();
}
public class RTools_NTS.Util.FloatToken : Token {
    private NumberFormatInfo numberFormatInfo;
    public string StringValue { get; }
    public FloatToken(string s);
    public FloatToken(float f);
    public FloatToken(double d);
    public FloatToken(string s, int line);
    public FloatToken(double f, int line);
    private NumberFormatInfo GetNumberFormatInfo();
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public virtual bool Equals(object other);
}
public class RTools_NTS.Util.IntToken : Token {
    public string StringValue { get; }
    public IntToken(int i);
    public IntToken(long i);
    public IntToken(string s);
    public IntToken(string s, int line);
    public IntToken(int i, int line);
    public IntToken(long l, int line);
    public static IntToken ParseHex(string s, int lineNumber);
    private void Parse(string s);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public virtual bool Equals(object other);
}
public class RTools_NTS.Util.QuoteToken : StringToken {
    public QuoteToken(string s);
    public QuoteToken(string s, int line);
}
public class RTools_NTS.Util.StreamTokenizer : object {
    public static int NChars;
    private static int Eof;
    private TextReader textReader;
    private int lineNumber;
    private CharBuffer backString;
    private CharBuffer nextTokenSb;
    private CharBuffer tmpSb;
    private CharBuffer expSb;
    private StreamTokenizerSettings settings;
    public TextReader TextReader { get; public set; }
    public StreamTokenizerSettings Settings { get; }
    public StreamTokenizer(TextReader sr);
    public StreamTokenizer(TextReader sr, StreamTokenizerSettings tokenizerSettings);
    public StreamTokenizer(string str);
    private static StreamTokenizer();
    public TextReader get_TextReader();
    public void set_TextReader(TextReader value);
    public StreamTokenizerSettings get_Settings();
    private void Initialize();
    private void InitializeStream();
    public void Display();
    public void Display(string prefix);
    private NextTokenState PickNextState(byte ctype, int c);
    private NextTokenState PickNextState(byte ctype, int c, NextTokenState excludeState);
    private int GetNextChar();
    public bool NextToken(Token& token);
    private bool GrabInt(CharBuffer sb, bool allowPlus, Char& thisChar);
    public bool Tokenize(IList`1<Token> tokens);
    public bool TokenizeReader(TextReader tr, IList`1<Token> tokens);
    public bool TokenizeFile(string fileName, IList`1<Token> tokens);
    public Token[] TokenizeFile(string fileName);
    public bool TokenizeString(string str, IList`1<Token> tokens);
    public bool TokenizeStream(Stream s, IList`1<Token> tokens);
    [IteratorStateMachineAttribute("RTools_NTS.Util.StreamTokenizer/<GetEnumerator>d__34")]
public sealed virtual IEnumerator`1<Token> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class RTools_NTS.Util.StreamTokenizerSettings : object {
    private Byte[] charTypes;
    private bool grabWhitespace;
    private bool grabEol;
    private bool slashSlashComments;
    private bool slashStarComments;
    private bool grabComments;
    private bool doUntermCheck;
    private bool parseNumbers;
    private bool parseHexNumbers;
    public Byte[] CharTypes { get; }
    public bool GrabWhitespace { get; public set; }
    public bool GrabEol { get; public set; }
    public bool SlashSlashComments { get; public set; }
    public bool SlashStarComments { get; public set; }
    public bool GrabComments { get; public set; }
    public bool DoUntermCheck { get; public set; }
    public bool ParseNumbers { get; public set; }
    public bool ParseHexNumbers { get; public set; }
    public StreamTokenizerSettings(StreamTokenizerSettings other);
    public Byte[] get_CharTypes();
    public bool get_GrabWhitespace();
    public void set_GrabWhitespace(bool value);
    public bool get_GrabEol();
    public void set_GrabEol(bool value);
    public bool get_SlashSlashComments();
    public void set_SlashSlashComments(bool value);
    public bool get_SlashStarComments();
    public void set_SlashStarComments(bool value);
    public bool get_GrabComments();
    public void set_GrabComments(bool value);
    public bool get_DoUntermCheck();
    public void set_DoUntermCheck(bool value);
    public bool get_ParseNumbers();
    public void set_ParseNumbers(bool value);
    public bool get_ParseHexNumbers();
    public void set_ParseHexNumbers(bool value);
    public void Copy(StreamTokenizerSettings other);
    public bool SetDefaults();
    public bool SetupForCodeParse();
    public void ResetCharTypeTable();
    public void WordChar(int c);
    public void WordChars(int startChar, int endChar);
    public void WordChars(string s);
    public void WhitespaceChar(int c);
    public void WhitespaceChars(int startChar, int endChar);
    public void OrdinaryChars(int startChar, int endChar);
    public void OrdinaryChar(int c);
    public void CommentChar(int c);
    public void QuoteChar(int c);
    public string CharTypeToString(byte ctype);
    public bool IsCharType(byte ctype, CharTypeBits type);
    public bool IsCharType(char c, CharTypeBits type);
    public bool IsCharType(int c, CharTypeBits type);
    public void Display();
    public void Display(string prefix);
}
public class RTools_NTS.Util.StreamTokenizerUntermCommentException : StreamTokenizerUntermException {
    public StreamTokenizerUntermCommentException(string msg);
}
public class RTools_NTS.Util.StreamTokenizerUntermException : Exception {
    public StreamTokenizerUntermException(string msg);
}
public class RTools_NTS.Util.StreamTokenizerUntermQuoteException : StreamTokenizerUntermException {
    public StreamTokenizerUntermQuoteException(string msg);
}
public abstract class RTools_NTS.Util.StringToken : Token {
    public string StringValue { get; }
    public StringToken(string s);
    public StringToken(string s, int line);
    public virtual string ToDebugString();
    public virtual string ToString();
    public virtual string get_StringValue();
    public virtual int GetHashCode();
}
public abstract class RTools_NTS.Util.Token : object {
    private int _lineNumber;
    protected object obj;
    private bool untermError;
    private string untermErrorMsg;
    public int LineNumber { get; }
    public object Object { get; }
    public bool UntermError { get; public set; }
    public string UntermErrorMsg { get; public set; }
    public string StringValue { get; }
    public Token(int line);
    public int get_LineNumber();
    public object get_Object();
    public bool get_UntermError();
    public void set_UntermError(bool value);
    public string get_UntermErrorMsg();
    public void set_UntermErrorMsg(string value);
    public virtual bool Equals(object other);
    public bool Equals(string s);
    public bool Equals(char c);
    public static bool op_Equality(Token t, object o);
    public static bool op_Inequality(Token t, object o);
    public static bool op_Equality(Token t, char c);
    public static bool op_Inequality(Token t, char c);
    public static bool op_Equality(Token t, string s);
    public static bool op_Inequality(Token t, string s);
    public virtual int GetHashCode();
    public virtual string get_StringValue();
    public string ToLineString();
    public virtual string ToDebugString();
    public object ConvertToType(Type t);
}
public enum RTools_NTS.Util.VerbosityLevel : Enum {
    public int value__;
    public static VerbosityLevel Error;
    public static VerbosityLevel Warn;
    public static VerbosityLevel Info;
    public static VerbosityLevel Debug;
}
public class RTools_NTS.Util.WhitespaceToken : StringToken {
    public WhitespaceToken(string s);
    public WhitespaceToken(string s, int line);
}
public class RTools_NTS.Util.WordToken : StringToken {
    public WordToken(string s);
    public WordToken(string s, int line);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
