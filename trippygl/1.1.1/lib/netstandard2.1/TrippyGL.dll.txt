[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class TrippyGL.ActiveVertexAttrib : ValueType {
    public int Location;
    public string Name;
    public int Size;
    public AttributeType AttribType;
    internal ActiveVertexAttrib(GraphicsDevice graphicsDevice, UInt32 programHandle, UInt32 attribIndex);
    public static bool op_Equality(ActiveVertexAttrib left, ActiveVertexAttrib right);
    public static bool op_Inequality(ActiveVertexAttrib left, ActiveVertexAttrib right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ActiveVertexAttrib other);
    public virtual bool Equals(object obj);
}
public enum TrippyGL.AttributeBaseType : Enum {
    public int value__;
    public static AttributeBaseType Byte;
    public static AttributeBaseType UnsignedByte;
    public static AttributeBaseType Short;
    public static AttributeBaseType UnsignedShort;
    public static AttributeBaseType Int;
    public static AttributeBaseType UnsignedInt;
    public static AttributeBaseType Float;
    public static AttributeBaseType Double;
    public static AttributeBaseType HalfFloat;
    public static AttributeBaseType Fixed;
}
public enum TrippyGL.AttributeType : Enum {
    public int value__;
    public static AttributeType Int;
    public static AttributeType UnsignedInt;
    public static AttributeType Float;
    public static AttributeType Double;
    public static AttributeType Int64Arb;
    public static AttributeType UnsignedInt64Arb;
    public static AttributeType FloatVec2;
    public static AttributeType FloatVec3;
    public static AttributeType FloatVec4;
    public static AttributeType IntVec2;
    public static AttributeType IntVec3;
    public static AttributeType IntVec4;
    public static AttributeType Bool;
    public static AttributeType BoolVec2;
    public static AttributeType BoolVec3;
    public static AttributeType BoolVec4;
    public static AttributeType FloatMat2;
    public static AttributeType FloatMat3;
    public static AttributeType FloatMat4;
    public static AttributeType FloatMat2x3;
    public static AttributeType FloatMat2x4;
    public static AttributeType FloatMat3x2;
    public static AttributeType FloatMat3x4;
    public static AttributeType FloatMat4x2;
    public static AttributeType FloatMat4x3;
    public static AttributeType UnsignedIntVec2;
    public static AttributeType UnsignedIntVec3;
    public static AttributeType UnsignedIntVec4;
    public static AttributeType DoubleMat2;
    public static AttributeType DoubleMat3;
    public static AttributeType DoubleMat4;
    public static AttributeType DoubleMat2x3;
    public static AttributeType DoubleMat2x4;
    public static AttributeType DoubleMat3x2;
    public static AttributeType DoubleMat3x4;
    public static AttributeType DoubleMat4x2;
    public static AttributeType DoubleMat4x3;
    public static AttributeType Int64Vec2Arb;
    public static AttributeType Int64Vec3Arb;
    public static AttributeType Int64Vec4Arb;
    public static AttributeType UnsignedInt64Vec2Arb;
    public static AttributeType UnsignedInt64Vec3Arb;
    public static AttributeType UnsignedInt64Vec4Arb;
    public static AttributeType DoubleVec2;
    public static AttributeType DoubleVec3;
    public static AttributeType DoubleVec4;
}
public enum TrippyGL.BatcherBeginMode : Enum {
    public int value__;
    public static BatcherBeginMode Deferred;
    public static BatcherBeginMode OnTheFly;
    public static BatcherBeginMode Immediate;
    public static BatcherBeginMode SortByTexture;
    public static BatcherBeginMode SortBackToFront;
    public static BatcherBeginMode SortFrontToBack;
}
public enum TrippyGL.BlendingFactor : Enum {
    public int value__;
    public static BlendingFactor Zero;
    public static BlendingFactor One;
    public static BlendingFactor SrcColor;
    public static BlendingFactor OneMinusSrcColor;
    public static BlendingFactor SrcAlpha;
    public static BlendingFactor OneMinusSrcAlpha;
    public static BlendingFactor DstAlpha;
    public static BlendingFactor OneMinusDstAlpha;
    public static BlendingFactor DstColor;
    public static BlendingFactor OneMinusDstColor;
    public static BlendingFactor SrcAlphaSaturate;
    public static BlendingFactor ConstantColor;
    public static BlendingFactor OneMinusConstantColor;
    public static BlendingFactor ConstantAlpha;
    public static BlendingFactor OneMinusConstantAlpha;
    public static BlendingFactor Src1Alpha;
    public static BlendingFactor Src1Color;
    public static BlendingFactor OneMinusSrc1Color;
    public static BlendingFactor OneMinusSrc1Alpha;
}
public enum TrippyGL.BlendingMode : Enum {
    public int value__;
    public static BlendingMode FuncAdd;
    public static BlendingMode Min;
    public static BlendingMode Max;
    public static BlendingMode FuncSubtract;
    public static BlendingMode FuncReverseSubtract;
    public static BlendingMode AlphaMin;
    public static BlendingMode AlphaMax;
}
public class TrippyGL.BlendState : object {
    public bool IsOpaque;
    public BlendingMode EquationModeRGB;
    public BlendingMode EquationModeAlpha;
    public BlendingFactor SourceFactorRGB;
    public BlendingFactor SourceFactorAlpha;
    public BlendingFactor DestFactorRGB;
    public BlendingFactor DestFactorAlpha;
    public Vector4 BlendColor;
    unknown BlendingMode EquationModeRGBA {public set; }
    unknown BlendingFactor SourceFactorRGBA {public set; }
    unknown BlendingFactor DestFactorRGBA {public set; }
    public static BlendState Opaque { get; }
    public static BlendState NonPremultiplied { get; }
    public static BlendState AlphaBlend { get; }
    public static BlendState Additive { get; }
    public static BlendState Substractive { get; }
    public BlendState(bool isOpaque);
    public BlendState(bool isOpaque, BlendingMode equationModeRgba, BlendingFactor sourceFactorRgba, BlendingFactor destFactorRgba, Vector4 blendColor);
    public void set_EquationModeRGBA(BlendingMode value);
    public void set_SourceFactorRGBA(BlendingFactor value);
    public void set_DestFactorRGBA(BlendingFactor value);
    public BlendState Clone();
    public virtual string ToString();
    public sealed virtual bool Equals(BlendState other);
    public static BlendState get_Opaque();
    public static BlendState get_NonPremultiplied();
    public static BlendState get_AlphaBlend();
    public static BlendState get_Additive();
    public static BlendState get_Substractive();
}
public enum TrippyGL.BlitFramebufferFilter : Enum {
    public int value__;
    public static BlitFramebufferFilter Nearest;
    public static BlitFramebufferFilter Linear;
}
public class TrippyGL.BufferCopyException : Exception {
    public BufferCopyException(string message);
    public BufferCopyException(string message, Exception innerException);
}
public class TrippyGL.BufferObject : GraphicsResource {
    public UInt32 Handle;
    [CompilerGeneratedAttribute]
private BufferUsage <UsageHint>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StorageLengthInBytes>k__BackingField;
    public BufferUsage UsageHint { get; private set; }
    public UInt32 StorageLengthInBytes { get; private set; }
    public BufferObject(GraphicsDevice graphicsDevice, UInt32 sizeInBytes, BufferUsage usageHint);
    [CompilerGeneratedAttribute]
public BufferUsage get_UsageHint();
    [CompilerGeneratedAttribute]
private void set_UsageHint(BufferUsage value);
    [CompilerGeneratedAttribute]
public UInt32 get_StorageLengthInBytes();
    [CompilerGeneratedAttribute]
private void set_StorageLengthInBytes(UInt32 value);
    public void RecreateStorage(UInt32 sizeInBytes, BufferUsage usageHint);
    protected virtual void Dispose(bool isManualDispose);
    public virtual string ToString();
    private static void ValidateBufferSize(UInt32 sizeInBytes);
    private static void ValidateBufferUsage(BufferUsage usageHint);
}
public abstract class TrippyGL.BufferObjectSubset : object {
    public BufferObject Buffer;
    public UInt32 BufferHandle;
    public BufferTarget BufferTarget;
    [CompilerGeneratedAttribute]
private UInt32 <StorageOffsetInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StorageLengthInBytes>k__BackingField;
    internal int bufferTargetBindingIndex;
    public UInt32 StorageOffsetInBytes { get; private set; }
    public UInt32 StorageLengthInBytes { get; private set; }
    public UInt32 StorageEndInBytes { get; }
    internal BufferObjectSubset(BufferObject bufferObject, BufferTarget bufferTarget);
    internal BufferObjectSubset(BufferObject bufferObject, BufferTarget bufferTarget, UInt32 storageOffsetBytes, UInt32 storageLengthBytes);
    [CompilerGeneratedAttribute]
public UInt32 get_StorageOffsetInBytes();
    [CompilerGeneratedAttribute]
private void set_StorageOffsetInBytes(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StorageLengthInBytes();
    [CompilerGeneratedAttribute]
private void set_StorageLengthInBytes(UInt32 value);
    public UInt32 get_StorageEndInBytes();
    private protected void InitializeStorage(UInt32 storageOffsetBytes, UInt32 storageLengthBytes);
    public virtual string ToString();
}
public enum TrippyGL.BufferTarget : Enum {
    public int value__;
    public static BufferTarget ParameterBuffer;
    public static BufferTarget ArrayBuffer;
    public static BufferTarget ElementArrayBuffer;
    public static BufferTarget PixelPackBuffer;
    public static BufferTarget PixelUnpackBuffer;
    public static BufferTarget UniformBuffer;
    public static BufferTarget TextureBuffer;
    public static BufferTarget TransformFeedbackBuffer;
    public static BufferTarget CopyReadBuffer;
    public static BufferTarget CopyWriteBuffer;
    public static BufferTarget DrawIndirectBuffer;
    public static BufferTarget ShaderStorageBuffer;
    public static BufferTarget DispatchIndirectBuffer;
    public static BufferTarget QueryBuffer;
    public static BufferTarget AtomicCounterBuffer;
}
public enum TrippyGL.BufferUsage : Enum {
    public int value__;
    public static BufferUsage StreamDraw;
    public static BufferUsage StreamRead;
    public static BufferUsage StreamCopy;
    public static BufferUsage StaticDraw;
    public static BufferUsage StaticRead;
    public static BufferUsage StaticCopy;
    public static BufferUsage DynamicDraw;
    public static BufferUsage DynamicRead;
    public static BufferUsage DynamicCopy;
}
[FlagsAttribute]
public enum TrippyGL.ClearBuffers : Enum {
    public UInt32 value__;
    public static ClearBuffers Depth;
    public static ClearBuffers Stencil;
    public static ClearBuffers Color;
}
public class TrippyGL.Color4b : ValueType {
    public byte R;
    public byte G;
    public byte B;
    public byte A;
    public UInt32 PackedValue { get; public set; }
    public static Color4b Transparent { get; }
    public static Color4b AliceBlue { get; }
    public static Color4b AntiqueWhite { get; }
    public static Color4b Aqua { get; }
    public static Color4b Aquamarine { get; }
    public static Color4b Azure { get; }
    public static Color4b Beige { get; }
    public static Color4b Bisque { get; }
    public static Color4b Black { get; }
    public static Color4b BlanchedAlmond { get; }
    public static Color4b Blue { get; }
    public static Color4b BlueViolet { get; }
    public static Color4b Brown { get; }
    public static Color4b BurlyWood { get; }
    public static Color4b CadetBlue { get; }
    public static Color4b Chartreuse { get; }
    public static Color4b Chocolate { get; }
    public static Color4b Coral { get; }
    public static Color4b CornflowerBlue { get; }
    public static Color4b Cornsilk { get; }
    public static Color4b Crimson { get; }
    public static Color4b Cyan { get; }
    public static Color4b DarkBlue { get; }
    public static Color4b DarkCyan { get; }
    public static Color4b DarkGoldenrod { get; }
    public static Color4b DarkGray { get; }
    public static Color4b DarkGreen { get; }
    public static Color4b DarkKhaki { get; }
    public static Color4b DarkMagenta { get; }
    public static Color4b DarkOliveGreen { get; }
    public static Color4b DarkOrange { get; }
    public static Color4b DarkOrchid { get; }
    public static Color4b DarkRed { get; }
    public static Color4b DarkSalmon { get; }
    public static Color4b DarkSeaGreen { get; }
    public static Color4b DarkSlateBlue { get; }
    public static Color4b DarkSlateGray { get; }
    public static Color4b DarkTurquoise { get; }
    public static Color4b DarkViolet { get; }
    public static Color4b DeepPink { get; }
    public static Color4b DeepSkyBlue { get; }
    public static Color4b DimGray { get; }
    public static Color4b DodgerBlue { get; }
    public static Color4b Firebrick { get; }
    public static Color4b FloralWhite { get; }
    public static Color4b ForestGreen { get; }
    public static Color4b Fuchsia { get; }
    public static Color4b Gainsboro { get; }
    public static Color4b GhostWhite { get; }
    public static Color4b Gold { get; }
    public static Color4b Goldenrod { get; }
    public static Color4b Gray { get; }
    public static Color4b Green { get; }
    public static Color4b GreenYellow { get; }
    public static Color4b Honeydew { get; }
    public static Color4b HotPink { get; }
    public static Color4b IndianRed { get; }
    public static Color4b Indigo { get; }
    public static Color4b Ivory { get; }
    public static Color4b Khaki { get; }
    public static Color4b Lavender { get; }
    public static Color4b LavenderBlush { get; }
    public static Color4b LawnGreen { get; }
    public static Color4b LemonChiffon { get; }
    public static Color4b LightBlue { get; }
    public static Color4b LightCoral { get; }
    public static Color4b LightCyan { get; }
    public static Color4b LightGoldenrodYellow { get; }
    public static Color4b LightGreen { get; }
    public static Color4b LightGray { get; }
    public static Color4b LightPink { get; }
    public static Color4b LightSalmon { get; }
    public static Color4b LightSeaGreen { get; }
    public static Color4b LightSkyBlue { get; }
    public static Color4b LightSlateGray { get; }
    public static Color4b LightSteelBlue { get; }
    public static Color4b LightYellow { get; }
    public static Color4b Lime { get; }
    public static Color4b LimeGreen { get; }
    public static Color4b Linen { get; }
    public static Color4b Magenta { get; }
    public static Color4b Maroon { get; }
    public static Color4b MediumAquamarine { get; }
    public static Color4b MediumBlue { get; }
    public static Color4b MediumOrchid { get; }
    public static Color4b MediumPurple { get; }
    public static Color4b MediumSeaGreen { get; }
    public static Color4b MediumSlateBlue { get; }
    public static Color4b MediumSpringGreen { get; }
    public static Color4b MediumTurquoise { get; }
    public static Color4b MediumVioletRed { get; }
    public static Color4b MidnightBlue { get; }
    public static Color4b MintCream { get; }
    public static Color4b MistyRose { get; }
    public static Color4b Moccasin { get; }
    public static Color4b NavajoWhite { get; }
    public static Color4b Navy { get; }
    public static Color4b OldLace { get; }
    public static Color4b Olive { get; }
    public static Color4b OliveDrab { get; }
    public static Color4b Orange { get; }
    public static Color4b OrangeRed { get; }
    public static Color4b Orchid { get; }
    public static Color4b PaleGoldenrod { get; }
    public static Color4b PaleGreen { get; }
    public static Color4b PaleTurquoise { get; }
    public static Color4b PaleVioletRed { get; }
    public static Color4b PapayaWhip { get; }
    public static Color4b PeachPuff { get; }
    public static Color4b Peru { get; }
    public static Color4b Pink { get; }
    public static Color4b Plum { get; }
    public static Color4b PowderBlue { get; }
    public static Color4b Purple { get; }
    public static Color4b Red { get; }
    public static Color4b RosyBrown { get; }
    public static Color4b RoyalBlue { get; }
    public static Color4b SaddleBrown { get; }
    public static Color4b Salmon { get; }
    public static Color4b SandyBrown { get; }
    public static Color4b SeaGreen { get; }
    public static Color4b SeaShell { get; }
    public static Color4b Sienna { get; }
    public static Color4b Silver { get; }
    public static Color4b SkyBlue { get; }
    public static Color4b SlateBlue { get; }
    public static Color4b SlateGray { get; }
    public static Color4b Snow { get; }
    public static Color4b SpringGreen { get; }
    public static Color4b SteelBlue { get; }
    public static Color4b Tan { get; }
    public static Color4b Teal { get; }
    public static Color4b Thistle { get; }
    public static Color4b Tomato { get; }
    public static Color4b Turquoise { get; }
    public static Color4b Violet { get; }
    public static Color4b Wheat { get; }
    public static Color4b White { get; }
    public static Color4b WhiteSmoke { get; }
    public static Color4b Yellow { get; }
    public static Color4b YellowGreen { get; }
    public Color4b(byte r, byte g, byte b, byte a);
    public Color4b(float r, float g, float b, float a);
    public Color4b(float r, float g, float b);
    public Color4b(Vector4& rgba);
    public Color4b(Vector3& rgb);
    public Color4b(UInt32 packedValue);
    public UInt32 get_PackedValue();
    public void set_PackedValue(UInt32 value);
    public int ToArgb();
    public static Color4b FromArgb(int argb);
    public Vector4 ToVector4();
    public Vector3 ToVector3();
    public static bool op_Equality(Color4b left, Color4b right);
    public static bool op_Inequality(Color4b left, Color4b right);
    public static Color4b op_Addition(Color4b left, Color4b right);
    public static Color4b op_Subtraction(Color4b left, Color4b right);
    public static Color4b op_Multiply(Color4b color, float scale);
    public static Color4b op_Multiply(float scale, Color4b color);
    public static Vector4 op_Implicit(Color4b color);
    public static Color4b op_Implicit(Vector4 vector);
    public static Color4b Multiply(Color4b color, float scale);
    public static Color4b MultiplyIncludeAlpha(Color4b color, float scale);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(Color4b other);
    public static Color4b FromHSV(float hue, float saturation, float value);
    public static Color4b FromHSV(Vector3& values);
    public static Color4b Add(Color4b x, Color4b y);
    public static Color4b Substract(Color4b x, Color4b y);
    public static Color4b Lerp(Color4b min, Color4b max, float amount);
    public static Color4b SmoothStep(Color4b min, Color4b max, float amount);
    public static Color4b get_Transparent();
    public static Color4b get_AliceBlue();
    public static Color4b get_AntiqueWhite();
    public static Color4b get_Aqua();
    public static Color4b get_Aquamarine();
    public static Color4b get_Azure();
    public static Color4b get_Beige();
    public static Color4b get_Bisque();
    public static Color4b get_Black();
    public static Color4b get_BlanchedAlmond();
    public static Color4b get_Blue();
    public static Color4b get_BlueViolet();
    public static Color4b get_Brown();
    public static Color4b get_BurlyWood();
    public static Color4b get_CadetBlue();
    public static Color4b get_Chartreuse();
    public static Color4b get_Chocolate();
    public static Color4b get_Coral();
    public static Color4b get_CornflowerBlue();
    public static Color4b get_Cornsilk();
    public static Color4b get_Crimson();
    public static Color4b get_Cyan();
    public static Color4b get_DarkBlue();
    public static Color4b get_DarkCyan();
    public static Color4b get_DarkGoldenrod();
    public static Color4b get_DarkGray();
    public static Color4b get_DarkGreen();
    public static Color4b get_DarkKhaki();
    public static Color4b get_DarkMagenta();
    public static Color4b get_DarkOliveGreen();
    public static Color4b get_DarkOrange();
    public static Color4b get_DarkOrchid();
    public static Color4b get_DarkRed();
    public static Color4b get_DarkSalmon();
    public static Color4b get_DarkSeaGreen();
    public static Color4b get_DarkSlateBlue();
    public static Color4b get_DarkSlateGray();
    public static Color4b get_DarkTurquoise();
    public static Color4b get_DarkViolet();
    public static Color4b get_DeepPink();
    public static Color4b get_DeepSkyBlue();
    public static Color4b get_DimGray();
    public static Color4b get_DodgerBlue();
    public static Color4b get_Firebrick();
    public static Color4b get_FloralWhite();
    public static Color4b get_ForestGreen();
    public static Color4b get_Fuchsia();
    public static Color4b get_Gainsboro();
    public static Color4b get_GhostWhite();
    public static Color4b get_Gold();
    public static Color4b get_Goldenrod();
    public static Color4b get_Gray();
    public static Color4b get_Green();
    public static Color4b get_GreenYellow();
    public static Color4b get_Honeydew();
    public static Color4b get_HotPink();
    public static Color4b get_IndianRed();
    public static Color4b get_Indigo();
    public static Color4b get_Ivory();
    public static Color4b get_Khaki();
    public static Color4b get_Lavender();
    public static Color4b get_LavenderBlush();
    public static Color4b get_LawnGreen();
    public static Color4b get_LemonChiffon();
    public static Color4b get_LightBlue();
    public static Color4b get_LightCoral();
    public static Color4b get_LightCyan();
    public static Color4b get_LightGoldenrodYellow();
    public static Color4b get_LightGreen();
    public static Color4b get_LightGray();
    public static Color4b get_LightPink();
    public static Color4b get_LightSalmon();
    public static Color4b get_LightSeaGreen();
    public static Color4b get_LightSkyBlue();
    public static Color4b get_LightSlateGray();
    public static Color4b get_LightSteelBlue();
    public static Color4b get_LightYellow();
    public static Color4b get_Lime();
    public static Color4b get_LimeGreen();
    public static Color4b get_Linen();
    public static Color4b get_Magenta();
    public static Color4b get_Maroon();
    public static Color4b get_MediumAquamarine();
    public static Color4b get_MediumBlue();
    public static Color4b get_MediumOrchid();
    public static Color4b get_MediumPurple();
    public static Color4b get_MediumSeaGreen();
    public static Color4b get_MediumSlateBlue();
    public static Color4b get_MediumSpringGreen();
    public static Color4b get_MediumTurquoise();
    public static Color4b get_MediumVioletRed();
    public static Color4b get_MidnightBlue();
    public static Color4b get_MintCream();
    public static Color4b get_MistyRose();
    public static Color4b get_Moccasin();
    public static Color4b get_NavajoWhite();
    public static Color4b get_Navy();
    public static Color4b get_OldLace();
    public static Color4b get_Olive();
    public static Color4b get_OliveDrab();
    public static Color4b get_Orange();
    public static Color4b get_OrangeRed();
    public static Color4b get_Orchid();
    public static Color4b get_PaleGoldenrod();
    public static Color4b get_PaleGreen();
    public static Color4b get_PaleTurquoise();
    public static Color4b get_PaleVioletRed();
    public static Color4b get_PapayaWhip();
    public static Color4b get_PeachPuff();
    public static Color4b get_Peru();
    public static Color4b get_Pink();
    public static Color4b get_Plum();
    public static Color4b get_PowderBlue();
    public static Color4b get_Purple();
    public static Color4b get_Red();
    public static Color4b get_RosyBrown();
    public static Color4b get_RoyalBlue();
    public static Color4b get_SaddleBrown();
    public static Color4b get_Salmon();
    public static Color4b get_SandyBrown();
    public static Color4b get_SeaGreen();
    public static Color4b get_SeaShell();
    public static Color4b get_Sienna();
    public static Color4b get_Silver();
    public static Color4b get_SkyBlue();
    public static Color4b get_SlateBlue();
    public static Color4b get_SlateGray();
    public static Color4b get_Snow();
    public static Color4b get_SpringGreen();
    public static Color4b get_SteelBlue();
    public static Color4b get_Tan();
    public static Color4b get_Teal();
    public static Color4b get_Thistle();
    public static Color4b get_Tomato();
    public static Color4b get_Turquoise();
    public static Color4b get_Violet();
    public static Color4b get_Wheat();
    public static Color4b get_White();
    public static Color4b get_WhiteSmoke();
    public static Color4b get_Yellow();
    public static Color4b get_YellowGreen();
}
public enum TrippyGL.CubemapFace : Enum {
    public int value__;
    public static CubemapFace PositiveX;
    public static CubemapFace NegativeX;
    public static CubemapFace PositiveY;
    public static CubemapFace NegativeY;
    public static CubemapFace PositiveZ;
    public static CubemapFace NegativeZ;
}
public enum TrippyGL.CullingMode : Enum {
    public int value__;
    public static CullingMode CullFront;
    public static CullingMode CullBack;
    public static CullingMode CullFrontAndBack;
}
public abstract class TrippyGL.DataBufferSubset : BufferObjectSubset {
    [CompilerGeneratedAttribute]
private UInt32 <StorageLength>k__BackingField;
    public UInt32 ElementSize;
    public UInt32 StorageLength { get; private set; }
    internal DataBufferSubset(UInt32 elementSize, BufferObject bufferObject, BufferTarget bufferTarget, UInt32 storageOffsetBytes, UInt32 storageLength);
    internal DataBufferSubset(UInt32 elementSize, BufferObject bufferObject, BufferTarget bufferTarget);
    [CompilerGeneratedAttribute]
public UInt32 get_StorageLength();
    [CompilerGeneratedAttribute]
private void set_StorageLength(UInt32 value);
    public void ResizeSubset(UInt32 storageOffsetBytes, UInt32 storageLength);
    public virtual string ToString();
    public static UInt32 CalculateRequiredSizeInBytes(UInt32 storageLength);
    public static void CopyBuffers(DataBufferSubset`1<T> source, UInt32 sourceOffset, DataBufferSubset`1<T> dest, UInt32 destOffset, UInt32 dataLength);
    public static void CopyBuffers(DataBufferSubset`1<T> source, DataBufferSubset`1<T> dest);
}
public abstract class TrippyGL.DataBufferSubset`1 : DataBufferSubset {
    internal DataBufferSubset`1(BufferObject bufferObject, BufferTarget bufferTarget, UInt32 storageOffsetBytes, UInt32 storageLength, ReadOnlySpan`1<T> data, UInt32 dataWriteOffset);
    internal DataBufferSubset`1(BufferObject bufferObject, BufferTarget bufferTarget, ReadOnlySpan`1<T> data, UInt32 dataWriteOffset);
    public void SetData(ReadOnlySpan`1<T> data, UInt32 storageOffset);
    public void GetData(Span`1<T> data, UInt32 storageOffset);
    public virtual string ToString();
}
public enum TrippyGL.DebugSeverity : Enum {
    public int value__;
    public static DebugSeverity DontCare;
    public static DebugSeverity Notification;
    public static DebugSeverity High;
    public static DebugSeverity Medium;
    public static DebugSeverity Low;
}
public enum TrippyGL.DebugSource : Enum {
    public int value__;
    public static DebugSource DontCare;
    public static DebugSource Api;
    public static DebugSource WindowSystem;
    public static DebugSource ShaderCompiler;
    public static DebugSource ThirdParty;
    public static DebugSource Application;
    public static DebugSource Other;
}
public enum TrippyGL.DebugType : Enum {
    public int value__;
    public static DebugType DontCare;
    public static DebugType Error;
    public static DebugType DeprecatedBehavior;
    public static DebugType UndefinedBehavior;
    public static DebugType Portability;
    public static DebugType Performance;
    public static DebugType Other;
    public static DebugType Marker;
    public static DebugType PushGroup;
    public static DebugType PopGroup;
}
public enum TrippyGL.DepthFunction : Enum {
    public int value__;
    public static DepthFunction Never;
    public static DepthFunction Less;
    public static DepthFunction Equal;
    public static DepthFunction LessOrEqual;
    public static DepthFunction Greater;
    public static DepthFunction NotEqual;
    public static DepthFunction GreaterOrEqual;
    public static DepthFunction Always;
}
public class TrippyGL.DepthState : object {
    public bool DepthTestingEnabled;
    public float ClearDepth;
    public DepthFunction DepthComparison;
    private double depthNear;
    private double depthFar;
    public bool DepthBufferWrittingEnabled;
    public double DepthRangeNear { get; public set; }
    public double DepthRangeFar { get; public set; }
    public static DepthState Default { get; }
    public static DepthState Inverted { get; }
    public static DepthState ReadOnly { get; }
    public static DepthState ReadOnlyInverted { get; }
    public static DepthState None { get; }
    public DepthState(bool testingEnabled, DepthFunction comparison, float clearDepth, double nearRange, double farRange, bool depthBufferWrittingEnabled);
    public double get_DepthRangeNear();
    public void set_DepthRangeNear(double value);
    public double get_DepthRangeFar();
    public void set_DepthRangeFar(double value);
    public DepthState Clone();
    public virtual string ToString();
    public sealed virtual bool Equals(DepthState other);
    public static DepthState get_Default();
    public static DepthState get_Inverted();
    public static DepthState get_ReadOnly();
    public static DepthState get_ReadOnlyInverted();
    public static DepthState get_None();
}
public enum TrippyGL.DepthStencilFormat : Enum {
    public int value__;
    public static DepthStencilFormat None;
    public static DepthStencilFormat Depth24Stencil8;
    public static DepthStencilFormat Depth32fStencil8;
    public static DepthStencilFormat Depth16;
    public static DepthStencilFormat Depth24;
    public static DepthStencilFormat Depth32f;
    public static DepthStencilFormat Stencil8;
}
public class TrippyGL.DirectionalLight : object {
    internal static string IncorrectUniformMessage;
    private ShaderUniform directionUniform;
    private ShaderUniform diffuseColorUniform;
    private ShaderUniform specularColorUniform;
    private Vector3 direction;
    private Vector3 diffuseColor;
    private Vector3 specularColor;
    public Vector3 Direction { get; public set; }
    public Vector3 DiffuseColor { get; public set; }
    public Vector3 SpecularColor { get; public set; }
    public DirectionalLight(ShaderUniform directionUniform, ShaderUniform diffuseColorUniform, ShaderUniform specularColorUniform);
    private static DirectionalLight();
    public Vector3 get_Direction();
    public void set_Direction(Vector3 value);
    public Vector3 get_DiffuseColor();
    public void set_DiffuseColor(Vector3 value);
    public Vector3 get_SpecularColor();
    public void set_SpecularColor(Vector3 value);
}
public enum TrippyGL.ElementType : Enum {
    public int value__;
    public static ElementType UnsignedByte;
    public static ElementType UnsignedShort;
    public static ElementType UnsignedInt;
}
[IsReadOnlyAttribute]
public class TrippyGL.Framebuffer2D : ValueType {
    public FramebufferObject Framebuffer;
    public Texture2D Texture;
    public bool IsEmpty { get; }
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public UInt32 Samples { get; }
    public Framebuffer2D(GraphicsDevice graphicsDevice, UInt32 width, UInt32 height, DepthStencilFormat depthStencilFormat, UInt32 samples, TextureImageFormat imageFormat, bool useDepthStencilTexture);
    public bool get_IsEmpty();
    public UInt32 get_Width();
    public UInt32 get_Height();
    public UInt32 get_Samples();
    public static FramebufferObject op_Implicit(Framebuffer2D framebuffer);
    public static Texture2D op_Implicit(Framebuffer2D framebuffer);
    public static bool op_Equality(Framebuffer2D left, Framebuffer2D right);
    public static bool op_Inequality(Framebuffer2D left, Framebuffer2D right);
    public void Resize(UInt32 width, UInt32 height);
    public bool TryGetDepthTexture(Texture2D& depthTexture);
    public sealed virtual void Dispose();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Framebuffer2D other);
    public virtual bool Equals(object obj);
}
public enum TrippyGL.FramebufferAttachmentPoint : Enum {
    public int value__;
    public static FramebufferAttachmentPoint Color0;
    public static FramebufferAttachmentPoint Color1;
    public static FramebufferAttachmentPoint Color2;
    public static FramebufferAttachmentPoint Color3;
    public static FramebufferAttachmentPoint Color4;
    public static FramebufferAttachmentPoint Color5;
    public static FramebufferAttachmentPoint Color6;
    public static FramebufferAttachmentPoint Color7;
    public static FramebufferAttachmentPoint Color8;
    public static FramebufferAttachmentPoint Color9;
    public static FramebufferAttachmentPoint Color10;
    public static FramebufferAttachmentPoint Color11;
    public static FramebufferAttachmentPoint Color12;
    public static FramebufferAttachmentPoint Color13;
    public static FramebufferAttachmentPoint Color14;
    public static FramebufferAttachmentPoint Color15;
    public static FramebufferAttachmentPoint Depth;
    public static FramebufferAttachmentPoint Stencil;
    public static FramebufferAttachmentPoint DepthStencil;
}
public class TrippyGL.FramebufferException : Exception {
    public FramebufferException(string message);
    public FramebufferException(string message, Exception innerException);
}
public class TrippyGL.FramebufferObject : GraphicsResource {
    public UInt32 Handle;
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Samples>k__BackingField;
    internal List`1<FramebufferTextureAttachment> textureAttachments;
    internal List`1<FramebufferRenderbufferAttachment> renderbufferAttachments;
    public UInt32 Width { get; private set; }
    public UInt32 Height { get; private set; }
    public UInt32 Samples { get; private set; }
    public int TextureAttachmentCount { get; }
    public int RenderbufferAttachmentCount { get; }
    public FramebufferObject(GraphicsDevice graphicsDevice);
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Samples();
    [CompilerGeneratedAttribute]
private void set_Samples(UInt32 value);
    public int get_TextureAttachmentCount();
    public int get_RenderbufferAttachmentCount();
    public void Attach(Texture texture, FramebufferAttachmentPoint attachmentPoint);
    public void Attach(RenderbufferObject renderbuffer, FramebufferAttachmentPoint attachmentPoint);
    public void Detach(FramebufferAttachmentPoint attachmentPoint);
    public bool TryDetachTexture(FramebufferAttachmentPoint point, FramebufferTextureAttachment& attachment);
    public bool TryDetachRenderbuffer(FramebufferAttachmentPoint point, FramebufferRenderbufferAttachment& attachment);
    public bool HasAttachment(FramebufferAttachmentPoint attachmentType);
    public FramebufferStatus GetStatus();
    public void UpdateFramebufferData();
    public bool TryGetTextureAttachment(FramebufferAttachmentPoint attachmentPoint, FramebufferTextureAttachment& attachment);
    public bool TryGetRenderbufferAttachment(FramebufferAttachmentPoint attachmentPoint, FramebufferRenderbufferAttachment& attachment);
    public void ReadPixelsPtr(Void* ptr, int x, int y, UInt32 width, UInt32 height, ReadPixelsFormat pixelFormat, PixelType pixelType);
    public void ReadPixels(Span`1<T> data, int x, int y, UInt32 width, UInt32 height, ReadPixelsFormat pixelFormat, PixelType pixelType);
    public virtual string ToString();
    protected virtual void Dispose(bool isManualDispose);
    public void DisposeAttachments();
    private static void ValidateAttachmentTypeExists(FramebufferAttachmentPoint attachment);
    private void ValidateAttachmentTypeNotUsed(FramebufferAttachmentPoint attachment);
    [CompilerGeneratedAttribute]
internal static void <UpdateFramebufferData>g__ValidateSize|27_0(UInt32 w, UInt32 h, <>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static void <UpdateFramebufferData>g__ValidateSamples|27_1(UInt32 s, <>c__DisplayClass27_0& );
}
[IsReadOnlyAttribute]
public class TrippyGL.FramebufferRenderbufferAttachment : ValueType {
    public RenderbufferObject Renderbuffer;
    public FramebufferAttachmentPoint AttachmentPoint;
    public FramebufferRenderbufferAttachment(RenderbufferObject renderbuffer, FramebufferAttachmentPoint attachmentPoint);
    public static bool op_Equality(FramebufferRenderbufferAttachment left, FramebufferRenderbufferAttachment right);
    public static bool op_Inequality(FramebufferRenderbufferAttachment left, FramebufferRenderbufferAttachment right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(FramebufferRenderbufferAttachment other);
    public virtual bool Equals(object obj);
}
[IsReadOnlyAttribute]
public class TrippyGL.FramebufferTextureAttachment : ValueType {
    public Texture Texture;
    public FramebufferAttachmentPoint AttachmentPoint;
    public FramebufferTextureAttachment(Texture texture, FramebufferAttachmentPoint attachmentPoint);
    public static bool op_Equality(FramebufferTextureAttachment left, FramebufferTextureAttachment right);
    public static bool op_Inequality(FramebufferTextureAttachment left, FramebufferTextureAttachment right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(FramebufferTextureAttachment other);
    public virtual bool Equals(object obj);
}
[IsReadOnlyAttribute]
public class TrippyGL.GeometryShaderData : ValueType {
    public PrimitiveType GeometryInputType;
    public PrimitiveType GeometryOutputType;
    public int GeometryShaderInvocations;
    public int GeometryVerticesOut;
    internal GeometryShaderData(GL gl, UInt32 programHandle);
    public static bool op_Equality(GeometryShaderData left, GeometryShaderData right);
    public static bool op_Inequality(GeometryShaderData left, GeometryShaderData right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(GeometryShaderData other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.GLDebugMessageReceivedHandler : MulticastDelegate {
    public GLDebugMessageReceivedHandler(object object, IntPtr method);
    public virtual void Invoke(DebugSource debugSource, DebugType debugType, int messageId, DebugSeverity debugSeverity, string message);
    public virtual IAsyncResult BeginInvoke(DebugSource debugSource, DebugType debugType, int messageId, DebugSeverity debugSeverity, string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class TrippyGL.GraphicsDevice : object {
    private static int BufferTargetCount;
    private static int uniformBufferIndex;
    private static int shaderStorageBufferIndex;
    private static int atomicCounterBufferIndex;
    private static int arrayBufferIndex;
    private static int textureBufferIndex;
    private static int pixelUnpackBufferIndex;
    private static int pixelPackBufferIndex;
    private static int drawIndirectBufferIndex;
    private static int dispatchIndirectBufferIndex;
    private static int copyReadBufferIndex;
    private static int copyWriteBufferIndex;
    private static int queryBufferIndex;
    internal static BufferTarget DefaultBufferTarget;
    private static int defaultBufferTargetBindingIndex;
    private BufferObject[] bufferBindings;
    private BufferTarget[] bufferBindingTargets;
    private BufferRangeBinding[][] bufferRangeBindings;
    private VertexArray vertexArray;
    private ShaderProgram shaderProgram;
    private Texture[] textureBindings;
    private int nextBindUnit;
    [CompilerGeneratedAttribute]
private int <ActiveTextureUnit>k__BackingField;
    private FramebufferObject drawFramebuffer;
    private FramebufferObject readFramebuffer;
    private RenderbufferObject renderbuffer;
    public GL GL;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private bool debugMessagingEnabled;
    [CompilerGeneratedAttribute]
private GLDebugMessageReceivedHandler DebugMessageReceived;
    [CompilerGeneratedAttribute]
private int <GLMajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GLMinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFragmentUniformComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxUniformLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxVaryingComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UniformBufferOffsetAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxUniformBufferBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxUniformBlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSamples>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTextureSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Max3DTextureSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCubeMapTextureSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRectangleTextureSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTextureBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTextureImageUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRenderbufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxVertexAttribs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxArrayTextureLayers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFramebufferColorAttachments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDrawBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxClipDistances>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransformFeedbackBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransformFeedbackInterleavedComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransformFeedbackSeparateComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransformFeedbackSeparateAttribs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxShaderStorageBufferBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAtomicCounterBufferBindings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDoublePrecisionVertexAttribsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVertexAttribDivisorAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInstancedDrawingAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGeometryShaderAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAdvancedTransformFeedbackAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDoublePrecitionShaderVariablesAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private ShaderCompiledHandler ShaderCompiled;
    private List`1<GraphicsResource> graphicsResources;
    private Vector4 clearColor;
    private Viewport viewport;
    private bool scissorTestEnabled;
    private Viewport scissorRect;
    private BlendState blendState;
    private DepthState depthState;
    private StencilState stencilState;
    private bool faceCullingEnabled;
    private CullingMode cullFaceMode;
    private PolygonFace polygonFrontFace;
    private PolygonMode polygonMode;
    private Boolean[] clipDistancesEnabled;
    private bool cubemapSeamlessEnabled;
    private bool rasterizerEnabled;
    public BufferObject ArrayBuffer { get; public set; }
    public BufferObject CopyReadBuffer { get; public set; }
    public BufferObject CopyWriteBuffer { get; public set; }
    public VertexArray VertexArray { get; public set; }
    public ShaderProgram ShaderProgram { get; public set; }
    public int ActiveTextureUnit { get; private set; }
    public FramebufferObject DrawFramebuffer { get; public set; }
    public FramebufferObject ReadFramebuffer { get; public set; }
    unknown FramebufferObject Framebuffer {public set; }
    public RenderbufferObject Renderbuffer { get; public set; }
    public bool IsDisposed { get; private set; }
    public bool DebugMessagingEnabled { get; public set; }
    public int GLMajorVersion { get; private set; }
    public int GLMinorVersion { get; private set; }
    public int MaxFragmentUniformComponents { get; private set; }
    public int MaxUniformLocations { get; private set; }
    public int MaxVaryingComponents { get; private set; }
    public int UniformBufferOffsetAlignment { get; private set; }
    public int MaxUniformBufferBindings { get; private set; }
    public int MaxUniformBlockSize { get; private set; }
    public int MaxSamples { get; private set; }
    public int MaxTextureSize { get; private set; }
    public int Max3DTextureSize { get; private set; }
    public int MaxCubeMapTextureSize { get; private set; }
    public int MaxRectangleTextureSize { get; private set; }
    public int MaxTextureBufferSize { get; private set; }
    public int MaxTextureImageUnits { get; private set; }
    public int MaxRenderbufferSize { get; private set; }
    public int MaxVertexAttribs { get; private set; }
    public int MaxArrayTextureLayers { get; private set; }
    public int MaxFramebufferColorAttachments { get; private set; }
    public int MaxDrawBuffers { get; private set; }
    public int MaxClipDistances { get; private set; }
    public int MaxTransformFeedbackBuffers { get; private set; }
    public int MaxTransformFeedbackInterleavedComponents { get; private set; }
    public int MaxTransformFeedbackSeparateComponents { get; private set; }
    public int MaxTransformFeedbackSeparateAttribs { get; private set; }
    public int MaxShaderStorageBufferBindings { get; private set; }
    public int MaxAtomicCounterBufferBindings { get; private set; }
    public string GLVersion { get; }
    public string GLVendor { get; }
    public string GLRenderer { get; }
    public string GLShadingLanguageVersion { get; }
    public bool IsDoublePrecisionVertexAttribsAvailable { get; private set; }
    public bool IsVertexAttribDivisorAvailable { get; private set; }
    public bool IsInstancedDrawingAvailable { get; private set; }
    public bool IsGeometryShaderAvailable { get; private set; }
    public bool IsAdvancedTransformFeedbackAvailable { get; private set; }
    public bool IsDoublePrecitionShaderVariablesAvailable { get; private set; }
    public Vector4 ClearColor { get; public set; }
    public Viewport Viewport { get; public set; }
    public bool ScissorTestEnabled { get; public set; }
    public Viewport ScissorRectangle { get; public set; }
    public BlendState BlendState { get; public set; }
    public bool BlendingEnabled { get; public set; }
    public DepthState DepthState { get; public set; }
    public bool DepthTestingEnabled { get; public set; }
    public float ClearDepth { get; public set; }
    public StencilState StencilState { get; public set; }
    public bool StencilTestingEnabled { get; public set; }
    public int ClearStencil { get; public set; }
    public bool FaceCullingEnabled { get; public set; }
    public CullingMode CullFaceMode { get; public set; }
    public PolygonFace PolygonFrontFace { get; public set; }
    public PolygonMode PolygonMode { get; public set; }
    public bool TextureCubemapSeamlessEnabled { get; public set; }
    public bool RasterizerEnabled { get; public set; }
    public GraphicsDevice(GL gl);
    private void InitBufferObjectStates();
    public BufferObject get_ArrayBuffer();
    public void set_ArrayBuffer(BufferObject value);
    public BufferObject get_CopyReadBuffer();
    public void set_CopyReadBuffer(BufferObject value);
    public BufferObject get_CopyWriteBuffer();
    public void set_CopyWriteBuffer(BufferObject value);
    internal void BindBufferObject(BufferObject buffer);
    internal void ForceBindBufferObject(BufferObject buffer);
    public void BindBuffer(BufferObjectSubset bufferSubset);
    internal void ForceBindBuffer(BufferObjectSubset bufferSubset);
    public void BindBufferRange(BufferObjectSubset bufferSubset, UInt32 bindingIndex, UInt32 offset, UInt32 size);
    internal void ForceBindBufferRange(BufferObjectSubset buffer, UInt32 bindingIndex, UInt32 offset, UInt32 size);
    internal void ForceBindBufferCopyRead(BufferObject buffer);
    internal void ForceBindBufferCopyWrite(BufferObject buffer);
    public bool IsBufferCurrentlyBound(BufferObjectSubset buffer);
    internal int GetBindingTargetIndex(BufferTarget bufferTarget);
    public void ResetBufferStates();
    public VertexArray get_VertexArray();
    public void set_VertexArray(VertexArray value);
    internal void ForceBindVertexArray(VertexArray array);
    public void ResetVertexArrayStates();
    public ShaderProgram get_ShaderProgram();
    public void set_ShaderProgram(ShaderProgram value);
    internal void ForceUseShaderProgram(ShaderProgram program);
    public void ResetShaderProgramStates();
    [CompilerGeneratedAttribute]
public int get_ActiveTextureUnit();
    [CompilerGeneratedAttribute]
private void set_ActiveTextureUnit(int value);
    private int GetNextBindTextureUnit();
    public void SetActiveTexture(int textureUnit);
    internal void ForceSetActiveTextureUnit(int textureUnit);
    public int BindTexture(Texture texture);
    public int BindTextureSetActive(Texture texture);
    internal int ForceBindTexture(Texture texture);
    internal void ForceBindTextureToCurrentUnit(Texture texture);
    public void BindAllTextures(ReadOnlySpan`1<Texture> textures);
    public void BindAllTextures(List`1<Texture> textures);
    public bool IsTextureBound(Texture texture);
    private void InitTextureStates();
    public void ResetTextureStates();
    public FramebufferObject get_DrawFramebuffer();
    public void set_DrawFramebuffer(FramebufferObject value);
    public FramebufferObject get_ReadFramebuffer();
    public void set_ReadFramebuffer(FramebufferObject value);
    public void set_Framebuffer(FramebufferObject value);
    public RenderbufferObject get_Renderbuffer();
    public void set_Renderbuffer(RenderbufferObject value);
    internal void ForceBindDrawFramebuffer(FramebufferObject framebuffer);
    internal void ForceBindReadFramebuffer(FramebufferObject framebuffer);
    internal void ForceBindRenderbuffer(RenderbufferObject renderbuffer);
    public void ResetFramebufferStates();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public void ResetStates();
    [CompilerGeneratedAttribute]
public void add_DebugMessageReceived(GLDebugMessageReceivedHandler value);
    [CompilerGeneratedAttribute]
public void remove_DebugMessageReceived(GLDebugMessageReceivedHandler value);
    public bool get_DebugMessagingEnabled();
    public void set_DebugMessagingEnabled(bool value);
    private void OnDebugMessageRecieved(GLEnum src, GLEnum type, int id, GLEnum sev, int length, IntPtr msg, IntPtr param);
    private void InitGLGetVariables();
    [CompilerGeneratedAttribute]
public int get_GLMajorVersion();
    [CompilerGeneratedAttribute]
private void set_GLMajorVersion(int value);
    [CompilerGeneratedAttribute]
public int get_GLMinorVersion();
    [CompilerGeneratedAttribute]
private void set_GLMinorVersion(int value);
    [CompilerGeneratedAttribute]
public int get_MaxFragmentUniformComponents();
    [CompilerGeneratedAttribute]
private void set_MaxFragmentUniformComponents(int value);
    [CompilerGeneratedAttribute]
public int get_MaxUniformLocations();
    [CompilerGeneratedAttribute]
private void set_MaxUniformLocations(int value);
    [CompilerGeneratedAttribute]
public int get_MaxVaryingComponents();
    [CompilerGeneratedAttribute]
private void set_MaxVaryingComponents(int value);
    [CompilerGeneratedAttribute]
public int get_UniformBufferOffsetAlignment();
    [CompilerGeneratedAttribute]
private void set_UniformBufferOffsetAlignment(int value);
    [CompilerGeneratedAttribute]
public int get_MaxUniformBufferBindings();
    [CompilerGeneratedAttribute]
private void set_MaxUniformBufferBindings(int value);
    [CompilerGeneratedAttribute]
public int get_MaxUniformBlockSize();
    [CompilerGeneratedAttribute]
private void set_MaxUniformBlockSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxSamples();
    [CompilerGeneratedAttribute]
private void set_MaxSamples(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTextureSize();
    [CompilerGeneratedAttribute]
private void set_MaxTextureSize(int value);
    [CompilerGeneratedAttribute]
public int get_Max3DTextureSize();
    [CompilerGeneratedAttribute]
private void set_Max3DTextureSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCubeMapTextureSize();
    [CompilerGeneratedAttribute]
private void set_MaxCubeMapTextureSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxRectangleTextureSize();
    [CompilerGeneratedAttribute]
private void set_MaxRectangleTextureSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTextureBufferSize();
    [CompilerGeneratedAttribute]
private void set_MaxTextureBufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTextureImageUnits();
    [CompilerGeneratedAttribute]
private void set_MaxTextureImageUnits(int value);
    [CompilerGeneratedAttribute]
public int get_MaxRenderbufferSize();
    [CompilerGeneratedAttribute]
private void set_MaxRenderbufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxVertexAttribs();
    [CompilerGeneratedAttribute]
private void set_MaxVertexAttribs(int value);
    [CompilerGeneratedAttribute]
public int get_MaxArrayTextureLayers();
    [CompilerGeneratedAttribute]
private void set_MaxArrayTextureLayers(int value);
    [CompilerGeneratedAttribute]
public int get_MaxFramebufferColorAttachments();
    [CompilerGeneratedAttribute]
private void set_MaxFramebufferColorAttachments(int value);
    [CompilerGeneratedAttribute]
public int get_MaxDrawBuffers();
    [CompilerGeneratedAttribute]
private void set_MaxDrawBuffers(int value);
    [CompilerGeneratedAttribute]
public int get_MaxClipDistances();
    [CompilerGeneratedAttribute]
private void set_MaxClipDistances(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTransformFeedbackBuffers();
    [CompilerGeneratedAttribute]
private void set_MaxTransformFeedbackBuffers(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTransformFeedbackInterleavedComponents();
    [CompilerGeneratedAttribute]
private void set_MaxTransformFeedbackInterleavedComponents(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTransformFeedbackSeparateComponents();
    [CompilerGeneratedAttribute]
private void set_MaxTransformFeedbackSeparateComponents(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTransformFeedbackSeparateAttribs();
    [CompilerGeneratedAttribute]
private void set_MaxTransformFeedbackSeparateAttribs(int value);
    [CompilerGeneratedAttribute]
public int get_MaxShaderStorageBufferBindings();
    [CompilerGeneratedAttribute]
private void set_MaxShaderStorageBufferBindings(int value);
    [CompilerGeneratedAttribute]
public int get_MaxAtomicCounterBufferBindings();
    [CompilerGeneratedAttribute]
private void set_MaxAtomicCounterBufferBindings(int value);
    public string get_GLVersion();
    public string get_GLVendor();
    public string get_GLRenderer();
    public string get_GLShadingLanguageVersion();
    private void InitIsAvailableVariables();
    [CompilerGeneratedAttribute]
public bool get_IsDoublePrecisionVertexAttribsAvailable();
    [CompilerGeneratedAttribute]
private void set_IsDoublePrecisionVertexAttribsAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsVertexAttribDivisorAvailable();
    [CompilerGeneratedAttribute]
private void set_IsVertexAttribDivisorAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInstancedDrawingAvailable();
    [CompilerGeneratedAttribute]
private void set_IsInstancedDrawingAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGeometryShaderAvailable();
    [CompilerGeneratedAttribute]
private void set_IsGeometryShaderAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAdvancedTransformFeedbackAvailable();
    [CompilerGeneratedAttribute]
private void set_IsAdvancedTransformFeedbackAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDoublePrecitionShaderVariablesAvailable();
    [CompilerGeneratedAttribute]
private void set_IsDoublePrecitionShaderVariablesAvailable(bool value);
    public void Clear(ClearBuffers mask);
    public void DrawArrays(PrimitiveType primitiveType, int startIndex, UInt32 count);
    public void DrawElements(PrimitiveType primitiveType, int startIndex, UInt32 count);
    public void DrawArraysInstanced(PrimitiveType primitiveType, int startIndex, UInt32 count, UInt32 instanceCount);
    public void DrawElementsInstanced(PrimitiveType primitiveType, int startIndex, UInt32 count, UInt32 instanceCount);
    public void BlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, ClearBuffers mask, BlitFramebufferFilter filter);
    public void BlitFramebuffer(Viewport srcRect, Viewport dstRect, ClearBuffers mask, BlitFramebufferFilter filter);
    [CompilerGeneratedAttribute]
public void add_ShaderCompiled(ShaderCompiledHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShaderCompiled(ShaderCompiledHandler value);
    internal void OnShaderCompiled(ShaderProgramBuilder& programBuilder, bool success);
    internal void OnResourceAdded(GraphicsResource createdResource);
    internal void OnResourceRemoved(GraphicsResource disposedResource);
    public void DisposeAllResources();
    public void FlushCommands();
    public void FinishCommands();
    public bool IsGLVersionAtLeast(int major, int minor);
    private void EnsureNotDisposed();
    public sealed virtual void Dispose();
    public Vector4 get_ClearColor();
    public void set_ClearColor(Vector4 value);
    public Viewport get_Viewport();
    public void set_Viewport(Viewport value);
    public void SetViewport(int x, int y, UInt32 width, UInt32 height);
    public bool get_ScissorTestEnabled();
    public void set_ScissorTestEnabled(bool value);
    public Viewport get_ScissorRectangle();
    public void set_ScissorRectangle(Viewport value);
    public void SetScissorRectangle(int x, int y, UInt32 width, UInt32 height);
    public BlendState get_BlendState();
    public void set_BlendState(BlendState value);
    public bool get_BlendingEnabled();
    public void set_BlendingEnabled(bool value);
    public void ResetBlendStates();
    public DepthState get_DepthState();
    public void set_DepthState(DepthState value);
    public bool get_DepthTestingEnabled();
    public void set_DepthTestingEnabled(bool value);
    public float get_ClearDepth();
    public void set_ClearDepth(float value);
    public void ResetDepthStates();
    public StencilState get_StencilState();
    public void set_StencilState(StencilState value);
    public bool get_StencilTestingEnabled();
    public void set_StencilTestingEnabled(bool value);
    public int get_ClearStencil();
    public void set_ClearStencil(int value);
    public void ResetStencilStates();
    public bool get_FaceCullingEnabled();
    public void set_FaceCullingEnabled(bool value);
    public CullingMode get_CullFaceMode();
    public void set_CullFaceMode(CullingMode value);
    public PolygonFace get_PolygonFrontFace();
    public void set_PolygonFrontFace(PolygonFace value);
    public void ResetFaceCullingStates();
    public PolygonMode get_PolygonMode();
    public void set_PolygonMode(PolygonMode value);
    public bool IsClipDistanceEnabled(int index);
    public void EnableClipDistance(int index);
    public void DisableClipDistance(int index);
    public void EnableClipDistanceRange(int min, int max);
    public void DisableClipDistanceRange(int min, int max);
    public void DisableAllClipDistances();
    public void ResetClipDistanceStates();
    public bool get_TextureCubemapSeamlessEnabled();
    public void set_TextureCubemapSeamlessEnabled(bool value);
    public bool get_RasterizerEnabled();
    public void set_RasterizerEnabled(bool value);
    [CompilerGeneratedAttribute]
private int <BindAllTextures>g__FindUnusedTextureUnit|65_0(ReadOnlySpan`1<Texture> texturesToBind);
    [CompilerGeneratedAttribute]
private bool <BindAllTextures>g__IsTextureUnitInUse|65_1(int unit, ReadOnlySpan`1<Texture> texturesToBind);
    [CompilerGeneratedAttribute]
private int <BindAllTextures>g__FindUnusedTextureUnit|66_0(List`1<Texture> texturesToBind);
    [CompilerGeneratedAttribute]
private bool <BindAllTextures>g__IsTextureUnitInUse|66_1(int unit, List`1<Texture> texturesToBind);
}
public abstract class TrippyGL.GraphicsResource : object {
    [CompilerGeneratedAttribute]
private GraphicsDevice <GraphicsDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public GraphicsDevice GraphicsDevice { get; internal set; }
    internal GL GL { get; }
    public bool IsDisposed { get; private set; }
    internal GraphicsResource(GraphicsDevice graphicsDevice);
    [CompilerGeneratedAttribute]
public GraphicsDevice get_GraphicsDevice();
    [CompilerGeneratedAttribute]
internal void set_GraphicsDevice(GraphicsDevice value);
    internal GL get_GL();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected virtual override void Finalize();
    protected abstract virtual void Dispose(bool isManualDispose);
    internal void DisposeByGraphicsDevice();
    public sealed virtual void Dispose();
}
public class TrippyGL.IndexBufferSubset : BufferObjectSubset {
    private static UInt32 SizeOfUint;
    private static UInt32 SizeOfUshort;
    private static UInt32 SizeOfByte;
    [CompilerGeneratedAttribute]
private UInt32 <StorageLength>k__BackingField;
    public UInt32 ElementSize;
    public ElementType ElementType;
    public UInt32 StorageLength { get; private set; }
    public IndexBufferSubset(BufferObject bufferObject, UInt32 storageOffsetBytes, UInt32 storageLength, ElementType elementType);
    public IndexBufferSubset(BufferObject bufferObject, ElementType elementType);
    public IndexBufferSubset(BufferObject bufferObject, UInt32 storageOffsetBytes, UInt32 storageLength, ReadOnlySpan`1<UInt32> data, UInt32 dataWriteOffset);
    public IndexBufferSubset(BufferObject bufferObject, UInt32 storageOffsetBytes, UInt32 storageLength, ReadOnlySpan`1<ushort> data, UInt32 dataWriteOffset);
    public IndexBufferSubset(BufferObject bufferObject, UInt32 storageOffsetBytes, UInt32 storageLength, ReadOnlySpan`1<byte> data, UInt32 dataWriteOffset);
    [CompilerGeneratedAttribute]
public UInt32 get_StorageLength();
    [CompilerGeneratedAttribute]
private void set_StorageLength(UInt32 value);
    public void SetData(ReadOnlySpan`1<UInt32> data, UInt32 storageOffset);
    public void SetData(ReadOnlySpan`1<ushort> data, UInt32 storageOffset);
    public void SetData(ReadOnlySpan`1<byte> data, UInt32 storageOffset);
    public void GetData(Span`1<UInt32> data, UInt32 storageOffset);
    public void GetData(Span`1<ushort> data, UInt32 storageOffset);
    public void GetData(Span`1<byte> data, UInt32 storageOffset);
    public void ResizeSubset(UInt32 storageOffsetBytes, UInt32 storageLength);
    private void ValidateCorrectElementType(ElementType elementType);
    private void ValidateSetParams(int dataLength, UInt32 storageOffset);
    private void ValidateGetParams(int dataLength, UInt32 storageOffset);
    public static UInt32 CalculateRequiredSizeInBytes(ElementType elementType, UInt32 storageLength);
    public static UInt32 GetSizeInBytesOfElementType(ElementType elementType);
}
public class TrippyGL.InvalidBlitException : Exception {
    public InvalidBlitException(string message);
    public InvalidBlitException(string message, Exception innerException);
}
public class TrippyGL.InvalidFramebufferAttachmentException : Exception {
    public InvalidFramebufferAttachmentException(string message);
    public InvalidFramebufferAttachmentException(string message, Exception innerException);
}
public interface TrippyGL.IVertex {
    public int AttribDescriptionCount { get; }
    public abstract virtual int get_AttribDescriptionCount();
    public abstract virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
}
public class TrippyGL.KerningTextureFont : TextureFont {
    private Single[] advances;
    private Vector2[0...,0...] kerningOffsets;
    public ReadOnlySpan`1<float> Advances { get; }
    public KerningTextureFont(Texture2D texture, float size, char firstChar, char lastChar, Vector2[] renderOffsets, Rectangle[] sources, Vector2[0...,0...] kerningOffsets, Single[] advances, float ascender, float descender, float lineGap, string name);
    public ReadOnlySpan`1<float> get_Advances();
    public virtual float GetAdvance(char character);
    public virtual Vector2 GetKerning(char fromChar, char toChar);
    public virtual Vector2 Measure(ReadOnlySpan`1<char> text);
    public virtual Vector2 MeasureLine(ReadOnlySpan`1<char> text);
    public SpacedTextureFont ToKerningless();
}
public class TrippyGL.MonospaceTextureFont : TextureFont {
    public float Advance;
    public MonospaceTextureFont(Texture2D texture, float size, char firstChar, char lastChar, Vector2[] renderOffsets, Rectangle[] sources, float advance, float ascender, float descender, float lineGap, string name);
    public virtual float GetAdvance(char character);
    public virtual Vector2 GetKerning(char fromChar, char toChar);
    public virtual Vector2 Measure(ReadOnlySpan`1<char> text);
    public virtual Vector2 MeasureLine(ReadOnlySpan`1<char> text);
}
public static class TrippyGL.OBJLoader : object {
    private static char NewlineIndicator;
    private static char IndicesSeparator;
    private static char CommentIndicator;
    private static int CharBufferLength;
    private static int MaxNumberCharacterLength;
    private static object listsLock;
    private static WeakReference`1<List`1<int>> indicesReference;
    private static WeakReference`1<List`1<Vector3>> positionsReference;
    private static WeakReference`1<List`1<Vector3>> normalsReference;
    private static WeakReference`1<List`1<Color4b>> colorsReference;
    private static WeakReference`1<List`1<Vector2>> texCoordsReference;
    private static OBJLoader();
    public static T[] FromFile(string file, ObjLoadOptions options);
    public static T[] FromStream(Stream stream, ObjLoadOptions options);
    public static T[] FromStream(StreamReader streamReader, ObjLoadOptions options);
    private static void SkipLine(StreamReader streamReader);
    private static bool SkipWhitespaces(StreamReader streamReader);
    private static void SkipWhitespacesNoEOL(StreamReader streamReader);
    private static void SkipUntilWhitespace(StreamReader streamReader);
    private static float ReadNextFloat(StreamReader streamReader, Span`1& charBuffer);
    private static void ReadThreeIntegers(StreamReader streamReader, Span`1& charBuffer, Int32& first, Int32& second, Int32& third);
    private static bool TryReadThreeIntegers(StreamReader streamReader, Span`1& charBuffer, Int32& first, Int32& second, Int32& third);
    private static bool ParseNextInt(StreamReader streamReader, Span`1& charBuffer, Int32& value);
    private static void ExpandCharBuffer(Span`1& charBuffer);
    private static void GetLists(bool loadNormals, bool loadColors, bool loadTexCoords, List`1& positions, List`1& normals, List`1& colors, List`1& texCoords, List`1& indices);
    private static void ReturnLists(List`1<Vector3> positions, List`1<Vector3> normals, List`1<Color4b> colors, List`1<Vector2> texCoords, List`1<int> indices);
    public static Vector3 MeasureModel(ReadOnlySpan`1<T> vertices, Vector3& min, Vector3& max);
    [CompilerGeneratedAttribute]
internal static void <FromStream>g__VerifyIndices|13_0(int first, int second, int third, <>c__DisplayClass13_0`1& );
}
public class TrippyGL.ObjLoaderException : Exception {
    public ObjLoaderException(string message);
    public ObjLoaderException(string message, Exception innerException);
}
[FlagsAttribute]
public enum TrippyGL.ObjLoadOptions : Enum {
    public int value__;
    public static ObjLoadOptions None;
    public static ObjLoadOptions TrianglesOnly;
}
public enum TrippyGL.PolygonFace : Enum {
    public int value__;
    public static PolygonFace Clockwise;
    public static PolygonFace CounterClockwise;
}
public class TrippyGL.PositionalLight : object {
    private ShaderUniform positionUniform;
    private ShaderUniform diffuseColorUniform;
    private ShaderUniform specularColorUniform;
    private ShaderUniform attenuationConfigUniform;
    private Vector3 position;
    private Vector3 diffuseColor;
    private Vector3 specularColor;
    private Vector3 attenuationConfig;
    public Vector3 Position { get; public set; }
    public Vector3 DiffuseColor { get; public set; }
    public Vector3 SpecularColor { get; public set; }
    public Vector3 AttenuationConfig { get; public set; }
    public PositionalLight(ShaderUniform positionUniform, ShaderUniform diffuseColorUniform, ShaderUniform specularColorUniform, ShaderUniform attenuationConfigUniform);
    public Vector3 get_Position();
    public void set_Position(Vector3 value);
    public Vector3 get_DiffuseColor();
    public void set_DiffuseColor(Vector3 value);
    public Vector3 get_SpecularColor();
    public void set_SpecularColor(Vector3 value);
    public Vector3 get_AttenuationConfig();
    public void set_AttenuationConfig(Vector3 value);
}
public class TrippyGL.PrimitiveBatcher`1 : object {
    public static int InitialCapacity;
    private T[] triangles;
    private T[] lines;
    [CompilerGeneratedAttribute]
private int <TriangleVertexCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineVertexCount>k__BackingField;
    public Span`1<T> TriangleVertices { get; }
    public Span`1<T> LineVertices { get; }
    public int TriangleVertexCount { get; private set; }
    public int LineVertexCount { get; private set; }
    public int TriangleCount { get; }
    public int LineCount { get; }
    public int TriangleVertexCapacity { get; public set; }
    public int LineVertexCapacity { get; public set; }
    public PrimitiveBatcher`1(int initialTriangleCount, int initialLineCount);
    public Span`1<T> get_TriangleVertices();
    public Span`1<T> get_LineVertices();
    [CompilerGeneratedAttribute]
public int get_TriangleVertexCount();
    [CompilerGeneratedAttribute]
private void set_TriangleVertexCount(int value);
    [CompilerGeneratedAttribute]
public int get_LineVertexCount();
    [CompilerGeneratedAttribute]
private void set_LineVertexCount(int value);
    public int get_TriangleCount();
    public int get_LineCount();
    public int get_TriangleVertexCapacity();
    public void set_TriangleVertexCapacity(int value);
    public int get_LineVertexCapacity();
    public void set_LineVertexCapacity(int value);
    public void AddTriangle(T& v1, T& v2, T& v3);
    public void AddTriangles(ReadOnlySpan`1<T> vertices);
    public void AddTriangleStrip(ReadOnlySpan`1<T> vertices);
    public void AddTriangleFan(ReadOnlySpan`1<T> vertex);
    public void AddQuad(T& v1, T& v2, T& v3, T& v4);
    public void AddQuads(ReadOnlySpan`1<T> vertex);
    public void AddLine(T& v1, T& v2);
    public void AddLines(ReadOnlySpan`1<T> vertices);
    public void AddLineStrip(ReadOnlySpan`1<T> vertices);
    public void AddLineLoop(ReadOnlySpan`1<T> vertices);
    public void EnsureTriangleSpace(int requiredVertexCount, bool copyOldData);
    public void EnsureLineSpace(int requiredVertexCount, bool copyOldData);
    private void ResizeTriangles(int newLength, bool copyOldData);
    private void ResizeLines(int newLength, bool copyOldData);
    public void TrimTriangles();
    public void TrimLines();
    public void ClearTriangles();
    public void ClearLines();
    public virtual string ToString();
}
public enum TrippyGL.PrimitiveType : Enum {
    public int value__;
    public static PrimitiveType Points;
    public static PrimitiveType Lines;
    public static PrimitiveType LineLoop;
    public static PrimitiveType LineStrip;
    public static PrimitiveType Triangles;
    public static PrimitiveType TriangleStrip;
    public static PrimitiveType TriangleFan;
    public static PrimitiveType Quads;
    public static PrimitiveType LinesAdjacency;
    public static PrimitiveType LineStripAdjacency;
    public static PrimitiveType TrianglesAdjacency;
    public static PrimitiveType TriangleStripAdjacency;
    public static PrimitiveType Patches;
}
public class TrippyGL.ProgramLinkException : Exception {
    public ProgramLinkException(string infoLog);
    public ProgramLinkException(string infoLog, Exception innerException);
}
public enum TrippyGL.ReadPixelsFormat : Enum {
    public int value__;
    public static ReadPixelsFormat Red;
    public static ReadPixelsFormat Green;
    public static ReadPixelsFormat Blue;
    public static ReadPixelsFormat Rgb;
    public static ReadPixelsFormat Bgr;
    public static ReadPixelsFormat Rgba;
    public static ReadPixelsFormat Bgra;
    public static ReadPixelsFormat DepthComponent;
    public static ReadPixelsFormat StencilIndex;
    public static ReadPixelsFormat DepthStencil;
}
public enum TrippyGL.RenderbufferFormat : Enum {
    public int value__;
    public static RenderbufferFormat Color4b;
    public static RenderbufferFormat Float;
    public static RenderbufferFormat Float2;
    public static RenderbufferFormat Float4;
    public static RenderbufferFormat Int;
    public static RenderbufferFormat Int2;
    public static RenderbufferFormat Int4;
    public static RenderbufferFormat UnsignedInt;
    public static RenderbufferFormat UnsignedInt2;
    public static RenderbufferFormat UnsignedInt4;
    public static RenderbufferFormat Depth16;
    public static RenderbufferFormat Depth24;
    public static RenderbufferFormat Depth32f;
    public static RenderbufferFormat Depth24Stencil8;
    public static RenderbufferFormat Depth32fStencil8;
    public static RenderbufferFormat Stencil8;
}
public class TrippyGL.RenderbufferObject : GraphicsResource {
    public UInt32 Handle;
    public UInt32 Width;
    public UInt32 Height;
    public UInt32 Samples;
    public RenderbufferFormat Format;
    public bool IsDepthOnly { get; }
    public bool IsStencilOnly { get; }
    public bool IsDepthStencil { get; }
    public bool IsColorRenderableFormat { get; }
    public RenderbufferObject(GraphicsDevice graphicsDevice, UInt32 width, UInt32 height, RenderbufferFormat format, UInt32 samples);
    public bool get_IsDepthOnly();
    public bool get_IsStencilOnly();
    public bool get_IsDepthStencil();
    public bool get_IsColorRenderableFormat();
    protected virtual void Dispose(bool isManualDispose);
    internal void ValidateSampleCount(UInt32 samples);
}
public class TrippyGL.ShaderBlockUniform : object {
    public string Name;
    public ShaderProgram OwnerProgram;
    public UInt32 BindingIndex;
    public int ActiveUniformCount;
    private UniformBufferSubset uniformSource;
    private UInt32 uniformBindOffsetBytes;
    private UInt32 uniformBindLengthBytes;
    internal ShaderBlockUniform(ShaderProgram owner, UInt32 bindingIndex, string name, int activeUniformCount);
    public void SetValue(UniformBufferSubset buffer, UInt32 elementIndex);
    internal void ApplyUniformValue();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class TrippyGL.ShaderBlockUniformList : ValueType {
    public ShaderProgram Program;
    private ShaderBlockUniform[] uniforms;
    public int TotalUniformCount;
    public ShaderBlockUniform Item { get; }
    public int Count { get; }
    internal ShaderBlockUniformList(ShaderProgram program);
    public ShaderBlockUniform get_Item(string name);
    public int get_Count();
    public static bool op_Equality(ShaderBlockUniformList left, ShaderBlockUniformList right);
    public static bool op_Inequality(ShaderBlockUniformList left, ShaderBlockUniformList right);
    internal void EnsureBufferBindingsSet();
    public ShaderBlockUniform GetUniformByName(ReadOnlySpan`1<char> name);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ShaderBlockUniformList other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.ShaderCompilationException : Exception {
    public ShaderCompilationException(string infoLog);
    public ShaderCompilationException(string infoLog, Exception innerException);
    public ShaderCompilationException(ShaderType shaderType, string infoLog);
    public ShaderCompilationException(ShaderType shaderType, string infoLog, Exception innerException);
}
public class TrippyGL.ShaderCompiledHandler : MulticastDelegate {
    public ShaderCompiledHandler(object object, IntPtr method);
    public virtual void Invoke(GraphicsDevice sender, ShaderProgramBuilder& modreq(System.Runtime.InteropServices.InAttribute) programBuilder, bool success);
    public virtual IAsyncResult BeginInvoke(GraphicsDevice sender, ShaderProgramBuilder& modreq(System.Runtime.InteropServices.InAttribute) programBuilder, bool success, AsyncCallback callback, object object);
    public virtual void EndInvoke(ShaderProgramBuilder& modreq(System.Runtime.InteropServices.InAttribute) programBuilder, IAsyncResult result);
}
public class TrippyGL.ShaderProgram : GraphicsResource {
    public UInt32 Handle;
    public GeometryShaderData GeometryShader;
    public ShaderUniformList Uniforms;
    public ShaderBlockUniformList BlockUniforms;
    private ActiveVertexAttrib[] activeAttribs;
    public bool HasVertexShader;
    public bool HasGeometryShader;
    public bool HasFragmentShader;
    internal bool areSamplerUniformsDirty;
    public ReadOnlySpan`1<ActiveVertexAttrib> ActiveAttribs { get; }
    internal ShaderProgram(GraphicsDevice graphicsDevice, UInt32 programHandle, ActiveVertexAttrib[] activeAttribs, bool hasVertexShader, bool hasGeometryShader, bool hasFragmentShader);
    public ReadOnlySpan`1<ActiveVertexAttrib> get_ActiveAttribs();
    internal void EnsureInUse();
    internal void EnsurePreDrawStates();
    public bool TryFindAttributeByLocation(int location, ActiveVertexAttrib& attrib);
    protected virtual void Dispose(bool isManualDispose);
    public static ShaderProgram FromCode(GraphicsDevice graphicsDevice, string vsCode, string fsCode, String[] attribNames);
    public static ShaderProgram FromFiles(GraphicsDevice graphicsDevice, string vsFile, string fsFile, String[] attribNames);
}
public class TrippyGL.ShaderProgramBuilder : ValueType {
    public string VertexShaderCode;
    public string GeometryShaderCode;
    public string FragmentShaderCode;
    private SpecifiedShaderAttrib[] specifiedAttribs;
    public string VertexShaderLog;
    public string GeometryShaderLog;
    public string FragmentShaderLog;
    public string ProgramLog;
    public bool HasVertexShader { get; }
    public bool HasGeometryShader { get; }
    public bool HasFragmentShader { get; }
    public bool HasAttribsSpecified { get; }
    public bool get_HasVertexShader();
    public bool get_HasGeometryShader();
    public bool get_HasFragmentShader();
    public bool get_HasAttribsSpecified();
    public static bool op_Equality(ShaderProgramBuilder left, ShaderProgramBuilder right);
    public static bool op_Inequality(ShaderProgramBuilder left, ShaderProgramBuilder right);
    public void SpecifyVertexAttribs(ReadOnlySpan`1<SpecifiedShaderAttrib> attributes);
    public void SpecifyVertexAttribs(ReadOnlySpan`1<VertexAttribDescription> attribs, ReadOnlySpan`1<string> attribNames);
    public void SpecifyVertexAttribs(ReadOnlySpan`1<VertexAttribSource> attribs, ReadOnlySpan`1<string> attribNames);
    public void SpecifyVertexAttribs(ReadOnlySpan`1<string> attribNames);
    internal UInt32 CreateInternal(GraphicsDevice graphicsDevice, ActiveVertexAttrib[]& activeAttribs, Boolean& hasVs, Boolean& hasGs, Boolean& hasFs, bool getLogs);
    public ShaderProgram Create(GraphicsDevice graphicsDevice, bool getLogs);
    private static ActiveVertexAttrib[] CreateActiveAttribArray(GraphicsDevice graphicsDevice, UInt32 programHandle);
    private static bool DoVertexAttributesMatch(ReadOnlySpan`1<ActiveVertexAttrib> activeAttribs, ReadOnlySpan`1<SpecifiedShaderAttrib> specifiedAttribs);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ShaderProgramBuilder other);
    public virtual bool Equals(object obj);
}
[IsReadOnlyAttribute]
public class TrippyGL.ShaderUniform : ValueType {
    public string Name;
    public UniformType UniformType;
    public ShaderProgram OwnerProgram;
    public int UniformLocation;
    public int Size;
    public bool IsSamplerType;
    private Texture[] textureValues;
    private Int32[] textureLastAppliedUnits;
    public static ShaderUniform Empty { get; }
    public bool IsEmpty { get; }
    public ReadOnlySpan`1<Texture> Textures { get; }
    internal ShaderUniform(ShaderProgram owner, int uniformLoc, string name, int size, UniformType type);
    public static ShaderUniform get_Empty();
    public bool get_IsEmpty();
    public ReadOnlySpan`1<Texture> get_Textures();
    public static bool op_Equality(ShaderUniform left, ShaderUniform right);
    public static bool op_Inequality(ShaderUniform left, ShaderUniform right);
    public void SetValueFloat(float value);
    public void SetValueDouble(double value);
    public void SetValueInt(int value);
    public void SetValueUint(UInt32 value);
    public void SetValueBool(bool value);
    public void SetValueVec2(float x, float y);
    public void SetValueDVec2(double x, double y);
    public void SetValueIVec2(int x, int y);
    public void SetValueUVec2(UInt32 x, UInt32 y);
    public void SetValueBVec2(bool x, bool y);
    public void SetValueVec2(Vector2& value);
    public void SetValueVec3(float x, float y, float z);
    public void SetValueDVec3(double x, double y, double z);
    public void SetValueIVec3(int x, int y, int z);
    public void SetValueUVec3(UInt32 x, UInt32 y, UInt32 z);
    public void SetValueBVec3(bool x, bool y, bool z);
    public void SetValueVec3(Vector3& value);
    public void SetValueVec4(float x, float y, float z, float w);
    public void SetValueDVec4(double x, double y, double z, double w);
    public void SetValueIVec4(int x, int y, int z, int w);
    public void SetValueUVec4(UInt32 x, UInt32 y, UInt32 z, UInt32 w);
    public void SetValueBVec4(bool x, bool y, bool z, bool w);
    public void SetValueVec4(Vector4& value);
    public void SetValueVec4(Color4b value);
    public void SetValueVec4(Quaternion& value);
    public void SetValueTexture(Texture texture, int uniformIndex);
    public void SetValueTextureArray(ReadOnlySpan`1<Texture> textures, int startUniformIndex);
    public void SetValueMat2Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat2Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat2x4Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat2x4Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat2x3Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat2x3Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat2(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat2(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat2x4(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat2x4(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat2x3(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat2x3(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat3Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat3Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat3x4Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat3x4Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat3x2Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat3x2Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat3(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat3(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat3x4(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat3x4(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat3x2(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat3x2(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat3x2(Matrix3x2& value, bool transpose);
    public void SetValueMat3x2Array(ReadOnlySpan`1<Matrix3x2> value, bool transpose);
    public void SetValueMat4Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat4Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat4x3Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat4x3Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat4x2Ptr(Single* ptr, int count, bool transpose);
    public void SetValueDMat4x2Ptr(Double* ptr, int count, bool transpose);
    public void SetValueMat4(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat4(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat4x3(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat4x3(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat4x2(ReadOnlySpan`1<float> value, bool transpose);
    public void SetValueDMat4x2(ReadOnlySpan`1<double> value, bool transpose);
    public void SetValueMat4(Matrix4x4& value, bool transpose);
    public void SetValueMat4Array(ReadOnlySpan`1<Matrix4x4> value, bool transpose);
    public void SetValue1ArrayPtr(Single* ptr, int count);
    public void SetValue1ArrayPtr(Double* ptr, int count);
    public void SetValue1ArrayPtr(Int32* ptr, int count);
    public void SetValue1ArrayPtr(UInt32* ptr, int count);
    public void SetValue1Array(ReadOnlySpan`1<float> value);
    public void SetValue1Array(ReadOnlySpan`1<double> value);
    public void SetValue1Array(ReadOnlySpan`1<int> value);
    public void SetValue1Array(ReadOnlySpan`1<UInt32> value);
    public void SetValue2ArrayPtr(Single* ptr, int count);
    public void SetValue2ArrayPtr(Double* ptr, int count);
    public void SetValue2ArrayPtr(Int32* ptr, int count);
    public void SetValue2ArrayPtr(UInt32* ptr, int count);
    public void SetValue2Array(ReadOnlySpan`1<Vector2> value);
    public void SetValue2Array(ReadOnlySpan`1<float> value);
    public void SetValue2Array(ReadOnlySpan`1<double> value);
    public void SetValue2Array(ReadOnlySpan`1<int> value);
    public void SetValue2Array(ReadOnlySpan`1<UInt32> value);
    public void SetValue3ArrayPtr(Single* ptr, int count);
    public void SetValue3ArrayPtr(Double* ptr, int count);
    public void SetValue3ArrayPtr(Int32* ptr, int count);
    public void SetValue3ArrayPtr(UInt32* ptr, int count);
    public void SetValue3Array(ReadOnlySpan`1<Vector3> value);
    public void SetValue3Array(ReadOnlySpan`1<float> value);
    public void SetValue3Array(ReadOnlySpan`1<double> value);
    public void SetValue3Array(ReadOnlySpan`1<int> value);
    public void SetValue3Array(ReadOnlySpan`1<UInt32> value);
    public void SetValue4ArrayPtr(Single* ptr, int count);
    public void SetValue4ArrayPtr(Double* ptr, int count);
    public void SetValue4ArrayPtr(Int32* ptr, int count);
    public void SetValue4ArrayPtr(UInt32* ptr, int count);
    public void SetValue4Array(ReadOnlySpan`1<Vector4> value);
    public void SetValue4Array(ReadOnlySpan`1<float> value);
    public void SetValue4Array(ReadOnlySpan`1<double> value);
    public void SetValue4Array(ReadOnlySpan`1<int> value);
    public void SetValue4Array(ReadOnlySpan`1<UInt32> value);
    internal void ApplyUniformTextureValues();
    private void ValidateUniformType(UniformType type);
    private void ValidateArrayAndType(UniformType type, int valueLength);
    private void ValidateIsSampler();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ShaderUniform other);
    public virtual bool Equals(object obj);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class TrippyGL.ShaderUniformList : ValueType {
    public ShaderProgram Program;
    private ShaderUniform[] uniforms;
    private List`1<Texture> textureList;
    internal bool hasSamplerUniforms;
    public bool IsEmpty { get; }
    public int Count { get; }
    public ReadOnlySpan`1<ShaderUniform> Uniforms { get; }
    public ShaderUniform Item { get; }
    private ShaderUniformList(ShaderProgram program, int totalUniformCount, int totalUniformBlockCount);
    public bool get_IsEmpty();
    public int get_Count();
    public ReadOnlySpan`1<ShaderUniform> get_Uniforms();
    public ShaderUniform get_Item(string name);
    public static bool op_Equality(ShaderUniformList left, ShaderUniformList right);
    public static bool op_Inequality(ShaderUniformList left, ShaderUniformList right);
    internal void EnsureSamplerUniformsSet();
    private void RemakeTextureList();
    public ShaderUniform GetUniformByName(ReadOnlySpan`1<char> name);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ShaderUniformList other);
    public virtual bool Equals(object obj);
    internal static ShaderUniformList CreateForProgram(ShaderProgram program);
}
public class TrippyGL.SimpleShaderProgram : ShaderProgram {
    public bool VertexColorsEnabled;
    public bool TextureEnabled;
    public bool LightingEnabled;
    public bool HasWorldUniform;
    private ShaderUniform worldUniform;
    private ShaderUniform viewUniform;
    private ShaderUniform projectionUniform;
    private ShaderUniform colorUniform;
    internal ShaderUniform sampUniform;
    private ShaderUniform cameraPosUniform;
    private ShaderUniform reflectivityUniform;
    private ShaderUniform specularPowerUniform;
    private ShaderUniform ambientLightColorUniform;
    private Matrix4x4 world;
    private Matrix4x4 view;
    private Matrix4x4 projection;
    private Vector4 color;
    private Texture2D texture;
    private float reflectivity;
    private float specularPower;
    private Vector3 ambientLightColor;
    private DirectionalLight[] directionalLights;
    private PositionalLight[] positionalLights;
    public Matrix4x4 World { get; public set; }
    public Matrix4x4 View { get; public set; }
    public Matrix4x4 Projection { get; public set; }
    public Vector4 Color { get; public set; }
    public Texture2D Texture { get; public set; }
    public float Reflectivity { get; public set; }
    public float SpecularPower { get; public set; }
    public Vector3 AmbientLightColor { get; public set; }
    public ReadOnlySpan`1<DirectionalLight> DirectionalLights { get; }
    public ReadOnlySpan`1<PositionalLight> PositionalLights { get; }
    internal SimpleShaderProgram(GraphicsDevice graphicsDevice, UInt32 programHandle, ActiveVertexAttrib[] activeAttribs, bool hasVertexShader, bool hasGeometryShader, bool hasFragmentShader, bool vertColorsEnabled, bool textureEnabled, int directionalLightCount, int positionalLightCount);
    public Matrix4x4 get_World();
    public void set_World(Matrix4x4 value);
    public Matrix4x4 get_View();
    public void set_View(Matrix4x4 value);
    public Matrix4x4 get_Projection();
    public void set_Projection(Matrix4x4 value);
    public Vector4 get_Color();
    public void set_Color(Vector4 value);
    public Texture2D get_Texture();
    public void set_Texture(Texture2D value);
    public float get_Reflectivity();
    public void set_Reflectivity(float value);
    public float get_SpecularPower();
    public void set_SpecularPower(float value);
    public Vector3 get_AmbientLightColor();
    public void set_AmbientLightColor(Vector3 value);
    public ReadOnlySpan`1<DirectionalLight> get_DirectionalLights();
    public ReadOnlySpan`1<PositionalLight> get_PositionalLights();
    private DirectionalLight[] CreateDirectionalLights(int directionalLightCount);
    private PositionalLight[] CreatePositionalLights(int positionalLightCount);
    public void SetView(Matrix4x4& view, Vector3& cameraPos);
    public static SimpleShaderProgram Create(GraphicsDevice graphicsDevice, int directionalLights, int positionalLights, bool excludeWorldMatrix);
}
public class TrippyGL.SimpleShaderProgramBuilder : ValueType {
    private static object stringBuilderReferenceLock;
    private static WeakReference`1<StringBuilder> stringBuilderReference;
    public string GLSLVersionString;
    public int PositionAttributeIndex;
    public int NormalAttributeIndex;
    public int ColorAttributeIndex;
    public int TexCoordsAttributeIndex;
    public bool VertexColorsEnabled;
    public bool TextureEnabled;
    public int DirectionalLights;
    public int PositionalLights;
    public bool ExcludeWorldMatrix;
    public bool DiscardTransparentFragments;
    public float TransparentFragmentThreshold;
    public string VertexShaderLog;
    public string FragmentShaderLog;
    public string ProgramLog;
    public bool LightingEnabled { get; }
    private static SimpleShaderProgramBuilder();
    public bool get_LightingEnabled();
    public static bool op_Equality(SimpleShaderProgramBuilder left, SimpleShaderProgramBuilder right);
    public static bool op_Inequality(SimpleShaderProgramBuilder left, SimpleShaderProgramBuilder right);
    public void ConfigureVertexAttribs();
    public SimpleShaderProgram Create(GraphicsDevice graphicsDevice);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SimpleShaderProgramBuilder other);
    public virtual bool Equals(object obj);
    private static StringBuilder GetStringBuilder();
    private static void ReturnStringBuilder(StringBuilder stringBuilder);
}
public class TrippyGL.SpacedTextureFont : TextureFont {
    private Single[] advances;
    public ReadOnlySpan`1<float> Advances { get; }
    public SpacedTextureFont(Texture2D texture, float size, char firstChar, char lastChar, Vector2[] renderOffsets, Rectangle[] sources, Single[] advances, float ascender, float descender, float lineGap, string name);
    public ReadOnlySpan`1<float> get_Advances();
    public virtual float GetAdvance(char character);
    public virtual Vector2 GetKerning(char fromChar, char toChar);
    public virtual Vector2 Measure(ReadOnlySpan`1<char> text);
    public virtual Vector2 MeasureLine(ReadOnlySpan`1<char> text);
}
[IsReadOnlyAttribute]
public class TrippyGL.SpecifiedShaderAttrib : ValueType {
    public AttributeType AttribType;
    public string Name;
    public SpecifiedShaderAttrib(string name, AttributeType type);
    public static bool op_Equality(SpecifiedShaderAttrib left, SpecifiedShaderAttrib right);
    public static bool op_Inequality(SpecifiedShaderAttrib left, SpecifiedShaderAttrib right);
    public bool Matches(ActiveVertexAttrib& activeAttrib);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SpecifiedShaderAttrib shaderAttrib);
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public enum TrippyGL.StencilFunction : Enum {
    public int value__;
    public static StencilFunction Never;
    public static StencilFunction Less;
    public static StencilFunction Equal;
    public static StencilFunction LessOrEqual;
    public static StencilFunction Greater;
    public static StencilFunction NotEqual;
    public static StencilFunction GreaterOrEqual;
    public static StencilFunction Always;
}
public enum TrippyGL.StencilOperation : Enum {
    public int value__;
    public static StencilOperation Zero;
    public static StencilOperation Invert;
    public static StencilOperation Keep;
    public static StencilOperation Replace;
    public static StencilOperation Increment;
    public static StencilOperation Decrement;
    public static StencilOperation IncrementWrap;
    public static StencilOperation DecrementWrap;
}
public class TrippyGL.StencilState : object {
    public static UInt32 FullMask;
    public static UInt32 EmptyMask;
    public bool StencilTestingEnabled;
    public int ClearStencil;
    public UInt32 FrontWriteMask;
    public UInt32 BackWriteMask;
    public StencilFunction FrontFunction;
    public StencilFunction BackFunction;
    public int FrontRefValue;
    public int BackRefValue;
    public UInt32 FrontTestMask;
    public UInt32 BackTestMask;
    public StencilOperation FrontStencilFailOperation;
    public StencilOperation FrontDepthFailOperation;
    public StencilOperation FrontPassOperation;
    public StencilOperation BackStencilFailOperation;
    public StencilOperation BackDepthFailOperation;
    public StencilOperation BackPassOperation;
    unknown UInt32 WriteMask {public set; }
    unknown StencilFunction Function {public set; }
    unknown int RefValue {public set; }
    unknown UInt32 TestMask {public set; }
    unknown StencilOperation StencilFailOperation {public set; }
    unknown StencilOperation DepthFailOperation {public set; }
    unknown StencilOperation PassOperation {public set; }
    public StencilState(bool testingEnabled, int clearStencil, UInt32 writeMask, StencilFunction function, int refValue, UInt32 testMask, StencilOperation sfail, StencilOperation dpfail, StencilOperation dppass);
    public void set_WriteMask(UInt32 value);
    public void set_Function(StencilFunction value);
    public void set_RefValue(int value);
    public void set_TestMask(UInt32 value);
    public void set_StencilFailOperation(StencilOperation value);
    public void set_DepthFailOperation(StencilOperation value);
    public void set_PassOperation(StencilOperation value);
    public StencilState Clone();
    public virtual string ToString();
    public sealed virtual bool Equals(StencilState other);
}
public abstract class TrippyGL.Texture : GraphicsResource {
    private protected static TextureMinFilter DefaultMinFilter;
    private protected static TextureMinFilter DefaultMipmapMinFilter;
    private protected static TextureMagFilter DefaultMagFilter;
    public UInt32 Handle;
    public TextureType TextureType;
    internal InternalFormat PixelInternalFormat;
    internal PixelType PixelType;
    internal PixelFormat PixelFormat;
    public TextureImageFormat ImageFormat;
    [CompilerGeneratedAttribute]
private bool <IsMipmapped>k__BackingField;
    private bool isNotMipmappable;
    internal int lastBindUnit;
    public bool IsMipmapped { get; private set; }
    public bool IsMipmappable { get; }
    public bool IsBound { get; }
    public bool IsBoundAndActive { get; }
    public int CurrentlyBoundUnit { get; }
    internal Texture(GraphicsDevice graphicsDevice, TextureType type, TextureImageFormat imageFormat);
    [CompilerGeneratedAttribute]
public bool get_IsMipmapped();
    [CompilerGeneratedAttribute]
private void set_IsMipmapped(bool value);
    public bool get_IsMipmappable();
    public bool get_IsBound();
    public bool get_IsBoundAndActive();
    public int get_CurrentlyBoundUnit();
    public void SetTextureFilters(TextureMinFilter minFilter, TextureMagFilter magFilter);
    public void GenerateMipmaps();
    protected virtual void Dispose(bool isManualDispose);
    public virtual string ToString();
}
public class TrippyGL.Texture1D : Texture {
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    public UInt32 Width { get; private set; }
    public Texture1D(GraphicsDevice graphicsDevice, UInt32 width, bool generateMipmaps, TextureImageFormat imageFormat);
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(UInt32 value);
    public void SetDataPtr(Void* ptr, int xOffset, UInt32 width, PixelFormat pixelFormat);
    public void SetData(ReadOnlySpan`1<T> data, int xOffset, PixelFormat pixelFormat);
    public void GetDataPtr(Void* ptr, PixelFormat pixelFormat);
    public void GetData(Span`1<T> data, PixelFormat pixelFormat);
    public void SetWrapMode(TextureWrapMode sWrapMode);
    public void RecreateImage(UInt32 width);
    private void ValidateTextureSize(UInt32 width);
    private void ValidateRectOperation(int xOffset, UInt32 width);
}
public class TrippyGL.Texture2D : TextureMultisamplable {
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    public UInt32 Width { get; private set; }
    public UInt32 Height { get; private set; }
    public Texture2D(GraphicsDevice graphicsDevice, UInt32 width, UInt32 height, bool generateMipmaps, UInt32 samples, TextureImageFormat imageFormat);
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(UInt32 value);
    public void SetDataPtr(Void* ptr, int rectX, int rectY, UInt32 rectWidth, UInt32 rectHeight, PixelFormat pixelFormat);
    public void SetData(ReadOnlySpan`1<T> data, int rectX, int rectY, UInt32 rectWidth, UInt32 rectHeight, PixelFormat pixelFormat);
    public void SetData(ReadOnlySpan`1<T> data, PixelFormat pixelFormat);
    public void GetDataPtr(Void* ptr, PixelFormat pixelFormat);
    public void GetData(Span`1<T> data, PixelFormat pixelFormat);
    public void SetWrapModes(TextureWrapMode sWrapMode, TextureWrapMode tWrapMode);
    public void RecreateImage(UInt32 width, UInt32 height);
    private void ValidateTextureSize(UInt32 width, UInt32 height);
    private void ValidateRectOperation(int rectX, int rectY, UInt32 rectWidth, UInt32 rectHeight);
}
public class TrippyGL.Texture2DArray : TextureMultisamplable {
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Depth>k__BackingField;
    public UInt32 Width { get; private set; }
    public UInt32 Height { get; private set; }
    public UInt32 Depth { get; private set; }
    public Texture2DArray(GraphicsDevice graphicsDevice, UInt32 width, UInt32 height, UInt32 depth, UInt32 samples, TextureImageFormat imageFormat);
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Depth();
    [CompilerGeneratedAttribute]
private void set_Depth(UInt32 value);
    public void SetDataPtr(Void* ptr, int rectX, int rectY, int rectZ, UInt32 rectWidth, UInt32 rectHeight, UInt32 rectDepth, PixelFormat pixelFormat);
    public void SetData(ReadOnlySpan`1<T> data, int rectX, int rectY, int rectZ, UInt32 rectWidth, UInt32 rectHeight, UInt32 rectDepth, PixelFormat pixelFormat);
    public void SetData(ReadOnlySpan`1<T> data, int depthLevel, PixelFormat pixelFormat);
    public void GetDataPtr(Void* ptr, PixelFormat pixelFormat);
    public void GetData(Span`1<T> data, PixelFormat pixelFormat);
    public void SetWrapModes(TextureWrapMode sWrapMode, TextureWrapMode tWrapMode);
    public void RecreateImage(UInt32 width, UInt32 height, UInt32 depth);
    private void ValidateTextureSize(UInt32 width, UInt32 height, UInt32 depth);
    private void ValidateRectOperation(int rectX, int rectY, int rectZ, UInt32 rectWidth, UInt32 rectHeight, UInt32 rectDepth);
}
public class TrippyGL.TextureBatcher : object {
    public static UInt32 InitialBatchItemsCapacity;
    public static UInt32 MaxBatchItemCapacity;
    private static UInt32 InitialBufferCapacity;
    private static UInt32 MaxBufferCapacity;
    [CompilerGeneratedAttribute]
private GraphicsDevice <GraphicsDevice>k__BackingField;
    private VertexColorTexture[] triangles;
    private VertexBuffer`1<VertexColorTexture> vertexBuffer;
    private TextureBatchItem[] batchItems;
    private int batchItemCount;
    [CompilerGeneratedAttribute]
private bool <IsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private BatcherBeginMode <BeginMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ShaderProgram <ShaderProgram>k__BackingField;
    [CompilerGeneratedAttribute]
private ShaderUniform <TextureUniform>k__BackingField;
    public GraphicsDevice GraphicsDevice { get; }
    public bool IsActive { get; private set; }
    public BatcherBeginMode BeginMode { get; private set; }
    public ShaderProgram ShaderProgram { get; private set; }
    public ShaderUniform TextureUniform { get; private set; }
    public bool IsDisposed { get; }
    public TextureBatcher(GraphicsDevice graphicsDevice, UInt32 initialBatchCapacity);
    [CompilerGeneratedAttribute]
public GraphicsDevice get_GraphicsDevice();
    [CompilerGeneratedAttribute]
public bool get_IsActive();
    [CompilerGeneratedAttribute]
private void set_IsActive(bool value);
    [CompilerGeneratedAttribute]
public BatcherBeginMode get_BeginMode();
    [CompilerGeneratedAttribute]
private void set_BeginMode(BatcherBeginMode value);
    [CompilerGeneratedAttribute]
public ShaderProgram get_ShaderProgram();
    [CompilerGeneratedAttribute]
private void set_ShaderProgram(ShaderProgram value);
    [CompilerGeneratedAttribute]
public ShaderUniform get_TextureUniform();
    [CompilerGeneratedAttribute]
private void set_TextureUniform(ShaderUniform value);
    public bool get_IsDisposed();
    public void SetShaderProgram(SimpleShaderProgram simpleProgram);
    public void SetShaderProgram(ShaderProgram shaderProgram, ShaderUniform textureUniform);
    public void Begin(BatcherBeginMode beginMode);
    public void End();
    private void ValidateBeginCalled();
    private bool EnsureBatchListCapacity(int requiredCapacity);
    private void EnsureBufferCapacity(int requiredCapacity);
    private TextureBatchItem GetNextBatchItem();
    public void DrawRaw(Texture2D texture, VertexColorTexture& VertexTL, VertexColorTexture& VertexTR, VertexColorTexture& VertexBR, VertexColorTexture& VertexBL);
    public void DrawRaw(Texture2D texture, VertexColorTexture& VertexTL, VertexColorTexture& VertexTR, VertexColorTexture& VertexBR, VertexColorTexture& VertexBL, Matrix4x4& matrix);
    public void Draw(Texture2D texture, Vector2 position, Nullable`1<Rectangle> source, Color4b color, Vector2 scale, float rotation, Vector2 origin, float depth);
    public void Draw(Texture2D texture, Vector2 position, Nullable`1<Rectangle> source, Color4b color, float scale, float rotation, Vector2 origin, float depth);
    public void Draw(Texture2D texture, Vector2 position, Nullable`1<Rectangle> source, Color4b color, float depth);
    public void Draw(Texture2D texture, Vector2 position, Nullable`1<Rectangle> source, float depth);
    public void Draw(Texture2D texture, Vector2 position, Color4b color, float depth);
    public void Draw(Texture2D texture, RectangleF destination, Nullable`1<Rectangle> source, Color4b color, float depth);
    public void Draw(Texture2D texture, RectangleF destination, Color4b color, float depth);
    public void Draw(Texture2D texture, RectangleF destination, float depth);
    public void DrawString(TextureFont font, ReadOnlySpan`1<char> text, Vector2 position, Color4b color, Vector2 scale, float rotation, Vector2 origin, float depth);
    public void DrawString(TextureFont font, ReadOnlySpan`1<char> text, Vector2 position, Color4b color, float scale, float rotation, Vector2 origin, float depth);
    public void DrawString(TextureFont font, ReadOnlySpan`1<char> text, Vector2 position, Color4b color, Vector2 scale, Vector2 origin, float depth);
    public void DrawString(TextureFont font, ReadOnlySpan`1<char> text, Vector2 position, Color4b color, float scale, Vector2 origin, float depth);
    public void DrawString(TextureFont font, ReadOnlySpan`1<char> text, Vector2 position, Color4b color, float depth);
    public void DrawString(TextureFont font, ReadOnlySpan`1<char> text, Vector2 position, float depth);
    public void DrawString(TextureFont font, StringBuilder text, Vector2 position, Color4b color, Vector2 scale, float rotation, Vector2 origin, float depth);
    public void DrawString(TextureFont font, StringBuilder text, Vector2 position, Color4b color, float scale, float rotation, Vector2 origin, float depth);
    public void DrawString(TextureFont font, StringBuilder text, Vector2 position, Color4b color, Vector2 scale, Vector2 origin, float depth);
    public void DrawString(TextureFont font, StringBuilder text, Vector2 position, Color4b color, float scale, Vector2 origin, float depth);
    public void DrawString(TextureFont font, StringBuilder text, Vector2 position, Color4b color, float depth);
    public void DrawString(TextureFont font, StringBuilder text, Vector2 position, float depth);
    private void StartDraw(Texture2D texture);
    private void EndDraw(TextureBatchItem item);
    private void SetItemSortKey(TextureBatchItem item);
    private bool FlushIfNeeded();
    private void Flush(bool sameTextureEnsured);
    private int FindDifferentTexture(Texture2D currentTexture, int startIndex);
    public sealed virtual void Dispose();
}
internal class TrippyGL.TextureBatchItem : object {
    public Texture2D Texture;
    public float SortValue;
    public VertexColorTexture VertexTL;
    public VertexColorTexture VertexTR;
    public VertexColorTexture VertexBL;
    public VertexColorTexture VertexBR;
    public void SetValue(Texture2D texture, Vector2 position, Nullable`1<Rectangle> source, Color4b color, Vector2 scale, float rotation, Vector2 origin, float depth);
    public void SetValue(Texture2D texture, Vector2 position, Rectangle source, Color4b color, Vector2 scale, float sin, float cos, float depth);
    public void SetValue(Texture2D texture, Vector2 position, Nullable`1<Rectangle> source, Color4b color, Vector2 scale, Vector2 origin, float depth);
    public void SetValue(Texture2D texture, Vector2 position, Rectangle source, Color4b color, Vector2 scale, float depth);
    public void SetValue(Texture2D texture, Vector2 position, Rectangle source, Color4b color, float depth);
    public void SetValue(Texture2D texture, RectangleF destination, Rectangle source, Color4b color, float depth);
    public sealed virtual int CompareTo(TextureBatchItem other);
    public virtual string ToString();
}
public class TrippyGL.TextureCubemap : Texture {
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    public UInt32 Size { get; private set; }
    public TextureCubemap(GraphicsDevice graphicsDevice, UInt32 size, TextureImageFormat imageFormat);
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(UInt32 value);
    public void SetDataPtr(CubemapFace face, Void* ptr, int rectX, int rectY, UInt32 rectWidth, UInt32 rectHeight, PixelFormat pixelFormat);
    public void SetData(CubemapFace face, ReadOnlySpan`1<T> data, int rectX, int rectY, UInt32 rectWidth, UInt32 rectHeight, PixelFormat pixelFormat);
    public void SetData(CubemapFace face, ReadOnlySpan`1<T> data, PixelFormat pixelFormat);
    public void GetDataPtr(CubemapFace face, Void* ptr, PixelFormat pixelFormat);
    public void GetData(CubemapFace face, Span`1<T> data, PixelFormat pixelFormat);
    public void SetWrapModes(TextureWrapMode sWrapMode, TextureWrapMode tWrapMode, TextureWrapMode rWrapMode);
    private void ValidateTextureSize(UInt32 size);
    private void ValidateRectOperation(int rectX, int rectY, UInt32 rectWidth, UInt32 rectHeight);
    private static void ValidateCubemapFace(CubemapFace face);
}
public abstract class TrippyGL.TextureFont : object {
    public static char NewlineIndicator;
    public Texture2D Texture;
    public float Size;
    public string Name;
    public char FirstChar;
    public char LastChar;
    public float Ascender;
    public float Descender;
    public float LineGap;
    public float LineAdvance;
    protected Vector2[] renderOffsets;
    protected Rectangle[] sources;
    public int CharCount { get; }
    public bool IsDisposed { get; }
    protected TextureFont(Texture2D texture, float size, char firstChar, char lastChar, Vector2[] renderOffsets, Rectangle[] sources, float ascender, float descender, float lineGap, string name);
    public int get_CharCount();
    public bool get_IsDisposed();
    protected void ValidateCharAvailable(char c);
    public bool HasCharacter(char character);
    public bool HasCharacters(ReadOnlySpan`1<char> characters);
    public abstract virtual float GetAdvance(char character);
    public abstract virtual Vector2 GetKerning(char fromChar, char toChar);
    public Rectangle GetSource(char character);
    public Vector2 GetRenderOffset(char character);
    public abstract virtual Vector2 Measure(ReadOnlySpan`1<char> text);
    public abstract virtual Vector2 MeasureLine(ReadOnlySpan`1<char> text);
    public float MeasureHeight(ReadOnlySpan`1<char> text);
    public sealed virtual void Dispose();
    public virtual string ToString();
    public string SanitizeString(string text, char defaultChar, bool ignoreNewline);
    public void SanitizeString(Span`1<char> text, char defaultChar, bool ignoreNewline);
    public void SanitizeString(StringBuilder text, char defaultChar, bool ignoreNewline);
}
public enum TrippyGL.TextureImageFormat : Enum {
    public int value__;
    public static TextureImageFormat Color4b;
    public static TextureImageFormat Float;
    public static TextureImageFormat Float2;
    public static TextureImageFormat Float3;
    public static TextureImageFormat Float4;
    public static TextureImageFormat Depth16;
    public static TextureImageFormat Depth24;
    public static TextureImageFormat Depth32f;
    public static TextureImageFormat Int;
    public static TextureImageFormat Int2;
    public static TextureImageFormat Int3;
    public static TextureImageFormat Int4;
    public static TextureImageFormat UnsignedInt;
    public static TextureImageFormat UnsignedInt2;
    public static TextureImageFormat UnsignedInt3;
    public static TextureImageFormat UnsignedInt4;
    public static TextureImageFormat Depth24Stencil8;
}
public enum TrippyGL.TextureMagFilter : Enum {
    public int value__;
    public static TextureMagFilter Nearest;
    public static TextureMagFilter Linear;
}
public enum TrippyGL.TextureMinFilter : Enum {
    public int value__;
    public static TextureMinFilter Nearest;
    public static TextureMinFilter Linear;
    public static TextureMinFilter NearestMipmapNearest;
    public static TextureMinFilter LinearMipmapNearest;
    public static TextureMinFilter NearestMipmapLinear;
    public static TextureMinFilter LinearMipmapLinear;
}
public abstract class TrippyGL.TextureMultisamplable : Texture {
    [CompilerGeneratedAttribute]
private UInt32 <Samples>k__BackingField;
    public UInt32 Samples { get; private set; }
    internal TextureMultisamplable(GraphicsDevice graphicsDevice, TextureType type, UInt32 samples, TextureImageFormat imageFormat);
    [CompilerGeneratedAttribute]
public UInt32 get_Samples();
    [CompilerGeneratedAttribute]
private void set_Samples(UInt32 value);
    private void ValidateSampleCount(UInt32 samples);
    protected void ValidateNotMultisampledPixelAccess();
    protected void ValidateNotMultisampledWrapStates();
}
public enum TrippyGL.TextureType : Enum {
    public int value__;
    public static TextureType Texture1D;
    public static TextureType Texture2D;
    public static TextureType Texture3D;
    public static TextureType TextureCubeMap;
    public static TextureType Texture1DArray;
    public static TextureType Texture2DArray;
    public static TextureType TextureCubeMapArray;
    public static TextureType Texture2DMultisample;
    public static TextureType Texture2DMultisampleArray;
}
public enum TrippyGL.TextureWrapMode : Enum {
    public int value__;
    public static TextureWrapMode Repeat;
    public static TextureWrapMode ClampToEdge;
    public static TextureWrapMode MirroredRepeat;
}
public abstract class TrippyGL.UniformBufferSubset : BufferObjectSubset {
    public UInt32 ElementSize;
    public UInt32 ElementStride;
    [CompilerGeneratedAttribute]
private UInt32 <StorageLength>k__BackingField;
    public UInt32 StorageLength { get; private set; }
    internal UniformBufferSubset(UInt32 elementSize, BufferObject bufferObject, UInt32 storageOffsetBytes, UInt32 storageLength);
    internal UniformBufferSubset(UInt32 elementSize, BufferObject bufferObject);
    [CompilerGeneratedAttribute]
public UInt32 get_StorageLength();
    [CompilerGeneratedAttribute]
private void set_StorageLength(UInt32 value);
    public void ResizeSubset(UInt32 storageOffsetBytes, UInt32 storageLength);
    internal void BindBufferRange(UInt32 bindingIndex, UInt32 storageOffsetBytes, UInt32 storageLengthBytes);
    internal void GetOffsetAndStorageLengthForIndex(UInt32 elementIndex, UInt32& storageOffsetBytes, UInt32& storageLengthBytes);
    public static UInt32 CalculateRequiredSizeInBytes(GraphicsDevice graphicsDevice, UInt32 storageLength);
}
public class TrippyGL.UniformBufferSubset`1 : UniformBufferSubset {
    public UniformBufferSubset`1(BufferObject bufferObject, UInt32 storageOffsetBytes, UInt32 storageLength);
    public UniformBufferSubset`1(BufferObject bufferObject);
    public void SetValue(T& value, int index);
    public void GetValue(T& value, int index);
    public T GetValue(int index);
}
public enum TrippyGL.UniformType : Enum {
    public int value__;
    public static UniformType Int;
    public static UniformType UnsignedInt;
    public static UniformType Float;
    public static UniformType Double;
    public static UniformType FloatVec2;
    public static UniformType FloatVec3;
    public static UniformType FloatVec4;
    public static UniformType IntVec2;
    public static UniformType IntVec3;
    public static UniformType IntVec4;
    public static UniformType Bool;
    public static UniformType BoolVec2;
    public static UniformType BoolVec3;
    public static UniformType BoolVec4;
    public static UniformType FloatMat2;
    public static UniformType FloatMat3;
    public static UniformType FloatMat4;
    public static UniformType Sampler1D;
    public static UniformType Sampler2D;
    public static UniformType Sampler3D;
    public static UniformType SamplerCube;
    public static UniformType Sampler1DShadow;
    public static UniformType Sampler2DShadow;
    public static UniformType Sampler2DRect;
    public static UniformType Sampler2DRectShadow;
    public static UniformType FloatMat2x3;
    public static UniformType FloatMat2x4;
    public static UniformType FloatMat3x2;
    public static UniformType FloatMat3x4;
    public static UniformType FloatMat4x2;
    public static UniformType FloatMat4x3;
    public static UniformType Sampler1DArray;
    public static UniformType Sampler2DArray;
    public static UniformType SamplerBuffer;
    public static UniformType Sampler1DArrayShadow;
    public static UniformType Sampler2DArrayShadow;
    public static UniformType SamplerCubeShadow;
    public static UniformType UnsignedIntVec2;
    public static UniformType UnsignedIntVec3;
    public static UniformType UnsignedIntVec4;
    public static UniformType IntSampler1D;
    public static UniformType IntSampler2D;
    public static UniformType IntSampler3D;
    public static UniformType IntSamplerCube;
    public static UniformType IntSampler2DRect;
    public static UniformType IntSampler1DArray;
    public static UniformType IntSampler2DArray;
    public static UniformType IntSamplerBuffer;
    public static UniformType UnsignedIntSampler1D;
    public static UniformType UnsignedIntSampler2D;
    public static UniformType UnsignedIntSampler3D;
    public static UniformType UnsignedIntSamplerCube;
    public static UniformType UnsignedIntSampler2DRect;
    public static UniformType UnsignedIntSampler1DArray;
    public static UniformType UnsignedIntSampler2DArray;
    public static UniformType UnsignedIntSamplerBuffer;
    public static UniformType DoubleMat2;
    public static UniformType DoubleMat3;
    public static UniformType DoubleMat4;
    public static UniformType DoubleMat2x3;
    public static UniformType DoubleMat2x4;
    public static UniformType DoubleMat3x2;
    public static UniformType DoubleMat3x4;
    public static UniformType DoubleMat4x2;
    public static UniformType DoubleMat4x3;
    public static UniformType DoubleVec2;
    public static UniformType DoubleVec3;
    public static UniformType DoubleVec4;
    public static UniformType SamplerCubeMapArray;
    public static UniformType SamplerCubeMapArrayShadow;
    public static UniformType IntSamplerCubeMapArray;
    public static UniformType UnsignedIntSamplerCubeMapArray;
    public static UniformType Sampler2DMultisample;
    public static UniformType IntSampler2DMultisample;
    public static UniformType UnsignedIntSampler2DMultisample;
    public static UniformType Sampler2DMultisampleArray;
    public static UniformType IntSampler2DMultisampleArray;
    public static UniformType UnsignedIntSampler2DMultisampleArray;
}
[ExtensionAttribute]
public static class TrippyGL.Utils.TrippyMath : object {
    public static float PiOver2;
    public static float PiOver4;
    public static float ThreePiOver2;
    public static float TwoPI;
    public static float Lerp(float min, float max, float amount);
    public static float LerpPrecise(float min, float max, float amount);
    public static float SmoothStep(float min, float max, float amount);
    public static float SmoothStepPrecise(float min, float max, float amount);
    public static float SmootherStep(float min, float max, float amount);
    public static float SmootherStepPrecise(float min, float max, float amount);
    public static int GetNextCapacity(int currentCapacity, int requiredCapacity);
    public static int IntegerPow(int value, int exponent);
    [ExtensionAttribute]
public static Vector2 RandomDirection2(Random random);
    [ExtensionAttribute]
public static Vector2 RandomDirection2(Random random, float length);
    [ExtensionAttribute]
public static Vector3 RandomDirection3(Random random);
    [ExtensionAttribute]
public static Vector3 RandomDirection3(Random random, float length);
    [ExtensionAttribute]
public static float NextFloat(Random random);
    [ExtensionAttribute]
public static float NextFloat(Random random, float max);
    [ExtensionAttribute]
public static float NextFloat(Random random, float min, float max);
    [ExtensionAttribute]
public static double NextDouble(Random random, double max);
    [ExtensionAttribute]
public static double NextDouble(Random random, double min, double max);
    [ExtensionAttribute]
public static bool NextBool(Random random);
    [ExtensionAttribute]
public static Color4b NextColor4b(Random random);
    [ExtensionAttribute]
public static Color4b NextColor4bFullAlpha(Random random);
}
public static class TrippyGL.Utils.TrippyUtils : object {
    public static bool IsVertexAttribIntegerType(AttributeBaseType dataBaseType);
    public static bool IsVertexAttribIntegerType(AttributeType attribType);
    public static bool IsVertexAttribFloatType(AttributeType attribType);
    public static bool IsVertexAttribDoubleType(AttributeType attribType);
    public static void GetVertexAttribTypeData(AttributeType attribType, UInt32& indexUseCount, Int32& size, AttributeBaseType& type);
    public static AttributeBaseType GetVertexAttribBaseType(AttributeType attribType);
    public static int GetVertexAttribTypeSize(AttributeType attribType);
    public static UInt32 GetVertexAttribTypeIndexCount(AttributeType attribType);
    public static UInt32 GetVertexAttribSizeInBytes(AttributeBaseType type);
    public static bool IsDepthStencilFormatDepthOnly(DepthStencilFormat format);
    public static bool IsDepthStencilFormatDepthAndStencil(DepthStencilFormat format);
    public static bool IsDepthStencilFormatStencilOnly(DepthStencilFormat format);
    public static bool IsUniformSamplerType(UniformType type);
    public static bool IsUniformSampler2DType(UniformType type);
    public static void GetTextureFormatEnums(TextureImageFormat imageFormat, InternalFormat& pixelInternalFormat, PixelType& pixelType, PixelFormat& pixelFormat);
    public static PixelFormat GetDefaultGetDataFormat(TextureImageFormat format);
    public static bool IsTextureTypeMipmappable(TextureType textureType);
    public static bool IsImageFormatIntegerType(TextureImageFormat imageFormat);
    public static bool IsImageFormatDepthOnly(TextureImageFormat imageFormat);
    public static bool IsImageFormatStencilOnly(TextureImageFormat imageFormat);
    public static bool IsImageFormatDepthStencil(TextureImageFormat imageFormat);
    public static bool IsImageFormatColorRenderable(TextureImageFormat imageFormat);
    public static bool IsFramebufferAttachmentPointColor(FramebufferAttachmentPoint attachment);
    public static bool IsRenderbufferFormatDepthOnly(RenderbufferFormat format);
    public static bool IsRenderbufferFormatStencilOnly(RenderbufferFormat format);
    public static bool IsRenderbufferFormatDepthStencil(RenderbufferFormat format);
    public static bool IsRenderbufferFormatColorRenderable(RenderbufferFormat format);
    public static FramebufferAttachmentPoint GetCorrespondingTextureFramebufferAttachmentPoint(TextureImageFormat format);
    public static FramebufferAttachmentPoint GetCorrespondingRenderbufferFramebufferAttachmentPoint(RenderbufferFormat format);
    public static TextureImageFormat DepthStencilFormatToTextureFormat(DepthStencilFormat depthStencilFormat);
}
public class TrippyGL.VertexArray : GraphicsResource {
    public UInt32 Handle;
    private VertexAttribSource[] attribSources;
    public IndexBufferSubset IndexBuffer;
    public ReadOnlySpan`1<VertexAttribSource> AttribSources { get; }
    internal VertexArray(GraphicsDevice graphicsDevice, VertexAttribSource[] attribSources, IndexBufferSubset indexBuffer, bool compensateStructPadding, UInt32 paddingPackValue);
    public VertexArray(GraphicsDevice graphicsDevice, ReadOnlySpan`1<VertexAttribSource> attribSources, IndexBufferSubset indexBuffer, bool compensateStructPadding, UInt32 paddingPackValue);
    public VertexArray(GraphicsDevice graphicsDevice, DataBufferSubset bufferSubset, ReadOnlySpan`1<VertexAttribDescription> attribDescriptions, IndexBufferSubset indexBuffer, bool compensateStructPadding, UInt32 paddingPackValue);
    public ReadOnlySpan`1<VertexAttribSource> get_AttribSources();
    public void UpdateVertexAttributes(bool compensateStructPadding, UInt32 paddingPackValue);
    protected virtual void Dispose(bool isManualDispose);
    public virtual string ToString();
    private static VertexAttribSource[] MakeAttribList(DataBufferSubset bufferSubset, ReadOnlySpan`1<VertexAttribDescription> attribDescriptions);
    public static VertexArray CreateSingleBuffer(GraphicsDevice graphicsDevice, DataBufferSubset dataBuffer, IndexBufferSubset indexBuffer, bool compensateStructPadding, UInt32 paddingPackValue);
    private void EnsureAttribsValid(VertexAttribSource[] attribSources);
}
[IsReadOnlyAttribute]
public class TrippyGL.VertexAttribDescription : ValueType {
    public int Size;
    public AttributeBaseType AttribBaseType;
    public UInt32 SizeInBytes;
    public bool Normalized;
    public UInt32 AttribIndicesUseCount;
    public AttributeType AttribType;
    public UInt32 AttribDivisor;
    public bool IsPadding { get; }
    public VertexAttribDescription(AttributeType attribType, UInt32 attribDivisor);
    public VertexAttribDescription(AttributeType attribType, bool normalized, AttributeBaseType dataBaseType, UInt32 attribDivisor);
    public VertexAttribDescription(UInt32 paddingBytes);
    public bool get_IsPadding();
    public static bool op_Equality(VertexAttribDescription left, VertexAttribDescription right);
    public static bool op_Inequality(VertexAttribDescription left, VertexAttribDescription right);
    public virtual string ToString();
    public static VertexAttribDescription CreatePadding(AttributeBaseType baseType, UInt32 size);
    public static VertexAttribDescription CreatePadding(AttributeType attribType);
    private static void ValidateAttribDivisor(UInt32 attribDivisor);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexAttribDescription other);
    public virtual bool Equals(object obj);
}
[IsReadOnlyAttribute]
public class TrippyGL.VertexAttribSource : ValueType {
    public DataBufferSubset BufferSubset;
    public VertexAttribDescription AttribDescription;
    public bool IsPadding { get; }
    public VertexAttribSource(DataBufferSubset bufferSubset, VertexAttribDescription attribDesc);
    public VertexAttribSource(DataBufferSubset bufferSubset, AttributeType attribType, UInt32 attribDivisor);
    public VertexAttribSource(DataBufferSubset bufferSubset, AttributeType attribType, bool normalized, AttributeBaseType dataBaseType, UInt32 attribDivisor);
    public VertexAttribSource(DataBufferSubset bufferSubset, UInt32 paddingBytes);
    public bool get_IsPadding();
    public static bool op_Equality(VertexAttribSource left, VertexAttribSource right);
    public static bool op_Inequality(VertexAttribSource left, VertexAttribSource right);
    public virtual string ToString();
    public static VertexAttribSource CreatePadding(DataBufferSubset bufferSubset, AttributeBaseType baseType, UInt32 size);
    public static VertexAttribSource CreatePadding(DataBufferSubset bufferSubset, AttributeType attribType);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VertexAttribSource other);
}
[IsReadOnlyAttribute]
public class TrippyGL.VertexBuffer`1 : ValueType {
    public BufferObject Buffer;
    public VertexDataBufferSubset`1<T> DataSubset;
    public VertexArray VertexArray;
    public UInt32 ElementSize;
    public bool IsEmpty { get; }
    public IndexBufferSubset IndexSubset { get; }
    public UInt32 StorageLength { get; }
    public UInt32 IndexStorageLength { get; }
    public bool IsDisposed { get; }
    public VertexBuffer`1(GraphicsDevice graphicsDevice, UInt32 storageLength, UInt32 indexStorageLength, ElementType indexElementType, BufferUsage usageHint);
    public VertexBuffer`1(GraphicsDevice graphicsDevice, UInt32 storageLength, UInt32 indexStorageLength, ElementType indexElementType, BufferUsage usageHint, ReadOnlySpan`1<T> data, UInt32 dataWriteOffset);
    public VertexBuffer`1(GraphicsDevice graphicsDevice, UInt32 storageLength, BufferUsage usageHint, ReadOnlySpan`1<T> data, UInt32 dataWriteOffset);
    public VertexBuffer`1(GraphicsDevice graphicsDevice, ReadOnlySpan`1<T> data, BufferUsage usageHint);
    public VertexBuffer`1(GraphicsDevice graphicsDevice, UInt32 storageLength, BufferUsage usageHint);
    public bool get_IsEmpty();
    public IndexBufferSubset get_IndexSubset();
    public UInt32 get_StorageLength();
    public UInt32 get_IndexStorageLength();
    public bool get_IsDisposed();
    public static VertexArray op_Implicit(VertexBuffer`1<T> vertexBuffer);
    public static bool op_Equality(VertexBuffer`1<T> left, VertexBuffer`1<T> right);
    public static bool op_Inequality(VertexBuffer`1<T> left, VertexBuffer`1<T> right);
    public void RecreateStorage(UInt32 storageLength, UInt32 indexStorageLength, BufferUsage usageHint);
    public void RecreateStorage(UInt32 storageLength, BufferUsage usageHint);
    public sealed virtual void Dispose();
    public virtual string ToString();
    private static void ValidateStorageLength(UInt32 storageLength);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexBuffer`1<T> other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexColor : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public Color4b Color;
    public int AttribDescriptionCount { get; }
    public VertexColor(Vector3 position, Color4b color);
    public VertexColor(Vector3 position);
    public static bool op_Equality(VertexColor left, VertexColor right);
    public static bool op_Inequality(VertexColor left, VertexColor right);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexColor other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexColorTexture : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public Color4b Color;
    public Vector2 TexCoords;
    public int AttribDescriptionCount { get; }
    public VertexColorTexture(Vector3 position, Color4b color, Vector2 texCoords);
    public VertexColorTexture(Vector3 position, Vector2 texCoords);
    public static bool op_Equality(VertexColorTexture left, VertexColorTexture right);
    public static bool op_Inequality(VertexColorTexture left, VertexColorTexture right);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexColorTexture other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexDataBufferSubset`1 : DataBufferSubset`1<T> {
    public VertexDataBufferSubset`1(BufferObject bufferObject, UInt32 storageOffsetBytes, UInt32 storageLength, ReadOnlySpan`1<T> data, UInt32 dataWriteOffset);
    public VertexDataBufferSubset`1(BufferObject bufferObject, ReadOnlySpan`1<T> data, UInt32 dataWriteOffset);
}
public class TrippyGL.VertexNormal : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public Vector3 Normal;
    public int AttribDescriptionCount { get; }
    public VertexNormal(Vector3 position, Vector3 normal);
    public static bool op_Equality(VertexNormal left, VertexNormal right);
    public static bool op_Inequality(VertexNormal left, VertexNormal right);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexNormal other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexNormalColor : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public Vector3 Normal;
    public Color4b Color;
    public int AttribDescriptionCount { get; }
    public VertexNormalColor(Vector3 position, Vector3 normal, Color4b color);
    public static bool op_Equality(VertexNormalColor left, VertexNormalColor right);
    public static bool op_Inequality(VertexNormalColor left, VertexNormalColor right);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexNormalColor other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexNormalColorTexture : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public Vector3 Normal;
    public Color4b Color;
    public Vector2 TexCoords;
    public int AttribDescriptionCount { get; }
    public VertexNormalColorTexture(Vector3 position, Vector3 normal, Color4b color, Vector2 texCoords);
    public static bool op_Equality(VertexNormalColorTexture left, VertexNormalColorTexture right);
    public static bool op_Inequality(VertexNormalColorTexture left, VertexNormalColorTexture right);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexNormalColorTexture other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexNormalTexture : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public Vector3 Normal;
    public Vector2 TexCoords;
    public int AttribDescriptionCount { get; }
    public VertexNormalTexture(Vector3 position, Vector3 normal, Vector2 texCoords);
    public static bool op_Equality(VertexNormalTexture left, VertexNormalTexture right);
    public static bool op_Inequality(VertexNormalTexture left, VertexNormalTexture right);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexNormalTexture other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexPosition : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public int AttribDescriptionCount { get; }
    public VertexPosition(Vector3 position);
    public VertexPosition(float x, float y, float z);
    public static bool op_Equality(VertexPosition left, VertexPosition right);
    public static bool op_Inequality(VertexPosition left, VertexPosition right);
    public static Vector3 op_Implicit(VertexPosition vertexPosition);
    public static VertexPosition op_Implicit(Vector3 position);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexPosition other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.VertexTexture : ValueType {
    public static int SizeInBytes;
    public Vector3 Position;
    public Vector2 TexCoords;
    public int AttribDescriptionCount { get; }
    public VertexTexture(Vector3 position, Vector2 texCoords);
    public static bool op_Equality(VertexTexture left, VertexTexture right);
    public static bool op_Inequality(VertexTexture left, VertexTexture right);
    public sealed virtual int get_AttribDescriptionCount();
    public sealed virtual void WriteAttribDescriptions(Span`1<VertexAttribDescription> descriptions);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VertexTexture other);
    public virtual bool Equals(object obj);
}
public class TrippyGL.Viewport : ValueType {
    public int X;
    public int Y;
    public UInt32 Width;
    public UInt32 Height;
    public int Right { get; public set; }
    public int Bottom { get; public set; }
    public Viewport(int x, int y, UInt32 width, UInt32 height);
    public Viewport(Rectangle& rectangle);
    public Viewport(Point position, Size size);
    public int get_Right();
    public void set_Right(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public static bool op_Equality(Viewport left, Viewport right);
    public static bool op_Inequality(Viewport left, Viewport right);
    public static Rectangle op_Implicit(Viewport viewport);
    public static Viewport op_Implicit(Rectangle rectangle);
    public bool Contains(Viewport& other);
    public bool Intersects(Viewport& other);
    public Viewport Intersection(Viewport& other);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Viewport other);
    public virtual bool Equals(object obj);
}
