[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal enum Microsoft.CodeCoverage.Core.ClientErrorCode : Enum {
    public int value__;
    public static ClientErrorCode Error;
    public static ClientErrorCode Timeout;
    public static ClientErrorCode LockTimeout;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.ClientErrorException : Exception {
    [CompilerGeneratedAttribute]
private UInt32 <ErrorCode>k__BackingField;
    public UInt32 ErrorCode { get; }
    public ClientErrorException(string message, UInt32 errorCode);
    public ClientErrorException(string message);
    public ClientErrorException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public UInt32 get_ErrorCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.CollectionHandle`1 : object {
    private T _collection;
    private CollectionLock`1<T> _collectionLock;
    internal CollectionHandle`1(CollectionLock`1<T> collectionLock);
    internal T Get();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.CollectionLock`1 : object {
    private Lazy`1<T> _collection;
    private Action`1<T> _releaseAction;
    private int _lock;
    internal CollectionLock`1(Func`1<T> generateAction, Action`1<T> releaseAction);
    internal T Acquire();
    internal void Release();
}
internal class Microsoft.CodeCoverage.Core.Collections.BoundedSet : object {
    [NullableAttribute("1")]
private Boolean[] _blocksArray;
    [NullableAttribute("1")]
private IList`1<UInt32> _blocksList;
    public BoundedSet(int size);
    public sealed virtual void Add(UInt32 blockIndex);
    public sealed virtual bool Contains(UInt32 blockIndex);
    public sealed virtual void Clear();
}
internal class Microsoft.CodeCoverage.Core.Collections.DefaultBoundedSet : object {
    [NullableAttribute("1")]
private HashSet`1<UInt32> _set;
    public sealed virtual void Add(UInt32 blockIndex);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(UInt32 blockIndex);
}
internal interface Microsoft.CodeCoverage.Core.Collections.IBoundedSet {
    public abstract virtual void Add(UInt32 blockIndex);
    public abstract virtual bool Contains(UInt32 blockIndex);
    public abstract virtual void Clear();
}
internal enum Microsoft.CodeCoverage.Core.Configurations.AssemblySearchType : Enum {
    public int value__;
    public static AssemblySearchType NotSpecified;
    public static AssemblySearchType MissingAny;
    public static AssemblySearchType MissingAll;
    public static AssemblySearchType None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.AttributeList : CachingExcludeIncludeList {
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    [NullableContextAttribute("2")]
public AttributeList(XElement element);
    protected virtual string get_ElementName();
    protected virtual bool get_IgnoreCase();
    protected virtual bool get_IgnorePathSeparator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Core.Configurations.CachingExcludeIncludeList : ExcludeIncludeList {
    private ConcurrentDictionary`2<string, bool> _includedResults;
    [NullableContextAttribute("2")]
public CachingExcludeIncludeList(XElement element);
    private void Included_CollectionChanged(object _, NotifyCollectionChangedEventArgs e);
    private void Excluded_CollectionChanged(object _, NotifyCollectionChangedEventArgs e);
    public virtual bool IsIncluded(string input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.CodeCoverageConfig : object {
    private static string RootElementName;
    private static string SkipNativeInstrumentationElementName;
    private static string UserElementName;
    private static string PathElementName;
    internal static UInt32 CommunicationTimeoutDefault;
    internal static UInt32 CacheCleaningTimeoutDefault;
    internal static UInt32 PipeClientsCountDefault;
    internal static UInt32 CacheExpirationTimeDefault;
    internal static UInt32 CacheExternalExpirationTimeDefault;
    internal static bool CollectFromChildProcessesDefault;
    internal static bool AllowLowIntegrityProcessesDefault;
    internal static bool ExcludeCompilerAutoGeneratedModulesDefault;
    internal static bool SymbolsRestrictOriginalPathAccessDefault;
    internal static bool SymbolsRestrictReferencePathAccessDefault;
    internal static bool SymbolsRestrictDBGAccessDefault;
    internal static bool SymbolsRestrictSystemRootAccessDefault;
    internal static bool EnableDynamicNativeInstrumentationDefault;
    internal static bool EnableStaticNativeInstrumentationRestoreDefault;
    internal static bool EnableDynamicManagedInstrumentationDefault;
    internal static bool EnableStaticManagedInstrumentationRestoreDefault;
    internal static bool EnableStaticManagedInstrumentationSafeInitializationDefault;
    internal static bool SkipNativeCacheInstrumentationDefault;
    internal static bool AllowAddressesOutsideOfImageDefault;
    internal static bool DumpStaticNativeDisassemblyDefault;
    internal static bool StaticNativeInstrumentationWriteFastDefault;
    internal static bool SelfMergeReportDefault;
    [CompilerGeneratedAttribute]
private bool <SplitCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CommunicationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CacheCleaningTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CacheExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CacheExternalExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CachePath>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PipeClientsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectFromChildProcesses>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseVerifiableInstrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLowIntegrityProcesses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SymbolsRestrictOriginalPathAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SymbolsRestrictReferencePathAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SymbolsRestrictDBGAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SymbolsRestrictSystemRootAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeCompilerAutoGeneratedModules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDynamicManagedInstrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableStaticManagedInstrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableStaticManagedInstrumentationRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableStaticManagedInstrumentationSafeInitialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDynamicNativeInstrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableStaticNativeInstrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableStaticNativeInstrumentationRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipNativeCacheInstrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAddressesOutsideOfImage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollectAspDotNet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DumpStaticNativeDisassembly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StaticNativeInstrumentationWriteFast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SelfMergeReport>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AllowedUsers>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SymbolSearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private EntryPointList <EntryPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleList <ModulePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKeyTokenList <PublicKeyTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private CompanyNameList <CompanyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeList <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceList <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionList <Functions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileLogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticNativeInstrumentationOpenFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticNativeInstrumentationWriteFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    public bool SplitCoverage { get; public set; }
    public UInt32 CommunicationTimeout { get; public set; }
    public UInt32 CacheCleaningTimeout { get; public set; }
    public UInt32 CacheExpirationTime { get; public set; }
    public UInt32 CacheExternalExpirationTime { get; public set; }
    public string CachePath { get; public set; }
    public UInt32 PipeClientsCount { get; public set; }
    public bool CollectFromChildProcesses { get; public set; }
    public Nullable`1<bool> UseVerifiableInstrumentation { get; public set; }
    public bool AllowLowIntegrityProcesses { get; public set; }
    public bool SymbolsRestrictOriginalPathAccess { get; public set; }
    public bool SymbolsRestrictReferencePathAccess { get; public set; }
    public bool SymbolsRestrictDBGAccess { get; public set; }
    public bool SymbolsRestrictSystemRootAccess { get; public set; }
    public bool ExcludeCompilerAutoGeneratedModules { get; public set; }
    public bool EnableDynamicManagedInstrumentation { get; public set; }
    public Nullable`1<bool> EnableStaticManagedInstrumentation { get; public set; }
    public bool EnableStaticManagedInstrumentationRestore { get; public set; }
    public bool EnableStaticManagedInstrumentationSafeInitialization { get; public set; }
    public bool EnableDynamicNativeInstrumentation { get; public set; }
    public Nullable`1<bool> EnableStaticNativeInstrumentation { get; public set; }
    public bool EnableStaticNativeInstrumentationRestore { get; public set; }
    public bool SkipNativeCacheInstrumentation { get; public set; }
    public bool AllowAddressesOutsideOfImage { get; public set; }
    public bool CollectAspDotNet { get; public set; }
    public bool DumpStaticNativeDisassembly { get; public set; }
    public bool StaticNativeInstrumentationWriteFast { get; public set; }
    public bool SelfMergeReport { get; public set; }
    public List`1<string> AllowedUsers { get; public set; }
    public String[] SymbolSearchPaths { get; public set; }
    public EntryPointList EntryPoints { get; public set; }
    public ModuleList ModulePaths { get; public set; }
    public PublicKeyTokenList PublicKeyTokens { get; public set; }
    public CompanyNameList CompanyNames { get; public set; }
    public AttributeList Attributes { get; public set; }
    public SourceList Sources { get; public set; }
    public FunctionList Functions { get; public set; }
    public string FileLogPath { get; public set; }
    public string LogLevel { get; public set; }
    public string StaticNativeInstrumentationOpenFlags { get; public set; }
    public string StaticNativeInstrumentationWriteFlags { get; public set; }
    public string CorrelationId { get; public set; }
    [NullableContextAttribute("2")]
internal CodeCoverageConfig(XElement element);
    internal XElement Serialize();
    [CompilerGeneratedAttribute]
public bool get_SplitCoverage();
    [CompilerGeneratedAttribute]
public void set_SplitCoverage(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_CommunicationTimeout();
    [CompilerGeneratedAttribute]
public void set_CommunicationTimeout(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_CacheCleaningTimeout();
    [CompilerGeneratedAttribute]
public void set_CacheCleaningTimeout(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_CacheExpirationTime();
    [CompilerGeneratedAttribute]
public void set_CacheExpirationTime(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_CacheExternalExpirationTime();
    [CompilerGeneratedAttribute]
public void set_CacheExternalExpirationTime(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_CachePath();
    [CompilerGeneratedAttribute]
public void set_CachePath(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_PipeClientsCount();
    [CompilerGeneratedAttribute]
public void set_PipeClientsCount(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_CollectFromChildProcesses();
    [CompilerGeneratedAttribute]
public void set_CollectFromChildProcesses(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseVerifiableInstrumentation();
    [CompilerGeneratedAttribute]
public void set_UseVerifiableInstrumentation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_AllowLowIntegrityProcesses();
    [CompilerGeneratedAttribute]
public void set_AllowLowIntegrityProcesses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SymbolsRestrictOriginalPathAccess();
    [CompilerGeneratedAttribute]
public void set_SymbolsRestrictOriginalPathAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_SymbolsRestrictReferencePathAccess();
    [CompilerGeneratedAttribute]
public void set_SymbolsRestrictReferencePathAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_SymbolsRestrictDBGAccess();
    [CompilerGeneratedAttribute]
public void set_SymbolsRestrictDBGAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_SymbolsRestrictSystemRootAccess();
    [CompilerGeneratedAttribute]
public void set_SymbolsRestrictSystemRootAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeCompilerAutoGeneratedModules();
    [CompilerGeneratedAttribute]
public void set_ExcludeCompilerAutoGeneratedModules(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableDynamicManagedInstrumentation();
    [CompilerGeneratedAttribute]
public void set_EnableDynamicManagedInstrumentation(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableStaticManagedInstrumentation();
    [CompilerGeneratedAttribute]
public void set_EnableStaticManagedInstrumentation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_EnableStaticManagedInstrumentationRestore();
    [CompilerGeneratedAttribute]
public void set_EnableStaticManagedInstrumentationRestore(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableStaticManagedInstrumentationSafeInitialization();
    [CompilerGeneratedAttribute]
public void set_EnableStaticManagedInstrumentationSafeInitialization(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableDynamicNativeInstrumentation();
    [CompilerGeneratedAttribute]
public void set_EnableDynamicNativeInstrumentation(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableStaticNativeInstrumentation();
    [CompilerGeneratedAttribute]
public void set_EnableStaticNativeInstrumentation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_EnableStaticNativeInstrumentationRestore();
    [CompilerGeneratedAttribute]
public void set_EnableStaticNativeInstrumentationRestore(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipNativeCacheInstrumentation();
    [CompilerGeneratedAttribute]
public void set_SkipNativeCacheInstrumentation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAddressesOutsideOfImage();
    [CompilerGeneratedAttribute]
public void set_AllowAddressesOutsideOfImage(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollectAspDotNet();
    [CompilerGeneratedAttribute]
public void set_CollectAspDotNet(bool value);
    [CompilerGeneratedAttribute]
public bool get_DumpStaticNativeDisassembly();
    [CompilerGeneratedAttribute]
public void set_DumpStaticNativeDisassembly(bool value);
    [CompilerGeneratedAttribute]
public bool get_StaticNativeInstrumentationWriteFast();
    [CompilerGeneratedAttribute]
public void set_StaticNativeInstrumentationWriteFast(bool value);
    [CompilerGeneratedAttribute]
public bool get_SelfMergeReport();
    [CompilerGeneratedAttribute]
public void set_SelfMergeReport(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_AllowedUsers();
    [CompilerGeneratedAttribute]
public void set_AllowedUsers(List`1<string> value);
    [CompilerGeneratedAttribute]
public String[] get_SymbolSearchPaths();
    [CompilerGeneratedAttribute]
public void set_SymbolSearchPaths(String[] value);
    [CompilerGeneratedAttribute]
public EntryPointList get_EntryPoints();
    [CompilerGeneratedAttribute]
public void set_EntryPoints(EntryPointList value);
    [CompilerGeneratedAttribute]
public ModuleList get_ModulePaths();
    [CompilerGeneratedAttribute]
public void set_ModulePaths(ModuleList value);
    [CompilerGeneratedAttribute]
public PublicKeyTokenList get_PublicKeyTokens();
    [CompilerGeneratedAttribute]
public void set_PublicKeyTokens(PublicKeyTokenList value);
    [CompilerGeneratedAttribute]
public CompanyNameList get_CompanyNames();
    [CompilerGeneratedAttribute]
public void set_CompanyNames(CompanyNameList value);
    [CompilerGeneratedAttribute]
public AttributeList get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(AttributeList value);
    [CompilerGeneratedAttribute]
public SourceList get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(SourceList value);
    [CompilerGeneratedAttribute]
public FunctionList get_Functions();
    [CompilerGeneratedAttribute]
public void set_Functions(FunctionList value);
    [CompilerGeneratedAttribute]
public string get_FileLogPath();
    [CompilerGeneratedAttribute]
public void set_FileLogPath(string value);
    [CompilerGeneratedAttribute]
public string get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(string value);
    [CompilerGeneratedAttribute]
public string get_StaticNativeInstrumentationOpenFlags();
    [CompilerGeneratedAttribute]
public void set_StaticNativeInstrumentationOpenFlags(string value);
    [CompilerGeneratedAttribute]
public string get_StaticNativeInstrumentationWriteFlags();
    [CompilerGeneratedAttribute]
public void set_StaticNativeInstrumentationWriteFlags(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.CodeCoverageRunSettingsProcessor : object {
    private DataCollectorConfiguration _defaultConfiguration;
    private ILogger _logger;
    public CodeCoverageRunSettingsProcessor(DataCollectorConfiguration defaultConfiguration, ILogger logger);
    public void Process(DataCollectorConfiguration configuration);
    private void Merge(ExcludeIncludeList list, ExcludeIncludeList defaultList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.CompanyNameList : CachingExcludeIncludeList {
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    [NullableContextAttribute("2")]
public CompanyNameList(XElement element);
    protected virtual string get_ElementName();
    protected virtual bool get_IgnoreCase();
    protected virtual bool get_IgnorePathSeparator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.Configurations.ConfigurationFileUtility : object {
    public static void ApplyDefaults(DataCollectorConfiguration configuration, ILogger logger);
    public static string GetXmlString(CodeCoverageConfig source);
    public static CodeCoverageConfig GetCodeCoverageConfig(string source);
    public static DataCollectorConfiguration GetConfiguration(FileInfo fileInfo, ILogger logger);
    public static DataCollectorConfiguration GetConfiguration(FileInfo fileInfo, ILogger logger, IEnvironment environment);
    public static DataCollectorConfiguration GetConfiguration(XmlElement configurationElement, ILogger logger);
    public static bool TryReadDataCollectorConfiguration(XDocument document, DataCollectorConfiguration& configuration);
    public static DataCollectorConfiguration GetConfiguration(XDocument configurationDocument, ILogger logger, IEnvironment environment);
    public static void ExcludeSourcesIfNeeded(DataCollectorConfiguration configuration, IEnumerable`1<string> sources);
    private static DataCollectorConfiguration GetDefaultConfiguration();
    public static void InjectEnvironmentVariables(DataCollectorConfiguration dataCollectorConfiguration, IEnvironment environment);
    private static void InjectEnvironmentVariable(ModuleList moduleList, IEnvironment environment);
    private static void InjectEnvironmentVariable(ExcludeIncludeList excludeIncludeList, IEnvironment environment);
    private static string ExpandEnvironmentVariables(string name, IEnvironment environment);
    private static void ApplyDefaults(DataCollectorConfiguration configuration, DataCollectorConfiguration defaultConfiguration, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.DataCollectionRunSettings : object {
    [CompilerGeneratedAttribute]
private DataCollectorSettings[] <DataCollectors>k__BackingField;
    public DataCollectorSettings[] DataCollectors { get; public set; }
    [NullableContextAttribute("2")]
public DataCollectionRunSettings(XElement element);
    public XElement Serialize();
    [CompilerGeneratedAttribute]
public DataCollectorSettings[] get_DataCollectors();
    [CompilerGeneratedAttribute]
public void set_DataCollectors(DataCollectorSettings[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.DataCollectorConfiguration : object {
    private static string RootElementName;
    internal static bool SplitCoverageDefault;
    internal static string FormatDefault;
    internal static string DefaultMergeStrategy;
    [CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SplitCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CoverageLogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstrumentationLogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CoverageFileLogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagedVanguardLogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CoverageFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCoverageConfig <CodeCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VanguardInstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CLRIEX86InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CLRIEX64InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CLRIEARM64InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticNativeInstrumenterX86InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticNativeInstrumenterX64InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticNativeRuntimeX86InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticNativeRuntimeX64InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StaticNativeRuntimeARM64InstallDir>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TelemetryEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PerTestCodeCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsertProbeIfCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IncludeTestAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergeStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblySearchType <ExcludeAssembliesWithoutSources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeterministicReport>k__BackingField;
    [CompilerGeneratedAttribute]
private DoesNotReturnAttributeScope <DoesNotReturnAttribute>k__BackingField;
    public string Framework { get; public set; }
    public bool SplitCoverage { get; public set; }
    public string CoverageLogLevel { get; public set; }
    public string InstrumentationLogLevel { get; public set; }
    public string CoverageFileLogPath { get; public set; }
    public string ManagedVanguardLogLevel { get; public set; }
    public string CoverageFileName { get; public set; }
    public string Format { get; public set; }
    public CodeCoverageConfig CodeCoverage { get; public set; }
    public string VanguardInstallDir { get; public set; }
    public string CLRIEX86InstallDir { get; public set; }
    public string CLRIEX64InstallDir { get; public set; }
    public string CLRIEARM64InstallDir { get; public set; }
    public string StaticNativeInstrumenterX86InstallDir { get; public set; }
    public string StaticNativeInstrumenterX64InstallDir { get; public set; }
    public string StaticNativeRuntimeX86InstallDir { get; public set; }
    public string StaticNativeRuntimeX64InstallDir { get; public set; }
    public string StaticNativeRuntimeARM64InstallDir { get; public set; }
    public bool TelemetryEnabled { get; public set; }
    public bool PerTestCodeCoverage { get; public set; }
    public bool InsertProbeIfCovered { get; public set; }
    public Nullable`1<bool> IncludeTestAssembly { get; public set; }
    public string MergeStrategy { get; public set; }
    public AssemblySearchType ExcludeAssembliesWithoutSources { get; public set; }
    public bool DeterministicReport { get; public set; }
    public DoesNotReturnAttributeScope DoesNotReturnAttribute { get; public set; }
    [NullableContextAttribute("2")]
public DataCollectorConfiguration(XElement element);
    public XElement Serialize();
    [CompilerGeneratedAttribute]
public string get_Framework();
    [CompilerGeneratedAttribute]
public void set_Framework(string value);
    [CompilerGeneratedAttribute]
public bool get_SplitCoverage();
    [CompilerGeneratedAttribute]
public void set_SplitCoverage(bool value);
    [CompilerGeneratedAttribute]
public string get_CoverageLogLevel();
    [CompilerGeneratedAttribute]
public void set_CoverageLogLevel(string value);
    [CompilerGeneratedAttribute]
public string get_InstrumentationLogLevel();
    [CompilerGeneratedAttribute]
public void set_InstrumentationLogLevel(string value);
    [CompilerGeneratedAttribute]
public string get_CoverageFileLogPath();
    [CompilerGeneratedAttribute]
public void set_CoverageFileLogPath(string value);
    [CompilerGeneratedAttribute]
public string get_ManagedVanguardLogLevel();
    [CompilerGeneratedAttribute]
public void set_ManagedVanguardLogLevel(string value);
    [CompilerGeneratedAttribute]
public string get_CoverageFileName();
    [CompilerGeneratedAttribute]
public void set_CoverageFileName(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public CodeCoverageConfig get_CodeCoverage();
    [CompilerGeneratedAttribute]
public void set_CodeCoverage(CodeCoverageConfig value);
    [CompilerGeneratedAttribute]
public string get_VanguardInstallDir();
    [CompilerGeneratedAttribute]
public void set_VanguardInstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_CLRIEX86InstallDir();
    [CompilerGeneratedAttribute]
public void set_CLRIEX86InstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_CLRIEX64InstallDir();
    [CompilerGeneratedAttribute]
public void set_CLRIEX64InstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_CLRIEARM64InstallDir();
    [CompilerGeneratedAttribute]
public void set_CLRIEARM64InstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_StaticNativeInstrumenterX86InstallDir();
    [CompilerGeneratedAttribute]
public void set_StaticNativeInstrumenterX86InstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_StaticNativeInstrumenterX64InstallDir();
    [CompilerGeneratedAttribute]
public void set_StaticNativeInstrumenterX64InstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_StaticNativeRuntimeX86InstallDir();
    [CompilerGeneratedAttribute]
public void set_StaticNativeRuntimeX86InstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_StaticNativeRuntimeX64InstallDir();
    [CompilerGeneratedAttribute]
public void set_StaticNativeRuntimeX64InstallDir(string value);
    [CompilerGeneratedAttribute]
public string get_StaticNativeRuntimeARM64InstallDir();
    [CompilerGeneratedAttribute]
public void set_StaticNativeRuntimeARM64InstallDir(string value);
    [CompilerGeneratedAttribute]
public bool get_TelemetryEnabled();
    [CompilerGeneratedAttribute]
public void set_TelemetryEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_PerTestCodeCoverage();
    [CompilerGeneratedAttribute]
public void set_PerTestCodeCoverage(bool value);
    [CompilerGeneratedAttribute]
public bool get_InsertProbeIfCovered();
    [CompilerGeneratedAttribute]
public void set_InsertProbeIfCovered(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IncludeTestAssembly();
    [CompilerGeneratedAttribute]
public void set_IncludeTestAssembly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_MergeStrategy();
    [CompilerGeneratedAttribute]
public void set_MergeStrategy(string value);
    [CompilerGeneratedAttribute]
public AssemblySearchType get_ExcludeAssembliesWithoutSources();
    [CompilerGeneratedAttribute]
public void set_ExcludeAssembliesWithoutSources(AssemblySearchType value);
    [CompilerGeneratedAttribute]
public bool get_DeterministicReport();
    [CompilerGeneratedAttribute]
public void set_DeterministicReport(bool value);
    [CompilerGeneratedAttribute]
public DoesNotReturnAttributeScope get_DoesNotReturnAttribute();
    [CompilerGeneratedAttribute]
public void set_DoesNotReturnAttribute(DoesNotReturnAttributeScope value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.DataCollectorSettings : object {
    private static string RootElementName;
    private static string FriendlyNameAttributeName;
    private static string UriAttributeName;
    private static string AssemblyQualifiedNameAttributeName;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyQualifiedName>k__BackingField;
    [CompilerGeneratedAttribute]
private DataCollectorConfiguration <Configuration>k__BackingField;
    public string FriendlyName { get; public set; }
    public string Uri { get; public set; }
    public string AssemblyQualifiedName { get; public set; }
    public DataCollectorConfiguration Configuration { get; public set; }
    [NullableContextAttribute("2")]
public DataCollectorSettings(XElement element);
    public XElement Serialize();
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
public void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyQualifiedName();
    [CompilerGeneratedAttribute]
public void set_AssemblyQualifiedName(string value);
    [CompilerGeneratedAttribute]
public DataCollectorConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(DataCollectorConfiguration value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.EntryPointList : CachingExcludeIncludeList {
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    [NullableContextAttribute("2")]
public EntryPointList(XElement element);
    protected virtual string get_ElementName();
    protected virtual bool get_IgnoreCase();
    protected virtual bool get_IgnorePathSeparator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Core.Configurations.ExcludeIncludeList : object {
    private static bool MergeDefaultsDefault;
    private static string MergeDefaultsAttributeName;
    private static string IncludeElementName;
    private static string ExcludeElementName;
    private IList`1<RegularExpression> _includedExpressions;
    private IList`1<RegularExpression> _excludedExpressions;
    private bool _includeAll;
    private bool _hasInclude;
    private bool _excludeAll;
    [CompilerGeneratedAttribute]
private bool <MergeDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableCollection`1<string> <Excluded>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableCollection`1<string> <Included>k__BackingField;
    public bool MergeDefaults { get; public set; }
    public ObservableCollection`1<string> Excluded { get; public set; }
    public ObservableCollection`1<string> Included { get; public set; }
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    public bool IncludeAll { get; }
    [NullableContextAttribute("2")]
public ExcludeIncludeList(XElement element);
    [CompilerGeneratedAttribute]
public bool get_MergeDefaults();
    [CompilerGeneratedAttribute]
public void set_MergeDefaults(bool value);
    private void Included_CollectionChanged(object _, NotifyCollectionChangedEventArgs e);
    private void Excluded_CollectionChanged(object _, NotifyCollectionChangedEventArgs e);
    private void UpdateExpressionsList(NotifyCollectionChangedEventArgs e, IList`1<RegularExpression> expressions, Boolean& all);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<string> get_Excluded();
    [CompilerGeneratedAttribute]
public void set_Excluded(ObservableCollection`1<string> value);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<string> get_Included();
    [CompilerGeneratedAttribute]
public void set_Included(ObservableCollection`1<string> value);
    protected abstract virtual string get_ElementName();
    protected abstract virtual bool get_IgnoreCase();
    protected abstract virtual bool get_IgnorePathSeparator();
    public bool get_IncludeAll();
    public virtual bool IsIncluded(string input);
    public bool IsIncludedExplicitly(string input);
    private bool InternalIsIncluded(string input);
    private bool InternalIsExcluded(string input);
    private bool MatchesExpression(string input, IList`1<RegularExpression> expressions);
    internal virtual XElement Serialize();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private XElement <Serialize>b__38_0(string s);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private XElement <Serialize>b__38_1(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.FunctionList : ExcludeIncludeList {
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    [NullableContextAttribute("2")]
public FunctionList(XElement element);
    protected virtual string get_ElementName();
    protected virtual bool get_IgnoreCase();
    protected virtual bool get_IgnorePathSeparator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.IncludeDirectory : object {
    [NullableAttribute("1")]
private static string RecursiveAttributeName;
    [NullableAttribute("1")]
private static string RootElementName;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    public string Path { get; public set; }
    public bool Recursive { get; }
    internal IncludeDirectory(string path, bool recursive);
    [NullableContextAttribute("1")]
internal IncludeDirectory(XElement element);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [NullableContextAttribute("1")]
internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.ModuleList : ExcludeIncludeList {
    private static string RootElementName;
    private static string IncludeDirectoriesElementName;
    [CompilerGeneratedAttribute]
private IncludeDirectory[] <Directories>k__BackingField;
    public IncludeDirectory[] Directories { get; public set; }
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    [NullableContextAttribute("2")]
internal ModuleList(XElement element);
    [CompilerGeneratedAttribute]
public IncludeDirectory[] get_Directories();
    [CompilerGeneratedAttribute]
public void set_Directories(IncludeDirectory[] value);
    protected virtual string get_ElementName();
    protected virtual bool get_IgnoreCase();
    protected virtual bool get_IgnorePathSeparator();
    internal virtual XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.PublicKeyTokenList : CachingExcludeIncludeList {
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    [NullableContextAttribute("2")]
public PublicKeyTokenList(XElement element);
    protected virtual string get_ElementName();
    protected virtual bool get_IgnoreCase();
    protected virtual bool get_IgnorePathSeparator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.RegularExpression : SimpleExpression {
    [NullableAttribute("2")]
private Regex _regex;
    private bool _ignorePathSeparator;
    internal bool IsValid { get; }
    internal RegularExpression(string pattern, bool ignoreCase, bool ignorePathSeparator);
    internal virtual bool Match(string value);
    internal virtual bool get_IsValid();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.RunSettings : object {
    [CompilerGeneratedAttribute]
private DataCollectionRunSettings <DataCollectionRunSettings>k__BackingField;
    public DataCollectionRunSettings DataCollectionRunSettings { get; public set; }
    [NullableContextAttribute("2")]
public RunSettings(XElement element);
    public XElement Serialize();
    [CompilerGeneratedAttribute]
public DataCollectionRunSettings get_DataCollectionRunSettings();
    [CompilerGeneratedAttribute]
public void set_DataCollectionRunSettings(DataCollectionRunSettings value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.SimpleExpression : object {
    private static string AnyMatchRegex;
    private bool _isPrefix;
    private bool _isSuffix;
    [NullableAttribute("2")]
private string _pattern;
    private bool _ignorePathSeparator;
    private StringComparison _stringComparison;
    internal bool IsValid { get; }
    internal SimpleExpression(string pattern, bool ignoreCase, bool ignorePathSeparator);
    internal virtual bool Match(string value);
    internal virtual bool get_IsValid();
    protected static string TrimPrefix(string pattern);
    protected static string TrimSuffix(string pattern);
    public static string ReAddPrefix(string pattern);
    public static string ReAddSuffix(string pattern);
    private static bool IsSpecialCharacter(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Configurations.SourceList : CachingExcludeIncludeList {
    protected string ElementName { get; }
    protected bool IgnoreCase { get; }
    protected bool IgnorePathSeparator { get; }
    [NullableContextAttribute("2")]
public SourceList(XElement element);
    protected virtual string get_ElementName();
    protected virtual bool get_IgnoreCase();
    protected virtual bool get_IgnorePathSeparator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.Constants : object {
    public static int MaxRetries;
    public static ushort CurrentCodeCoverageSchemaVersion;
    public static UInt32 CodeCoverageFileHeaderMagic;
    public static UInt32 CodeCoverageStreamHeaderMagic;
    public static string GlobalCacheId;
    public static string GlobalMutexPrefixId;
    [CompilerGeneratedAttribute]
private static Guid <ModulesSkippedStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <ModuleDataStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <CoverageDataStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <PerSnapshotCoverageDataStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <SnapshotTagsDataStreamType>k__BackingField;
    public static string CoverageFileExtension;
    public static string CoverageFileBackupExtension;
    public static string ModuleCoverageFileExtension;
    public static string ModuleCoverageFileBackupExtension;
    public static string ModuleBufferFileExtension;
    public static string CoverageXmlFileExtension;
    public static string CoberturaFileExtension;
    public static string XmlFileExtension;
    public static string ExeFileExtension;
    public static string DefaultGeneratorName;
    public static string CoberturaGeneratorName;
    public static string XmlGeneratorName;
    public static string CoverageGeneratorName;
    public static string VanguardX86ProfilerConfigVariable;
    public static string VanguardX64ProfilerConfigVariable;
    public static string VanguardARM64ProfilerConfigVariable;
    public static string CoreclrProfilerPathVariable32;
    public static string CoreclrProfilerPathVariable64;
    public static string CoreclrProfilerPathVariableARM64;
    public static string CoreclrEnableProfilingVariable;
    public static string CoreclrProfilerVariable;
    public static string CorProfilerPathVariable;
    public static string CorProfilerPathVariable32;
    public static string CorProfilerPathVariable64;
    public static string CorProfilerPathVariableARM64;
    public static string CorEnableProfilingVariable;
    public static string CorProfilerVariable;
    public static string VanguardInstrumentationMethodGuid;
    public static string ClrInstrumentationEngineProfilerGuid;
    public static string CodeCoverageSessionNameVariable;
    public static string CodeCoveragePipePathVariable;
    public static string CodeCoverageDataPrefixVariable;
    public static string CodeCoverageFlagsVariable;
    public static string CodeCoveragePipeCountVariable;
    public static string PathEnvironmentVariable;
    public static string ClrIeLogLevelVariable;
    public static string ClrIeDisableCodeSignatureValidationVariable;
    public static string ClrieFileLogPathVariable;
    public static string DefaultOutputWithoutExtensions;
    public static string DefaultOutput;
    public static string LogLevelError;
    public static string LogLevelInfo;
    public static string LogLevelVerbose;
    public static string CoberturaConditionTypeSwitch;
    public static string CoberturaConditionTypeJump;
    public static int MaxTaskCount;
    internal static int MaxNumberOfServerInstances;
    internal static int InitialNumberOfServerInstances;
    internal static int MaxPipeMessageSize;
    internal static long SeventyFivePercentMaxPipeMessageSize;
    public static int DefaultTimeout;
    public static int DefaultDisconnectionTimeout;
    public static int MaxFilePathLength;
    public static string CodeCoverageFeatureFlag;
    public static string VANGUARD_DOTNETCOVERAGECONSOLE_DEBUG;
    public static string VANGUARD_CODECOVERAGECONSOLE_DEBUG;
    public static string VANGUARD_DATACOLLECTOR_DEBUG;
    public static string VanguardConfigFileName;
    public static string TestingPlatformSemVer;
    public static string TestingPlatformEnabledCommandLineOption;
    public static string TestingPlatformSettingsCommandLineOption;
    public static string TestingPlatformOutputCommandLineOption;
    public static string TestingPlatformOutputFormatCommandLineOption;
    public static string TestingPlatformVsTestRunsettingsCommandLineOption;
    public static string CodeCoverageFriendlyName;
    public static string ClrIeX86FileName;
    public static string ClrIeX64FileName;
    public static string ClrIeARM64FileName;
    public static string ClrieX64LinuxFileName;
    public static string ClrieX64MacosFileName;
    public static string VanguardX86ProfilerConfigFileName;
    public static string VanguardX64ProfilerConfigFileName;
    public static string VanguardARM64ProfilerConfigFileName;
    public static string ClrIeX86InstallDirVariable;
    public static string ClrIeX64InstallDirVariable;
    public static string ClrIeARM64InstallDirVariable;
    public static string StaticCovrunDllX86FileName;
    public static string StaticCovrunDllX64FileName;
    public static string StaticCovrunDllARM64FileName;
    public static string VanguardStaticInstrumenterConsoleX86FileName;
    public static string VanguardStaticInstrumenterConsoleX64FileName;
    public static string VanguardStaticInstrumenterX86FileName;
    public static string VanguardStaticInstrumenterX64FileName;
    public static string ManagedStaticTrackerNamespace;
    public static string SeCreateGlobalPrivilege;
    public static string SeSecurityPrivilege;
    public static string GlobalPrefix;
    public static Guid ModulesSkippedStreamType { get; }
    public static Guid ModuleDataStreamType { get; }
    public static Guid CoverageDataStreamType { get; }
    public static Guid PerSnapshotCoverageDataStreamType { get; }
    public static Guid SnapshotTagsDataStreamType { get; }
    private static Constants();
    [CompilerGeneratedAttribute]
public static Guid get_ModulesSkippedStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_ModuleDataStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_CoverageDataStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_PerSnapshotCoverageDataStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_SnapshotTagsDataStreamType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Coverage.BoundedLineStatisticsCalculator : object {
    private Nullable`1[] _data;
    private List`1<UInt32> _indexes;
    public BoundedLineStatisticsCalculator(IEnumerable`1<UInt32> lineNumbers);
    public sealed virtual void Add(UInt32 lineNumber, CoverageStatus status);
    public sealed virtual BlockCoverageStatistics GetStatistics(UInt32 blocksCovered, UInt32 blocksNotCovered);
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Coverage.CoverageBuffersMerger : object {
    private ICoverageFileReader _coverageFileReader;
    private ICoverageFileWriter _coverageFileWriter;
    private ICoverageFileConfiguration _coverageFileConfiguration;
    public CoverageBuffersMerger(ICoverageFileReader coverageFileReader, ICoverageFileWriter coverageFileWriter, ICoverageFileConfiguration coverageFileConfiguration);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Coverage.CoverageBuffersMerger/<MergeCoverageBuffers>d__4")]
public Task`1<string> MergeCoverageBuffers(string covxFile, IList`1<string> coverageBufferFiles, ushort schemaVersion, CancellationToken cancellationToken, bool skipInvalidFiles);
    private ValueTuple`2<CoverageBufferData, Byte[]> MergeCovBufferFiles(IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CoverageFileConfiguration configuration, CancellationToken cancellationToken);
    private static Byte[] MergeCoverageBufferData(IEnumerable`1<CoverageBufferData> buffersData, bool skipInvalidFiles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Coverage.CoverageFileConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <ReadModules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadSkippedModules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadSkippedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadSnapshotsData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateCoverageBufferFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixCoverageBuffersMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipInvalidData>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageMergeOperation <MergeOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoverageFileConfiguration <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoverageFileConfiguration <DefaultSkipInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoverageFileConfiguration <NoSkippedData>k__BackingField;
    public bool ReadModules { get; public set; }
    public bool ReadSkippedModules { get; public set; }
    public bool ReadSkippedFunctions { get; public set; }
    public bool ReadSnapshotsData { get; public set; }
    public bool GenerateCoverageBufferFiles { get; public set; }
    public bool FixCoverageBuffersMismatch { get; public set; }
    public int MaxDegreeOfParallelism { get; public set; }
    public bool SkipInvalidData { get; public set; }
    public CoverageMergeOperation MergeOperation { get; public set; }
    internal static CoverageFileConfiguration Default { get; }
    internal static CoverageFileConfiguration DefaultSkipInvalid { get; }
    internal static CoverageFileConfiguration NoSkippedData { get; }
    private static CoverageFileConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadModules();
    [CompilerGeneratedAttribute]
public void set_ReadModules(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSkippedModules();
    [CompilerGeneratedAttribute]
public void set_ReadSkippedModules(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSkippedFunctions();
    [CompilerGeneratedAttribute]
public void set_ReadSkippedFunctions(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSnapshotsData();
    [CompilerGeneratedAttribute]
public void set_ReadSnapshotsData(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_GenerateCoverageBufferFiles();
    [CompilerGeneratedAttribute]
public void set_GenerateCoverageBufferFiles(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FixCoverageBuffersMismatch();
    [CompilerGeneratedAttribute]
public void set_FixCoverageBuffersMismatch(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipInvalidData();
    [CompilerGeneratedAttribute]
public void set_SkipInvalidData(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual CoverageMergeOperation get_MergeOperation();
    [CompilerGeneratedAttribute]
public void set_MergeOperation(CoverageMergeOperation value);
    [CompilerGeneratedAttribute]
internal static CoverageFileConfiguration get_Default();
    [CompilerGeneratedAttribute]
internal static CoverageFileConfiguration get_DefaultSkipInvalid();
    [CompilerGeneratedAttribute]
internal static CoverageFileConfiguration get_NoSkippedData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Coverage.CoverageFileMessages : object {
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<ModuleMessages> <ModulesMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ModuleSkippedMessage> <SkippedModuleMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<Guid, Byte[]> <CoverageBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<SnapshotTagsDataMessage> <SnapshotTagsDataMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<Guid, ConcurrentBag`1<PerSnapshotCoverageDataMessage>> <PerSnapshotCoverageDataMessages>k__BackingField;
    public ConcurrentBag`1<ModuleMessages> ModulesMessages { get; public set; }
    public ConcurrentDictionary`2<string, ModuleSkippedMessage> SkippedModuleMessages { get; }
    public ConcurrentDictionary`2<Guid, Byte[]> CoverageBuffers { get; public set; }
    public ConcurrentBag`1<SnapshotTagsDataMessage> SnapshotTagsDataMessages { get; }
    public ConcurrentDictionary`2<Guid, ConcurrentBag`1<PerSnapshotCoverageDataMessage>> PerSnapshotCoverageDataMessages { get; public set; }
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<ModuleMessages> get_ModulesMessages();
    [CompilerGeneratedAttribute]
public void set_ModulesMessages(ConcurrentBag`1<ModuleMessages> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, ModuleSkippedMessage> get_SkippedModuleMessages();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<Guid, Byte[]> get_CoverageBuffers();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffers(ConcurrentDictionary`2<Guid, Byte[]> value);
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<SnapshotTagsDataMessage> get_SnapshotTagsDataMessages();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<Guid, ConcurrentBag`1<PerSnapshotCoverageDataMessage>> get_PerSnapshotCoverageDataMessages();
    [CompilerGeneratedAttribute]
public void set_PerSnapshotCoverageDataMessages(ConcurrentDictionary`2<Guid, ConcurrentBag`1<PerSnapshotCoverageDataMessage>> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.Coverage.CoverageReportExtensions : object {
    public static BlockCoverageStatistics AddStatistics(BlockCoverageStatistics source, BlockCoverageStatistics other);
    public static BlockCoverageStatistics AddStatistics(BlockCoverageStatistics source, CoverageStatistics other);
    [ExtensionAttribute]
public static XmlFileData ToXmlFileData(CoverageReport report);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetUniqueSourceFiles(CoverageReport coverageReport);
    [ExtensionAttribute]
public static SourceReport ToSourceReport(CoverageReport[] coverageReports, int maxDegreeOfParallelism);
    [ExtensionAttribute]
public static SourceReport ToSourceReport(FileData[] files);
    [ExtensionAttribute]
public static FileData[] GetFileCoverage(ModuleData[] modules, HashSet`1<string> sourceFiles, int maxDegreeOfParallelism);
    [ExtensionAttribute]
public static FileData[] GetFileCoverage(IEnumerable`1<ModuleData> modules, Dictionary`2<string, HashSet`1<UInt32>> changeset, int maxDegreeOfParallelism, bool replaceDirectorySeparator);
    [ExtensionAttribute]
public static FileData[] GetFileCoverage(CoberturaFile coberturaFile, HashSet`1<string> sourceFiles, int maxDegreeOfParallelism);
    [ExtensionAttribute]
public static FileData[] GetFileCoverage(CoberturaFile coberturaFile, Dictionary`2<string, HashSet`1<UInt32>> sourceFiles, int maxDegreeOfParallelism);
    private static Dictionary`2<string, HashSet`1<UInt32>> ToChangeset(HashSet`1<string> sourceFiles);
    [CompilerGeneratedAttribute]
internal static void <ToSourceReport>g__AddFileToReport|6_0(InternalDirectoryData sourceReport, FileData fileData, Dictionary`2<string, InternalDirectoryData> pathToDirectoryMap);
    [CompilerGeneratedAttribute]
internal static InternalDirectoryData <ToSourceReport>g__PopulateDirectories|6_1(String[] tokens, InternalDirectoryData parent);
    [CompilerGeneratedAttribute]
internal static void <ToSourceReport>g__MergeDirectoryData|6_2(InternalDirectoryData internalDirectory);
    [CompilerGeneratedAttribute]
internal static DirectoryData <ToSourceReport>g__ToDirectoryData|6_3(InternalDirectoryData internalDirectory);
    [CompilerGeneratedAttribute]
internal static void <GetFileCoverage>g__PopulateFileLines|8_0(Dictionary`2<string, HashSet`1<UInt32>> changeset, FunctionData function, ConcurrentDictionary`2<string, ConcurrentDictionary`2<MultiBlockLineData, CoverageLineData>> pathToLinesMap, bool replaceDirectorySeparator);
    [CompilerGeneratedAttribute]
internal static bool <GetFileCoverage>g__IsLineIncluded|8_3(MultiBlockLineData line, Dictionary`2<string, HashSet`1<UInt32>> changeset);
    [CompilerGeneratedAttribute]
internal static FileData[] <GetFileCoverage>g__LinesMapToFileData|8_1(ConcurrentDictionary`2<string, ConcurrentDictionary`2<MultiBlockLineData, CoverageLineData>> pathToLinesMap);
    [CompilerGeneratedAttribute]
internal static ConcurrentDictionary`2<string, ConcurrentDictionary`2<CoberturaLine, CoverageLineData>> <GetFileCoverage>g__GetPathToLinesCoverageMap|10_0(IEnumerable`1<CoberturaPackage> packages, Dictionary`2<string, HashSet`1<UInt32>> changeset, int maxDegreeOfParallelism);
    [CompilerGeneratedAttribute]
internal static void <GetFileCoverage>g__PopulateFileLines|10_1(Dictionary`2<string, HashSet`1<UInt32>> changeset, CoberturaClass coberturaClass, ConcurrentDictionary`2<string, ConcurrentDictionary`2<CoberturaLine, CoverageLineData>> pathToLinesMap);
    [CompilerGeneratedAttribute]
internal static FileData[] <GetFileCoverage>g__LinesMapToFileData|10_2(ConcurrentDictionary`2<string, ConcurrentDictionary`2<CoberturaLine, CoverageLineData>> pathToLinesMap);
}
internal interface Microsoft.CodeCoverage.Core.Coverage.ILineStatisticsCalculator {
    public abstract virtual void Add(UInt32 lineNumber, CoverageStatus status);
    public abstract virtual BlockCoverageStatistics GetStatistics(UInt32 blocksCovered, UInt32 blocksNotCovered);
    public abstract virtual void Reset();
}
internal class Microsoft.CodeCoverage.Core.Coverage.LineStatisticsCalculator : object {
    [NullableAttribute("1")]
private Dictionary`2<UInt32, CoverageStatus> _data;
    public sealed virtual void Add(UInt32 lineNumber, CoverageStatus status);
    public sealed virtual BlockCoverageStatistics GetStatistics(UInt32 blocksCovered, UInt32 blocksNotCovered);
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.Coverage.MessagesHelpers : object {
    [ExtensionAttribute]
public static UInt32 UpdateStartBlockIndex(FunctionInstrumentedMessage message, UInt32 newStartBlockIndex);
    [ExtensionAttribute]
public static Dictionary`2<string, List`1<ModuleMessages>> GroupByModuleIdentifierOrDefault(CoverageFileMessages coverageFileMessages);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Core.Coverage.MessagesHelpers/<GetModuleData>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<ModuleMessagesData> GetModuleData(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
public static CoverageReport ToCoverageReportData(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
internal static SkippedModuleData[] ToSkippedModuleReportData(ICollection`1<ModuleSkippedMessage> messages);
    private static SnapshotTag[] ToSnapshotTags(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
private static ModuleData[] ToModuleReportData(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
private static ModuleData ToModuleReportData(ModuleMessagesData moduleData);
    [ExtensionAttribute]
internal static Dictionary`2<UInt32, SourceFileData> ToSourceFiles(ICollection`1<SourceFileDataMessage> messages);
    [ExtensionAttribute]
internal static FunctionData[] ToFunctions(IList`1<FunctionInstrumentedMessage> functions, Byte[] coverageBuffer, ModuleData module, Dictionary`2<UInt32, SourceFileData> sourceFiles);
    [ExtensionAttribute]
internal static MultiBlockLineData[] ToMultiBlockLineData(FunctionInstrumentedMessage message, Dictionary`2<UInt32, SourceFileData> sourceFiles);
    internal static MultiBlockLineData[] MergeMultiBlockLineData(IEnumerable`1<MultiBlockLineData> lines);
    [ExtensionAttribute]
internal static SkippedFunctionData[] ToSkippedFunctions(ICollection`1<FunctionSkippedMessage> messages);
    private static void PopulatePerSnapshotCoverageBuffers(CoverageFileMessages coverageFileMessages, Guid identifier, ModuleData module);
    [ExtensionAttribute]
public static bool HasDuplicateModules(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
public static MergeCoverageFileData ToMergeCoverageFileData(CoverageFileMessages messages, ICoverageMessagesReader coverageMessagesReader);
    [ExtensionAttribute]
public static MergeModuleMessages ToMergeModuleMessages(ModuleMessages messages, Byte[] coverageBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Coverage.ModuleMessagesData : ValueType {
    [CompilerGeneratedAttribute]
private ModuleMessages <ModuleMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ConcurrentBag`1<PerSnapshotCoverageDataMessage> <PerSnapshotCoverageDataMessages>k__BackingField;
    public ModuleMessages ModuleMessages { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    [NullableAttribute("2")]
public ConcurrentBag`1<PerSnapshotCoverageDataMessage> PerSnapshotCoverageDataMessages { get; public set; }
    public ModuleMessagesData(ModuleMessages ModuleMessages, Byte[] CoverageBuffer, ConcurrentBag`1<PerSnapshotCoverageDataMessage> PerSnapshotCoverageDataMessages);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ModuleMessages get_ModuleMessages();
    [CompilerGeneratedAttribute]
public void set_ModuleMessages(ModuleMessages value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ConcurrentBag`1<PerSnapshotCoverageDataMessage> get_PerSnapshotCoverageDataMessages();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PerSnapshotCoverageDataMessages(ConcurrentBag`1<PerSnapshotCoverageDataMessage> value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleMessagesData left, ModuleMessagesData right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleMessagesData left, ModuleMessagesData right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleMessagesData other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ModuleMessages& ModuleMessages, Byte[]& CoverageBuffer, ConcurrentBag`1& PerSnapshotCoverageDataMessages);
}
internal class Microsoft.CodeCoverage.Core.Coverage.PerSnapshotCoverageDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotIdsDataMessage <SnapshotIds>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageBufferHashMessage <BufferHashMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private SingleBitCoverageBuffer <CoverageBuffer>k__BackingField;
    public Guid Identifier { get; public set; }
    public SnapshotIdsDataMessage SnapshotIds { get; public set; }
    public CoverageBufferHashMessage BufferHashMessage { get; public set; }
    public SingleBitCoverageBuffer CoverageBuffer { get; public set; }
    public PerSnapshotCoverageDataMessage(Guid Identifier, SnapshotIdsDataMessage SnapshotIds, CoverageBufferHashMessage BufferHashMessage, SingleBitCoverageBuffer CoverageBuffer);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SnapshotIdsDataMessage get_SnapshotIds();
    [CompilerGeneratedAttribute]
public void set_SnapshotIds(SnapshotIdsDataMessage value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CoverageBufferHashMessage get_BufferHashMessage();
    [CompilerGeneratedAttribute]
public void set_BufferHashMessage(CoverageBufferHashMessage value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SingleBitCoverageBuffer get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(SingleBitCoverageBuffer value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PerSnapshotCoverageDataMessage left, PerSnapshotCoverageDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PerSnapshotCoverageDataMessage left, PerSnapshotCoverageDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PerSnapshotCoverageDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Identifier, SnapshotIdsDataMessage& SnapshotIds, CoverageBufferHashMessage& BufferHashMessage, SingleBitCoverageBuffer& CoverageBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Coverage.SingleBitCoverageBuffer : ValueType {
    private static int CellSize;
    private int _length;
    private UInt32[] _buffer;
    public int Length { get; }
    public SingleBitCoverageBuffer(int length);
    public SingleBitCoverageBuffer(Byte[] buffer, int length);
    public int get_Length();
    public void OrOperator(SingleBitCoverageBuffer other);
    public void OrOperator(SingleBitCoverageBuffer other, int offset);
    public void CopyToArray(Byte[] buffer);
    public string Md5();
}
internal class Microsoft.CodeCoverage.Core.Coverage.SplitCoverageFileConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <ReadSkippedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixCoverageBuffersMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateCoverageBufferFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipInvalidData>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageMergeOperation <MergeOperation>k__BackingField;
    public bool ReadModules { get; }
    public bool ReadSkippedModules { get; }
    public bool ReadSnapshotsData { get; }
    public bool ReadSkippedFunctions { get; }
    public bool FixCoverageBuffersMismatch { get; }
    public bool GenerateCoverageBufferFiles { get; }
    public int MaxDegreeOfParallelism { get; }
    public bool SkipInvalidData { get; }
    public CoverageMergeOperation MergeOperation { get; }
    [NullableContextAttribute("1")]
public SplitCoverageFileConfiguration(ICoverageFileConfiguration coverageFileConfiguration);
    public sealed virtual bool get_ReadModules();
    public sealed virtual bool get_ReadSkippedModules();
    public sealed virtual bool get_ReadSnapshotsData();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSkippedFunctions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FixCoverageBuffersMismatch();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_GenerateCoverageBufferFiles();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipInvalidData();
    [CompilerGeneratedAttribute]
public sealed virtual CoverageMergeOperation get_MergeOperation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.Coverage.StatisticsCalculator : object {
    public static void CalculateStatistics(FunctionData function, Byte[] coverageBuffer, int coverageBufferSize, IBoundedSet boundedSet, ILineStatisticsCalculator lineStatisticsCalculator, bool recalculateStatistics);
    public static void CalculateStatistics(DirectoryData directory);
    public static void CalculateStatistics(FileData file, ILineStatisticsCalculator lineStatisticsCalculator);
    internal static BlockCoverageStatistics GetStatistics(Byte[] coverageBuffer, int coverageBufferSize, ICollection`1<MultiBlockLineData> lines, IBoundedSet boundedSet, ILineStatisticsCalculator lineStatisticsCalculator, HashSet`1<int> changeset, bool recalculateStatistics);
    private static ValueTuple`2<UInt32, UInt32> GetBlocksStatistics(Byte[] coverageBuffer, int coverageBufferSize, IEnumerable`1<MultiBlockLineData> lines, IBoundedSet boundedSet, bool recalculateStatistics);
    internal static BlockCoverageStatistics GetLinesStatistics(IEnumerable`1<CoverageLineData> lines, UInt32 blocksCovered, UInt32 blocksNotCovered, ILineStatisticsCalculator calculator, HashSet`1<int> changeset, bool recalculateStatistics);
    [CompilerGeneratedAttribute]
internal static void <CalculateStatistics>g__AddStatistics|1_0(CoverageStatistics source, CoverageStatistics other);
}
public enum Microsoft.CodeCoverage.Core.CoverageMergeOperation : Enum {
    public int value__;
    public static CoverageMergeOperation MergeSimilarFormats;
    public static CoverageMergeOperation MergeToCoverage;
    public static CoverageMergeOperation MergeToXml;
    public static CoverageMergeOperation MergeToCobertura;
}
public enum Microsoft.CodeCoverage.Core.CoverageReportType : Enum {
    public int value__;
    public static CoverageReportType Coverage;
    public static CoverageReportType Xml;
    public static CoverageReportType Cobertura;
    public static CoverageReportType CoverageV2;
}
public enum Microsoft.CodeCoverage.Core.CoverageStatus : Enum {
    public int value__;
    public static CoverageStatus yes;
    public static CoverageStatus partial;
    public static CoverageStatus no;
}
public enum Microsoft.CodeCoverage.Core.DoesNotReturnAttributeScope : Enum {
    public int value__;
    public static DoesNotReturnAttributeScope None;
    public static DoesNotReturnAttributeScope SameAssembly;
    public static DoesNotReturnAttributeScope AllAssemblies;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Core.Exceptions.CoverageException : Exception {
    public CoverageException(string message);
    public CoverageException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Core.Exceptions.CoverageFileException : CoverageException {
    public CoverageFileException(string path);
    public CoverageFileException(string path, Exception innerException);
}
public class Microsoft.CodeCoverage.Core.Exceptions.CoverageReportException : CoverageException {
    [NullableContextAttribute("1")]
public CoverageReportException(Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Core.Exceptions.InvalidBufferCountException : CoverageException {
    public InvalidBufferCountException(string message);
    public InvalidBufferCountException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Core.Exceptions.InvalidCoverageFileException : CoverageException {
    public InvalidCoverageFileException(string path);
    public InvalidCoverageFileException(string path, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Core.Exceptions.UnsupportedCoverageFileException : CoverageException {
    public UnsupportedCoverageFileException(string path);
    public UnsupportedCoverageFileException(string path, Exception innerException);
}
public enum Microsoft.CodeCoverage.Core.FunctionSkipReason : Enum {
    public int value__;
    public static FunctionSkipReason too_small;
    public static FunctionSkipReason too_large;
    public static FunctionSkipReason source_excluded;
    public static FunctionSkipReason name_excluded;
    public static FunctionSkipReason excluded_inline;
    public static FunctionSkipReason has_external_branch;
    public static FunctionSkipReason is_duplicate;
    public static FunctionSkipReason attribute_excluded;
    public static FunctionSkipReason no_line_information;
    public static FunctionSkipReason instrumentation_failure;
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.Core.IEnvironment {
    public PlatformOperatingSystem OperatingSystem { get; }
    public Architecture ProcessArchitecture { get; }
    public bool IsWindows { get; }
    public abstract virtual PlatformOperatingSystem get_OperatingSystem();
    public abstract virtual Architecture get_ProcessArchitecture();
    public abstract virtual bool get_IsWindows();
    public abstract virtual string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public abstract virtual string ExpandEnvironmentVariables(string name);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.Core.ILogger {
    public abstract virtual void LogWarning(string message);
    public abstract virtual void LogError(string message);
    public abstract virtual void LogInfo(string message);
    public abstract virtual void LogVerbose(string message);
    public abstract virtual void LogError(Exception exceptionToTrace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Core.IO.BinaryMessageReader : object {
    [CompilerGeneratedAttribute]
private BinaryReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveTag>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CurrentTag>k__BackingField;
    public BinaryReader Reader { get; }
    public long CurrentPosition { get; }
    public long End { get; }
    public long Start { get; }
    protected bool HaveTag { get; protected set; }
    protected UInt32 CurrentTag { get; protected set; }
    public BinaryMessageReader(BinaryReader reader, long startOffset, long endOffset, bool sync);
    [CompilerGeneratedAttribute]
public BinaryReader get_Reader();
    public long get_CurrentPosition();
    [CompilerGeneratedAttribute]
public long get_End();
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
protected bool get_HaveTag();
    [CompilerGeneratedAttribute]
protected void set_HaveTag(bool value);
    [CompilerGeneratedAttribute]
protected UInt32 get_CurrentTag();
    [CompilerGeneratedAttribute]
protected void set_CurrentTag(UInt32 value);
    public virtual bool HasMessage(ushort messageTag);
    public void Sync();
    public bool CanRead();
    internal static T[] ReadArray(BinaryReader reader, Func`2<BinaryReader, T> elementReader);
    internal void ThrowIfInvalidTag(ushort messageTag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.IO.BinaryMessageWriter : object {
    private static IMessagePositionWriter GetMessagePositionWriter(BinaryWriter writer, int schemaVersion, ushort messageTag);
    public static void WriteTestCoverageDataMessage(BinaryWriter writer, TestCoverageDataMessage message, int schemaVersion);
    public static void WriteModuleBufferMessage(BinaryWriter writer, ModuleBufferMessage message, int schemaVersion);
    public static void WriteModuleInstrumentedMessage(BinaryWriter writer, ModuleInstrumentedMessage message, int schemaVersion);
    public static void WriteFunctionInstrumentedMessage(BinaryWriter writer, FunctionInstrumentedMessage message, int schemaVersion);
    public static void WriteFunctionSkippedMessage(BinaryWriter writer, FunctionSkippedMessage message, int schemaVersion);
    public static void WriteSourceFileDataMessage(BinaryWriter writer, SourceFileDataMessage message, int schemaVersion);
    public static void WriteModuleSkippedMessage(BinaryWriter writer, ModuleSkippedMessage message, int schemaVersion);
    public static void WriteSnapshotIdsDataMessage(BinaryWriter writer, SnapshotIdsDataMessage message, int schemaVersion);
    public static void WriteCoverageBufferHashMessage(BinaryWriter writer, CoverageBufferHashMessage message, int schemaVersion);
    public static void WriteSnapshotTagsDataMessage(BinaryWriter writer, SnapshotTagsDataMessage message, int schemaVersion);
    public static void WriteNotSupportedMessage(BinaryWriter writer, NotSupportedMessage message, int schemaVersion);
    public static void WriteSuccessMessage(BinaryWriter writer);
    public static void WriteRegisterClientMessage(BinaryWriter writer, RegisterClientMessage message);
    public static void WriteRegisterClientResponseMessage(BinaryWriter writer);
    public static void WriteCreateStreamMessage(BinaryWriter writer, CreateStreamMessage message);
    public static void WriteCreateStreamResponseMessage(BinaryWriter writer, CreateStreamResponseMessage message);
    public static void WriteWriteStreamMessage(BinaryWriter writer, WriteStreamMessage message);
    public static void WriteCloseStreamMessage(BinaryWriter writer, CloseStreamMessage message);
    public static void WriteClientErrorMessage(BinaryWriter writer, ClientErrorMessage message);
    public static void WriteShutdownMessage(BinaryWriter writer);
    public static void WriteWriteStreamBuffersMessage(BinaryWriter writer, WriteStreamBuffersMessage message);
    public static void WriteConfigLoggerMessage(BinaryWriter writer);
    public static void WriteGetCoverageDataMessage(BinaryWriter writer, GetCoverageDataMessage message);
    public static void WriteInitializeClientMessage(BinaryWriter writer, InitializeClientMessage message);
    public static void WriteInitializeClientResponseMessage(BinaryWriter writer, InitializeClientResponseMessage message);
    public static void WriteLoadModuleDataMessage(BinaryWriter writer, LoadModuleDataMessage message);
    public static void WriteInstrumentedModuleMessage(BinaryWriter writer, InstrumentedModuleMessage message);
    public static void WriteInstrumentedFunctionMessage(BinaryWriter writer, InstrumentedFunctionMessage message);
    public static void WritePreloadModuleDataMessage(BinaryWriter writer, PreloadModuleDataMessage message);
    public static void WritePreloadModuleDataResponseMessage(BinaryWriter writer, PreloadModuleDataResponseMessage message);
    public static void WriteGetInformationMessage(BinaryWriter writer, GetInformationMessage message);
    public static void WriteGetInformationResponseMessage(BinaryWriter writer, GetInformationResponseMessage message);
    public static void WriteShutdownLoggerMessage(BinaryWriter writer);
    public static void WriteInstrumentationStatisticsMessage(BinaryWriter writer, InstrumentationStatisticsMessage message);
    public static void WriteGenerateReportsRequestMessage(BinaryWriter writer);
    public static void WriteCacheMessage(BinaryWriter writer, CacheMessage message);
    public static void WriteFetchNativeModuleDataMessage(BinaryWriter writer, FetchCacheMessage message);
    public static void WriteSnapshotMessage(BinaryWriter writer, SnapshotMessage message);
    public static void WriteFilePathsMessage(BinaryWriter writer, FilePathsMessage message);
    private static void WriteBufferMessage(BinaryWriter writer, BufferMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageBufferFile : CoverageFileBase {
    private CoverageBufferData _coverageBufferData;
    private CoverageBufferFile(string path);
    public static CoverageBufferData Read(string path);
    public static CoverageBufferData ReadCoverageBufferFile(string path, CancellationToken token);
    protected virtual void ProcessStreamHeader(StreamHeader streamHeader, BinaryReader reader, bool readModuleHandles, bool readOnlyTestList, String[] orderedTestIds);
    private void RecordCoverageDataStream(CoverageFileMessageReader reader, Guid identifier);
    private Byte[] GetCoverageBuffer(BinaryReader reader);
    internal static void WriteModuleCoverageBufferData(string outputFolder, ModuleHandle moduleHandle);
    internal static void WriteModuleCoverageBufferData(string outputPath, string moduleName, UInt32 imageLinkTime, Guid coverageBufferId, Byte[] coverageBuffer);
    private static void WriteBufferData(BinaryWriter writer, ModuleBufferMessage message, Byte[] coverageBuffer, Guid coverageBufferId);
    internal static Byte[] MergeCoverageBuffer(IEnumerable`1<string> bufferFiles, bool skipInvalidFiles, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileBase : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; }
    [NullableContextAttribute("2")]
protected CoverageFileBase(string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    protected virtual void ReadFile(BinaryReader reader, CancellationToken token, bool readModuleHandles, bool readOnlyTestList, IList`1<string> testIds);
    protected abstract virtual void ProcessStreamHeader(StreamHeader streamHeader, BinaryReader reader, bool readModuleHandles, bool readOnlyTestList, String[] orderedTestIds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileConverterLegacy : object {
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileConverterLegacy/<ToXmlFileAsync>d__0")]
public static Task ToXmlFileAsync(string path, string outputPath, bool includeSkippedFunctions, bool includeSkippedModules, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileConverterLegacy/<ToCoverageXmlFileAsync>d__1")]
public static Task`1<CoverageXmlFile> ToCoverageXmlFileAsync(string path, bool includeSkippedFunctions, bool includeSkippedModules, CancellationToken token);
    internal static void WriteXmlFile(string path, CoverageData coverageData, bool includeSkippedModules, CancellationToken token);
    internal static void WriteXmlFile(string path, CoverageXmlFile coverageXmlFile);
    internal static CoverageXmlFile ToXml(CoverageData coverageData, bool includeSkippedModules, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileConverterLegacy/<ToCoberturaFileAsync>d__5")]
public static Task ToCoberturaFileAsync(string path, string outputPath, CancellationToken token);
    internal static void WriteToCoberturaFile(string path, CoverageData coverageData, CancellationToken token);
    internal static CoberturaFile ToCobertura(CoverageData coverageData, CancellationToken token);
    private static ValueTuple`2<MinimalSequencePointsFinder`1<UInt32>, int> BuildMinimalSequencePointsFinderAndCalculateMaxNumberOfMethods(ModuleWrapper module);
    private static void AddMethod(Function function, CoberturaPackageBuilder packageBuilder, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder, ModuleWrapper module, CancellationToken token);
    private static CoberturaLine[] CalculateLines(List`1<BlockLineData> lineData, UInt32 sourceId, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileLegacy : CoverageFileBase {
    private bool _cacheCoverageMessages;
    [CompilerGeneratedAttribute]
private CoverageData <CoverageData>k__BackingField;
    internal CoverageData CoverageData { get; private set; }
    internal CoverageFileLegacy(CoverageData coverageData);
    [NullableContextAttribute("2")]
private CoverageFileLegacy(string path, bool cacheCoverageMessages);
    [CompilerGeneratedAttribute]
internal CoverageData get_CoverageData();
    [CompilerGeneratedAttribute]
private void set_CoverageData(CoverageData value);
    public long GetModuleCoverageBufferOffset(string moduleName, UInt32 moduleLinkTime);
    public void UpdateModuleCoverageBuffer(long offset, Byte[] coverageBuffer);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileLegacy/<MergeCoverageBufferFilesAsync>d__10")]
public static Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, CancellationToken token, bool skipInvalidFiles);
    private static string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CancellationToken token);
    public static CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles, int maxTaskCount, bool loadAllModuleData);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileLegacy/<MergeCoverageFilesAsync>d__13")]
public static Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, CancellationToken token, bool skipInvalidFiles, int taskCount, bool loadAllModuleData);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileLegacy/<MergeCoverageFilesAsync>d__14")]
internal static Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<ValueTuple`2<string, CoverageFileLegacy>> files, CancellationToken token, bool skipInvalidFiles, int taskCount, bool loadAllModuleData);
    [NullableContextAttribute("2")]
internal static CoverageFileLegacy GetCoverageFile(ValueTuple`2<string, CoverageFileLegacy> file, bool skipInvalidFiles, CancellationToken token);
    private static CoverageFileLegacy Merge(CoverageFileLegacy file1, CoverageFileLegacy file2, bool skipInvalidFiles, CancellationToken token);
    private static void MergeModules(CoverageFileLegacy file1, CoverageFileLegacy file2, CoverageFileLegacy target, bool skipInvalidFiles, CancellationToken token);
    private static void AddModule(CoverageFileLegacy file, CoverageFileLegacy target, string moduleId, bool skipInvalidFiles);
    private static void MergeModule(CoverageFileLegacy target, ModuleWrapper module1, ModuleWrapper module2, CancellationToken token);
    private static void MergeModuleCoverageBuffer(CoverageFileLegacy target, ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2, CancellationToken token);
    private static Byte[] MergeFunctionsCoverageBuffer(ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2);
    private static UInt32 MergeFunctionMessages(ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2, List`1<Byte[]> finalCoverageBufferList, UInt32 functionStartIndex, bool mergeCommonMessages, bool addMissingMessagesToModule2);
    private static Byte[] GetBiggerCoverageBuffer(ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2, FunctionInstrumentedMessage message1, FunctionInstrumentedMessage message2, UInt32 functionBufferCount);
    private static void UpdateSourceIds(ModuleWrapper module1, ModuleWrapper module2, FunctionInstrumentedMessage message2);
    private static void MergeSkippedModules(CoverageFileLegacy file1, CoverageFileLegacy file2, CoverageFileLegacy target, CancellationToken token);
    private static void MergeModuleHandles(string moduleId1, ModuleHandle moduleHandle1, CoverageFileLegacy file1, CoverageFileLegacy file2, BinaryReader reader1, BinaryReader reader2, bool skipInvalidFiles, bool allowMergeWithSameId);
    private static bool AreEqualByHash(ModuleHandle moduleHandle1, ModuleHandle moduleHandle2, BinaryReader reader1, BinaryReader reader2);
    private static bool TryMergeCoverageBuffers(ModuleHandle moduleHandle1, ModuleHandle moduleHandle2, CoverageFileLegacy file1, CoverageFileLegacy file2, BinaryReader reader1, BinaryReader reader2, bool skipInvalidFiles);
    private static void MergeTestListData(CoverageData coverageData1, CoverageData coverageData2, CoverageData target);
    private static void MergePerTestData(CoverageData coverageData1, CoverageData coverageData2, CoverageData target);
    internal static CoverageData ReadCoverageFile(string path, SnapshotTag[] snapshotTags);
    internal static SnapshotTag[] ReadTestCases(string path);
    public static CoverageData Read(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    public static CoverageData Read(string path, IList`1<string> testIds, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileLegacy/<ReadAsync>d__35")]
public static Task`1<CoverageData> ReadAsync(string path, CancellationToken token, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileLegacy/<ReadAsync>d__36")]
public static Task`1<CoverageData> ReadAsync(string path, CancellationToken token, IList`1<string> testIds, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    private static CoverageFileLegacy ReadCoverageFile(string path, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool readModuleHandles, bool cacheCoverageMessages, IList`1<string> testIds, bool readOnlyTestList, CancellationToken token);
    internal static CoverageFileLegacy ReadCoverageFile(string path, BinaryReader reader, bool cacheCoverageMessages, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool readModuleHandles, IList`1<string> testIds, bool readOnlyTestList, CancellationToken token);
    protected virtual void ProcessStreamHeader(StreamHeader streamHeader, BinaryReader reader, bool readModuleHandles, bool readOnlyTestList, String[] orderedTestIds);
    private void RecordTestListInformationDataStreamType(CoverageFileMessageReader reader, String[] orderedTestIds);
    private void RecordPerTestCodeCoverageDataStream(CoverageFileMessageReader reader, Guid identifier, String[] orderedTestIds);
    private void RecordCoverageDataStream(CoverageFileMessageReader reader, Guid identifier);
    private void RecordModuleStream(CoverageFileMessageReader reader, bool readModuleHandles);
    internal static void GetSkippedModule(CoverageFileMessageReader reader, IList`1<SkippedModule> modules, string filePath);
    private static void ReadModuleData(string path, BinaryReader reader, ModuleWrapper module, IList`1<string> testIds, bool readSkippedFunctions, bool cacheCoverageMessages, IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> moduleDataLocations, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations, Byte[] coverageBuffer);
    private static IList`1<FunctionWrapper> ReadModuleStream(string path, BinaryReader reader, ModuleWrapper module, IList`1<string> testIds, long streamEnd, bool readSkippedFunctions, bool cacheCoverageMessages, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations, Byte[] coverageBuffer);
    private static IList`1<FunctionWrapper> ReadModuleStream(string path, BinaryReader reader, ModuleWrapper module, IList`1<string> testIds, bool readSkippedFunctions, bool cacheCoverageMessages, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations, Byte[] coverageBuffer, CoverageFileMessageReader stream);
    internal static void LoadRawData(ModuleHandle moduleHandle);
    internal static void LoadRawData(ModuleHandle moduleHandle, BinaryReader reader);
    internal static void CalculateRawDataHash(ModuleHandle moduleHandle, BinaryReader binaryReader);
    [NullableContextAttribute("2")]
internal Byte[] GetCoverageBuffer(Guid coverageBufferId, bool skipInvalidFiles, BinaryReader binaryReader);
    private static Byte[] GetCoverageBuffer(string path, BinaryReader reader, Guid coverageBufferId, IList`1<string> testIds, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations);
    private static Byte[] MergeCoverageBuffer(string path, BinaryReader reader, long start, long blockCount, Byte[] buffer);
    internal static void ReadSourceFile(CoverageFileMessageReader reader, ModuleWrapper module, IDictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static void ReadSourceFile(SourceFileDataMessage message, ModuleWrapper module, IDictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static FunctionWrapper ReadFunction(CoverageFileMessageReader reader, ModuleWrapper module, Byte[] coverageBuffer, Dictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static FunctionWrapper ReadFunction(FunctionInstrumentedMessage message, ModuleWrapper module, Byte[] coverageBuffer, Dictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static void ReadSkippedMessage(CoverageFileMessageReader reader, ModuleWrapper module, bool readSkippedFunctions, bool cacheCoverageMessages);
    internal static void ReadSkippedMessage(FunctionSkippedMessage message, ModuleWrapper module, bool readSkippedFunctions, bool cacheCoverageMessages);
    private void LoadAllModuleData(bool readSkippedFunctions, bool skipInvalidFiles);
    private void LoadAllCoverageBuffers(bool skipInvalidFiles);
    internal static void LoadAllRawData(CoverageData coverageData);
    private void LoadModuleData(string moduleId, bool readSkippedFunctions, bool skipInvalidFiles);
    private void ReadModule(BinaryReader reader, bool readSkippedFunctions, IList`1<string> testIds, string moduleId);
    private void ReadSkippedModules(BinaryReader reader);
    private void ReadModules(BinaryReader reader, bool readSkippedFunctions, IList`1<string> testIds);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageFileLegacy/<SplitCoverageFileAsync>d__67")]
public static Task SplitCoverageFileAsync(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    private static void SplitCoverageFile(CoverageData coverageData, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    internal static void Write(string path, CoverageData coverageData);
    internal static void Write(string path, CoverageData coverageData, CancellationToken token);
    private static void Write(BinaryWriter writer, CoverageData coverageData, CancellationToken token);
    private static void WriteInstrumentedModuleData(BinaryWriter writer, ModuleWrapper module);
    private static void WriteInstrumentedModuleData(BinaryWriter writer, ModuleHandle moduleHandle);
    private static void WriteModuleCoverageData(BinaryWriter writer, Guid coverageBufferId, Byte[] coverageBuffer);
    private static void WriteSingleSkippedModuleToFile(string outputFolder, SkippedModule module, ConcurrentDictionary`2<string, byte> writtenModules);
    private static void WriteSkippedModuleData(BinaryWriter writer, SkippedModule module);
    private static void WriteSingleModuleHandleToFile(string outputFolder, ModuleHandle moduleHandle, ConcurrentDictionary`2<string, byte> writtenModules, bool generateCoverageBufferFiles);
    private static void WriteInstrumentedModule(string outputFolder, ModuleHandle moduleHandle, bool generateCoverageBufferFiles);
    private static void WriteSnapshotTagsData(BinaryWriter writer, SnapshotTag[] snapshotTags);
    private static void WritePerSnapshotData(BinaryWriter writer, Guid identifier, KeyValuePair`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>> perTestCoverageData);
    [CompilerGeneratedAttribute]
internal static void <MergeSkippedModules>g__MergeSkippedModule|25_0(CoverageFileLegacy file, CoverageFileLegacy target, CancellationToken token);
    [CompilerGeneratedAttribute]
internal static void <MergeTestListData>g__MergeTestListData|29_0(CoverageData coverageData, CoverageData target);
    [CompilerGeneratedAttribute]
internal static void <MergePerTestData>g__MergePerTestData|30_0(CoverageData coverageData, CoverageData target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.IO.Coverage.Legacy.CoverageXmlFileUtility : object {
    public static bool TryDeserializeXmlFileData(XDocument document, ICoverageFileConfiguration coverageFileConfiguration, XmlFileData& report);
    public static XmlFileData ReadXmlFile(string path, ICoverageFileConfiguration coverageFileConfiguration);
    [ExtensionAttribute]
private static void PopulateSourceFiles(XmlFileData report, ICoverageFileConfiguration coverageFileConfiguration);
    public static void WriteXmlCoverageFile(string path, XmlFileData report, ICoverageFileConfiguration coverageFileConfiguration);
    public static CoverageFileLegacy ToCoverageFile(CoverageXmlFile coverageXmlFile);
    private static ModuleWrapper ToModuleWrapper(Module module);
    private static ValueTuple`2<FunctionInstrumentedMessage, Byte[]> ToFunctionInstrumentedMessage(Function function, UInt32 startBlockIndex);
    private static FunctionSkippedMessage ToFunctionSkippedMessage(SkippedFunction skippedFunction);
    private static SourceFileDataMessage ToSourceFileDataMessage(SourceFile sourceFile);
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.BlockLineDataMessageComparer : object {
    public sealed virtual bool Equals(BlockLineDataMessage message, BlockLineDataMessage otherMessage);
    public sealed virtual int GetHashCode(BlockLineDataMessage obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.CoverageFileDataMerger : object {
    private IModuleMerger _moduleMerger;
    [NullableAttribute("2")]
private ILogger _logger;
    public CoverageFileDataMerger(IModuleMerger moduleMerger, ILogger logger);
    public sealed virtual MergeCoverageFileData MergeMessagesData(IReadOnlyCollection`1<MergeCoverageFileData> mergeData, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private IDictionary`2<string, ModuleSkippedMessage> MergeSkippedModules(IReadOnlyCollection`1<MergeCoverageFileData> files);
    private IList`1<MergeModuleData> MergeModules(IEnumerable`1<MergeModuleData> modules, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static void ProcessModules(IEnumerable`1<MergeModuleData> modules, Dictionary`2<string, List`1<MergeModuleData>> pathToModules);
    private void MergeSimilarModules(Dictionary`2<string, List`1<MergeModuleData>> pathToModules, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private int FastMergeModules(Dictionary`2<string, List`1<MergeModuleData>> pathToModules, string modulePath, CancellationToken cancellationToken);
    private ValueTuple`3<int, int, int> SlowMergeModules(Dictionary`2<string, List`1<MergeModuleData>> pathToModules, string modulePath, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static void CalculateCoverageBuffer(MergeModuleData module, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.FunctionHasher : object {
    [NullableContextAttribute("1")]
public sealed virtual string SHA256Hash(FunctionInstrumentedMessage message);
    [NullableContextAttribute("1")]
private void FillStream(BinaryWriter writer, FunctionInstrumentedMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.FunctionKey : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string NamespaceName { get; public set; }
    public FunctionKey(string Name, string TypeName, string NamespaceName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamespaceName(string value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FunctionKey left, FunctionKey right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FunctionKey left, FunctionKey right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FunctionKey other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, String& TypeName, String& NamespaceName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.FunctionMerger : object {
    private IFunctionHasher _functionHasher;
    [NullableAttribute("2")]
private ILogger _logger;
    private static BlockLineDataMessageComparer _blockLineDataMessageComparer;
    public FunctionMerger(IFunctionHasher functionHasher, ILogger logger);
    private static FunctionMerger();
    public sealed virtual bool CanSlowMerge(MergeFunctionData function, MergeFunctionData otherFunction);
    private bool LineDataOverlap(MergeFunctionData function, MergeFunctionData otherFunction);
    public sealed virtual void FastMerge(MergeFunctionData function, MergeFunctionData otherFunction);
    public sealed virtual MergeFunctionData SlowMerge(MergeFunctionData functionData, MergeFunctionData otherFunctionData);
    private ValueTuple`2<MergeFunctionData, MergeFunctionData> PrepareFunctions(MergeFunctionData functionData, MergeFunctionData otherFunctionData);
    private ValueTuple`2<MergeFunctionData, MergeFunctionData> CompareFunctions(MergeFunctionData functionData, MergeFunctionData otherFunctionData);
    private byte GetMergedCoverage(Dictionary`2<UInt32, byte> functionIndexToCoverage, Dictionary`2<UInt32, byte> otherFunctionIndexToCoverage, UInt32 index, UInt32 otherIndex);
    private CoverageStatus GetCoverageStatus(List`1<BlockLineDataMessage> blockLineData, Dictionary`2<UInt32, byte> indexToCoverage);
    private bool ChangeToCoveredStatus(CoverageStatus coverageStatus, CoverageStatus otherCoverageStatus);
    private ValueTuple`5<List`1<BlockLineDataMessage>, Dictionary`2<UInt32, byte>, Dictionary`2<UInt32, UInt32>, List`1<BlockLineDataMessage>, Dictionary`2<UInt32, byte>> GetFunctionWithMoreLines(Dictionary`2<UInt32, byte> functionIndexToCoverage, Dictionary`2<UInt32, byte> otherFunctionIndexToCoverage, Dictionary`2<UInt32, UInt32> functionOldToNewIndex, Dictionary`2<UInt32, UInt32> otherFunctionOldToNewIndex, List`1<BlockLineDataMessage> functionLines, List`1<BlockLineDataMessage> otherFunctionLines);
    private BlockLineDataMessage GenerateBlockLine(Dictionary`2<UInt32, byte> functionIndexToCoverage, Dictionary`2<UInt32, UInt32> functionOldToNewIndex, Dictionary`2<UInt32, byte> targetIndexToCoverage, List`1<BlockLineDataMessage> functionLines, BlockLineDataMessage line, byte coverage);
    private BlockLineDataMessage GenerateBlockLine(BlockLineDataMessage blockLine, Dictionary`2<UInt32, UInt32> functionOldToNewIndex, Dictionary`2<UInt32, byte> targetIndexToCoverage, byte coverage);
    private void UpdateFunctionData(UInt32 oldBlockIndex, UInt32 newBlockIndex, List`1<BlockLineDataMessage> functionBlockLineData, Dictionary`2<UInt32, byte> functionIndexToCoverage, Dictionary`2<UInt32, UInt32> functionOldToNewIndex, Dictionary`2<UInt32, byte> targetIndexToCoverage, byte coverage);
    private void StoreNonCommonLines(MergeFunctionData functionData, MergeFunctionData otherFunctionData, Dictionary`2<UInt32, UInt32> functionOldToNewIndex, Dictionary`2<UInt32, byte> targetIndexToCoverage, List`1<BlockLineDataMessage> targetBlockLineData);
    public sealed virtual IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> MergeSkipped(IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> skippedFunctions, IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> otherSkippedFunctions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Merge.ICoverageFileDataMerger {
    public abstract virtual MergeCoverageFileData MergeMessagesData(IReadOnlyCollection`1<MergeCoverageFileData> messages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Merge.IFunctionHasher {
    public abstract virtual string SHA256Hash(FunctionInstrumentedMessage message);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Merge.IFunctionMerger {
    public abstract virtual bool CanSlowMerge(MergeFunctionData function, MergeFunctionData otherFunction);
    public abstract virtual void FastMerge(MergeFunctionData function, MergeFunctionData otherFunction);
    public abstract virtual MergeFunctionData SlowMerge(MergeFunctionData function, MergeFunctionData otherFunction);
    public abstract virtual IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> MergeSkipped(IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> skippedFunctions, IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> otherSkippedFunctions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Merge.IModuleMerger {
    public abstract virtual bool CanFastMerge(MergeModuleData module, MergeModuleData otherModule);
    public abstract virtual bool CanSlowMerge(MergeModuleData module, MergeModuleData otherModule, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual void FastMerge(MergeModuleData module, MergeModuleData otherModule);
    public abstract virtual ValueTuple`3<MergeModuleData, int, int> SlowMerge(MergeModuleData module, MergeModuleData otherModule, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.LineDataKey : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    public UInt32 StartLine { get; public set; }
    public UInt32 EndLine { get; public set; }
    public UInt32 StartColumn { get; public set; }
    public UInt32 EndColumn { get; public set; }
    public UInt32 SourceId { get; public set; }
    public LineDataKey(UInt32 StartLine, UInt32 EndLine, UInt32 StartColumn, UInt32 EndColumn, UInt32 SourceId);
    [CompilerGeneratedAttribute]
public UInt32 get_StartLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceId(UInt32 value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(LineDataKey left, LineDataKey right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(LineDataKey left, LineDataKey right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LineDataKey other);
    [CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StartLine, UInt32& EndLine, UInt32& StartColumn, UInt32& EndColumn, UInt32& SourceId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.MergeCoverageFileData : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MergeModuleData> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ModuleSkippedMessage> <SkippedModules>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Index { get; public set; }
    public IList`1<MergeModuleData> Modules { get; public set; }
    public IDictionary`2<string, ModuleSkippedMessage> SkippedModules { get; public set; }
    public MergeCoverageFileData(int Index, IList`1<MergeModuleData> Modules, IDictionary`2<string, ModuleSkippedMessage> SkippedModules);
    [CompilerGeneratedAttribute]
protected MergeCoverageFileData(MergeCoverageFileData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Index(int value);
    [CompilerGeneratedAttribute]
public IList`1<MergeModuleData> get_Modules();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Modules(IList`1<MergeModuleData> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ModuleSkippedMessage> get_SkippedModules();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkippedModules(IDictionary`2<string, ModuleSkippedMessage> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MergeCoverageFileData left, MergeCoverageFileData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MergeCoverageFileData left, MergeCoverageFileData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MergeCoverageFileData other);
    [CompilerGeneratedAttribute]
public virtual MergeCoverageFileData <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Index, IList`1& Modules, IDictionary`2& SkippedModules);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.MergeFunctionData : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<UInt32, ValueTuple`2<UInt32, UInt32>> _ranges;
    [CompilerGeneratedAttribute]
private Dictionary`2<LineDataKey, List`1<BlockLineDataMessage>> <BlockLineData>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<UInt32, byte> <IndexToCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionInstrumentedMessage <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Dictionary`2<LineDataKey, List`1<BlockLineDataMessage>> BlockLineData { get; private set; }
    public Dictionary`2<UInt32, byte> IndexToCoverage { get; private set; }
    public FunctionInstrumentedMessage Function { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    public MergeFunctionData(FunctionInstrumentedMessage function, Byte[] coverageBuffer);
    [CompilerGeneratedAttribute]
protected MergeFunctionData(MergeFunctionData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Dictionary`2<LineDataKey, List`1<BlockLineDataMessage>> get_BlockLineData();
    [CompilerGeneratedAttribute]
private void set_BlockLineData(Dictionary`2<LineDataKey, List`1<BlockLineDataMessage>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<UInt32, byte> get_IndexToCoverage();
    [CompilerGeneratedAttribute]
private void set_IndexToCoverage(Dictionary`2<UInt32, byte> value);
    [CompilerGeneratedAttribute]
public FunctionInstrumentedMessage get_Function();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Function(FunctionInstrumentedMessage value);
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    public void ClearLineRanges();
    public Dictionary`2<UInt32, ValueTuple`2<UInt32, UInt32>> GetLinesRange();
    public void PopulateBlockLineData();
    public void PopulateIndexToCoverage();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MergeFunctionData left, MergeFunctionData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MergeFunctionData left, MergeFunctionData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MergeFunctionData other);
    [CompilerGeneratedAttribute]
public virtual MergeFunctionData <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.MergeModuleData : object {
    private ICoverageMessagesReader _coverageMessagesReader;
    [NullableAttribute("2")]
private string _hash;
    [NullableAttribute("2")]
private MergeModuleMessages _moduleMessages;
    [NullableAttribute("2")]
private string _path;
    private long _start;
    private long _end;
    private long _offset;
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ModuleBytes>k__BackingField;
    public ModuleInstrumentedMessage ModuleInstrumentedMessage { get; }
    public Byte[] CoverageBuffer { get; public set; }
    public Byte[] ModuleBytes { get; private set; }
    public string Hash { get; }
    public MergeModuleData(ModuleInstrumentedMessage moduleInstrumentedMessage, Byte[] coverageBuffer, string path, long start, long end, long offset, ICoverageMessagesReader coverageMessagesReader);
    public MergeModuleData(ModuleInstrumentedMessage moduleInstrumentedMessage, Byte[] moduleBytes, Byte[] coverageBuffer, MergeModuleMessages mergeModuleMessages, ICoverageMessagesReader coverageMessagesReader);
    [CompilerGeneratedAttribute]
public ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ModuleBytes();
    [CompilerGeneratedAttribute]
private void set_ModuleBytes(Byte[] value);
    public string get_Hash();
    public bool AreMessagesLoaded();
    public MergeModuleMessages GetMergeModuleMessages(ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public void LoadModuleBytes();
    [NullableContextAttribute("2")]
private MergeModuleMessages ProcessModuleMessages(ModuleMessages messages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.MergeModuleMessages : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<UInt32, SourceFileDataMessage> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<FunctionKey, IList`1<MergeFunctionData>> <Functions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> <SkippedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IDictionary`2<UInt32, SourceFileDataMessage> SourceFiles { get; public set; }
    public IDictionary`2<FunctionKey, IList`1<MergeFunctionData>> Functions { get; public set; }
    public IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> SkippedFunctions { get; public set; }
    public MergeModuleMessages(IDictionary`2<UInt32, SourceFileDataMessage> SourceFiles, IDictionary`2<FunctionKey, IList`1<MergeFunctionData>> Functions, IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> SkippedFunctions);
    [CompilerGeneratedAttribute]
protected MergeModuleMessages(MergeModuleMessages original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IDictionary`2<UInt32, SourceFileDataMessage> get_SourceFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceFiles(IDictionary`2<UInt32, SourceFileDataMessage> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<FunctionKey, IList`1<MergeFunctionData>> get_Functions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Functions(IDictionary`2<FunctionKey, IList`1<MergeFunctionData>> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> get_SkippedFunctions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkippedFunctions(IDictionary`2<SkippedFunctionKey, FunctionSkippedMessage> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MergeModuleMessages left, MergeModuleMessages right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MergeModuleMessages left, MergeModuleMessages right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MergeModuleMessages other);
    [CompilerGeneratedAttribute]
public virtual MergeModuleMessages <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IDictionary`2& SourceFiles, IDictionary`2& Functions, IDictionary`2& SkippedFunctions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.ModuleMerger : object {
    private IFunctionMerger _functionMerger;
    private ICoverageMessagesReader _coverageMessagesReader;
    private IFunctionHasher _functionHasher;
    [NullableAttribute("2")]
private ILogger _logger;
    public ModuleMerger(IFunctionMerger functionMerger, ICoverageMessagesReader coverageMessagesReader, IFunctionHasher functionHasher, ILogger logger);
    public sealed virtual bool CanFastMerge(MergeModuleData module, MergeModuleData otherModule);
    public sealed virtual bool CanSlowMerge(MergeModuleData module, MergeModuleData otherModule, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static bool HaveCommonSourceFiles(MergeModuleMessages module, MergeModuleMessages otherModule);
    public sealed virtual void FastMerge(MergeModuleData module, MergeModuleData otherModule);
    public sealed virtual ValueTuple`3<MergeModuleData, int, int> SlowMerge(MergeModuleData module, MergeModuleData otherModule, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static void UpdateFunctionsSourceFileIds(MergeModuleMessages messages, Dictionary`2<string, UInt32> pathToIdMap, Dictionary`2<string, UInt32> hashToIdMap, Dictionary`2<UInt32, SourceFileDataMessage> mergedSourceFiles);
    private static void UpdateFunctionSourceFileIds(IDictionary`2<UInt32, SourceFileDataMessage> sourceFiles, Dictionary`2<string, UInt32> pathToIdMap, Dictionary`2<string, UInt32> hashToIdMap, IDictionary`2<UInt32, SourceFileDataMessage> mergedSourceFiles, MergeFunctionData functionData);
    private static UInt32 AddSourceFile(IDictionary`2<UInt32, SourceFileDataMessage> sourceFiles, Dictionary`2<string, UInt32> hashToIdMap, Dictionary`2<string, UInt32> pathToIdMap, IDictionary`2<UInt32, SourceFileDataMessage> mergedSourceFiles, UInt32 lineDataSourceId);
    private int ProcessFunctions(MergeModuleMessages messages, Dictionary`2<FunctionKey, Dictionary`2<string, MergeFunctionData>> keysToFunctions);
    private int MergeFunctions(Dictionary`2<FunctionKey, Dictionary`2<string, MergeFunctionData>> keysToFunctions);
    private void MergeFunctions(string functionHash, Dictionary`2<string, MergeFunctionData> functions, Int32& slowMergeCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Merge.SkippedFunctionKey : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string Name { get; public set; }
    public string TypeName { get; public set; }
    public SkippedFunctionKey(string Name, string TypeName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeName(string value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SkippedFunctionKey left, SkippedFunctionKey right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SkippedFunctionKey left, SkippedFunctionKey right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SkippedFunctionKey other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, String& TypeName);
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Processor.CoverageBufferAdjuster : object {
    [NullableContextAttribute("1")]
public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
    [NullableContextAttribute("1")]
internal Byte[] AdjustCoverageBuffer(ModuleMessages moduleMessages, Byte[] coverageBuffer);
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Processor.DuplicateModuleRemover : object {
    [NullableContextAttribute("1")]
public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Processor.IMessagesProcessor {
    public abstract virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Processor.MessagesProcessor : object {
    private IMessagesProcessor[] _messagesProcessors;
    public MessagesProcessor(IMessagesProcessor[] messagesProcessors);
    public static MessagesProcessor GetDefaultMessageProcessor();
    public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Processor.ModuleDataMerger : object {
    public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Processor.ModuleDataMerger/<GetModuleData>d__2")]
private IEnumerable`1<ModuleMessagesData> GetModuleData(IList`1<ModuleMessages> modules, ConcurrentDictionary`2<Guid, Byte[]> coverageBuffers, ConcurrentDictionary`2<Guid, ConcurrentBag`1<PerSnapshotCoverageDataMessage>> perSnapshotCoverageMessages);
    private Nullable`1<ModuleMessagesData> GetModuleData(ModuleMessages moduleMessages, ConcurrentDictionary`2<Guid, Byte[]> coverageBuffers, ConcurrentDictionary`2<Guid, ConcurrentBag`1<PerSnapshotCoverageDataMessage>> perSnapshotCoverageMessages);
    private bool ContainsUniqueFunctionsOnly(IList`1<ModuleMessagesData> modules);
    internal ModuleMessagesData MergeModules(IList`1<ModuleMessagesData> modules);
    private static Dictionary`2<ValueTuple`2<UInt32, int>, UInt32> MergeSourceFiles(IList`1<ModuleMessagesData> modules, UniqueModuleMessages finalMessages);
    private static int MergeFunctions(IList`1<ModuleMessagesData> modules, UniqueModuleMessages messages, Dictionary`2<ValueTuple`2<UInt32, int>, UInt32> oldIdToNewIdMap);
    private static void MergeSkippedFunctions(IList`1<ModuleMessagesData> modules, UniqueModuleMessages messages);
    private Byte[] MergeCoverageBuffers(IList`1<ModuleMessagesData> modules, int finalCoverageBufferSize);
    private ConcurrentBag`1<PerSnapshotCoverageDataMessage> MergePerSnapshotCoverageDataMessages(IList`1<ModuleMessagesData> modules, int finalCoverageBufferSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Read.CoverageFileReader : object {
    private ICoverageHeaderReader _headerReader;
    private ICoverageMessagesReader _messagesReaderV1;
    private ICoverageMessagesReader _messagesReaderV2;
    private IMessagesProcessor _messagesProcessor;
    [NullableAttribute("2")]
private ILogger _logger;
    public CoverageFileReader(ICoverageHeaderReader headerReader, ICoverageMessagesReader messagesReaderV1, ICoverageMessagesReader messagesReaderV2, IMessagesProcessor messagesProcessor, ILogger logger);
    private ICoverageMessagesReader GetMessagesReader(ushort schemaVersion);
    public sealed virtual bool IsValidCoverageFile(string path);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Read.CoverageFileReader/<ReadCoverageFileAsync>d__8")]
public sealed virtual Task`1<CoverageFileMessages> ReadCoverageFileAsync(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public sealed virtual CoverageFileMessages ReadCoverageFile(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public sealed virtual CoverageBufferData ReadCoverageBufferFile(string path, CancellationToken cancellationToken);
    private void ProcessStream(ICoverageMessagesReader reader, StreamHeader streamHeader, Byte[] bytes, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void ProcessSkippedModuleStream(ICoverageMessagesReader reader, Byte[] bytes, int size, CoverageFileMessages coverageFileMessages, CancellationToken cancellationToken);
    private void ProcessCoverageData(ICoverageMessagesReader reader, Byte[] streamBytes, int size, Guid coverageBufferId, CoverageFileMessages coverageFileMessages);
    private void ProcessModuleDataStream(ICoverageMessagesReader reader, Byte[] bytes, int size, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void ProcessPerSnapshotCoverageDataStream(ICoverageMessagesReader reader, Byte[] bytes, int size, Guid identifier, CoverageFileMessages coverageFileMessages, CancellationToken cancellationToken);
    private void ProcessSnapshotTagsDataStream(ICoverageMessagesReader reader, Byte[] bytes, int size, CoverageFileMessages coverageFileMessages, CancellationToken cancellationToken);
    public sealed virtual MergeCoverageFileData ReadMergeCoverageFileData(string path, int index, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private MergeCoverageFileData ReadMergeData(string path, int index, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private ICoverageMessagesReader <ReadMergeData>g__GetMessagesReader|18_0(ushort schemaVersion);
    [CompilerGeneratedAttribute]
internal static MergeModuleData <ReadMergeData>g__ReadModuleData|18_1(BinaryReader reader, string path, IDictionary`2<Guid, Byte[]> coverageBuffers, long start, long end, ICoverageMessagesReader messagesReader, ushort schemaVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Read.CoverageHeaderReader : object {
    internal static ushort MaximumMessageSchemaVersion;
    [NullableAttribute("2")]
private ILogger _logger;
    [NullableContextAttribute("2")]
public CoverageHeaderReader(ILogger logger);
    public sealed virtual FileHeader ReadFileHeader(BinaryReader reader);
    public sealed virtual StreamHeader ReadStreamHeader(BinaryReader reader);
    public sealed virtual CoverageStreamHandle[] ReadStreamHeaders(BinaryReader reader, UInt32 streamsCount, CancellationToken cancellationToken);
    public sealed virtual void ReadStreamBytes(BinaryReader reader, CoverageStreamHandle streamHeader, Byte[] buffer);
    private void ValidateFileHeader(FileHeader fileHeader);
    private void ValidateStreamHeader(StreamHeader streamHeader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Core.IO.Coverage.Read.CoverageMessagesReader : object {
    [NullableAttribute("2")]
private ILogger _logger;
    protected ushort SchemaVersion { get; }
    [NullableContextAttribute("2")]
protected CoverageMessagesReader(ILogger logger);
    protected abstract virtual ushort get_SchemaVersion();
    public sealed virtual IList`1<ModuleSkippedMessage> ReadSkippedModules(Byte[] bytes, int size, CancellationToken cancellationToken);
    public sealed virtual ModuleMessages ReadModuleData(Byte[] bytes, int size, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public sealed virtual Byte[] ReadCoverageData(Byte[] bytes, int size);
    public sealed virtual PerSnapshotCoverageDataMessage ReadPerSnapshotCoverageData(Byte[] bytes, int size, Guid identifier, CancellationToken cancellationToken);
    public sealed virtual SnapshotTagsDataMessage ReadSnapshotTagsData(Byte[] bytes, int size, CancellationToken cancellationToken);
    public sealed virtual CoverageBufferData ReadCoverageBufferData(Byte[] bytes, int size, Guid identifier);
    private TResult ReadData(Byte[] bytes, int size, Func`2<CoverageFileMessageReader, TResult> action);
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Read.CoverageMessagesReaderV1 : CoverageMessagesReader {
    protected ushort SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesReaderV1(ILogger logger);
    protected virtual ushort get_SchemaVersion();
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Read.CoverageMessagesReaderV2 : CoverageMessagesReader {
    protected ushort SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesReaderV2(ILogger logger);
    protected virtual ushort get_SchemaVersion();
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Read.CoverageStreamHandle : ValueType {
    [CompilerGeneratedAttribute]
private StreamHeader <StreamHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    public StreamHeader StreamHeader { get; public set; }
    public long Start { get; public set; }
    public CoverageStreamHandle(StreamHeader StreamHeader, long Start);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StreamHeader get_StreamHeader();
    [CompilerGeneratedAttribute]
public void set_StreamHeader(StreamHeader value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CoverageStreamHandle left, CoverageStreamHandle right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CoverageStreamHandle left, CoverageStreamHandle right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CoverageStreamHandle other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(StreamHeader& StreamHeader, Int64& Start);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Read.ICoverageFileReader {
    public abstract virtual bool IsValidCoverageFile(string path);
    public abstract virtual CoverageFileMessages ReadCoverageFile(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual Task`1<CoverageFileMessages> ReadCoverageFileAsync(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual CoverageBufferData ReadCoverageBufferFile(string path, CancellationToken cancellationToken);
    public abstract virtual MergeCoverageFileData ReadMergeCoverageFileData(string path, int index, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Read.ICoverageHeaderReader {
    public abstract virtual FileHeader ReadFileHeader(BinaryReader reader);
    public abstract virtual StreamHeader ReadStreamHeader(BinaryReader reader);
    public abstract virtual CoverageStreamHandle[] ReadStreamHeaders(BinaryReader reader, UInt32 streamsCount, CancellationToken cancellationToken);
    public abstract virtual void ReadStreamBytes(BinaryReader reader, CoverageStreamHandle streamHeader, Byte[] buffer);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Read.ICoverageMessagesReader {
    public abstract virtual IList`1<ModuleSkippedMessage> ReadSkippedModules(Byte[] bytes, int size, CancellationToken cancellationToken);
    public abstract virtual ModuleMessages ReadModuleData(Byte[] bytes, int size, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual Byte[] ReadCoverageData(Byte[] bytes, int size);
    public abstract virtual PerSnapshotCoverageDataMessage ReadPerSnapshotCoverageData(Byte[] bytes, int size, Guid identifier, CancellationToken cancellationToken);
    public abstract virtual SnapshotTagsDataMessage ReadSnapshotTagsData(Byte[] bytes, int size, CancellationToken cancellationToken);
    public abstract virtual CoverageBufferData ReadCoverageBufferData(Byte[] bytes, int size, Guid identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Read.ModuleMessages : ValueType {
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SourceFileDataMessage> <SourceFileDataMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionInstrumentedMessage> <FunctionInstrumentedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionSkippedMessage> <FunctionSkippedMessages>k__BackingField;
    public ModuleInstrumentedMessage ModuleInstrumentedMessage { get; public set; }
    public IList`1<SourceFileDataMessage> SourceFileDataMessages { get; public set; }
    public IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; public set; }
    public IList`1<FunctionSkippedMessage> FunctionSkippedMessages { get; public set; }
    public ModuleMessages(ModuleInstrumentedMessage ModuleInstrumentedMessage, IList`1<SourceFileDataMessage> SourceFileDataMessages, IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages, IList`1<FunctionSkippedMessage> FunctionSkippedMessages);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [CompilerGeneratedAttribute]
public void set_ModuleInstrumentedMessage(ModuleInstrumentedMessage value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    [CompilerGeneratedAttribute]
public void set_SourceFileDataMessages(IList`1<SourceFileDataMessage> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    [CompilerGeneratedAttribute]
public void set_FunctionInstrumentedMessages(IList`1<FunctionInstrumentedMessage> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    [CompilerGeneratedAttribute]
public void set_FunctionSkippedMessages(IList`1<FunctionSkippedMessage> value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleMessages left, ModuleMessages right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleMessages left, ModuleMessages right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleMessages other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ModuleInstrumentedMessage& ModuleInstrumentedMessage, IList`1& SourceFileDataMessages, IList`1& FunctionInstrumentedMessages, IList`1& FunctionSkippedMessages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter : object {
    private ICoverageMessagesWriter _coverageMessagesWriterV1;
    private ICoverageMessagesWriter _coverageMessagesWriterV2;
    private IMessagesProcessor _messagesProcessor;
    [NullableAttribute("2")]
private ILogger _logger;
    public CoverageFileWriter(ICoverageMessagesWriter messagesWriterV1, ICoverageMessagesWriter messagesWriterV2, IMessagesProcessor messagesProcessor, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter/<WriteAsync>d__5")]
public sealed virtual Task WriteAsync(string path, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter/<WriteAsync>d__6")]
public sealed virtual Task WriteAsync(string path, ushort schemaVersion, MergeCoverageFileData coverageFileData, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter/<WriteAsync>d__7")]
private Task WriteAsync(string path, ushort schemaVersion, ICoverageFileConfiguration coverageFileConfiguration, Func`3<ICoverageMessagesWriter, ConcurrentBag`1<MemoryStream>, List`1<Task>> writeModules, CancellationToken cancellationToken);
    private List`1<Task> PrepareMergeCoverageFileMessagesTasks(ICoverageMessagesWriter messagesWriter, CoverageFileMessages coverageFileMessages, ConcurrentBag`1<MemoryStream> streams, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private List`1<Task> PrepareMergeCoverageFileDataTasks(ICoverageMessagesWriter messagesWriter, MergeCoverageFileData coverageFileData, ConcurrentBag`1<MemoryStream> streams, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter/<WriteSplitCoverageFilesAsync>d__10")]
public sealed virtual Task`1<IReadOnlyCollection`1<string>> WriteSplitCoverageFilesAsync(string outputFolder, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter/<WriteSplitCoverageFile>d__11")]
private Task WriteSplitCoverageFile(string outputFolder, ushort schemaVersion, ConcurrentBag`1<string> outputFiles, ModuleMessages module, Byte[] coverageBuffer, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void CheckPrerequisites(string path, int schemaVersion);
    private ICoverageMessagesWriter GetMessagesWriter(ushort schemaVersion);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter/<WriteModules>d__14")]
private Task WriteModules(ICoverageMessagesWriter messagesWriter, CoverageFileMessages coverageFileMessages, ConcurrentBag`1<MemoryStream> streams, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void WriteModule(ICoverageMessagesWriter messagesWriter, ModuleMessages module, ConcurrentBag`1<MemoryStream> streams, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageFileWriter/<WriteModules>d__16")]
private Task WriteModules(ICoverageMessagesWriter messagesWriter, IList`1<MergeModuleData> mergeModuleData, ConcurrentBag`1<MemoryStream> streams, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void WriteModuleCoverageData(ICoverageMessagesWriter messagesWriter, Guid coverageBufferId, Byte[] coverageBuffer, ConcurrentBag`1<MemoryStream> streams, CancellationToken cancellationToken);
    private void WriteSkippedModuleData(ICoverageMessagesWriter messagesWriter, ICollection`1<ModuleSkippedMessage> moduleMessages, ConcurrentBag`1<MemoryStream> streams, CancellationToken cancellationToken);
    private void WritePerSnapshotData(ICoverageMessagesWriter messagesWriter, CoverageFileMessages coverageFileMessages, ConcurrentBag`1<MemoryStream> streams, CancellationToken cancellationToken);
    private void WriteStream(Guid streamType, Guid identifier, ConcurrentBag`1<MemoryStream> streams, Action`1<BinaryWriter> writeStreamData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageMessagesWriter : object {
    [NullableAttribute("2")]
private ILogger _logger;
    protected int SchemaVersion { get; }
    [NullableContextAttribute("2")]
protected CoverageMessagesWriter(ILogger logger);
    protected abstract virtual int get_SchemaVersion();
    public sealed virtual void WriteModulesSkippedStream(BinaryWriter writer, IEnumerable`1<ModuleSkippedMessage> moduleMessages, CancellationToken cancellationToken);
    public sealed virtual void WriteCoverageDataStream(BinaryWriter writer, Byte[] coverageBuffer, CancellationToken cancellationToken);
    public sealed virtual void WriteModuleDataStream(BinaryWriter writer, ModuleMessages module, CancellationToken cancellationToken);
    public sealed virtual void WriteModuleDataStream(BinaryWriter writer, Byte[] bytes, CancellationToken cancellationToken);
    public sealed virtual void WritePerSnapshotCoverageDataStream(BinaryWriter writer, PerSnapshotCoverageDataMessage perSnapshotCoverageDataMessage, CancellationToken cancellationToken);
    public sealed virtual void WriteSnapshotTagsDataStream(BinaryWriter writer, SnapshotTagsDataMessage tests, CancellationToken cancellationToken);
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageMessagesWriterV1 : CoverageMessagesWriter {
    protected int SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesWriterV1(ILogger logger);
    protected virtual int get_SchemaVersion();
}
internal class Microsoft.CodeCoverage.Core.IO.Coverage.Write.CoverageMessagesWriterV2 : CoverageMessagesWriter {
    protected int SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesWriterV2(ILogger logger);
    protected virtual int get_SchemaVersion();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Write.ICoverageFileWriter {
    public abstract virtual Task WriteAsync(string path, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual Task WriteAsync(string path, ushort schemaVersion, MergeCoverageFileData coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual Task`1<IReadOnlyCollection`1<string>> WriteSplitCoverageFilesAsync(string outputFolder, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IO.Coverage.Write.ICoverageMessagesWriter {
    public abstract virtual void WriteModulesSkippedStream(BinaryWriter writer, IEnumerable`1<ModuleSkippedMessage> moduleMessages, CancellationToken cancellationToken);
    public abstract virtual void WriteCoverageDataStream(BinaryWriter writer, Byte[] coverageBuffer, CancellationToken cancellationToken);
    public abstract virtual void WriteModuleDataStream(BinaryWriter writer, ModuleMessages module, CancellationToken cancellationToken);
    public abstract virtual void WriteModuleDataStream(BinaryWriter writer, Byte[] bytes, CancellationToken cancellationToken);
    public abstract virtual void WritePerSnapshotCoverageDataStream(BinaryWriter writer, PerSnapshotCoverageDataMessage perSnapshotCoverageDataMessages, CancellationToken cancellationToken);
    public abstract virtual void WriteSnapshotTagsDataStream(BinaryWriter writer, SnapshotTagsDataMessage tests, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.CoverageFileMessageReader : BinaryMessageReader {
    private int _schemaVersion;
    private bool _readMessageSize;
    private UInt32 _currentMessageSize;
    public CoverageFileMessageReader(BinaryReader reader, long startOffset, long endOffset, bool sync, int schemaVersion);
    public virtual bool HasMessage(ushort messageTag);
    public void SkipCurrentMessage();
    public TestCoverageDataMessage ReadTestCoverageDataMessage();
    public ModuleBufferMessage ReadModuleBufferMessage();
    public ModuleInstrumentedMessage ReadModuleInstrumentedMessage();
    public SourceFileDataMessage ReadSourceFileDataMessage();
    public FunctionInstrumentedMessage ReadFunctionInstrumentedMessage();
    public FunctionSkippedMessage ReadFunctionSkippedMessage();
    public ModuleSkippedMessage ReadModuleSkippedMessage();
    public SnapshotIdsDataMessage ReadSnapshotIdsDataMessage();
    public CoverageBufferHashMessage ReadCoverageBufferHashMessage();
    public SnapshotTagsDataMessage ReadSnapshotTagsInformationDataMessage();
    [CompilerGeneratedAttribute]
private SnapshotTag <ReadSnapshotTagsInformationDataMessage>b__15_0(BinaryReader r);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.IO.CoverageFileObjectsFactory : object {
    public static ValueTuple`2<IReportsReader, IReportsMerger> CreateReportsReaderAndMerger(ICoverageFileConfiguration coverageFileConfiguration, ILogger logger);
    public static ValueTuple`3<ICoverageFileReader, IReportsReader, IReportsMerger> CreateUtilityObjects(ICoverageFileConfiguration coverageFileConfiguration, ILogger logger);
}
internal class Microsoft.CodeCoverage.Core.IO.FileHeader : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MessageSchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StreamsCount>k__BackingField;
    public UInt32 Magic { get; public set; }
    public ushort MessageSchemaVersion { get; public set; }
    public UInt32 StreamsCount { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Magic();
    [CompilerGeneratedAttribute]
public void set_Magic(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ushort get_MessageSchemaVersion();
    [CompilerGeneratedAttribute]
public void set_MessageSchemaVersion(ushort value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamsCount();
    [CompilerGeneratedAttribute]
public void set_StreamsCount(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.InterprocessMessageReader : BinaryMessageReader {
    public InterprocessMessageReader(BinaryReader reader, long startOffset, long endOffset, bool sync);
    public SuccessMessage ReadSuccessMessage();
    public RegisterClientMessage ReadRegisterClientMessage();
    public RegisterClientResponseMessage ReadRegisterClientResponseMessage();
    public CreateStreamMessage ReadCreateStreamMessage();
    public CreateStreamResponseMessage ReadCreateStreamResponseMessage();
    public WriteStreamMessage ReadWriteStreamMessage();
    public CloseStreamMessage ReadCloseStreamMessage();
    public ClientErrorMessage ReadClientErrorMessage();
    public ShutdownMessage ReadShutdownMessage();
    public WriteStreamBuffersMessage ReadWriteStreamBuffersMessage();
    public ConfigLoggerMessage ReadConfigLoggerMessage();
    public GetCoverageDataMessage ReadGetCoverageDataMessage();
    public InitializeClientMessage ReadInitializeClientMessage();
    public InitializeClientResponseMessage ReadInitializeClientResponseMessage();
    public LoadModuleDataMessage ReadLoadModuleDataMessage();
    public InstrumentedModuleMessage ReadInstrumentedModuleMessage();
    public InstrumentedFunctionMessage ReadInstrumentedFunctionMessage();
    public PreloadModuleDataMessage ReadPreloadModuleDataMessage();
    public PreloadModuleDataResponseMessage ReadPreloadModuleDataResponseMessage();
    public GetInformationMessage ReadGetInformationMessage();
    public GetInformationResponseMessage ReadGetInformationResponseMessage();
    public ShutdownLoggerMessage ReadShutdownLoggerMessage();
    public InstrumentationStatisticsMessage ReadInstrumentationStatisticsMessage();
    public GenerateReportsRequestMessage ReadGenerateReportsRequestMessage();
    public CacheMessage ReadCacheMessage();
    public FetchCacheMessage ReadFetchCacheMessage();
    public SnapshotMessage ReadSnapshotMessage();
    public FilePathsMessage ReadFilePathsMessage();
    internal static BufferMessage ReadBufferMessage(BinaryReader reader);
}
internal class Microsoft.CodeCoverage.Core.IO.MessagePosition : ValueType {
    [CompilerGeneratedAttribute]
private long <StartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TagPosition>k__BackingField;
    public long StartPosition { get; public set; }
    public long TagPosition { get; public set; }
    public MessagePosition(long StartPosition, long TagPosition);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_StartPosition();
    [CompilerGeneratedAttribute]
public void set_StartPosition(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TagPosition();
    [CompilerGeneratedAttribute]
public void set_TagPosition(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MessagePosition left, MessagePosition right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MessagePosition left, MessagePosition right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(MessagePosition other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Int64& StartPosition, Int64& TagPosition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.RawStream : ValueType {
    [CompilerGeneratedAttribute]
private StreamHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public StreamHeader Header { get; public set; }
    public Byte[] Data { get; public set; }
    public RawStream(StreamHeader Header, Byte[] Data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StreamHeader get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(StreamHeader value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RawStream left, RawStream right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RawStream left, RawStream right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RawStream other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(StreamHeader& Header, Byte[]& Data);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.CodeCoverage.Core.IO.StreamHeader : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StreamSize>k__BackingField;
    public UInt32 Magic { get; public set; }
    public Guid StreamType { get; public set; }
    public Guid Identifier { get; public set; }
    public UInt32 StreamSize { get; public set; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Magic();
    [CompilerGeneratedAttribute]
public void set_Magic(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public void set_StreamType(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamSize();
    [CompilerGeneratedAttribute]
public void set_StreamSize(UInt32 value);
    [NullableContextAttribute("1")]
private string get_DebuggerDisplay();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamHeader left, StreamHeader right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamHeader left, StreamHeader right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(StreamHeader other);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IStreamNameGenerator {
    public abstract virtual string GetStreamNamePrefix(string sessionName);
    public abstract virtual string GenerateStreamName(string streamName, Guid streamType, string sessionName, Guid identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Logger.NullLogger : object {
    public sealed virtual void LogError(string message);
    public sealed virtual void LogError(Exception exceptionToTrace);
    public sealed virtual void LogInfo(string message);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogWarning(string message);
}
public enum Microsoft.CodeCoverage.Core.MergeStrategy : Enum {
    public int value__;
    public static MergeStrategy Legacy;
    public static MergeStrategy Squash;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.BufferMessage : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    public static ushort MessageTag;
    public Byte[] Buffer { get; public set; }
    public BufferMessage(Byte[] Buffer);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public void set_Buffer(Byte[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BufferMessage left, BufferMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BufferMessage left, BufferMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BufferMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Byte[]& Buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.CacheMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferMessage[] <Cache>k__BackingField;
    public static ushort MessageTag;
    public Guid Key { get; public set; }
    public string Prefix { get; public set; }
    public BufferMessage[] Cache { get; public set; }
    public CacheMessage(Guid Key, string Prefix, BufferMessage[] Cache);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BufferMessage[] get_Cache();
    [CompilerGeneratedAttribute]
public void set_Cache(BufferMessage[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CacheMessage left, CacheMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CacheMessage left, CacheMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CacheMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Key, String& Prefix, BufferMessage[]& Cache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.ClientErrorMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ErrorCode>k__BackingField;
    public static ushort MessageTag;
    public string Message { get; public set; }
    public String[] Arguments { get; public set; }
    public UInt32 ErrorCode { get; public set; }
    public ClientErrorMessage(string Message, String[] Arguments, UInt32 ErrorCode);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(String[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ClientErrorMessage left, ClientErrorMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ClientErrorMessage left, ClientErrorMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ClientErrorMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Message, String[]& Arguments, UInt32& ErrorCode);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.CloseStreamMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discard>k__BackingField;
    public static ushort MessageTag;
    public UInt32 StreamId { get; public set; }
    public bool Discard { get; public set; }
    public CloseStreamMessage(UInt32 StreamId, bool Discard);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Discard();
    [CompilerGeneratedAttribute]
public void set_Discard(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CloseStreamMessage left, CloseStreamMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CloseStreamMessage left, CloseStreamMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CloseStreamMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StreamId, Boolean& Discard);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.ConfigLoggerMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ConfigLoggerMessage left, ConfigLoggerMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ConfigLoggerMessage left, ConfigLoggerMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConfigLoggerMessage other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.CreateStreamMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoClose>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public static ushort MessageTag;
    public Guid StreamType { get; public set; }
    public Guid Identifier { get; public set; }
    public bool AutoClose { get; public set; }
    public string BufferName { get; public set; }
    public UInt32 BufferSize { get; public set; }
    public string BufferHeader { get; public set; }
    public Guid Key { get; public set; }
    public string Prefix { get; public set; }
    public CreateStreamMessage(Guid StreamType, Guid Identifier, bool AutoClose, string BufferName, UInt32 BufferSize, string BufferHeader, Guid Key, string Prefix);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public void set_StreamType(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AutoClose();
    [CompilerGeneratedAttribute]
public void set_AutoClose(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferName();
    [CompilerGeneratedAttribute]
public void set_BufferName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferHeader();
    [CompilerGeneratedAttribute]
public void set_BufferHeader(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CreateStreamMessage left, CreateStreamMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CreateStreamMessage left, CreateStreamMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CreateStreamMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& StreamType, Guid& Identifier, Boolean& AutoClose, String& BufferName, UInt32& BufferSize, String& BufferHeader, Guid& Key, String& Prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.CreateStreamResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discard>k__BackingField;
    public static ushort MessageTag;
    public UInt32 StreamId { get; public set; }
    public string BufferName { get; public set; }
    public bool Discard { get; public set; }
    public CreateStreamResponseMessage(UInt32 StreamId, string BufferName, bool Discard);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferName();
    [CompilerGeneratedAttribute]
public void set_BufferName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Discard();
    [CompilerGeneratedAttribute]
public void set_Discard(bool value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CreateStreamResponseMessage left, CreateStreamResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CreateStreamResponseMessage left, CreateStreamResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CreateStreamResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StreamId, String& BufferName, Boolean& Discard);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.FetchCacheMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public static ushort MessageTag;
    public Guid Key { get; public set; }
    public string Prefix { get; public set; }
    public FetchCacheMessage(Guid Key, string Prefix);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FetchCacheMessage left, FetchCacheMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FetchCacheMessage left, FetchCacheMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FetchCacheMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Key, String& Prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.FilePathsMessage : ValueType {
    [CompilerGeneratedAttribute]
private String[] <FilePaths>k__BackingField;
    public static ushort MessageTag;
    public String[] FilePaths { get; public set; }
    public FilePathsMessage(String[] FilePaths);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_FilePaths();
    [CompilerGeneratedAttribute]
public void set_FilePaths(String[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FilePathsMessage left, FilePathsMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FilePathsMessage left, FilePathsMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FilePathsMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String[]& FilePaths);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.GenerateReportsRequestMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GenerateReportsRequestMessage left, GenerateReportsRequestMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GenerateReportsRequestMessage left, GenerateReportsRequestMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GenerateReportsRequestMessage other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.GetCoverageDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    public static ushort MessageTag;
    public string OutputFilePath { get; public set; }
    public GetCoverageDataMessage(string OutputFilePath);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public void set_OutputFilePath(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GetCoverageDataMessage left, GetCoverageDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GetCoverageDataMessage left, GetCoverageDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GetCoverageDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& OutputFilePath);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.GetInformationMessage : ValueType {
    [CompilerGeneratedAttribute]
private InformationType <InformationType>k__BackingField;
    public static ushort MessageTag;
    public InformationType InformationType { get; public set; }
    public GetInformationMessage(InformationType InformationType);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InformationType get_InformationType();
    [CompilerGeneratedAttribute]
public void set_InformationType(InformationType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GetInformationMessage left, GetInformationMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GetInformationMessage left, GetInformationMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GetInformationMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(InformationType& InformationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.GetInformationResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public static ushort MessageTag;
    public string Information { get; public set; }
    public GetInformationResponseMessage(string Information);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
public void set_Information(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GetInformationResponseMessage left, GetInformationResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GetInformationResponseMessage left, GetInformationResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GetInformationResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Information);
}
internal enum Microsoft.CodeCoverage.Core.Messages.Control.InformationType : Enum {
    public int value__;
    public static InformationType DataCollector;
    public static InformationType CodeCoverage;
    public static InformationType LoggerProcessId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InitializeClientMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessOwnerSid>k__BackingField;
    public static ushort MessageTag;
    public UInt32 SchemaVersion { get; public set; }
    public UInt32 ProcessId { get; public set; }
    public string Path { get; public set; }
    public string ProcessOwnerSid { get; public set; }
    public InitializeClientMessage(UInt32 SchemaVersion, UInt32 ProcessId, string Path, string ProcessOwnerSid);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProcessOwnerSid();
    [CompilerGeneratedAttribute]
public void set_ProcessOwnerSid(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InitializeClientMessage left, InitializeClientMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InitializeClientMessage left, InitializeClientMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InitializeClientMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& SchemaVersion, UInt32& ProcessId, String& Path, String& ProcessOwnerSid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InitializeClientResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsCodeCoverageEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CommunicationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public static ushort MessageTag;
    public bool IsCodeCoverageEnabled { get; public set; }
    public UInt32 CommunicationTimeout { get; public set; }
    public string Path { get; public set; }
    public InitializeClientResponseMessage(bool IsCodeCoverageEnabled, UInt32 CommunicationTimeout, string Path);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
public void set_IsCodeCoverageEnabled(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_CommunicationTimeout();
    [CompilerGeneratedAttribute]
public void set_CommunicationTimeout(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InitializeClientResponseMessage left, InitializeClientResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InitializeClientResponseMessage left, InitializeClientResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InitializeClientResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsCodeCoverageEnabled, UInt32& CommunicationTimeout, String& Path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InstrumentationStatisticsMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CoverageBufferId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Dynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Managed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mixed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PortablePdb>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Instrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Failed>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Elapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    public static ushort MessageTag;
    public Guid Id { get; public set; }
    public Guid CoverageBufferId { get; public set; }
    public string Path { get; public set; }
    public bool Dynamic { get; public set; }
    public bool Managed { get; public set; }
    public bool Mixed { get; public set; }
    public bool PortablePdb { get; public set; }
    public UInt32 ModuleSize { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    public UInt32 Instrumented { get; public set; }
    public UInt32 Skipped { get; public set; }
    public UInt32 Failed { get; public set; }
    public UInt32 Elapsed { get; public set; }
    public String[] Properties { get; public set; }
    public InstrumentationStatisticsMessage(Guid Id, Guid CoverageBufferId, string Path, bool Dynamic, bool Managed, bool Mixed, bool PortablePdb, UInt32 ModuleSize, UInt32 ModuleLinkTime, UInt32 Instrumented, UInt32 Skipped, UInt32 Failed, UInt32 Elapsed, String[] Properties);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_CoverageBufferId();
    [CompilerGeneratedAttribute]
public void set_CoverageBufferId(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Dynamic();
    [CompilerGeneratedAttribute]
public void set_Dynamic(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Managed();
    [CompilerGeneratedAttribute]
public void set_Managed(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Mixed();
    [CompilerGeneratedAttribute]
public void set_Mixed(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_PortablePdb();
    [CompilerGeneratedAttribute]
public void set_PortablePdb(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleSize();
    [CompilerGeneratedAttribute]
public void set_ModuleSize(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Instrumented();
    [CompilerGeneratedAttribute]
public void set_Instrumented(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Failed();
    [CompilerGeneratedAttribute]
public void set_Failed(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Elapsed();
    [CompilerGeneratedAttribute]
public void set_Elapsed(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(String[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InstrumentationStatisticsMessage left, InstrumentationStatisticsMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InstrumentationStatisticsMessage left, InstrumentationStatisticsMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstrumentationStatisticsMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Id, Guid& CoverageBufferId, String& Path, Boolean& Dynamic, Boolean& Managed, Boolean& Mixed, Boolean& PortablePdb, UInt32& ModuleSize, UInt32& ModuleLinkTime, UInt32& Instrumented, UInt32& Skipped, UInt32& Failed, UInt32& Elapsed, String[]& Properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InstrumentedFunctionMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <FunctionBlocks>k__BackingField;
    public static ushort MessageTag;
    public UInt32 MetadataToken { get; public set; }
    public UInt32 Offset { get; public set; }
    public IList`1<int> FunctionBlocks { get; public set; }
    public InstrumentedFunctionMessage(UInt32 MetadataToken, UInt32 Offset, IList`1<int> FunctionBlocks);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<int> get_FunctionBlocks();
    [CompilerGeneratedAttribute]
public void set_FunctionBlocks(IList`1<int> value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InstrumentedFunctionMessage left, InstrumentedFunctionMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InstrumentedFunctionMessage left, InstrumentedFunctionMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstrumentedFunctionMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& MetadataToken, UInt32& Offset, IList`1& FunctionBlocks);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InstrumentedModuleMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BufferSize>k__BackingField;
    public static ushort MessageTag;
    public string BufferName { get; public set; }
    public UInt32 BufferSize { get; public set; }
    public InstrumentedModuleMessage(string BufferName, UInt32 BufferSize);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferName();
    [CompilerGeneratedAttribute]
public void set_BufferName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InstrumentedModuleMessage left, InstrumentedModuleMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InstrumentedModuleMessage left, InstrumentedModuleMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstrumentedModuleMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& BufferName, UInt32& BufferSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.LoadModuleDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    public static ushort MessageTag;
    public string ModulePath { get; public set; }
    public Guid Mvid { get; public set; }
    public LoadModuleDataMessage(string ModulePath, Guid Mvid);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public void set_ModulePath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Mvid();
    [CompilerGeneratedAttribute]
public void set_Mvid(Guid value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(LoadModuleDataMessage left, LoadModuleDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(LoadModuleDataMessage left, LoadModuleDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(LoadModuleDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& ModulePath, Guid& Mvid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.PreloadModuleDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    public static ushort MessageTag;
    public string ModulePath { get; public set; }
    public PreloadModuleDataMessage(string ModulePath);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public void set_ModulePath(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PreloadModuleDataMessage left, PreloadModuleDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PreloadModuleDataMessage left, PreloadModuleDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PreloadModuleDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& ModulePath);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.PreloadModuleDataResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsSupported>k__BackingField;
    public static ushort MessageTag;
    public bool IsSupported { get; public set; }
    public PreloadModuleDataResponseMessage(bool IsSupported);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsSupported();
    [CompilerGeneratedAttribute]
public void set_IsSupported(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PreloadModuleDataResponseMessage left, PreloadModuleDataResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PreloadModuleDataResponseMessage left, PreloadModuleDataResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PreloadModuleDataResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsSupported);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.RegisterClientMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessOwnerSid>k__BackingField;
    public static ushort MessageTag;
    public UInt32 SchemaVersion { get; public set; }
    public UInt32 ProcessId { get; public set; }
    public string ProcessOwnerSid { get; public set; }
    public RegisterClientMessage(UInt32 SchemaVersion, UInt32 ProcessId, string ProcessOwnerSid);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProcessOwnerSid();
    [CompilerGeneratedAttribute]
public void set_ProcessOwnerSid(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RegisterClientMessage left, RegisterClientMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RegisterClientMessage left, RegisterClientMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RegisterClientMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& SchemaVersion, UInt32& ProcessId, String& ProcessOwnerSid);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.RegisterClientResponseMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RegisterClientResponseMessage left, RegisterClientResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RegisterClientResponseMessage left, RegisterClientResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RegisterClientResponseMessage other);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.ShutdownLoggerMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ShutdownLoggerMessage left, ShutdownLoggerMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ShutdownLoggerMessage left, ShutdownLoggerMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ShutdownLoggerMessage other);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.ShutdownMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ShutdownMessage left, ShutdownMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ShutdownMessage left, ShutdownMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ShutdownMessage other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.SnapshotMessage : ValueType {
    [CompilerGeneratedAttribute]
private bool <Reset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    public static ushort MessageTag;
    public bool Reset { get; public set; }
    public string OutputFilePath { get; public set; }
    public string TagId { get; public set; }
    public string TagName { get; public set; }
    public SnapshotMessage(bool Reset, string OutputFilePath, string TagId, string TagName);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Reset();
    [CompilerGeneratedAttribute]
public void set_Reset(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public void set_OutputFilePath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TagId();
    [CompilerGeneratedAttribute]
public void set_TagId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TagName();
    [CompilerGeneratedAttribute]
public void set_TagName(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotMessage left, SnapshotMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotMessage left, SnapshotMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Boolean& Reset, String& OutputFilePath, String& TagId, String& TagName);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.SuccessMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SuccessMessage left, SuccessMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SuccessMessage left, SuccessMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SuccessMessage other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.WriteStreamBuffersMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetBuffers>k__BackingField;
    public static ushort MessageTag;
    public Guid StreamType { get; public set; }
    public string BufferHeader { get; public set; }
    public bool ResetBuffers { get; public set; }
    public WriteStreamBuffersMessage(Guid StreamType, string BufferHeader, bool ResetBuffers);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public void set_StreamType(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferHeader();
    [CompilerGeneratedAttribute]
public void set_BufferHeader(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ResetBuffers();
    [CompilerGeneratedAttribute]
public void set_ResetBuffers(bool value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(WriteStreamBuffersMessage left, WriteStreamBuffersMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(WriteStreamBuffersMessage left, WriteStreamBuffersMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(WriteStreamBuffersMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& StreamType, String& BufferHeader, Boolean& ResetBuffers);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.WriteStreamMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    public static ushort MessageTag;
    public UInt32 StreamId { get; public set; }
    public WriteStreamMessage(UInt32 StreamId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(WriteStreamMessage left, WriteStreamMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(WriteStreamMessage left, WriteStreamMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(WriteStreamMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StreamId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.CoverageData.ModuleBufferMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    public static ushort MessageTag;
    public string Name { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    public ModuleBufferMessage(string Name, UInt32 ModuleLinkTime);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleBufferMessage left, ModuleBufferMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleBufferMessage left, ModuleBufferMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleBufferMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Name, UInt32& ModuleLinkTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.CoverageData.TestCoverageDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <TestId>k__BackingField;
    public static ushort MessageTag;
    public string TestId { get; public set; }
    public TestCoverageDataMessage(string TestId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TestId();
    [CompilerGeneratedAttribute]
public void set_TestId(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TestCoverageDataMessage left, TestCoverageDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TestCoverageDataMessage left, TestCoverageDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TestCoverageDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& TestId);
}
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.BlockLineDataMessage : ValueType {
    public static ushort MessageTag;
    [CompilerGeneratedAttribute]
private UInt32 <BlockIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndColumn>k__BackingField;
    public UInt32 BlockIndex { get; public set; }
    public UInt32 SourceId { get; public set; }
    public UInt32 StartLine { get; public set; }
    public UInt32 StartColumn { get; public set; }
    public UInt32 EndLine { get; public set; }
    public UInt32 EndColumn { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BlockIndex();
    [CompilerGeneratedAttribute]
public void set_BlockIndex(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StartLine();
    [CompilerGeneratedAttribute]
public void set_StartLine(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StartColumn();
    [CompilerGeneratedAttribute]
public void set_StartColumn(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(UInt32 value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.FunctionInstrumentedMessage : object {
    public static ushort MessageTag;
    [CompilerGeneratedAttribute]
private UInt32 <FunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FunctionRva>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartBlockIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockLineDataMessage[] <LineData>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public UInt32 FunctionId { get; public set; }
    public UInt32 FunctionRva { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public UInt32 StartBlockIndex { get; public set; }
    public UInt32 BlockCount { get; public set; }
    public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string NamespaceName { get; public set; }
    public BlockLineDataMessage[] LineData { get; public set; }
    [CompilerGeneratedAttribute]
protected FunctionInstrumentedMessage(FunctionInstrumentedMessage original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public UInt32 get_FunctionId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FunctionId(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_FunctionRva();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FunctionRva(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MetadataToken(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartBlockIndex();
    [CompilerGeneratedAttribute]
public void set_StartBlockIndex(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
public void set_BlockCount(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public BlockLineDataMessage[] get_LineData();
    [CompilerGeneratedAttribute]
public void set_LineData(BlockLineDataMessage[] value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FunctionInstrumentedMessage left, FunctionInstrumentedMessage right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FunctionInstrumentedMessage left, FunctionInstrumentedMessage right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(FunctionInstrumentedMessage other);
    [CompilerGeneratedAttribute]
public virtual FunctionInstrumentedMessage <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.FunctionSkippedMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <FunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OriginalFunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionSkipReason <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    public static ushort MessageTag;
    public UInt32 FunctionId { get; public set; }
    public UInt32 OriginalFunctionId { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public FunctionSkipReason SkipReason { get; public set; }
    public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string ExceptionMessage { get; public set; }
    public FunctionSkippedMessage(UInt32 FunctionId, UInt32 OriginalFunctionId, UInt32 MetadataToken, FunctionSkipReason SkipReason, string Name, string TypeName, string ExceptionMessage);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_FunctionId();
    [CompilerGeneratedAttribute]
public void set_FunctionId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_OriginalFunctionId();
    [CompilerGeneratedAttribute]
public void set_OriginalFunctionId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FunctionSkipReason get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(FunctionSkipReason value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FunctionSkippedMessage left, FunctionSkippedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FunctionSkippedMessage left, FunctionSkippedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FunctionSkippedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& FunctionId, UInt32& OriginalFunctionId, UInt32& MetadataToken, FunctionSkipReason& SkipReason, String& Name, String& TypeName, String& ExceptionMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.ModuleInstrumentedMessage : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <ModuleIdentifierBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CoverageBufferId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Architecture>k__BackingField;
    public static ushort MessageTag;
    public Byte[] ModuleIdentifierBytes { get; public set; }
    public Guid CoverageBufferId { get; public set; }
    public string Path { get; public set; }
    public UInt32 ModuleSize { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    public string TargetFramework { get; public set; }
    public string Configuration { get; public set; }
    public string Architecture { get; public set; }
    public string ModuleIdentifier { get; }
    public string FileName { get; }
    public ModuleInstrumentedMessage(Byte[] ModuleIdentifierBytes, Guid CoverageBufferId, string Path, UInt32 ModuleSize, UInt32 ModuleLinkTime, string TargetFramework, string Configuration, string Architecture);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_ModuleIdentifierBytes();
    [CompilerGeneratedAttribute]
public void set_ModuleIdentifierBytes(Byte[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_CoverageBufferId();
    [CompilerGeneratedAttribute]
public void set_CoverageBufferId(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleSize();
    [CompilerGeneratedAttribute]
public void set_ModuleSize(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Architecture();
    [CompilerGeneratedAttribute]
public void set_Architecture(string value);
    public string get_ModuleIdentifier();
    public string get_FileName();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleInstrumentedMessage left, ModuleInstrumentedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleInstrumentedMessage left, ModuleInstrumentedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleInstrumentedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Byte[]& ModuleIdentifierBytes, Guid& CoverageBufferId, String& Path, UInt32& ModuleSize, UInt32& ModuleLinkTime, String& TargetFramework, String& Configuration, String& Architecture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.NotSupportedMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public static ushort MessageTag;
    public string Message { get; public set; }
    public NotSupportedMessage(string Message);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NotSupportedMessage left, NotSupportedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NotSupportedMessage left, NotSupportedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(NotSupportedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.SourceFileDataMessage : object {
    public static ushort MessageTag;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ChecksumType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    public UInt32 SourceId { get; public set; }
    public string Path { get; public set; }
    public UInt32 ChecksumType { get; public set; }
    public Byte[] Checksum { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Path(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_ChecksumType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChecksumType(UInt32 value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Checksum(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModulesSkipped.ModuleSkippedMessage : ValueType {
    [CompilerGeneratedAttribute]
private ModuleSkipReason <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    public static ushort MessageTag;
    public ModuleSkipReason SkipReason { get; public set; }
    public string Path { get; public set; }
    public string ExceptionMessage { get; public set; }
    public ModuleSkippedMessage(ModuleSkipReason SkipReason, string Path, string ExceptionMessage);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ModuleSkipReason get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(ModuleSkipReason value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleSkippedMessage left, ModuleSkippedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleSkippedMessage left, ModuleSkippedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleSkippedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ModuleSkipReason& SkipReason, String& Path, String& ExceptionMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.PerSnapshotCoverageData.CoverageBufferHashMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <HashName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferHash>k__BackingField;
    public static ushort MessageTag;
    public string HashName { get; public set; }
    public string BufferHash { get; public set; }
    public CoverageBufferHashMessage(string HashName, string BufferHash);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_HashName();
    [CompilerGeneratedAttribute]
public void set_HashName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferHash();
    [CompilerGeneratedAttribute]
public void set_BufferHash(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CoverageBufferHashMessage left, CoverageBufferHashMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CoverageBufferHashMessage left, CoverageBufferHashMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CoverageBufferHashMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& HashName, String& BufferHash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.PerSnapshotCoverageData.SnapshotIdsDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private String[] <SnapshotIds>k__BackingField;
    public static ushort MessageTag;
    public String[] SnapshotIds { get; public set; }
    public SnapshotIdsDataMessage(String[] SnapshotIds);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_SnapshotIds();
    [CompilerGeneratedAttribute]
public void set_SnapshotIds(String[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotIdsDataMessage left, SnapshotIdsDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotIdsDataMessage left, SnapshotIdsDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotIdsDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String[]& SnapshotIds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.SnapshotTagsData.SnapshotTagsDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private SnapshotTag[] <SnapshotTags>k__BackingField;
    public static ushort MessageTag;
    public SnapshotTag[] SnapshotTags { get; public set; }
    public SnapshotTagsDataMessage(SnapshotTag[] SnapshotTags);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SnapshotTag[] get_SnapshotTags();
    [CompilerGeneratedAttribute]
public void set_SnapshotTags(SnapshotTag[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotTagsDataMessage left, SnapshotTagsDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotTagsDataMessage left, SnapshotTagsDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotTagsDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(SnapshotTag[]& SnapshotTags);
}
public enum Microsoft.CodeCoverage.Core.ModuleSkipReason : Enum {
    public int value__;
    public static ModuleSkipReason no_symbols;
    public static ModuleSkipReason path_is_excluded;
    public static ModuleSkipReason public_key_token_is_excluded;
    public static ModuleSkipReason company_name_is_excluded;
    public static ModuleSkipReason optimized_or_instrumented;
    public static ModuleSkipReason has_fixed_base;
    public static ModuleSkipReason nothing_instrumented;
    public static ModuleSkipReason instrumentation_failure;
    public static ModuleSkipReason configuration_changed;
    public static ModuleSkipReason module_compiler_generated;
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Native.INativeHelper {
    public abstract virtual IntPtr LoadLibrary(string dllToLoad);
    public abstract virtual IntPtr GetProcAddress(IntPtr hModule, string procedureName);
    public abstract virtual bool FreeLibrary(IntPtr hModule);
    public abstract virtual bool CloseHandle(IntPtr hObject);
    public abstract virtual Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public abstract virtual bool LookupPrivilegeValue(string lpSystemName, string lpName, Int64& lpLuid);
    public abstract virtual bool OpenProcessToken(IntPtr processHandle, TokenAccess desiredAccess, IntPtr& tokenHandle);
    public abstract virtual bool GetTokenInformation(IntPtr tokenHandle, TokenInformationClass tokenInformationClass, TokenPrivileges& tokenInformation, int tokenInformationLength, Int32& returnLength);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Native.IPrivilegeChecker {
    public abstract virtual bool IsPrivilegeEnabled(string privilegeName);
}
internal class Microsoft.CodeCoverage.Core.Native.LuidAndAttributes : ValueType {
    public long Luid;
    public SePrivilege Attributes;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Native.NativeHelper : object {
    public sealed virtual IntPtr LoadLibrary(string dllToLoad);
    public sealed virtual IntPtr GetProcAddress(IntPtr hModule, string procedureName);
    public sealed virtual bool FreeLibrary(IntPtr hModule);
    public sealed virtual bool CloseHandle(IntPtr hObject);
    public sealed virtual Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public sealed virtual bool LookupPrivilegeValue(string lpSystemName, string lpName, Int64& lpLuid);
    public sealed virtual bool OpenProcessToken(IntPtr processHandle, TokenAccess desiredAccess, IntPtr& tokenHandle);
    public sealed virtual bool GetTokenInformation(IntPtr tokenHandle, TokenInformationClass tokenInformationClass, TokenPrivileges& tokenInformation, int tokenInformationLength, Int32& returnLength);
}
internal class Microsoft.CodeCoverage.Core.Native.NopPrivilegeChecker : object {
    [NullableContextAttribute("1")]
public sealed virtual bool IsPrivilegeEnabled(string privilegeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Native.PrivilegeChecker : object {
    private IEnvironment _environment;
    private INativeHelper _nativeHelper;
    private ILogger _logger;
    public PrivilegeChecker(IEnvironment environment, INativeHelper nativeHelper, ILogger logger);
    public sealed virtual bool IsPrivilegeEnabled(string privilegeName);
}
[FlagsAttribute]
internal enum Microsoft.CodeCoverage.Core.Native.SePrivilege : Enum {
    public UInt32 value__;
    public static SePrivilege None;
    public static SePrivilege EnabledByDefault;
    public static SePrivilege Enabled;
    public static SePrivilege Removed;
    public static SePrivilege UsedForAccess;
}
[FlagsAttribute]
internal enum Microsoft.CodeCoverage.Core.Native.TokenAccess : Enum {
    public UInt32 value__;
    public static TokenAccess AssignPrimary;
    public static TokenAccess Duplicate;
    public static TokenAccess Impersonate;
    public static TokenAccess Query;
    public static TokenAccess QuerySource;
    public static TokenAccess AdjustPrivileges;
    public static TokenAccess AdjustGroups;
    public static TokenAccess AdjustDefault;
    public static TokenAccess AdjustSessionId;
    public static TokenAccess MaximumAllowed;
}
internal enum Microsoft.CodeCoverage.Core.Native.TokenInformationClass : Enum {
    public int value__;
    public static TokenInformationClass None;
    public static TokenInformationClass TokenUser;
    public static TokenInformationClass TokenGroups;
    public static TokenInformationClass TokenPrivileges;
    public static TokenInformationClass TokenOwner;
    public static TokenInformationClass TokenPrimaryGroup;
    public static TokenInformationClass TokenDefaultDacl;
    public static TokenInformationClass TokenSource;
    public static TokenInformationClass TokenType;
    public static TokenInformationClass TokenImpersonationLevel;
    public static TokenInformationClass TokenStatistics;
    public static TokenInformationClass TokenRestrictedSids;
    public static TokenInformationClass TokenSessionId;
    public static TokenInformationClass TokenGroupsAndPrivileges;
    public static TokenInformationClass TokenSessionReference;
    public static TokenInformationClass TokenSandBoxInert;
    public static TokenInformationClass TokenAuditPolicy;
    public static TokenInformationClass TokenOrigin;
    public static TokenInformationClass TokenElevationType;
    public static TokenInformationClass TokenLinkedToken;
    public static TokenInformationClass TokenElevation;
    public static TokenInformationClass TokenHasRestrictions;
    public static TokenInformationClass TokenAccessInformation;
    public static TokenInformationClass TokenVirtualizationAllowed;
    public static TokenInformationClass TokenVirtualizationEnabled;
    public static TokenInformationClass TokenIntegrityLevel;
    public static TokenInformationClass TokenUIAccess;
    public static TokenInformationClass TokenMandatoryPolicy;
    public static TokenInformationClass TokenLogonSid;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Native.TokenPrivileges : ValueType {
    internal UInt32 PrivilegeCount;
    internal LuidAndAttributes[] Privileges;
    private static int privilegesArraySize;
    public TokenPrivileges(LuidAndAttributes[] luidAndAttributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.PlatformEnvironment : object {
    private static string LinuxReleaseFile;
    private static string LinuxReleaseFileIdPrefix;
    private IFileHelper _fileHelper;
    private IRuntimeInformationHelper _runtimeInformationHelper;
    private Nullable`1<PlatformOperatingSystem> _platformOperatingSystem;
    public PlatformOperatingSystem OperatingSystem { get; }
    public bool IsWindows { get; }
    public Architecture ProcessArchitecture { get; }
    internal PlatformEnvironment(IFileHelper fileHelper, IRuntimeInformationHelper runtimeInformationHelper);
    public sealed virtual PlatformOperatingSystem get_OperatingSystem();
    public sealed virtual bool get_IsWindows();
    public sealed virtual Architecture get_ProcessArchitecture();
    private string GetLinuxDistributionFromFile();
    public sealed virtual string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public sealed virtual string ExpandEnvironmentVariables(string name);
}
public enum Microsoft.CodeCoverage.Core.PlatformOperatingSystem : Enum {
    public int value__;
    public static PlatformOperatingSystem Windows;
    public static PlatformOperatingSystem UbuntuX64;
    public static PlatformOperatingSystem AlpineX64;
    public static PlatformOperatingSystem MacosX64;
    public static PlatformOperatingSystem DynamicNotSupported;
}
internal static class Microsoft.CodeCoverage.Core.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string AllTests { get; }
    internal static string CodeCoverageLoggingDisabled { get; }
    internal static string CoverageFileException { get; }
    internal static string CoverageReportException { get; }
    internal static string FailedToCreateDirectory { get; }
    internal static string FailedToCreateFile { get; }
    internal static string InvalidBlockIndexExceptionMessage { get; }
    internal static string InvalidCoverageFileException { get; }
    internal static string InvalidCoverageReportException { get; }
    internal static string OffsetOutOfRangeExceptionMessage { get; }
    internal static string SnapshotNotSupportedException { get; }
    internal static string UnsupportedCoverageFileException { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_AllTests();
    internal static string get_CodeCoverageLoggingDisabled();
    internal static string get_CoverageFileException();
    internal static string get_CoverageReportException();
    internal static string get_FailedToCreateDirectory();
    internal static string get_FailedToCreateFile();
    internal static string get_InvalidBlockIndexExceptionMessage();
    internal static string get_InvalidCoverageFileException();
    internal static string get_InvalidCoverageReportException();
    internal static string get_OffsetOutOfRangeExceptionMessage();
    internal static string get_SnapshotNotSupportedException();
    internal static string get_UnsupportedCoverageFileException();
}
public enum Microsoft.CodeCoverage.Core.SourceFileCheckSumType : Enum {
    public UInt32 value__;
    public static SourceFileCheckSumType Unknown;
    public static SourceFileCheckSumType Md5;
    public static SourceFileCheckSumType Sha1;
    public static SourceFileCheckSumType Sha256;
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.SourceFileCheckSumTypeConverter : object {
    private static Guid SourceHashMD5;
    private static Guid SourceHashSHA1;
    private static Guid SourceHashSHA256;
    private static SourceFileCheckSumTypeConverter();
    [ExtensionAttribute]
internal static SourceFileCheckSumType ToSourceFileCheckSumType(Guid checkSumType);
    [ExtensionAttribute]
internal static SourceFileCheckSumType ToSourceFileCheckSumType(UInt32 checkSumType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.CacheCleaner : object {
    private DataCollectorConfiguration _config;
    private IDirectoryHelper _directoryHelper;
    private IMutexFactory _mutexFactory;
    private ICancellationTokenSourceFactory _cancellationTokenSourceFactory;
    private ILogger _logger;
    private DateTime _sessionStartTimeStamp;
    [NullableContextAttribute("2")]
public CacheCleaner(DataCollectorConfiguration dataCollectorConfiguration, IDirectoryHelper directoryHelper, IMutexFactory mutexFactory, ICancellationTokenSourceFactory cancellationTokenSourceFactory, ILogger logger, DateTime sessionStartTimeStamp);
    public sealed virtual void Clean();
    private void CleanSession(string path, TimeSpan expirationTime, CancellationToken token);
    private bool IsCacheEntryExpired(string path, TimeSpan expirationTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.CachingStaticInstrumenter : object {
    private IStaticNativeInstrumenter _instrumenter;
    private IDirectoryHelper _directoryHelper;
    private IFileHelper _fileHelper;
    private ILogger _logger;
    private IMutexFactory _mutexFactory;
    private TimeSpan _mutexTimeout;
    [NullableAttribute("2")]
private string _configurationHash;
    [NullableAttribute("2")]
private string _cachePath;
    [NullableAttribute("2")]
private string _correlationId;
    [NullableContextAttribute("2")]
internal CachingStaticInstrumenter(IStaticNativeInstrumenter instrumenter, IDirectoryHelper directoryHelper, IFileHelper fileHelper, ILogger logger, IMutexFactory mutexFactory);
    public sealed virtual UInt32 Initialize(CodeCoverageConfig configuration, string sessionId);
    public sealed virtual UInt32 Instrument(string binaryPath, string outputPath);
    public sealed virtual void Dispose();
    private string CalculateFileMD5(string path);
}
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.CleanUpFunction : MulticastDelegate {
    public CleanUpFunction(object object, IntPtr method);
    public virtual UInt32 Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.ConcurrentStaticInstrumenter : object {
    private IStaticNativeInstrumenter _innerInstrumenter;
    private ILogger _logger;
    private IMutexFactory _mutexFactory;
    private TimeSpan _mutexTimeout;
    [NullableContextAttribute("2")]
internal ConcurrentStaticInstrumenter(IStaticNativeInstrumenter innerInstrumenter, ILogger logger, IMutexFactory mutexFactory);
    public sealed virtual UInt32 Initialize(CodeCoverageConfig configuration, string sessionId);
    public sealed virtual UInt32 Instrument(string binaryPath, string outputPath);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.ConsoleStaticNativeInstrumenter : object {
    private string _consolePath;
    private string _configurationFilePath;
    [NullableAttribute("2")]
private string _sessionId;
    [NullableContextAttribute("2")]
internal ConsoleStaticNativeInstrumenter(string consolePath, string configurationFilePath);
    public sealed virtual UInt32 Initialize(CodeCoverageConfig configuration, string sessionId);
    public sealed virtual UInt32 Instrument(string binaryPath, string outputPath);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.ConsoleStaticNativeInstrumenterFactory : object {
    private IProfilersLocationProvider _profilersLocationProvider;
    private IFileHelper _fileHelper;
    private IDirectoryHelper _directoryHelper;
    private IMutexFactory _mutexFactory;
    [NullableContextAttribute("2")]
public ConsoleStaticNativeInstrumenterFactory(IProfilersLocationProvider profilersLocationProvider, IFileHelper fileHelper, IDirectoryHelper directoryHelper, IMutexFactory mutexFactory);
    public sealed virtual IStaticNativeInstrumenter Create(ILogger logger, DataCollectorConfiguration configuration, string configurationFilePath);
}
internal interface Microsoft.CodeCoverage.Core.StaticInstrumentation.ICacheCleaner {
    public abstract virtual void Clean();
}
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.InitializeFunction : MulticastDelegate {
    public InitializeFunction(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual UInt32 Invoke(string configurationPath, string sessionId, string libraryPath);
    public virtual IAsyncResult BeginInvoke(string configurationPath, string sessionId, string libraryPath, AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.InstrumentationFunction : MulticastDelegate {
    public InstrumentationFunction(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual UInt32 Invoke(string binaryPath, string outputPath);
    public virtual IAsyncResult BeginInvoke(string binaryPath, string outputPath, AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.StaticInstrumentation.IStaticNativeInstrumenter {
    public abstract virtual UInt32 Initialize(CodeCoverageConfig configuration, string sessionId);
    public abstract virtual UInt32 Instrument(string binaryPath, string outputPath);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.StaticInstrumentation.IStaticNativeInstrumenterFactory {
    public abstract virtual IStaticNativeInstrumenter Create(ILogger logger, DataCollectorConfiguration configuration, string configurationFilePath);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.StaticInstrumentation.IStaticNativeRuntimeProvider {
    public abstract virtual IReadOnlyCollection`1<string> CopyRuntime(IEnumerable`1<string> directories);
    public abstract virtual void RemoveRuntime(IEnumerable`1<string> copiedFiles);
    [NullableContextAttribute("2")]
public abstract virtual string UpdatePathEnvironmentVariable(string pathEnvironmentVariable);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.StaticInstrumentation.IStaticNativeRuntimeProviderFactory {
    public abstract virtual IStaticNativeRuntimeProvider Create(ILogger logger, DataCollectorConfiguration configuration);
}
internal enum Microsoft.CodeCoverage.Core.StaticInstrumentation.StaticNativeInstrumentationResult : Enum {
    public UInt32 value__;
    public static StaticNativeInstrumentationResult Success;
    public static StaticNativeInstrumentationResult ErrorUnknown;
    public static StaticNativeInstrumentationResult ErrorStringConversion;
    public static StaticNativeInstrumentationResult ErrorFailedToMoveFile;
    public static StaticNativeInstrumentationResult ErrorNoEntryPointInImage;
    public static StaticNativeInstrumentationResult ErrorBinaryCompressed;
    public static StaticNativeInstrumentationResult ErrorInvalidPeFile;
    public static StaticNativeInstrumentationResult ErrorInstrPdbMismatch;
    public static StaticNativeInstrumentationResult ErrorNoFixupData;
    public static StaticNativeInstrumentationResult ErrorInstrPdbFailure;
    public static StaticNativeInstrumentationResult ErrorInstrPdbWritable;
    public static StaticNativeInstrumentationResult ErrorEmittedByBBInstr;
    public static StaticNativeInstrumentationResult ErrorInstrUnsupportedArchitecture;
    public static StaticNativeInstrumentationResult ErrorInstrOutOfMem;
    public static StaticNativeInstrumentationResult ErrorUnableToInstrumentGeneric;
    public static StaticNativeInstrumentationResult SuccessFromCache;
    public static StaticNativeInstrumentationResult ErrorBinaryPathSyncMutexNotAcquired;
}
internal static class Microsoft.CodeCoverage.Core.StaticInstrumentation.StaticNativeInstrumentationResultHelper : object {
    public static UInt32 GenericResultCodeBase;
    public static UInt32 ModuleSkippedResultCodeBase;
    internal static bool IsInitializationSuccessful(UInt32 result);
    internal static bool CanConvertToGenericResultCode(UInt32 result);
    internal static StaticNativeInstrumentationResult ConvertToGenericResultCode(UInt32 result);
    internal static UInt32 ConvertToUInt(StaticNativeInstrumentationResult result);
    internal static bool CanConvertToModuleSkippedResultCode(UInt32 result);
    internal static ModuleSkipReason ConvertToModuleSkipReason(UInt32 result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.StaticNativeInstrumenter : SafeHandle {
    private string _instrumentationModulePath;
    private IntPtr _instrumentationModule;
    private InitializeFunction _initializeFunction;
    private InstrumentationFunction _instrumentationFunction;
    private CleanUpFunction _cleanUpFunction;
    private INativeHelper _nativeHelper;
    public bool IsInvalid { get; }
    [NullableContextAttribute("2")]
internal StaticNativeInstrumenter(INativeHelper nativeHelper, string nativeInstrumenterlibraryPath, IntPtr instrumentationModule, InitializeFunction initializeFunction, InstrumentationFunction instrumentationFunction, CleanUpFunction cleanUpFunction);
    public sealed virtual UInt32 Initialize(CodeCoverageConfig configuration, string sessionId);
    public sealed virtual UInt32 Instrument(string binaryPath, string outputPath);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StaticInstrumentation.StaticNativeInstrumenterFactory : object {
    private static string InitializationFunctionName;
    private static string InstrumentationFunctionName;
    private static string CleanUpFunctionName;
    private IProfilersLocationProvider _profilersLocationProvider;
    private IFileHelper _fileHelper;
    private IDirectoryHelper _directoryHelper;
    private INativeHelper _nativeHelper;
    private IMutexFactory _mutexFactory;
    public StaticNativeInstrumenterFactory(IProfilersLocationProvider profilersLocationProvider, IFileHelper fileHelper, IDirectoryHelper directoryHelper, INativeHelper nativeHelper, IMutexFactory mutexFactory);
    public sealed virtual IStaticNativeInstrumenter Create(ILogger logger, DataCollectorConfiguration configuration, string configurationFilePath);
    private bool GetFunction(IntPtr module, ILogger logger, string functionName, T& function);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.StreamNameGenerator : object {
    private bool _hasCreateGlobalPrivilege;
    private string _tempPath;
    public StreamNameGenerator(IEnvironment environment, IPrivilegeChecker privilegeChecker);
    public sealed virtual string GenerateStreamName(string streamName, Guid streamType, string sessionName, Guid identifier);
    public sealed virtual string GetStreamNamePrefix(string sessionName);
    private string AddPrefixes(string streamName);
    private char GetStreamTypeChar(Guid streamType);
}
internal class Microsoft.CodeCoverage.Core.Threading.CancellationTokenSourceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual CancellationTokenSource Create(int millisecondsDelay);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Threading.ICancellationTokenSourceFactory {
    public abstract virtual CancellationTokenSource Create(int millisecondsDelay);
}
internal interface Microsoft.CodeCoverage.Core.Threading.IMutex {
    public abstract virtual bool WaitOne(TimeSpan timeout);
    public abstract virtual void ReleaseMutex();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Threading.IMutexFactory {
    public abstract virtual IMutex Create(bool initiallyOwned, string name);
    public abstract virtual IMutex Create(bool initiallyOwned, string name, Boolean& createdNew);
}
internal class Microsoft.CodeCoverage.Core.Threading.Mutex : object {
    [NullableAttribute("1")]
private Mutex _mutex;
    [NullableContextAttribute("1")]
public Mutex(bool initiallyOwned, string name);
    [NullableContextAttribute("2")]
public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    public sealed virtual void Dispose();
    public sealed virtual void ReleaseMutex();
    public sealed virtual bool WaitOne(TimeSpan timeout);
}
internal class Microsoft.CodeCoverage.Core.Threading.MutexFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IMutex Create(bool initiallyOwned, string name);
    [NullableContextAttribute("1")]
public sealed virtual IMutex Create(bool initiallyOwned, string name, Boolean& createdNew);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.BaseProfilersLocationProvider : object {
    private IEnvironment _environment;
    internal BaseProfilersLocationProvider(IEnvironment environment);
    protected string GetClrInstrumentationEngineX64FileName();
    protected string GetClrInstrumentationEngineARM64FileName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.Utils.BinaryExtensions : object {
    [ExtensionAttribute]
internal static UInt32 ReadUInt(BinaryReader reader);
    [ExtensionAttribute]
internal static Guid ReadGuid(BinaryReader reader);
    internal static void ReadBytes(BinaryReader reader, Byte[] bytes);
    internal static Byte[] ReadBytes(BinaryReader reader);
    internal static string ReadString(BinaryReader reader);
    internal static T[] ReadArray(BinaryReader reader, Func`2<BinaryReader, T> returnItemFunction);
    internal static string ReadStringBytes(BinaryReader reader);
    [ExtensionAttribute]
internal static void Write(BinaryWriter writer, Guid guid);
    internal static void Write(BinaryWriter writer, UInt32 value);
    internal static void WriteBytes(BinaryWriter writer, Byte[] buffer);
    internal static void WriteString(BinaryWriter writer, string text, bool addLength);
    internal static void WriteStringBytes(BinaryWriter writer, string text, bool addLength);
    internal static void WriteFileHeader(BinaryWriter writer, UInt32 fileHeaderMagic, ushort schemaVersion, UInt32 streamsCount);
    internal static void WriteStreamHeader(BinaryWriter writer, UInt32 streamHeaderMagic, Guid streamType, Guid identifier, UInt32 streamSize, long streamPosition);
    internal static void WriteStreamHeader(BinaryWriter writer, StreamHeader streamHeader);
    internal static void WriteStreamHeader(BinaryWriter writer, UInt32 streamHeaderMagic, Guid streamType, Guid identifier, UInt32 streamSize);
    [ExtensionAttribute]
internal static void Write(BinaryWriter writer, SingleBitCoverageBuffer coverageBuffer);
}
internal class Microsoft.CodeCoverage.Core.Utils.ConsoleOutputPathGenerator : object {
    [NullableContextAttribute("1")]
public sealed virtual string GenerateOutputPath(string requestedOutputPath, string defaultExtension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.ConvertModulesData : object {
    [CompilerGeneratedAttribute]
private MergeCoverageFileData <CoverageToCobertura>k__BackingField;
    [CompilerGeneratedAttribute]
private MergeCoverageFileData <CoverageToXml>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<ModuleData> <XmlToCobertura>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<ModuleData> <XmlModules>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CoberturaFile> <CoberturaFiles>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public MergeCoverageFileData CoverageToCobertura { get; public set; }
    public MergeCoverageFileData CoverageToXml { get; public set; }
    public Collection`1<ModuleData> XmlToCobertura { get; public set; }
    public Collection`1<ModuleData> XmlModules { get; public set; }
    public Collection`1<CoberturaFile> CoberturaFiles { get; public set; }
    public ConvertModulesData(MergeCoverageFileData CoverageToCobertura, MergeCoverageFileData CoverageToXml, Collection`1<ModuleData> XmlToCobertura, Collection`1<ModuleData> XmlModules, Collection`1<CoberturaFile> CoberturaFiles);
    [CompilerGeneratedAttribute]
protected ConvertModulesData(ConvertModulesData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public MergeCoverageFileData get_CoverageToCobertura();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CoverageToCobertura(MergeCoverageFileData value);
    [CompilerGeneratedAttribute]
public MergeCoverageFileData get_CoverageToXml();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CoverageToXml(MergeCoverageFileData value);
    [CompilerGeneratedAttribute]
public Collection`1<ModuleData> get_XmlToCobertura();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_XmlToCobertura(Collection`1<ModuleData> value);
    [CompilerGeneratedAttribute]
public Collection`1<ModuleData> get_XmlModules();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_XmlModules(Collection`1<ModuleData> value);
    [CompilerGeneratedAttribute]
public Collection`1<CoberturaFile> get_CoberturaFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CoberturaFiles(Collection`1<CoberturaFile> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ConvertModulesData left, ConvertModulesData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ConvertModulesData left, ConvertModulesData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ConvertModulesData other);
    [CompilerGeneratedAttribute]
public virtual ConvertModulesData <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(MergeCoverageFileData& CoverageToCobertura, MergeCoverageFileData& CoverageToXml, Collection`1& XmlToCobertura, Collection`1& XmlModules, Collection`1& CoberturaFiles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.DataCollectorOutputPathGenerator : object {
    private string _sessionDirectory;
    public DataCollectorOutputPathGenerator(string sessionDirectory);
    public sealed virtual string GenerateOutputPath(string requestedOutputPath, string defaultExtension);
    private string GenerateCoverageFileName();
    private string EnsureSessionDirectory(string path);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GenerateCoverageFileName>g__GetUserName|4_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.DirectoryHelper : object {
    public sealed virtual string GetCurrentDirectory();
    public sealed virtual void Delete(string path, bool recursive);
    public sealed virtual void CreateDirectory(string path);
    public sealed virtual void CreateDirectoryIfNeeded(string filePath);
    public sealed virtual bool Exists(string path);
    public sealed virtual bool Exists(DirectoryInfo directoryInfo);
    public sealed virtual FileInfo[] GetFiles(DirectoryInfo directoryInfo, string searchPattern, SearchOption searchOption);
    public sealed virtual String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual String[] GetDirectories(string path);
    public sealed virtual DateTime GetLastAccessTimeUtc(string path);
    public sealed virtual void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.EmptyReportsReaderLogger : object {
    [CompilerGeneratedAttribute]
private static Lazy`1<IReportsReaderLogger> <EmptyLogger>k__BackingField;
    internal static Lazy`1<IReportsReaderLogger> EmptyLogger { get; }
    private static EmptyReportsReaderLogger();
    public sealed virtual void LogInvalidReport(string path, Exception exception);
    public sealed virtual void LogValidReport(string path);
    public sealed virtual void LogWarning(string message);
    public sealed virtual void LogError(string message);
    public sealed virtual void LogInfo(string message);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogError(Exception exceptionToTrace);
    public sealed virtual void LogDeleteReport(string path);
    [CompilerGeneratedAttribute]
internal static Lazy`1<IReportsReaderLogger> get_EmptyLogger();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.EnvironmentVariablesCalculator : object {
    private static string PROCESSOR_ARCHITECTURE;
    private IEnvironment _environment;
    private IFileHelper _fileHelper;
    private IDirectoryHelper _directoryHelper;
    private IProfilersLocationProvider _profilersLocationProvider;
    private IStaticNativeRuntimeProviderFactory _staticNativeRuntimeProviderFactory;
    private IStreamNameGenerator _streamNameGenerator;
    public EnvironmentVariablesCalculator(IEnvironment environment, IFileHelper fileHelper, IDirectoryHelper directoryHelper, IProfilersLocationProvider profilersLocationProvider, IStaticNativeRuntimeProviderFactory staticNativeRuntimeProviderFactory, IStreamNameGenerator streamNameGenerator);
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables(bool intellitraceEnabled, string sessionName, string pipePath, DataCollectorConfiguration configuration, ILogger logger);
    private IEnumerable`1<KeyValuePair`2<string, string>> GetNetCoreEnvironmentVariables(DataCollectorConfiguration configuration);
    private IEnumerable`1<KeyValuePair`2<string, string>> GetNetFrameworkEnvironmentVariables(bool intellitraceEnabled, DataCollectorConfiguration configuration);
    private IEnumerable`1<KeyValuePair`2<string, string>> GetClrIeProfilerCommonEnvironmentVariables(DataCollectorConfiguration configuration, ILogger logger);
    private bool IsDynamicCodeCoverageEnabled(DataCollectorConfiguration configuration);
    private bool IsManagedDynamicCodeCoverageEnabled(DataCollectorConfiguration configuration);
    private bool IsNativeDynamicCodeCoverageEnabled(DataCollectorConfiguration configuration);
    [NullableContextAttribute("2")]
private string GetFileLogPathAndGenerateDirectoryIfNeeded(DataCollectorConfiguration configuration, ILogger logger);
    private string GetFileLogPath(DataCollectorConfiguration configuration);
    private bool IsDirectory(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.FileHelper : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual bool Exists(FileInfo fileInfo);
    public sealed virtual void WriteAllText(string path, string contents);
    public sealed virtual String[] ReadAllLines(string path);
    public sealed virtual void Delete(string path);
    public sealed virtual void Move(string sourceFileName, string destFileName);
    public sealed virtual void Copy(string sourceFileName, string destFileName, bool overwrite);
    public sealed virtual Stream OpenRead(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.Utils.Helpers : object {
    public static CoverageMergeOperation ToCoverageMergeOperation(CoverageReportType coverageReportType);
    public static string GetGlobalCachePath(string cachePath);
    public static string GetCachePath(string cachePath, string correlationId);
    public static string GetMutexName(string correlationId, string hash);
    public static string GetMutexName(string hash);
    public static Byte[] ToBytesArray(string value);
    public static string CalculateStringSha256(string input);
    public static string ConvertToString(Byte[] hashBytes);
    internal static string GenerateOutputPath(string coverageFilePath, CoverageMergeOperation mergeOperation);
    [ExtensionAttribute]
internal static void PopulateFullPaths(String[] mergedFiles, IDirectoryHelper directoryHelper);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IDirectoryHelper {
    public abstract virtual string GetCurrentDirectory();
    public abstract virtual void Delete(string path, bool recursive);
    public abstract virtual void CreateDirectory(string path);
    public abstract virtual void CreateDirectoryIfNeeded(string filePath);
    public abstract virtual bool Exists(string path);
    public abstract virtual bool Exists(DirectoryInfo directoryInfo);
    public abstract virtual FileInfo[] GetFiles(DirectoryInfo directoryInfo, string searchPattern, SearchOption searchOption);
    public abstract virtual String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual String[] GetDirectories(string path);
    public abstract virtual DateTime GetLastAccessTimeUtc(string path);
    public abstract virtual void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IEnvironmentVariablesCalculator {
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables(bool intellitraceEnabled, string sessionName, string pipePath, DataCollectorConfiguration configuration, ILogger logger);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IFileHelper {
    public abstract virtual bool Exists(string path);
    public abstract virtual bool Exists(FileInfo fileInfo);
    public abstract virtual void WriteAllText(string path, string contents);
    public abstract virtual String[] ReadAllLines(string path);
    public abstract virtual void Delete(string path);
    public abstract virtual void Move(string sourceFileName, string destFileName);
    public abstract virtual void Copy(string sourceFileName, string destFileName, bool overwrite);
    public abstract virtual Stream OpenRead(string path);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IOutputPathGenerator {
    public abstract virtual string GenerateOutputPath(string requestedOutputPath, string defaultExtension);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IProfilersLocationProvider {
    public abstract virtual string GetVanguardPath(DataCollectorConfiguration configuration);
    public abstract virtual string GetVanguardProfilerConfigX64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetVanguardProfilerConfigARM64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetVanguardProfilerConfigX86Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetClrInstrumentationEngineX86Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetClrInstrumentationEngineX64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetClrInstrumentationEngineARM64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeInstrumenterX86Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeInstrumenterX64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeInstrumenterConsoleX86Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeInstrumenterConsoleX64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeRuntimeX86Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeRuntimeX64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeRuntimeARM64Path(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeRuntimeX86Directory(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeRuntimeX64Directory(DataCollectorConfiguration configuration);
    public abstract virtual string GetStaticNativeRuntimeARM64Directory(DataCollectorConfiguration configuration);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IReportsMerger {
    public abstract virtual Task`1<String[]> MergeReports(ReportsContainer reports, string outputPath, CoverageMergeOperation mergeOperation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IReportsReader {
    public abstract virtual ReportsContainer ReadCoverageReports(String[] files, CancellationToken cancellationToken);
    public abstract virtual ReportsContainer ReadCoverageReports(String[] files, IReportsReaderLogger logger, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.Utils.IReportsReaderLogger {
    public abstract virtual void LogValidReport(string path);
    public abstract virtual void LogInvalidReport(string path, Exception exception);
    public abstract virtual void LogDeleteReport(string path);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeCoverage.Core.Utils.IRuntimeInformationHelper {
    public string RuntimeIdentifier { get; }
    public Architecture OSArchitecture { get; }
    public abstract virtual string get_RuntimeIdentifier();
    public abstract virtual bool IsOSPlatform(OSPlatform osPlatform);
    public abstract virtual Architecture get_OSArchitecture();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.ModulesMap : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<ValueTuple`2<CoverageReportType, object>>> <Reports>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ModuleSkippedMessage> <SkippedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SkippedModuleData> <SkippedModuleData>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, List`1<ValueTuple`2<CoverageReportType, object>>> Reports { get; public set; }
    public Dictionary`2<string, ModuleSkippedMessage> SkippedMessages { get; public set; }
    public Dictionary`2<string, SkippedModuleData> SkippedModuleData { get; public set; }
    public ModulesMap(Dictionary`2<string, List`1<ValueTuple`2<CoverageReportType, object>>> Reports, Dictionary`2<string, ModuleSkippedMessage> SkippedMessages, Dictionary`2<string, SkippedModuleData> SkippedModuleData);
    [CompilerGeneratedAttribute]
protected ModulesMap(ModulesMap original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<ValueTuple`2<CoverageReportType, object>>> get_Reports();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Reports(Dictionary`2<string, List`1<ValueTuple`2<CoverageReportType, object>>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ModuleSkippedMessage> get_SkippedMessages();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkippedMessages(Dictionary`2<string, ModuleSkippedMessage> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SkippedModuleData> get_SkippedModuleData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkippedModuleData(Dictionary`2<string, SkippedModuleData> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ModulesMap left, ModulesMap right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ModulesMap left, ModulesMap right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ModulesMap other);
    [CompilerGeneratedAttribute]
public virtual ModulesMap <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Dictionary`2& Reports, Dictionary`2& SkippedMessages, Dictionary`2& SkippedModuleData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.ProfilersLocationProvider : BaseProfilersLocationProvider {
    private static string VanguardInstallDirVariable;
    private static string VanguardX64ProfilerConfigPath;
    private static string VanguardARM64ProfilerConfigPath;
    private static string VanguardStaticInstrumenterX64Path;
    private static string VanguardStaticInstrumenterConsoleX64Path;
    private static string StaticCovrunDllX64Path;
    private static string StaticCovrunDllARM64Path;
    private IFileHelper _fileHelper;
    private IDirectoryHelper _directoryHelper;
    private IEnvironment _environment;
    [NullableAttribute("2")]
private string _vsInstallPath;
    private string _defaultVanguardDirectory;
    private string _defaultClrIeDirectory;
    internal ProfilersLocationProvider(IFileHelper fileHelper, IDirectoryHelper directoryHelper, IEnvironment environment);
    internal ProfilersLocationProvider(string vsInstallPath, IFileHelper fileHelper, IDirectoryHelper directoryHelper, IEnvironment environment);
    private static ProfilersLocationProvider();
    internal string DefaultVanguardDirectory();
    internal string DefaultClrIeDirectory();
    public sealed virtual string GetVanguardPath(DataCollectorConfiguration configuration);
    public sealed virtual string GetVanguardProfilerConfigX86Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetVanguardProfilerConfigX64Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetVanguardProfilerConfigARM64Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetClrInstrumentationEngineX86Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetClrInstrumentationEngineX64Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetClrInstrumentationEngineARM64Path(DataCollectorConfiguration configuration);
    private string GetClrInstrumentationEnginePath(string arch, string fileName, string environmentVariableName, string configurationInstallationPath);
    private string GetVanguardDirectory(DataCollectorConfiguration configuration);
    private string GetDefaultVanguardDirectory();
    private string GetDefaultClrIeDirectory();
    private string GetCurrentAssemblyLocation();
    public sealed virtual string GetStaticNativeInstrumenterX86Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeInstrumenterX64Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeInstrumenterConsoleX86Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeInstrumenterConsoleX64Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeRuntimeX86Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeRuntimeX64Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeRuntimeARM64Path(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeRuntimeX86Directory(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeRuntimeX64Directory(DataCollectorConfiguration configuration);
    public sealed virtual string GetStaticNativeRuntimeARM64Directory(DataCollectorConfiguration configuration);
    private string GetStaticNativeLibraryPath(DataCollectorConfiguration configuration, string configurationValue, string fileName, string fileNameWithArchitecture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.Utils.ReportConverters : object {
    internal static Lazy`1<CoverageMessagesReaderV1> CoverageMessagesReaderV1 { get; }
    internal static Lazy`1<Dictionary`2<string, ModuleSkippedMessage>> EmptyModuleSkippedMessages { get; }
    internal static Lazy`1<Dictionary`2<SkippedFunctionKey, FunctionSkippedMessage>> EmptyFunctionSkippedMessages { get; }
    [ExtensionAttribute]
public static CoberturaFile ToCobertura(XmlFileData xmlFile, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static CoberturaFile ToCobertura(MergeCoverageFileData coverageData, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public static CoberturaPackage PopulateClasses(string modulePath, CoberturaPackageBuilder packageBuilder);
    private static CoberturaPackageBuilder PopulateFunctions(MergeModuleData module, MergeModuleMessages messages, CancellationToken cancellationToken);
    private static CoberturaPackageBuilder PopulateFunctions(ModuleData module, CancellationToken cancellationToken);
    internal static Lazy`1<CoverageMessagesReaderV1> get_CoverageMessagesReaderV1();
    internal static Lazy`1<Dictionary`2<string, ModuleSkippedMessage>> get_EmptyModuleSkippedMessages();
    internal static Lazy`1<Dictionary`2<SkippedFunctionKey, FunctionSkippedMessage>> get_EmptyFunctionSkippedMessages();
    [ExtensionAttribute]
public static MergeCoverageFileData ToMergeCoverageFileData(CoberturaFile coberturaFile, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static MergeModuleData ToMergeModuleData(CoberturaPackage package, String[] sources);
    internal static void AddMergedFunction(Dictionary`2<FunctionKey, IList`1<MergeFunctionData>> functionsMap, FunctionInstrumentedMessage message, Byte[] coverageBuffer);
    [ExtensionAttribute]
public static XmlFileData ToXmlFileData(CoberturaFile coberturaFile, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static ModuleData ToModule(CoberturaPackage package, String[] sources);
    [ExtensionAttribute]
public static XmlFileData ToXmlFileData(MergeCoverageFileData mergeCoverageFileData, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static ModuleData ToModule(MergeModuleData module, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<MinimalSequencePointsFinder`1<UInt32>, int> <PopulateFunctions>g__BuildMinimalSequencePointsFinderAndCalculateMaxNumberOfMethods|3_0(MergeModuleMessages module, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <PopulateFunctions>g__AddMethod|3_1(MergeFunctionData function, CoberturaPackageBuilder packageBuilder, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder, MergeModuleMessages messages, Byte[] coverageBuffer);
    [CompilerGeneratedAttribute]
internal static CoberturaLine[] <PopulateFunctions>g__CalculateLines|3_2(IEnumerable`1<BlockLineDataMessage> lineData, UInt32 sourceId, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder, Byte[] coverageBuffer);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<MinimalSequencePointsFinder`1<UInt32>, int> <PopulateFunctions>g__BuildMinimalSequencePointsFinderAndCalculateMaxNumberOfMethods|4_0(ModuleData module, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <PopulateFunctions>g__AddMethod|4_1(FunctionData function, CoberturaPackageBuilder packageBuilder, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder);
    [CompilerGeneratedAttribute]
internal static CoberturaLine[] <PopulateFunctions>g__CalculateLines|4_2(IEnumerable`1<MultiBlockLineData> lineData, UInt32 sourceId, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder);
    [CompilerGeneratedAttribute]
internal static SourceFileData <ToModule>g__ToSourceFileData|15_1(string path, Dictionary`2<string, UInt32> sourceFiles);
    [CompilerGeneratedAttribute]
internal static FunctionData <ToModule>g__ToFunctionData|15_2(ModuleData module, UInt32& functionId, string typeName, string namespaceName, SourceFileData sourceFile, CoberturaMethod method, IBoundedSet boundedSet, ILineStatisticsCalculator lineStatisticsCalculator);
}
internal static class Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpers : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpers/<MergeCoverageFilesAsync>d__1`1")]
public static Task`1<T> MergeCoverageFilesAsync(Queue`1<T> queue, MergeCoverageFiles`1<T> mergeCoverageFiles, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken token);
    [NullableContextAttribute("1")]
private static void MergeCoverageFilesFromQueue(Queue`1<T> queue, MergeCoverageFiles`1<T> mergeCoverageFiles, bool skipInvalidFiles, object lockObject, CancellationToken token);
    [NullableContextAttribute("2")]
private static bool PrepareMergeTaskInput(Queue`1<T> queue, object lockObject, T& input1, T& input2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy : object {
    private static ICoverageFileReader _coverageFileReader;
    private static ReportMergeHelpersLegacy();
    public static IList`1<ValueTuple`3<string, CoverageReportType, object>> GetCoverageReports(IList`1<string> inputFiles, bool skipInvalidFiles, CancellationToken token);
    public static ValueTuple`2<CoverageReportType, object> GetCoverageReport(string path, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeCoverageReportsAsync>d__4")]
public static Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputPath, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeCoverageReportsAsync>d__5")]
public static Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputPath, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeCoverageFilesAsync>d__6`1")]
public static Task`1<T> MergeCoverageFilesAsync(Queue`1<ValueTuple`2<string, T>> queue, GetCoverageFile`1<T> getCoverageFile, MergeCoverageFiles`1<T> mergeCoverageFiles, CancellationToken token, bool skipInvalidFiles, int taskCount);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeCoverageFilesAsync>d__7`1")]
private static Task MergeCoverageFilesAsync(Queue`1<ValueTuple`2<string, T>> queue, GetCoverageFile`1<T> getCoverageFile, MergeCoverageFiles`1<T> mergeCoverageFiles, bool skipInvalidFiles, object lockObject, CancellationToken token);
    private static bool PrepareMergeTaskInput(Queue`1<ValueTuple`2<string, T>> queue, object lockObject, ValueTuple`2& input1, ValueTuple`2& input2);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeSimilarFormatsAsync>d__9")]
private static Task`1<IList`1<string>> MergeSimilarFormatsAsync(string outputPath, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeReportsAsync>d__10")]
private static Task`1<string> MergeReportsAsync(string outputPath, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeCoberturaAsync>d__11")]
private static Task`1<CoberturaFile> MergeCoberturaAsync(IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportMergeHelpersLegacy/<MergeCoverageAsync>d__12")]
private static Task`1<CoverageData> MergeCoverageAsync(IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, bool skipInvalidFiles, int taskCount, CancellationToken token, bool loadAllModuleData);
    internal static string RemoveFileExtension(string outputPath, string extension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.ReportsContainer : object {
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<MergeCoverageFileData> <CoverageFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<CoberturaFile> <CoberturaFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<XmlFileData> <XmlFiles>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ConcurrentBag`1<MergeCoverageFileData> CoverageFiles { get; public set; }
    public ConcurrentBag`1<CoberturaFile> CoberturaFiles { get; public set; }
    public ConcurrentBag`1<XmlFileData> XmlFiles { get; public set; }
    public ReportsContainer(ConcurrentBag`1<MergeCoverageFileData> CoverageFiles, ConcurrentBag`1<CoberturaFile> CoberturaFiles, ConcurrentBag`1<XmlFileData> XmlFiles);
    [CompilerGeneratedAttribute]
protected ReportsContainer(ReportsContainer original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<MergeCoverageFileData> get_CoverageFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CoverageFiles(ConcurrentBag`1<MergeCoverageFileData> value);
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<CoberturaFile> get_CoberturaFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CoberturaFiles(ConcurrentBag`1<CoberturaFile> value);
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<XmlFileData> get_XmlFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_XmlFiles(ConcurrentBag`1<XmlFileData> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ReportsContainer left, ReportsContainer right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ReportsContainer left, ReportsContainer right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ReportsContainer other);
    [CompilerGeneratedAttribute]
public virtual ReportsContainer <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ConcurrentBag`1& CoverageFiles, ConcurrentBag`1& CoberturaFiles, ConcurrentBag`1& XmlFiles);
}
internal static class Microsoft.CodeCoverage.Core.Utils.ReportsContainerExtensions : object {
    [NullableContextAttribute("1")]
internal static ModulesMap CreateModulesMap(IReadOnlyCollection`1<MergeCoverageFileData> coverageFiles, IReadOnlyCollection`1<CoberturaFile> coberturaFiles, IReadOnlyCollection`1<XmlFileData> xmlFiles);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <CreateModulesMap>g__AddModule|0_0(ModulesMap modulesMap, string key, CoverageReportType reportType, object module);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.ReportsMerger : object {
    private ICoverageFileWriter _coverageFileWriter;
    private ICoverageFileDataMerger _coverageFileDataMerger;
    private ICoverageFileConfiguration _coverageFileConfiguration;
    private IDirectoryHelper _directoryHelper;
    public ReportsMerger(ICoverageFileWriter coverageFileWriter, ICoverageFileDataMerger coverageFileDataMerger, ICoverageFileConfiguration coverageFileConfiguration, IDirectoryHelper directoryHelper);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportsMerger/<MergeReports>d__5")]
public sealed virtual Task`1<String[]> MergeReports(ReportsContainer reports, string outputPath, CoverageMergeOperation mergeOperation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportsMerger/<MergeReportsInternal>d__6")]
private Task`1<String[]> MergeReportsInternal(ReportsContainer reports, string outputPath, CoverageMergeOperation mergeOperation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportsMerger/<MergeSimilarFormats>d__7")]
private static Task`1<ValueTuple`3<MergeCoverageFileData, CoberturaFile, XmlFileData>> MergeSimilarFormats(ReportsContainer reports, ICoverageFileDataMerger coverageFileDataMerger, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportsMerger/<MergeToCoverageAsync>d__8")]
private static Task`1<MergeCoverageFileData> MergeToCoverageAsync(ReportsContainer reports, ICoverageFileDataMerger coverageFileDataMerger, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportsMerger/<MergeToCoberturaAsync>d__9")]
public static Task`1<CoberturaFile> MergeToCoberturaAsync(ReportsContainer reports, ICoverageFileDataMerger coverageFileDataMerger, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Utils.ReportsMerger/<MergeToXmlAsync>d__10")]
public static Task`1<XmlFileData> MergeToXmlAsync(ReportsContainer reports, ICoverageFileDataMerger coverageFileDataMerger, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    internal static ConvertModulesData MergeToXmlCoverageModulesData(ModulesMap modulesMap);
    private static ConcurrentBag`1<CoberturaFile> ToCobertura(IReadOnlyCollection`1<MergeCoverageFileData> reports, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private static ConcurrentBag`1<CoberturaFile> ToCobertura(IReadOnlyCollection`1<XmlFileData> reports, int maxDegreeOfParallelism, CancellationToken cancellationToken);
    private static ConcurrentBag`1<TOutput> ToReportType(IReadOnlyCollection`1<TInput> reports, Action`2<TInput, ConcurrentBag`1<TOutput>> convertAction, int maxDegreeOfParallelism, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static Task`1<T> <MergeSimilarFormats>g__CreateMergeTask|7_3(IReadOnlyCollection`1<T> reports, List`1<Task> tasks, Func`1<Task`1<T>> mergeAction);
    [CompilerGeneratedAttribute]
internal static CoberturaFile <MergeToXmlAsync>g__ConvertAndMergeToCobertura|10_1(ICoverageFileDataMerger coverageFileDataMerger, ICoverageFileConfiguration coverageFileConfiguration, ConvertModulesData convertData, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Utils.ReportsReader : object {
    private ICoverageFileReader _coverageFileReader;
    [CompilerGeneratedAttribute]
private ICoverageFileConfiguration <CoverageFileConfiguration>k__BackingField;
    protected ICoverageFileConfiguration CoverageFileConfiguration { get; }
    public ReportsReader(ICoverageFileReader coverageFileReader, ICoverageFileConfiguration coverageFileConfiguration);
    [CompilerGeneratedAttribute]
protected ICoverageFileConfiguration get_CoverageFileConfiguration();
    public sealed virtual ReportsContainer ReadCoverageReports(String[] files, CancellationToken cancellationToken);
    public sealed virtual ReportsContainer ReadCoverageReports(String[] files, IReportsReaderLogger logger, CancellationToken cancellationToken);
    protected bool TryLoadCoverageFile(string file, int index, ReportsContainer reports, CancellationToken cancellationToken, Exception& exception);
    protected static void ThrowInvalidFileException(string file, ICoverageFileConfiguration coverageFileConfiguration, Exception exception);
}
internal class Microsoft.CodeCoverage.Core.Utils.RuntimeInformationHelper : object {
    [NullableAttribute("2")]
public string RuntimeIdentifier { get; }
    public Architecture OSArchitecture { get; }
    [NullableContextAttribute("2")]
public sealed virtual string get_RuntimeIdentifier();
    public sealed virtual Architecture get_OSArchitecture();
    public sealed virtual bool IsOSPlatform(OSPlatform osPlatform);
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.Utils.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetFileName(string path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.Utils.StringUtils : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.Utils.XmlUtils : object {
    [NullableContextAttribute("2")]
public static bool TryReadCoberturaFile(string path, CoberturaFile& coberturaFile);
    public static bool TryDeserializeCoberturaFile(XDocument document, CoberturaFile& coberturaFile);
    public static bool TryDeserializeCoverageXmlFile(XDocument document, CoverageXmlFile& coverageXmlFile);
    public static bool TryDeserializeXmlFileData(XDocument document, XmlFileData& xmlFileData);
    public static bool TryDeserializeRunSettings(XDocument document, RunSettings& runSettings);
    public static bool TryDeserializeDataCollectorConfiguration(XDocument document, DataCollectorConfiguration& configuration);
    public static CoberturaFile ReadCoberturaFile(string path);
    public static XmlFileData ReadXmlFileDataFile(string path);
    public static CoverageXmlFile ReadCoverageXmlFile(string path);
    public static RunSettings ReadRunSettings(string path);
    public static void Write(string path, CoberturaFile coberturaFile);
    public static void Write(string path, XmlFileData xmlFileData);
    public static void Write(string path, CoverageXmlFile coverageXmlFile);
    public static void Write(string path, RunSettings runSettings);
    public static string Serialize(CodeCoverageConfig config);
    public static string Serialize(DataCollectorConfiguration config);
    internal static void Write(string path, Func`1<XElement> serialization);
    internal static string Serialize(Func`1<XElement> serialization);
    [NullableContextAttribute("0")]
internal static TEnum ReadAttributeEnumValue(XElement element, string attributeName, TEnum defaultValue);
    [NullableContextAttribute("0")]
internal static TEnum ReadElementEnumValue(XElement element, string elementName, TEnum defaultValue);
    internal static bool ReadAttributeBoolValue(XElement element, string attributeName, bool defaultValue);
    internal static UInt32 ReadElementUInt32Value(XElement element, string elementName, UInt32 defaultValue);
    internal static void WriteElementUInt32(XElement element, string elementName, UInt32 value, UInt32 defaultValue);
    internal static double ReadElementDoubleValue(XElement element, string elementName, double defaultValue);
    internal static void WriteElement(XElement element, string elementName, double value, double defaultValue);
    internal static bool ReadElementBoolValue(XElement element, string elementName, bool defaultValue);
    internal static void WriteElement(XElement element, string elementName, bool value, bool defaultValue);
    internal static Nullable`1<bool> ReadElementNullableBoolValue(XElement element, string elementName);
    internal static void WriteElementNullableBool(XElement element, string elementName, Nullable`1<bool> value);
    internal static string ReadElementStringValue(XElement element, string elementName, string defaultValue);
    internal static void WriteElement(XElement element, string elementName, string value);
    private static bool TryRead(string path, Func`2<string, T> reader, T& output);
    private static bool TryDeserialize(XDocument document, Func`2<XElement, T> deserializer, T& output);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Vanguard.Legacy.ModuleHandle : object {
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RawData>k__BackingField;
    internal ModuleInstrumentedMessage ModuleInstrumentedMessage { get; }
    [NullableAttribute("1")]
internal string Path { get; }
    internal long Start { get; }
    internal long End { get; }
    internal long Offset { get; }
    internal Byte[] CoverageBuffer { get; internal set; }
    internal string Hash { get; internal set; }
    internal Byte[] RawData { get; internal set; }
    [NullableContextAttribute("1")]
internal ModuleHandle(string path, ModuleInstrumentedMessage moduleInstrumentedMessage, long start, long end, long offset);
    [CompilerGeneratedAttribute]
internal ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal long get_Start();
    [CompilerGeneratedAttribute]
internal long get_End();
    [CompilerGeneratedAttribute]
internal long get_Offset();
    [CompilerGeneratedAttribute]
internal Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
internal void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal string get_Hash();
    [CompilerGeneratedAttribute]
internal void set_Hash(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_RawData();
    [CompilerGeneratedAttribute]
internal void set_RawData(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaClass : CoverageDetails {
    private static string RootElementName;
    private static string MethodsElementName;
    private static string LinesElementName;
    private static string NameAttributeName;
    private static string FilenameAttributeName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaMethod[] <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaLine[] <Lines>k__BackingField;
    public string Name { get; public set; }
    public string Filename { get; public set; }
    public CoberturaMethod[] Methods { get; public set; }
    public CoberturaLine[] Lines { get; public set; }
    internal CoberturaClass(XElement element);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
public void set_Filename(string value);
    [CompilerGeneratedAttribute]
public CoberturaMethod[] get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(CoberturaMethod[] value);
    [CompilerGeneratedAttribute]
public CoberturaLine[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(CoberturaLine[] value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaClassExtensions : object {
    [ExtensionAttribute]
public static void PopulateClassLines(CoberturaClass coberturaClass);
    [ExtensionAttribute]
public static CoberturaClass[] ToArray(Dictionary`2<ValueTuple`2<string, string>, CoberturaClass> input);
    [CompilerGeneratedAttribute]
internal static void <PopulateClassLines>g__AddCondition|0_0(CoberturaCondition condition, <>c__DisplayClass0_0& , <>c__DisplayClass0_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaCondition : object {
    private static string RootElementName;
    private static string NumberAttributeName;
    private static string TypeAttributeName;
    private static string CoverageAttributeName;
    [CompilerGeneratedAttribute]
private int <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Coverage>k__BackingField;
    internal CoberturaConditionInternalData InternalData;
    public int Number { get; public set; }
    public string Type { get; public set; }
    public string Coverage { get; public set; }
    internal CoberturaCondition(XElement element);
    [CompilerGeneratedAttribute]
public int get_Number();
    [CompilerGeneratedAttribute]
public void set_Number(int value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Coverage();
    [CompilerGeneratedAttribute]
public void set_Coverage(string value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Cobertura.CoberturaConditionInternalData : ValueType {
    private UInt32[] _targetOffsetsOrHits;
    private UInt32 _offsetOrHit;
    public int CoveredBranches { get; }
    public int Branches { get; }
    public void Initialize(UInt32 offset, UInt32[] targetOffsets);
    public int get_CoveredBranches();
    public int get_Branches();
    public void AddTargetOffset(UInt32 targetOffset);
    public void PopulateCoverageStatus(Byte[] buffer);
    public bool TryMerge(CoberturaConditionInternalData other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaConditionsHelper : object {
    private static Regex _conditionRegex;
    private static CoberturaConditionsHelper();
    public static string ToLineConditionCoverage(int coveredBranchesCount, int branchesCount);
    public static bool TryParseLineConditionCoverage(string conditionCoverage, Int32& coveredBranchesCount, Int32& branchesCount);
    public static string ToConditionCoverage(int coveredBranchesCount, int branchesCount);
    public static double ToConditionCoveragePercentage(int coveredBranchesCount, int branchesCount);
    public static string ToConditionCoverage(double coverage);
    public static bool TryParseConditionCoverage(string conditionCoverageString, Double& conditionCoverage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaFile : CoverageDetails {
    private static string RootElementName;
    private static string FileVersion;
    private static string VersionAttributeName;
    private static string TimestampAttributeName;
    private static string LinesCoveredAttributeName;
    private static string LinesValidAttributeName;
    private static string BranchesCoveredAttributeName;
    private static string BranchesValidAttributeName;
    private static string SourcesElementName;
    private static string SourceElementName;
    private static string PackagesElementName;
    [CompilerGeneratedAttribute]
private static Lazy`1<CoberturaFile> <EmptyCoberturaFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CoberturaPackage> <Packages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LinesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LinesValid>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BranchesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BranchesValid>k__BackingField;
    internal static Lazy`1<CoberturaFile> EmptyCoberturaFile { get; }
    public string Version { get; public set; }
    public long Timestamp { get; public set; }
    public String[] Sources { get; public set; }
    public List`1<CoberturaPackage> Packages { get; public set; }
    public long LinesCovered { get; public set; }
    public long LinesValid { get; public set; }
    public long BranchesCovered { get; public set; }
    public long BranchesValid { get; public set; }
    internal CoberturaFile(XElement element);
    private static CoberturaFile();
    [CompilerGeneratedAttribute]
internal static Lazy`1<CoberturaFile> get_EmptyCoberturaFile();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
    [CompilerGeneratedAttribute]
public String[] get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(String[] value);
    [CompilerGeneratedAttribute]
public List`1<CoberturaPackage> get_Packages();
    [CompilerGeneratedAttribute]
public void set_Packages(List`1<CoberturaPackage> value);
    [CompilerGeneratedAttribute]
public long get_LinesCovered();
    [CompilerGeneratedAttribute]
public void set_LinesCovered(long value);
    [CompilerGeneratedAttribute]
public long get_LinesValid();
    [CompilerGeneratedAttribute]
public void set_LinesValid(long value);
    [CompilerGeneratedAttribute]
public long get_BranchesCovered();
    [CompilerGeneratedAttribute]
public void set_BranchesCovered(long value);
    [CompilerGeneratedAttribute]
public long get_BranchesValid();
    [CompilerGeneratedAttribute]
public void set_BranchesValid(long value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaFileUtility : object {
    public static CoverageFileLegacy ToCoverageFile(CoberturaFile coberturaFile);
    private static ModuleWrapper ToModuleWrapper(CoberturaPackage package, String[] sources);
    internal static ValueTuple`2<FunctionInstrumentedMessage, Byte[]> ToFunctionInstrumentedMessage(CoberturaMethod method, string typeName, string namespaceName, UInt32 startBlockIndex, UInt32 functionId, UInt32 sourceId);
    internal static SourceFileDataMessage ToSourceFileDataMessage(string path, Dictionary`2<string, UInt32> sourceFiles);
    internal static UInt32 AddSourceFile(string path, Dictionary`2<string, UInt32> sourceFiles);
    internal static Byte[] GetNewIdBytes();
    internal static Byte[] GetNewIdBytes(Guid idGuid);
    internal static ValueTuple`2<string, string> PopulateClassProperties(CoberturaClass coberturaClass);
    internal static string CalculateClassPath(string fileName, String[] sources);
    internal static void AddPackage(CoberturaFile coberturaFile, CoberturaPackage coberturaPackage, CancellationToken token);
    internal static bool AllConditionsHasInternalData(CoberturaLine coberturaLine);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Cobertura.CoberturaFileUtility/<MergeCoberturaFilesAsync>d__11")]
public static Task`1<CoberturaFile> MergeCoberturaFilesAsync(IReadOnlyCollection`1<CoberturaFile> coberturaFiles, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken token);
    internal static CoberturaFile Merge(CoberturaFile file1, CoberturaFile file2, bool skipInvalidFiles, CancellationToken token);
    internal static void Merge(CoberturaPackage target, String[] targetSources, CoberturaPackage source, String[] sourceSources, Boolean& includeSourcesFromSourcePackage, CancellationToken token);
    internal static void Merge(CoberturaClass target, CoberturaClass source, CancellationToken token);
    internal static void Merge(CoberturaMethod target, CoberturaMethod source, CancellationToken token);
    internal static void Merge(CoberturaLine targetLine, CoberturaLine line);
    private static bool CanBeFastMerged(CoberturaMethod target, CoberturaMethod source);
    private static bool TryMergeConditions(CoberturaLine targetLine, CoberturaLine line);
    private static bool TryMergeConditionsUsingInternalData(CoberturaLine targetLine, CoberturaLine line);
    private static bool TryRegenerateConditionsStats(CoberturaLine line, CoberturaConditionStatistics[] lineStats, int coveredBranches, int branches);
    private static void InvalidateAllLineStatistics(CoberturaConditionStatistics[] lineStats);
    private static bool AreConditionsMergeable(CoberturaCondition targetCondition, CoberturaCondition lineCondition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaLine : object {
    private static string RootElementName;
    private static string NumberAttributeName;
    private static string HitsAttributeName;
    private static string BranchAttributeName;
    private static string ConditionCoverageAttributeName;
    private static string ConditionsElementName;
    [CompilerGeneratedAttribute]
private int <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hits>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConditionCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaCondition[] <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<UInt32> <Offset>k__BackingField;
    public int Number { get; public set; }
    public int Hits { get; public set; }
    public bool Branch { get; public set; }
    public string ConditionCoverage { get; public set; }
    public CoberturaCondition[] Conditions { get; public set; }
    public ISet`1<UInt32> Offset { get; public set; }
    internal CoberturaLine(XElement element);
    [CompilerGeneratedAttribute]
public int get_Number();
    [CompilerGeneratedAttribute]
public void set_Number(int value);
    [CompilerGeneratedAttribute]
public int get_Hits();
    [CompilerGeneratedAttribute]
public void set_Hits(int value);
    [CompilerGeneratedAttribute]
public bool get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(bool value);
    [CompilerGeneratedAttribute]
public string get_ConditionCoverage();
    [CompilerGeneratedAttribute]
public void set_ConditionCoverage(string value);
    [CompilerGeneratedAttribute]
public CoberturaCondition[] get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(CoberturaCondition[] value);
    [CompilerGeneratedAttribute]
public ISet`1<UInt32> get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(ISet`1<UInt32> value);
    internal XElement Serialize();
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaLineExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static CoberturaLine[] ToSortedArray(IDictionary`2<int, CoberturaLine> input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaMethod : CoverageDetails {
    private static string RootElementName;
    private static string LinesElementName;
    private static string NameAttributeName;
    private static string SignatureAttributeName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaLine[] <Lines>k__BackingField;
    public string Name { get; public set; }
    public string Signature { get; public set; }
    public CoberturaLine[] Lines { get; public set; }
    internal CoberturaMethod(XElement element);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    [CompilerGeneratedAttribute]
public CoberturaLine[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(CoberturaLine[] value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaPackage : CoverageDetails {
    private static string RootElementName;
    private static string ClassesElementName;
    private static string NameAttributeName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaClass[] <Classes>k__BackingField;
    public string Name { get; public set; }
    public CoberturaClass[] Classes { get; public set; }
    internal CoberturaPackage(XElement element);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public CoberturaClass[] get_Classes();
    [CompilerGeneratedAttribute]
public void set_Classes(CoberturaClass[] value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Cobertura.CoberturaPackageBuilder : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<string, string>, CoberturaMethodArrayWithIndex> _methodsMap;
    private CoberturaMethodElement[] _methods;
    private int _methodsSize;
    public CoberturaPackageBuilder(int classesCapacity, int methodsCapacity);
    public void AddMethod(string namespaceName, string typeName, string filename, CoberturaMethod method);
    public CoberturaClass[] GetClasses();
    private void AddMethod(string name, string filename, CoberturaMethod method);
}
public static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaStatisticsCalculator : object {
    [NullableContextAttribute("1")]
public static void CalculateStatistics(CoberturaFile coverage);
    internal static ValueTuple`4<int, int, int, int> CalculateStatistics(CoberturaPackage package);
    internal static ValueTuple`4<int, int, int, int> CalculateStatistics(CoberturaClass class);
    internal static ValueTuple`4<int, int, int, int> CalculateStatistics(CoberturaMethod method);
    [NullableContextAttribute("1")]
private static int SumAllBranches(CoberturaLine coberturaLine);
    [NullableContextAttribute("1")]
private static int SumAllCoveredBranches(CoberturaLine coberturaLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeCoverage.IO.Cobertura.CoverageDetails : object {
    private static string LineRateAttributeName;
    private static string BranchRateAttributeName;
    private static string ComplexityAttributeName;
    [CompilerGeneratedAttribute]
private double <LineRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BranchRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Complexity>k__BackingField;
    public double LineRate { get; public set; }
    public double BranchRate { get; public set; }
    public double Complexity { get; public set; }
    internal CoverageDetails(XElement element);
    [CompilerGeneratedAttribute]
public double get_LineRate();
    [CompilerGeneratedAttribute]
public void set_LineRate(double value);
    [CompilerGeneratedAttribute]
public double get_BranchRate();
    [CompilerGeneratedAttribute]
public void set_BranchRate(double value);
    [CompilerGeneratedAttribute]
public double get_Complexity();
    [CompilerGeneratedAttribute]
public void set_Complexity(double value);
    internal void Serialize(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Cobertura.MinimalSequencePointsFinder`1 : object {
    private Dictionary`2<T, Dictionary`2<int, int>> _mapping;
    [NullableAttribute("2")]
private Dictionary`2<int, int> _currentMappingForSourceFile;
    public MinimalSequencePointsFinder`1(int capacity);
    [MemberNotNullAttribute("_currentMappingForSourceFile")]
public void SetSourceFile(T sourceFile);
    public void AddSequencePoint(int startLine, int endLine);
    public bool IsMinimal(int lineNumber, int startLine, int endLine);
}
internal class Microsoft.CodeCoverage.IO.Coverage.BasicBlockInfo : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CoverageStatus>k__BackingField;
    public UInt32 Left { get; public set; }
    public UInt32 Right { get; public set; }
    public UInt32 CoverageStatus { get; public set; }
    public BasicBlockInfo(UInt32 left, UInt32 right, UInt32 coverageStatus);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(UInt32 value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual int CompareTo(BasicBlockInfo other);
}
public class Microsoft.CodeCoverage.IO.Coverage.BlockCoverageStatistics : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <BlocksCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlocksNotCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesPartiallyCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesNotCovered>k__BackingField;
    public UInt32 BlocksCovered { get; public set; }
    public UInt32 BlocksNotCovered { get; public set; }
    public UInt32 LinesCovered { get; public set; }
    public UInt32 LinesPartiallyCovered { get; public set; }
    public UInt32 LinesNotCovered { get; public set; }
    public BlockCoverageStatistics(UInt32 BlocksCovered, UInt32 BlocksNotCovered, UInt32 LinesCovered, UInt32 LinesPartiallyCovered, UInt32 LinesNotCovered);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BlocksCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BlocksNotCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksNotCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LinesCovered();
    [CompilerGeneratedAttribute]
public void set_LinesCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LinesPartiallyCovered();
    [CompilerGeneratedAttribute]
public void set_LinesPartiallyCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LinesNotCovered();
    [CompilerGeneratedAttribute]
public void set_LinesNotCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BlockCoverageStatistics left, BlockCoverageStatistics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BlockCoverageStatistics left, BlockCoverageStatistics right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BlockCoverageStatistics other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& BlocksCovered, UInt32& BlocksNotCovered, UInt32& LinesCovered, UInt32& LinesPartiallyCovered, UInt32& LinesNotCovered);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.BlockLineData : ValueType {
    private static string RootElementName;
    private static string SourceIdAttributeName;
    private static string StartLineAttributeName;
    private static string EndLineAttributeName;
    private static string StartColumnAttributeName;
    private static string EndColumnAttributeName;
    private static string CoveredAttributeName;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageStatus <CoverageStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndColumn>k__BackingField;
    internal UInt32 Index { get; internal set; }
    public UInt32 SourceId { get; public set; }
    public CoverageStatus CoverageStatus { get; public set; }
    public UInt32 StartLine { get; public set; }
    public UInt32 StartColumn { get; public set; }
    public UInt32 EndLine { get; public set; }
    public UInt32 EndColumn { get; public set; }
    internal BlockLineData(XElement element);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal UInt32 get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CoverageStatus get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(CoverageStatus value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StartLine();
    [CompilerGeneratedAttribute]
public void set_StartLine(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StartColumn();
    [CompilerGeneratedAttribute]
public void set_StartColumn(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(UInt32 value);
    public virtual string ToString();
    internal XElement Serialize();
    public sealed virtual int CompareTo(BlockLineData other);
    public static bool op_Equality(BlockLineData left, BlockLineData right);
    public static bool op_Inequality(BlockLineData left, BlockLineData right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private bool Equals(BlockLineData other);
    public static bool op_LessThan(BlockLineData left, BlockLineData right);
    public static bool op_LessThanOrEqual(BlockLineData left, BlockLineData right);
    public static bool op_GreaterThan(BlockLineData left, BlockLineData right);
    public static bool op_GreaterThanOrEqual(BlockLineData left, BlockLineData right);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.CoverageBufferData : object {
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`3<Guid, long, long> <CoverageBufferLocation>k__BackingField;
    public string ModuleName { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    internal Byte[] CoverageBuffer { get; internal set; }
    internal Guid Identifier { get; internal set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
internal ValueTuple`3<Guid, long, long> CoverageBufferLocation { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
public void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
internal void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal Guid get_Identifier();
    [CompilerGeneratedAttribute]
internal void set_Identifier(Guid value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal ValueTuple`3<Guid, long, long> get_CoverageBufferLocation();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal void set_CoverageBufferLocation(ValueTuple`3<Guid, long, long> value);
    public static bool op_Equality(CoverageBufferData left, CoverageBufferData right);
    public static bool op_Inequality(CoverageBufferData left, CoverageBufferData right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private bool Equals(CoverageBufferData other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.CoverageData : object {
    [CompilerGeneratedAttribute]
private IList`1<ModuleWrapper> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SkippedModule> <SkippedModules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <TestIds>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<SnapshotTag> <SnapshotTags>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SnapshotTag> <SnapshotTagsInformationMessages>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<Guid, Dictionary`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>>> <CoveragePerSnapshotMessages>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<ValueTuple`2<long, long>> <SkippedModuleLocations>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> <CoverageDataLocations>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> <ModuleDataLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ModuleInstrumentedMessage> <ModuleIds>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<ModuleHandle>> <ModuleHandles>k__BackingField;
    public IList`1<ModuleWrapper> Modules { get; }
    public IList`1<SkippedModule> SkippedModules { get; }
    public IList`1<string> TestIds { get; }
    internal ISet`1<SnapshotTag> SnapshotTags { get; }
    internal bool HasPerTestData { get; }
    internal List`1<SnapshotTag> SnapshotTagsInformationMessages { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<Guid, Dictionary`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>>> CoveragePerSnapshotMessages { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IList`1<ValueTuple`2<long, long>> SkippedModuleLocations { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> CoverageDataLocations { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> ModuleDataLocations { get; }
    internal IDictionary`2<string, ModuleInstrumentedMessage> ModuleIds { get; }
    internal IDictionary`2<string, List`1<ModuleHandle>> ModuleHandles { get; }
    [CompilerGeneratedAttribute]
public IList`1<ModuleWrapper> get_Modules();
    [CompilerGeneratedAttribute]
public IList`1<SkippedModule> get_SkippedModules();
    [CompilerGeneratedAttribute]
public IList`1<string> get_TestIds();
    [CompilerGeneratedAttribute]
internal ISet`1<SnapshotTag> get_SnapshotTags();
    internal bool get_HasPerTestData();
    [CompilerGeneratedAttribute]
internal List`1<SnapshotTag> get_SnapshotTagsInformationMessages();
    [CompilerGeneratedAttribute]
internal Dictionary`2<Guid, Dictionary`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>>> get_CoveragePerSnapshotMessages();
    [CompilerGeneratedAttribute]
internal IList`1<ValueTuple`2<long, long>> get_SkippedModuleLocations();
    [CompilerGeneratedAttribute]
internal IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> get_CoverageDataLocations();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> get_ModuleDataLocations();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, ModuleInstrumentedMessage> get_ModuleIds();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, List`1<ModuleHandle>> get_ModuleHandles();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeCoverage.IO.Coverage.CoverageStatistics : object {
    [CompilerGeneratedAttribute]
private UInt32 <BlocksCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlocksNotCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesPartiallyCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesNotCovered>k__BackingField;
    public string BlockCoverage { get; }
    public string LineCoverage { get; }
    public UInt32 BlocksCovered { get; public set; }
    public UInt32 BlocksNotCovered { get; public set; }
    public UInt32 LinesCovered { get; public set; }
    public UInt32 LinesPartiallyCovered { get; public set; }
    public UInt32 LinesNotCovered { get; public set; }
    internal CoverageStatistics(XElement element);
    public string get_BlockCoverage();
    public string get_LineCoverage();
    [CompilerGeneratedAttribute]
public UInt32 get_BlocksCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlocksNotCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksNotCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LinesCovered();
    [CompilerGeneratedAttribute]
public void set_LinesCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LinesPartiallyCovered();
    [CompilerGeneratedAttribute]
public void set_LinesPartiallyCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LinesNotCovered();
    [CompilerGeneratedAttribute]
public void set_LinesNotCovered(UInt32 value);
    internal void ResetStatistics();
    internal XElement Serialize(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Function : CoverageStatistics {
    private static string RootElementName;
    private static string RangesElementName;
    private static string IdAttributeName;
    private static string TokenAttributeName;
    private static string NameAttributeName;
    private static string NamespaceAttributeName;
    private static string TypeNameAttributeName;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BlockLineData> <LineData>k__BackingField;
    public UInt32 Id { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public string Name { get; public set; }
    public string NamespaceName { get; public set; }
    public string TypeName { get; public set; }
    public List`1<BlockLineData> LineData { get; public set; }
    internal Function(XElement element);
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public List`1<BlockLineData> get_LineData();
    [CompilerGeneratedAttribute]
public void set_LineData(List`1<BlockLineData> value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.FunctionWrapper : object {
    private static UInt32 PartiallyCovered;
    private static UInt32 Covered;
    private static UInt32 NotCovered;
    private static UInt32 Unknown;
    [CompilerGeneratedAttribute]
private Function <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartBlockIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockLineData[] <LineDataOriginal>k__BackingField;
    public Function Function { get; public set; }
    public UInt32 Id { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public string Name { get; public set; }
    public string NamespaceName { get; public set; }
    public string TypeName { get; public set; }
    public UInt32 StartBlockIndex { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    public UInt32 BlockCount { get; public set; }
    public BlockLineData[] LineDataOriginal { get; public set; }
    [CompilerGeneratedAttribute]
public Function get_Function();
    [CompilerGeneratedAttribute]
public void set_Function(Function value);
    public UInt32 get_Id();
    public void set_Id(UInt32 value);
    public UInt32 get_MetadataToken();
    public void set_MetadataToken(UInt32 value);
    public string get_Name();
    public void set_Name(string value);
    public string get_NamespaceName();
    public void set_NamespaceName(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartBlockIndex();
    [CompilerGeneratedAttribute]
public void set_StartBlockIndex(UInt32 value);
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
public void set_BlockCount(UInt32 value);
    [CompilerGeneratedAttribute]
public BlockLineData[] get_LineDataOriginal();
    [CompilerGeneratedAttribute]
public void set_LineDataOriginal(BlockLineData[] value);
    internal void Merge(Byte[] buffer, UInt32 offset, UInt32 count);
    public void CalculateStatistics();
    private UInt32[] CalculateStatistics(IList`1<BasicBlockInfo> blockInfos);
    private bool FasterAlgorithm(IList`1<BasicBlockInfo> blockInfos, UInt32[]& statistics);
    private UInt32[] SlowerAlgorithm(IList`1<BasicBlockInfo> blockInfos);
    private bool IsCovered(UInt32 blockIndex);
}
public interface Microsoft.CodeCoverage.IO.Coverage.ICoverageFileConfiguration {
    public bool ReadModules { get; }
    public bool ReadSkippedModules { get; }
    public bool ReadSkippedFunctions { get; }
    public bool ReadSnapshotsData { get; }
    public bool GenerateCoverageBufferFiles { get; }
    public bool FixCoverageBuffersMismatch { get; }
    public int MaxDegreeOfParallelism { get; }
    public bool SkipInvalidData { get; }
    public CoverageMergeOperation MergeOperation { get; }
    public abstract virtual bool get_ReadModules();
    public abstract virtual bool get_ReadSkippedModules();
    public abstract virtual bool get_ReadSkippedFunctions();
    public abstract virtual bool get_ReadSnapshotsData();
    public abstract virtual bool get_GenerateCoverageBufferFiles();
    public abstract virtual bool get_FixCoverageBuffersMismatch();
    public abstract virtual int get_MaxDegreeOfParallelism();
    public abstract virtual bool get_SkipInvalidData();
    public abstract virtual CoverageMergeOperation get_MergeOperation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Module : CoverageStatistics {
    private static string RootElementName;
    private static string FunctionsElementName;
    private static string SourceFilesElementName;
    private static string SkippedFunctionsElementName;
    private static string IdAttributeName;
    private static string NameAttributeName;
    private static string PathAttributeName;
    private bool _includeSkippedFunctions;
    private string _id;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdString>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Function> <Functions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SkippedFunction> <SkippedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SourceFile> <SourceFiles>k__BackingField;
    public string Name { get; public set; }
    public string Path { get; public set; }
    public string TargetFramework { get; public set; }
    public string Architecture { get; public set; }
    public string Configuration { get; public set; }
    public string Id { get; public set; }
    public string IdString { get; public set; }
    public List`1<Function> Functions { get; public set; }
    public List`1<SkippedFunction> SkippedFunctions { get; public set; }
    public List`1<SourceFile> SourceFiles { get; public set; }
    public Module(string id, bool includeSkippedFunctions);
    internal Module(XElement element);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public string get_Architecture();
    [CompilerGeneratedAttribute]
public void set_Architecture(string value);
    [CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(string value);
    public string get_Id();
    public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_IdString();
    [CompilerGeneratedAttribute]
public void set_IdString(string value);
    [CompilerGeneratedAttribute]
public List`1<Function> get_Functions();
    [CompilerGeneratedAttribute]
public void set_Functions(List`1<Function> value);
    [CompilerGeneratedAttribute]
public List`1<SkippedFunction> get_SkippedFunctions();
    [CompilerGeneratedAttribute]
public void set_SkippedFunctions(List`1<SkippedFunction> value);
    [CompilerGeneratedAttribute]
public List`1<SourceFile> get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(List`1<SourceFile> value);
    public bool ShouldSerializeSkipFunctions();
    public bool ShouldSerializeSourceFiles();
    public bool ShouldSerializeSkippedFunctions();
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.ModuleWrapper : object {
    private UInt32 _nextSourceFileId;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<ValueTuple`2<UInt32, UInt32>, FunctionInstrumentedMessage> _functionInstrumentedMessagesMap;
    private IDictionary`2<UInt32, FunctionSkippedMessage> _functionSkippedMessagesMap;
    private IDictionary`2<string, UInt32> _sourcePathToIdMap;
    private IDictionary`2<UInt32, SourceFile> _sourceFiles;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<ValueTuple`2<UInt32, UInt32>, SkippedFunction> _skippedFunctions;
    private Byte[] _emptyCoverageBuffer;
    [CompilerGeneratedAttribute]
private Module <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SourceFileDataMessage> <SourceFileDataMessages>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<ValueTuple`3<UInt32, UInt32, string>, FunctionWrapper> <FunctionWrappers>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <CoverageBuffers>k__BackingField;
    public Module Module { get; public set; }
    public string Id { get; public set; }
    public string IdString { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    public string TargetFramework { get; public set; }
    public string Architecture { get; public set; }
    public string Configuration { get; public set; }
    public UInt32 BlocksCovered { get; public set; }
    public UInt32 BlocksNotCovered { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    public UInt32 BlockCount { get; public set; }
    public List`1<Function> Functions { get; public set; }
    public List`1<SkippedFunction> SkippedFunctions { get; public set; }
    public List`1<SourceFile> SourceFiles { get; public set; }
    internal ICollection`1<FunctionSkippedMessage> FunctionSkippedMessages { get; }
    internal IList`1<SourceFileDataMessage> SourceFileDataMessages { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<ValueTuple`3<UInt32, UInt32, string>, FunctionWrapper> FunctionWrappers { get; }
    public UInt32 ImageLinkTime { get; }
    public UInt32 ImageSize { get; }
    internal ModuleInstrumentedMessage ModuleInstrumentedMessage { get; internal set; }
    internal ICollection`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; }
    internal IDictionary`2<string, Byte[]> CoverageBuffers { get; }
    internal ModuleWrapper(string id, bool includeSkippedFunctions, ModuleInstrumentedMessage moduleInstrumentedMessage);
    [CompilerGeneratedAttribute]
public Module get_Module();
    [CompilerGeneratedAttribute]
public void set_Module(Module value);
    public string get_Id();
    public void set_Id(string value);
    public string get_IdString();
    public void set_IdString(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Path();
    public void set_Path(string value);
    public string get_TargetFramework();
    public void set_TargetFramework(string value);
    public string get_Architecture();
    public void set_Architecture(string value);
    public string get_Configuration();
    public void set_Configuration(string value);
    public UInt32 get_BlocksCovered();
    public void set_BlocksCovered(UInt32 value);
    public UInt32 get_BlocksNotCovered();
    public void set_BlocksNotCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
public void set_BlockCount(UInt32 value);
    public List`1<Function> get_Functions();
    public void set_Functions(List`1<Function> value);
    public List`1<SkippedFunction> get_SkippedFunctions();
    public void set_SkippedFunctions(List`1<SkippedFunction> value);
    public List`1<SourceFile> get_SourceFiles();
    public void set_SourceFiles(List`1<SourceFile> value);
    internal ICollection`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    [CompilerGeneratedAttribute]
internal IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    [CompilerGeneratedAttribute]
public IDictionary`2<ValueTuple`3<UInt32, UInt32, string>, FunctionWrapper> get_FunctionWrappers();
    public UInt32 get_ImageLinkTime();
    public UInt32 get_ImageSize();
    [CompilerGeneratedAttribute]
internal ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [CompilerGeneratedAttribute]
internal void set_ModuleInstrumentedMessage(ModuleInstrumentedMessage value);
    internal ICollection`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, Byte[]> get_CoverageBuffers();
    public void ClearObjects();
    public ValueTuple`2<SourceFile, bool> AddSourceFile(string path, SourceFileCheckSumType checksumType, Byte[] checksum);
    public SourceFile GetSourceFile(UInt32 id);
    public ValueTuple`2<SkippedFunction, bool> AddSkippedFunction(bool checkInFunctions, UInt32 functionId, UInt32 originalFunctionId, UInt32 metadataToken, FunctionSkipReason functionSkipReason, string name, string typeName, string exceptionMessage);
    internal void RemoveSkippedFunction(UInt32 functionId, UInt32 metadataToken);
    internal ValueTuple`2<FunctionWrapper, bool> AddFunction(UInt32 functionId, UInt32 metadataToken, string name, string typeName, string namespaceName, UInt32 blockCount);
    internal ValueTuple`2<FunctionWrapper, bool> AddFunction(FunctionWrapper function);
    internal void AddFunctionSkippedMessage(FunctionSkippedMessage message);
    internal Nullable`1<FunctionSkippedMessage> GetFunctionSkippedMessage(UInt32 functionId);
    internal void ClearFunctionSkippedMessages();
    internal void AddFunctionInstrumentedMessage(FunctionInstrumentedMessage message);
    [NullableContextAttribute("2")]
internal FunctionInstrumentedMessage GetFunctionInstrumentedMessage(UInt32 functionId, UInt32 metadataToken);
    internal void RemoveFunctionInstrumentedMessage(UInt32 functionId, UInt32 metadataToken);
    internal void UpdateFunctionInstrumentedMessage(FunctionInstrumentedMessage message);
    internal Byte[] GetCoverageBuffer(IList`1<string> testIds);
    internal Byte[] GetCoverageBuffer(SnapshotTag snapshotTag);
    public void CalculateStatistics();
    private void PopulateObjectsFromMessages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.CoverageLineData : object {
    [CompilerGeneratedAttribute]
private UInt32 <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageStatus <CoverageStatus>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public UInt32 StartLine { get; public set; }
    public UInt32 StartColumn { get; public set; }
    public UInt32 EndLine { get; public set; }
    public UInt32 EndColumn { get; public set; }
    public CoverageStatus CoverageStatus { get; public set; }
    public CoverageLineData(UInt32 StartLine, UInt32 StartColumn, UInt32 EndLine, UInt32 EndColumn);
    internal CoverageLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, CoverageStatus coverageStatus);
    [CompilerGeneratedAttribute]
protected CoverageLineData(CoverageLineData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public UInt32 get_StartLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public CoverageStatus get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(CoverageStatus value);
    internal void MergeCoverageStatus(CoverageStatus otherCoverageStatus);
    [NullableContextAttribute("2")]
public virtual bool Equals(CoverageLineData other);
    public virtual int GetHashCode();
    internal static int CompareTo(CoverageLineData first, CoverageLineData second);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(CoverageLineData other);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CoverageLineData left, CoverageLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CoverageLineData left, CoverageLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual CoverageLineData <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StartLine, UInt32& StartColumn, UInt32& EndLine, UInt32& EndColumn);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.CoverageReport : CoverageStatistics {
    [CompilerGeneratedAttribute]
private ModuleData[] <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotTag[] <SnapshotTags>k__BackingField;
    [CompilerGeneratedAttribute]
private SkippedModuleData[] <SkippedModules>k__BackingField;
    public ModuleData[] Modules { get; }
    public SnapshotTag[] SnapshotTags { get; }
    public SkippedModuleData[] SkippedModules { get; }
    public CoverageReport(ModuleData[] modules, SnapshotTag[] snapshotTags, SkippedModuleData[] skippedModules);
    [CompilerGeneratedAttribute]
public ModuleData[] get_Modules();
    [CompilerGeneratedAttribute]
public SnapshotTag[] get_SnapshotTags();
    [CompilerGeneratedAttribute]
public SkippedModuleData[] get_SkippedModules();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.DirectoryData : CoverageStatistics {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryData[] <Directories>k__BackingField;
    [CompilerGeneratedAttribute]
private FileData[] <Files>k__BackingField;
    public string Name { get; public set; }
    public DirectoryData[] Directories { get; public set; }
    public FileData[] Files { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public DirectoryData[] get_Directories();
    [CompilerGeneratedAttribute]
public void set_Directories(DirectoryData[] value);
    [CompilerGeneratedAttribute]
public FileData[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(FileData[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.FileData : CoverageStatistics {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageLineData[] <Lines>k__BackingField;
    public string Name { get; public set; }
    public CoverageLineData[] Lines { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public CoverageLineData[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(CoverageLineData[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.FunctionData : CoverageStatistics {
    private static string RootElementName;
    private static string RangesElementName;
    private static string IdAttributeName;
    private static string TokenAttributeName;
    private static string NameAttributeName;
    private static string NamespaceAttributeName;
    private static string TypeNameAttributeName;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private MultiBlockLineData[] <LineData>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartBlockIndex>k__BackingField;
    public UInt32 Id { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public string Name { get; public set; }
    public string NamespaceName { get; public set; }
    public string TypeName { get; public set; }
    public MultiBlockLineData[] LineData { get; public set; }
    internal UInt32 BlockCount { get; internal set; }
    internal UInt32 StartBlockIndex { get; internal set; }
    internal FunctionData(XElement element);
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public MultiBlockLineData[] get_LineData();
    [CompilerGeneratedAttribute]
public void set_LineData(MultiBlockLineData[] value);
    [CompilerGeneratedAttribute]
internal UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
internal void set_BlockCount(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_StartBlockIndex();
    [CompilerGeneratedAttribute]
internal void set_StartBlockIndex(UInt32 value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.ModuleData : CoverageStatistics {
    private static UInt32 IdLength;
    private static string RootElementName;
    private static string FunctionsElementName;
    private static string SourceFilesElementName;
    private static string SkippedFunctionsElementName;
    private static string IdAttributeName;
    private static string NameAttributeName;
    private static string PathAttributeName;
    private Byte[] _emptyCoverageBuffer;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, SingleBitCoverageBuffer> <CoverageBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SignatureAge>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionData[] <Functions>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceFileData[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private SkippedFunctionData[] <SkippedFunctions>k__BackingField;
    public Byte[] CoverageBuffer { get; }
    internal IDictionary`2<string, SingleBitCoverageBuffer> CoverageBuffers { get; }
    internal string Id { get; }
    public string IdString { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    internal UInt32 ImageLinkTime { get; internal set; }
    internal UInt32 ImageSize { get; internal set; }
    public Guid Signature { get; private set; }
    public UInt32 SignatureAge { get; private set; }
    public FunctionData[] Functions { get; public set; }
    public SourceFileData[] SourceFiles { get; public set; }
    public SkippedFunctionData[] SkippedFunctions { get; public set; }
    public bool SupportsSnapshotCoverage { get; }
    public ModuleData(string id, string name, UInt32 imageLinkTime, UInt32 imageSize, Byte[] coverageBuffer);
    internal ModuleData(XElement element);
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, SingleBitCoverageBuffer> get_CoverageBuffers();
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
public string get_IdString();
    [CompilerGeneratedAttribute]
public void set_IdString(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ImageLinkTime();
    [CompilerGeneratedAttribute]
internal void set_ImageLinkTime(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ImageSize();
    [CompilerGeneratedAttribute]
internal void set_ImageSize(UInt32 value);
    [CompilerGeneratedAttribute]
public Guid get_Signature();
    [CompilerGeneratedAttribute]
private void set_Signature(Guid value);
    [CompilerGeneratedAttribute]
public UInt32 get_SignatureAge();
    [CompilerGeneratedAttribute]
private void set_SignatureAge(UInt32 value);
    [CompilerGeneratedAttribute]
public FunctionData[] get_Functions();
    [CompilerGeneratedAttribute]
public void set_Functions(FunctionData[] value);
    [CompilerGeneratedAttribute]
public SourceFileData[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(SourceFileData[] value);
    [CompilerGeneratedAttribute]
public SkippedFunctionData[] get_SkippedFunctions();
    [CompilerGeneratedAttribute]
public void set_SkippedFunctions(SkippedFunctionData[] value);
    public bool get_SupportsSnapshotCoverage();
    public void ApplyDefaultCoverage();
    public void ApplySnapshotCoverage(SnapshotTag[] snapshotTags, bool recalculateStatistics);
    internal Byte[] GetCoverageBuffer(SnapshotTag snapshotTag);
    private void PopulateSignature();
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.MultiBlockLineData : CoverageLineData {
    private static string RootElementName;
    private static string SourceIdAttributeName;
    private static string StartLineAttributeName;
    private static string EndLineAttributeName;
    private static string StartColumnAttributeName;
    private static string EndColumnAttributeName;
    private static string CoveredAttributeName;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IList`1<UInt32> <AdditionalBlockIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceFileData <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    internal UInt32 Index { get; internal set; }
    [NullableAttribute("2")]
internal IList`1<UInt32> AdditionalBlockIndexes { get; internal set; }
    public IEnumerable`1<UInt32> BlockIndexes { get; }
    public SourceFileData SourceFile { get; public set; }
    public UInt32 SourceId { get; public set; }
    public MultiBlockLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, UInt32 blockIndex, CoverageStatus coverageStatus);
    public MultiBlockLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, SourceFileData sourceFile, CoverageStatus coverageStatus);
    public MultiBlockLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, UInt32 blockIndex, SourceFileData sourceFile);
    internal MultiBlockLineData(XElement element);
    [CompilerGeneratedAttribute]
private MultiBlockLineData(MultiBlockLineData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
internal UInt32 get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(UInt32 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IList`1<UInt32> get_AdditionalBlockIndexes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_AdditionalBlockIndexes(IList`1<UInt32> value);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.Report.MultiBlockLineData/<get_BlockIndexes>d__22")]
public IEnumerable`1<UInt32> get_BlockIndexes();
    [CompilerGeneratedAttribute]
public SourceFileData get_SourceFile();
    [CompilerGeneratedAttribute]
public void set_SourceFile(SourceFileData value);
    public UInt32 get_SourceId();
    public void set_SourceId(UInt32 value);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(MultiBlockLineData other);
    internal XElement Serialize();
    internal static MultiBlockLineData Deserialize(XElement element);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(MultiBlockLineData other);
    public static bool op_LessThan(MultiBlockLineData left, MultiBlockLineData right);
    public static bool op_LessThanOrEqual(MultiBlockLineData left, MultiBlockLineData right);
    public static bool op_GreaterThan(MultiBlockLineData left, MultiBlockLineData right);
    public static bool op_GreaterThanOrEqual(MultiBlockLineData left, MultiBlockLineData right);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MultiBlockLineData left, MultiBlockLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MultiBlockLineData left, MultiBlockLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CoverageLineData other);
    [CompilerGeneratedAttribute]
public virtual CoverageLineData <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.SkippedFunctionData : object {
    private static string RootElementName;
    private static string IdAttributeName;
    private static string OriginalIdAttributeName;
    private static string TokenAttributeName;
    private static string NameAttributeName;
    private static string TypeNameAttributeName;
    private static string ReasonAttributeName;
    private static string ExceptionMessageAttributeName;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OriginalId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionSkipReason <FunctionSkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    public UInt32 Id { get; public set; }
    public UInt32 OriginalId { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public string Name { get; public set; }
    public string TypeName { get; public set; }
    public FunctionSkipReason FunctionSkipReason { get; public set; }
    public string ExceptionMessage { get; public set; }
    internal SkippedFunctionData(XElement element);
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_OriginalId();
    [CompilerGeneratedAttribute]
public void set_OriginalId(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public FunctionSkipReason get_FunctionSkipReason();
    [CompilerGeneratedAttribute]
public void set_FunctionSkipReason(FunctionSkipReason value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    internal XElement Serialize();
    public static bool op_Equality(SkippedFunctionData left, SkippedFunctionData right);
    public static bool op_Inequality(SkippedFunctionData left, SkippedFunctionData right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private bool Equals(SkippedFunctionData other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.SkippedModuleData : object {
    private static string RootElementName;
    private static string NameAttributeName;
    private static string PathAttributeName;
    private static string ReasonAttributeName;
    private static string ExceptionMessageAttributeName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSkipReason <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    public string Name { get; public set; }
    public string Path { get; public set; }
    public ModuleSkipReason SkipReason { get; public set; }
    public string ExceptionMessage { get; public set; }
    internal SkippedModuleData(XElement element);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public ModuleSkipReason get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(ModuleSkipReason value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    internal XElement Serialize();
    public static bool op_Equality(SkippedModuleData left, SkippedModuleData right);
    public static bool op_Inequality(SkippedModuleData left, SkippedModuleData right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private bool Equals(SkippedModuleData other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.SnapshotTag : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private static SnapshotTag <AllSnapshotTags>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public String[] Properties { get; public set; }
    public static SnapshotTag AllSnapshotTags { get; }
    public SnapshotTag(string Id, string Name, String[] Properties);
    [CompilerGeneratedAttribute]
protected SnapshotTag(SnapshotTag original);
    private static SnapshotTag();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Properties(String[] value);
    [CompilerGeneratedAttribute]
public static SnapshotTag get_AllSnapshotTags();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotTag left, SnapshotTag right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotTag left, SnapshotTag right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SnapshotTag other);
    [CompilerGeneratedAttribute]
public virtual SnapshotTag <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name, String[]& Properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.SourceFileData : object {
    private static string MD5;
    private static string SHA1;
    private static string SHA256;
    private static string Unknown;
    private static string RootElementName;
    private static string IdAttributeName;
    private static string PathAttributeName;
    private static string ChecksumTypeAttributeName;
    private static string ChecksumAttributeName;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceFileCheckSumType <ChecksumType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    internal static SourceFileData EmptySourceFile { get; }
    internal bool IsValid { get; }
    public UInt32 Id { get; public set; }
    public string Path { get; public set; }
    public SourceFileCheckSumType ChecksumType { get; public set; }
    public Byte[] Checksum { get; public set; }
    private string ChecksumTypeString { get; private set; }
    public SourceFileData(string path);
    public SourceFileData(UInt32 id, string path, SourceFileCheckSumType checksumType, Byte[] checksum);
    internal SourceFileData(XElement element);
    internal static SourceFileData get_EmptySourceFile();
    [CompilerGeneratedAttribute]
internal bool get_IsValid();
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public SourceFileCheckSumType get_ChecksumType();
    [CompilerGeneratedAttribute]
public void set_ChecksumType(SourceFileCheckSumType value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
public void set_Checksum(Byte[] value);
    private bool ShouldSerializeChecksumType();
    private bool ShouldSerializeChecksum();
    private string get_ChecksumTypeString();
    private void set_ChecksumTypeString(string value);
    internal XElement Serialize();
    public static bool op_Equality(SourceFileData left, SourceFileData right);
    public static bool op_Inequality(SourceFileData left, SourceFileData right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private bool Equals(SourceFileData other);
    private bool EqualsCheckSums(Byte[] otherCheckSum);
    public virtual int GetHashCode();
}
public class Microsoft.CodeCoverage.IO.Coverage.Report.SourceReport : DirectoryData {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.XmlFileData : object {
    private static string RootElementName;
    private static string ModulesElementName;
    private static string SkippedModulesElementName;
    [CompilerGeneratedAttribute]
private ModuleData[] <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private SkippedModuleData[] <SkippedModules>k__BackingField;
    public ModuleData[] Modules { get; public set; }
    public SkippedModuleData[] SkippedModules { get; public set; }
    internal XmlFileData(XElement element);
    [CompilerGeneratedAttribute]
public ModuleData[] get_Modules();
    [CompilerGeneratedAttribute]
public void set_Modules(ModuleData[] value);
    [CompilerGeneratedAttribute]
public SkippedModuleData[] get_SkippedModules();
    [CompilerGeneratedAttribute]
public void set_SkippedModules(SkippedModuleData[] value);
    internal XElement Serialize();
}
internal class Microsoft.CodeCoverage.IO.Coverage.Segment : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CoverageStatus>k__BackingField;
    public UInt32 Left { get; public set; }
    public bool Span { get; public set; }
    public UInt32 CoverageStatus { get; public set; }
    public Segment(UInt32 left, bool span);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Span();
    [CompilerGeneratedAttribute]
public void set_Span(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(UInt32 value);
    public sealed virtual int CompareTo(Segment other);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public class Microsoft.CodeCoverage.IO.Coverage.SkippedFunction : SkippedFunctionData {
    [NullableContextAttribute("1")]
internal SkippedFunction(XElement element);
}
public class Microsoft.CodeCoverage.IO.Coverage.SkippedModule : SkippedModuleData {
    [NullableContextAttribute("1")]
internal SkippedModule(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.SourceFile : SourceFileData {
    public SourceFile(UInt32 id, string path, SourceFileCheckSumType checksumType, Byte[] checksum);
    internal SourceFile(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.TestCaseInformation : SnapshotTag {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public TestCaseInformation(string Id, string Name, String[] Properties);
    [CompilerGeneratedAttribute]
protected TestCaseInformation(TestCaseInformation original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestCaseInformation left, TestCaseInformation right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestCaseInformation left, TestCaseInformation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotTag other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestCaseInformation other);
    [CompilerGeneratedAttribute]
public virtual SnapshotTag <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name, String[]& Properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.CoverageFileUtility : object {
    private Lazy`1<ICoverageFileUtilityV2> _coverageFileUtilityV2;
    private Lazy`1<CoverageFileConfiguration> _coverageFileConfiguration;
    internal CoverageFileUtility(CoverageFileConfiguration coverageFileConfiguration, ICoverageFileUtilityV2 coverageFileUtilityV2);
    public sealed virtual bool IsValidCoverageFile(string path);
    public sealed virtual CoverageData ReadCoverageFile(string path);
    public sealed virtual CoverageData ReadCoverageFile(string path, IList`1<string> testIds);
    public sealed virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages);
    public sealed virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds);
    public sealed virtual TestCaseInformation[] ReadTestCases(string path);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, CancellationToken token);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, IList`1<string> testIds, CancellationToken token);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, CancellationToken token);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds, CancellationToken token);
    public sealed virtual void WriteCoverageFile(string path, CoverageData coverageData);
    public sealed virtual void SplitCoverageFile(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<SplitCoverageFileAsync>d__16")]
public sealed virtual Task SplitCoverageFileAsync(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    public sealed virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles);
    public sealed virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageBufferFilesAsync>d__19")]
public sealed virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageBufferFilesAsync>d__20")]
public sealed virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CancellationToken token);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files, int taskCount);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles, int taskCount);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__25")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__26")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__27")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__28")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, int taskCount, CancellationToken token);
    public sealed virtual void ConvertCoverageFile(string path, string outputPath, bool includeSkippedFunctions, bool includeSkippedModules);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<GetCoverageReportAsync>d__30")]
public sealed virtual Task`1<ValueTuple`2<CoverageReportType, object>> GetCoverageReportAsync(string path, bool skipInvalidFile, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__31")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__32")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__33")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__34")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__35")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__36")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__37")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<TrySquashMerge>d__39")]
private Task`1<bool> TrySquashMerge(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [CompilerGeneratedAttribute]
private ICoverageFileUtilityV2 <.ctor>b__2_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.CoverageFileUtilityV2 : object {
    private ICoverageFileConfiguration _fileConfiguration;
    private ICoverageFileReader _coverageFileReader;
    private IReportsReader _reportsReader;
    private IReportsMerger _reportsMerger;
    public CoverageFileUtilityV2(ICoverageFileConfiguration coverageFileConfiguration);
    public CoverageFileUtilityV2(ICoverageFileConfiguration coverageFileConfiguration, ILogger logger);
    internal CoverageFileUtilityV2(ICoverageFileConfiguration coverageFileConfiguration, ValueTuple`3<ICoverageFileReader, IReportsReader, IReportsMerger> coverageObjects);
    public virtual bool IsValidCoverageFile(string path);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<ReadCoverageFileAsync>d__8")]
public virtual Task`1<CoverageReport> ReadCoverageFileAsync(string path, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<string> GetUniqueSourceFiles(CoverageReport coverageReport);
    [ObsoleteAttribute("Use "FileData[] GetFileCoverage(CoverageReport coverageReport, HashSet<string> sourceFiles)" instead.")]
public sealed virtual IList`1<CoverageLineData> GetCoverageLines(string sourceFile, CoverageReport coverageReport);
    public sealed virtual XmlFileData ReadXmlCoverageFile(string path);
    public sealed virtual void WriteXmlCoverageFile(string path, XmlFileData report);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<ToXmlFileAsync>d__13")]
public sealed virtual Task ToXmlFileAsync(string path, string outputPath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<ToXmlFileAsync>d__14")]
public sealed virtual Task`1<XmlFileData> ToXmlFileAsync(string path, CancellationToken cancellationToken);
    public sealed virtual CoberturaFile ReadCoberturaFile(string path);
    public sealed virtual SourceReport ToSourceReport(CoverageReport[] coverageReports);
    public sealed virtual SourceReport ToSourceReport(FileData[] files);
    public sealed virtual FileData[] GetFileCoverage(ModuleData[] modules, HashSet`1<string> sourceFiles);
    public sealed virtual FileData[] GetFileCoverage(ModuleData[] modules, Dictionary`2<string, HashSet`1<UInt32>> changeset);
    public sealed virtual FileData[] GetFileCoverage(CoberturaFile coberturaFile, HashSet`1<string> sourceFiles);
    public sealed virtual FileData[] GetFileCoverage(CoberturaFile coberturaFile, Dictionary`2<string, HashSet`1<UInt32>> changeset);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<MergeCoverageFilesAsync>d__22")]
[ObsoleteAttribute("Use "Task<string[]> MergeCoverageFilesAsync(string outputPath, string[] files, CoverageMergeOperation mergeOperation, CancellationToken cancellationToken)" instead.")]
public sealed virtual Task MergeCoverageFilesAsync(string outputPath, IList`1<string> files, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<MergeCoverageFilesAsync>d__23")]
public sealed virtual Task`1<String[]> MergeCoverageFilesAsync(string outputPath, String[] files, CoverageMergeOperation mergeOperation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.CoverageXmlFile : object {
    private static string RootElementName;
    private static string ModulesElementName;
    private static string SkippedModulesElementName;
    [CompilerGeneratedAttribute]
private List`1<Module> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SkippedModule> <SkippedModules>k__BackingField;
    public List`1<Module> Modules { get; public set; }
    public List`1<SkippedModule> SkippedModules { get; public set; }
    internal CoverageXmlFile(XElement element);
    [CompilerGeneratedAttribute]
public List`1<Module> get_Modules();
    [CompilerGeneratedAttribute]
public void set_Modules(List`1<Module> value);
    [CompilerGeneratedAttribute]
public List`1<SkippedModule> get_SkippedModules();
    [CompilerGeneratedAttribute]
public void set_SkippedModules(List`1<SkippedModule> value);
    internal XElement Serialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This exception is obsolete and will be removed in a future version. Please use CoverageFileException from Microsoft.CodeCoverage.Core.Exceptions namespace.")]
public class Microsoft.CodeCoverage.IO.Exceptions.CoverageFileException : VanguardException {
    public CoverageFileException(string path);
    public CoverageFileException(string path, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This exception is obsolete and will be removed in a future version. Please use InvalidBufferCountException from Microsoft.CodeCoverage.Core.Exceptions namespace.")]
public class Microsoft.CodeCoverage.IO.Exceptions.InvalidBufferCountException : VanguardException {
    public InvalidBufferCountException(string message);
    public InvalidBufferCountException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This exception is obsolete and will be removed in a future version. Please use InvalidCoverageFileException from Microsoft.CodeCoverage.Core.Exceptions namespace.")]
public class Microsoft.CodeCoverage.IO.Exceptions.InvalidCoverageFileException : VanguardException {
    public InvalidCoverageFileException(string path);
    public InvalidCoverageFileException(string path, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This exception is obsolete and will be removed in a future version. Please use UnsupportedCoverageFileException from Microsoft.CodeCoverage.Core.Exceptions namespace.")]
public class Microsoft.CodeCoverage.IO.Exceptions.UnsupportedCoverageFileException : VanguardException {
    public UnsupportedCoverageFileException(string path);
    public UnsupportedCoverageFileException(string path, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This exception is obsolete and will be removed in a future version. Please use CoverageException from Microsoft.CodeCoverage.Core.Exceptions namespace.")]
public class Microsoft.CodeCoverage.IO.Exceptions.VanguardException : Exception {
    public VanguardException(string message);
    public VanguardException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.IO.ICoverageFileUtility {
    public abstract virtual bool IsValidCoverageFile(string path);
    public abstract virtual CoverageData ReadCoverageFile(string path);
    public abstract virtual CoverageData ReadCoverageFile(string path, IList`1<string> testIds);
    public abstract virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages);
    public abstract virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds);
    public abstract virtual TestCaseInformation[] ReadTestCases(string path);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, CancellationToken token);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, IList`1<string> testIds, CancellationToken token);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, CancellationToken token);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds, CancellationToken token);
    public abstract virtual void WriteCoverageFile(string path, CoverageData coverageData);
    public abstract virtual void SplitCoverageFile(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles);
    public abstract virtual Task SplitCoverageFileAsync(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    public abstract virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles);
    public abstract virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles);
    public abstract virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, CancellationToken token);
    public abstract virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files, int taskCount);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles, int taskCount);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, CancellationToken token);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, int taskCount, CancellationToken token);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, int taskCount, CancellationToken token);
    public abstract virtual void ConvertCoverageFile(string path, string outputPath, bool includeSkippedModules, bool includeSkippedFunctions);
    public abstract virtual Task`1<ValueTuple`2<CoverageReportType, object>> GetCoverageReportAsync(string path, bool skipInvalidFile, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.IO.ICoverageFileUtilityV2 {
    public abstract virtual bool IsValidCoverageFile(string path);
    public abstract virtual Task`1<CoverageReport> ReadCoverageFileAsync(string path, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<string> GetUniqueSourceFiles(CoverageReport coverageReport);
    [ObsoleteAttribute("Use "FileData[] GetFileCoverage(CoverageReport coverageReport, HashSet<string> sourceFiles)" instead.")]
public abstract virtual IList`1<CoverageLineData> GetCoverageLines(string sourceFile, CoverageReport coverageReport);
    public abstract virtual XmlFileData ReadXmlCoverageFile(string path);
    public abstract virtual void WriteXmlCoverageFile(string path, XmlFileData report);
    public abstract virtual Task ToXmlFileAsync(string path, string outputPath, CancellationToken cancellationToken);
    public abstract virtual Task`1<XmlFileData> ToXmlFileAsync(string path, CancellationToken cancellationToken);
    public abstract virtual CoberturaFile ReadCoberturaFile(string path);
    public abstract virtual SourceReport ToSourceReport(FileData[] files);
    public abstract virtual SourceReport ToSourceReport(CoverageReport[] coverageReports);
    public abstract virtual FileData[] GetFileCoverage(ModuleData[] modules, HashSet`1<string> sourceFiles);
    public abstract virtual FileData[] GetFileCoverage(ModuleData[] modules, Dictionary`2<string, HashSet`1<UInt32>> changeset);
    public abstract virtual FileData[] GetFileCoverage(CoberturaFile coberturaFile, HashSet`1<string> sourceFiles);
    public abstract virtual FileData[] GetFileCoverage(CoberturaFile coberturaFile, Dictionary`2<string, HashSet`1<UInt32>> changeset);
    [ObsoleteAttribute("Use "Task<string[]> MergeCoverageFilesAsync(string outputPath, string[] files, CoverageMergeOperation mergeOperation, CancellationToken cancellationToken)" instead.")]
public abstract virtual Task MergeCoverageFilesAsync(string outputPath, IList`1<string> files, CancellationToken cancellationToken);
    public abstract virtual Task`1<String[]> MergeCoverageFilesAsync(string outputPath, String[] files, CoverageMergeOperation mergeOperation, CancellationToken cancellationToken);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
