[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeCoverage.Instrumentation.CecilPdbReader : object {
    private PEReader _reader;
    private UnmanagedMemoryStream _stream;
    private ModuleDefinition _moduleDefinition;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    public Byte[] IdBytes { get; }
    public string PdbPath { get; }
    public CecilPdbReader(PEReader reader, string pdbPath, Byte[] idBytes);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_IdBytes();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.CecilPdbReader/<GetSequencePoints>d__11")]
public sealed virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    public sealed virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
    private void Initialize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.CoberturaReportHelper : object {
    [ExtensionAttribute]
public static CoberturaPackage ToCoberturaPackage(AssemblyMetadata assemblyMetadata);
    public static CoberturaPackage ToCoberturaPackage(Byte[] streamData);
    [ExtensionAttribute]
public static void PopulateCoverageStatus(CoberturaPackage package, Byte[] coverageBuffer);
    [ExtensionAttribute]
internal static void PopulateMethodLines(CoberturaPackage package);
    private static void ParsePackageMethods(AssemblyMetadata assemblyMetadata, CoberturaPackage package);
    private static void AddMethod(MethodMetadata method, UInt32 offset, CoberturaPackage package, Dictionary`2<ValueTuple`2<string, string>, CoberturaClass> coberturaClasses, Dictionary`2<string, IList`1<CoberturaClass>> filesClassesDictionary, Dictionary`2<int, MethodBlock> instructionBlockMap);
    private static CoberturaClass GetCoberturaClass(string namespaceName, string typeName, CoberturaPackage package, IDictionary`2<ValueTuple`2<string, string>, CoberturaClass> coberturaClasses, string filename, IList`1<CoberturaClass> existingClasses);
    private static void PopulateClassLines(Dictionary`2<int, List`1<ValueTuple`2<CoberturaLine, CoberturaMethod>>> lineMethodDictionary, CoberturaClass coberturaClass);
    private static void AddMethod(BinaryMessageReader reader, CoberturaPackage package, IDictionary`2<ValueTuple`2<string, string>, CoberturaClass> coberturaClasses, IDictionary`2<UInt32, string> sourceFiles, Dictionary`2<string, IList`1<CoberturaClass>> filesClassesDictionary);
    private static Dictionary`2<int, List`1<ValueTuple`2<CoberturaLine, CoberturaMethod>>> ParseSequencePoints(MethodMetadata method, UInt32 offset, CoberturaMethod coberturaMethod, Dictionary`2<int, MethodBlock> instructionBlockMap);
    private static CoberturaLine AddCoberturaLine(CoberturaMethod coberturaMethod, Dictionary`2<int, List`1<ValueTuple`2<CoberturaLine, CoberturaMethod>>> lineMethodDictionary, int startLine, int lineNumber);
    private static Dictionary`2<int, List`1<ValueTuple`2<CoberturaLine, CoberturaMethod>>> ParseSequencePoints(BlockLineDataMessage[] lineData, CoberturaMethod coberturaMethod);
    private static void AddCoberturaConditions(MethodMetadata method, UInt32 offset, int i, SequencePointMetadata sequencePoint, CoberturaLine coberturaLine, HashSet`1<int> conditionsAlreadyInserted, Dictionary`2<int, MethodBlock> instructionBlockMap);
    private static CoberturaCondition CreateCoberturaCondition(UInt32 offset, SequencePointMetadata sequencePoint, CoberturaLine coberturaLine, Dictionary`2<int, MethodBlock> instructionBlockMap, Instruction instruction);
    private static void RemoveExistingLines(IList`1<CoberturaClass> coberturaClasses, Dictionary`2<int, List`1<ValueTuple`2<CoberturaLine, CoberturaMethod>>> lineMethodMetadata);
    private static void AddSourceFile(BinaryMessageReader reader, Dictionary`2<UInt32, string> sourceFiles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.Helper : object {
    public static string PrefixSeparator;
    public static string ManagedPrefix;
    public static string UnmanagedPrefix;
    public static string EntrypointPrefix;
    private static MethodAttributes NoMethodBodyAttributes;
    private static MethodImplAttributes NoMethodBodyImplementationAttributes;
    [ExtensionAttribute]
public static bool HasBody(MethodDefinition methodDefinition);
    public static IDictionary`2<TypeDefinitionHandle, TypeMetadata> GetTypes(ReflectionContainer reflectionContainer, TypeDefinitionHandleCollection handles, AssemblyMetadata parent);
    public static TypeMetadata GetType(ReflectionContainer reflectionContainer, TypeDefinitionHandle handle, AssemblyMetadata parent);
    public static IList`1<EventMetadata> GetEvents(ReflectionContainer reflectionContainer, EventDefinitionHandleCollection handles, TypeMetadata parent);
    public static EventMetadata GetEvent(ReflectionContainer reflectionContainer, EventDefinitionHandle handle, TypeMetadata parent);
    public static IList`1<PropertyMetadata> GetProperties(ReflectionContainer reflectionContainer, PropertyDefinitionHandleCollection handles, TypeMetadata parent);
    public static PropertyMetadata GetProperty(ReflectionContainer reflectionContainer, PropertyDefinitionHandle handle, TypeMetadata parent);
    public static IList`1<MethodMetadata> GetMethods(ReflectionContainer reflectionContainer, PropertyAccessors accessors, TypeMetadata parent);
    public static IList`1<MethodMetadata> GetMethods(ReflectionContainer reflectionContainer, EventAccessors accessors, TypeMetadata parent);
    public static IList`1<MethodMetadata> GetMethods(ReflectionContainer reflectionContainer, MethodDefinitionHandleCollection handles, TypeMetadata parent);
    public static MethodMetadata GetMethod(ReflectionContainer reflectionContainer, MethodDefinitionHandle handle, TypeMetadata parent);
    public static string RemoveTypeParameter(string name);
    public static string GetParametersString(ReflectionContainer reflectionContainer, MethodDefinition definition);
    public static string GetParametersString(ReflectionContainer reflectionContainer, TypeDefinition definition);
    [NullableContextAttribute("0")]
internal static Byte[] CalculatePublicKeyToken(ImmutableArray`1<byte> publicKey);
    private static void AddGenericParameters(MethodDefinition methodDefinition, StringBuilder stringBuilder, SignatureVisualizer visualizer, MethodSignature`1<string> signature);
    private static void AddParameters(ReflectionContainer reflectionContainer, StringBuilder stringBuilder, ParameterHandleCollection parameterHandles, MethodSignature`1<string> signature);
    public static UInt32 GetBlockSize(AssemblyMetadata assemblyMetadata, CancellationToken token);
    public static IList`1<CustomAttributeMetadata> GetCustomAttributes(ReflectionContainer reflectionContainer, CustomAttributeHandleCollection handles);
    internal static CustomAttributeMetadata GetCustomAttribute(MetadataReader metadataReader, CustomAttribute customAttribute);
    public static bool IsPartOfExpressionBreakpointsPattern(MethodBlock currentBlock, MethodBlock previousBlock, MethodBlock nextBlock);
    private static bool IsExpressionBreakpointsPattern(Instruction instruction1, Instruction instruction2, Instruction instruction3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.IL.BranchInstruction : Instruction {
    [CompilerGeneratedAttribute]
private int <TargetOffset>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int TargetOffset { get; public set; }
    public BranchInstruction(ILOpCode OpCode, InstructionTerminationType TerminationType, int Offset, int TargetOffset);
    [CompilerGeneratedAttribute]
protected BranchInstruction(BranchInstruction original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_TargetOffset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetOffset(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BranchInstruction left, BranchInstruction right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BranchInstruction left, BranchInstruction right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Instruction other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(BranchInstruction other);
    [CompilerGeneratedAttribute]
public virtual Instruction <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ILOpCode& OpCode, InstructionTerminationType& TerminationType, Int32& Offset, Int32& TargetOffset);
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.IL.Extensions : object {
    private static ILOpCodeInfo None;
    private static ILOpCodeInfo Byte;
    private static ILOpCodeInfo ByteBranch;
    private static ILOpCodeInfo Int;
    private static ILOpCodeInfo IntBranch;
    private static ILOpCodeInfo Token;
    private static ILOpCodeInfo Long;
    private static ILOpCodeInfo Single;
    private static ILOpCodeInfo Double;
    private static ILOpCodeInfo Switch;
    private static ILOpCodeInfo TwoNone;
    private static ILOpCodeInfo TwoToken;
    private static ILOpCodeInfo TwoUShort;
    private static ILOpCodeInfo TwoByte;
    private static Extensions();
    [ExtensionAttribute]
public static ILOpCode DecodeOpCode(BlobReader& blob);
    [ExtensionAttribute]
public static InstructionTerminationType GetInstructionTerminationType(ILOpCode opCode);
    [ExtensionAttribute]
public static bool IsShortBranch(ILOpCode opCode);
    [ExtensionAttribute]
public static bool IsDirectBranch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static bool IsIndirectBranch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static bool IsConditionalBranch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static bool IsSwitch(InstructionTerminationType instructionTerminationType);
    [ExtensionAttribute]
public static ILOpCodeInfo GetILOpCodeInfo(ILOpCode opCode);
}
internal enum Microsoft.CodeCoverage.Instrumentation.IL.ILOpCodeFlags : Enum {
    public int value__;
    public static ILOpCodeFlags None;
    public static ILOpCodeFlags Meta;
    public static ILOpCodeFlags Unused;
    public static ILOpCodeFlags Branch;
}
internal class Microsoft.CodeCoverage.Instrumentation.IL.ILOpCodeInfo : object {
    [CompilerGeneratedAttribute]
private int <OpCodeLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperandLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ILOperandType <OperandType>k__BackingField;
    [CompilerGeneratedAttribute]
private ILOpCodeFlags <OpCodeFlags>k__BackingField;
    public int OpCodeLength { get; public set; }
    public int OperandLength { get; public set; }
    public ILOperandType OperandType { get; public set; }
    public ILOpCodeFlags OpCodeFlags { get; public set; }
    public ILOpCodeInfo(int opCodeLength, int operandLength, ILOperandType operandType, ILOpCodeFlags opCodeFlags);
    [CompilerGeneratedAttribute]
public int get_OpCodeLength();
    [CompilerGeneratedAttribute]
public void set_OpCodeLength(int value);
    [CompilerGeneratedAttribute]
public int get_OperandLength();
    [CompilerGeneratedAttribute]
public void set_OperandLength(int value);
    [CompilerGeneratedAttribute]
public ILOperandType get_OperandType();
    [CompilerGeneratedAttribute]
public void set_OperandType(ILOperandType value);
    [CompilerGeneratedAttribute]
public ILOpCodeFlags get_OpCodeFlags();
    [CompilerGeneratedAttribute]
public void set_OpCodeFlags(ILOpCodeFlags value);
}
internal enum Microsoft.CodeCoverage.Instrumentation.IL.ILOperandType : Enum {
    public int value__;
    public static ILOperandType None;
    public static ILOperandType Byte;
    public static ILOperandType Int;
    public static ILOperandType UShort;
    public static ILOperandType Long;
    public static ILOperandType Single;
    public static ILOperandType Double;
    public static ILOperandType Token;
    public static ILOperandType Switch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.IL.Instruction : object {
    [CompilerGeneratedAttribute]
private ILOpCode <OpCode>k__BackingField;
    [CompilerGeneratedAttribute]
private InstructionTerminationType <TerminationType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ILOpCode OpCode { get; public set; }
    public InstructionTerminationType TerminationType { get; public set; }
    public int Offset { get; public set; }
    public Instruction(ILOpCode OpCode, InstructionTerminationType TerminationType, int Offset);
    [CompilerGeneratedAttribute]
protected Instruction(Instruction original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ILOpCode get_OpCode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OpCode(ILOpCode value);
    [CompilerGeneratedAttribute]
public InstructionTerminationType get_TerminationType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TerminationType(InstructionTerminationType value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Offset(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Instruction left, Instruction right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Instruction left, Instruction right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Instruction other);
    [CompilerGeneratedAttribute]
public virtual Instruction <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ILOpCode& OpCode, InstructionTerminationType& TerminationType, Int32& Offset);
}
internal enum Microsoft.CodeCoverage.Instrumentation.IL.InstructionTerminationType : Enum {
    public int value__;
    public static InstructionTerminationType FallThrough;
    public static InstructionTerminationType Branch;
    public static InstructionTerminationType ConditionalBranch;
    public static InstructionTerminationType Throw;
    public static InstructionTerminationType Switch;
    public static InstructionTerminationType Call;
    public static InstructionTerminationType IndirectCall;
    public static InstructionTerminationType Return;
    public static InstructionTerminationType Trap;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.IL.SwitchInstruction : Instruction {
    [CompilerGeneratedAttribute]
private Int32[] <TargetOffsets>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Int32[] TargetOffsets { get; public set; }
    public SwitchInstruction(ILOpCode OpCode, InstructionTerminationType TerminationType, int Offset, Int32[] TargetOffsets);
    [CompilerGeneratedAttribute]
protected SwitchInstruction(SwitchInstruction original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Int32[] get_TargetOffsets();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetOffsets(Int32[] value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SwitchInstruction left, SwitchInstruction right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SwitchInstruction left, SwitchInstruction right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Instruction other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SwitchInstruction other);
    [CompilerGeneratedAttribute]
public virtual Instruction <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ILOpCode& OpCode, InstructionTerminationType& TerminationType, Int32& Offset, Int32[]& TargetOffsets);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.ILibraryHelper {
    public abstract virtual bool IsNativeLibrary(string path);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.IModuleCoverageContainer {
    [NullableAttribute("2")]
public string PdbPath { get; }
    public UInt32 BlockSize { get; }
    public Guid Identifier { get; }
    [NullableAttribute("2")]
public string BufferName { get; }
    public int BufferSize { get; }
    public bool IsSkipped { get; }
    public ModuleSkipReason ModuleSkipReason { get; }
    public ModuleInstrumentedMessage ModuleInstrumentedMessage { get; }
    public IList`1<InstrumentedFunctionMessage> InstrumentedFunctionMessages { get; }
    public IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; }
    public IList`1<FunctionSkippedMessage> FunctionSkippedMessages { get; }
    public IList`1<SourceFileDataMessage> SourceFileDataMessages { get; }
    public bool IsMixed { get; }
    public bool IsPortablePdb { get; }
    [NullableAttribute("2")]
public string TargetFramework { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_PdbPath();
    public abstract virtual UInt32 get_BlockSize();
    public abstract virtual Guid get_Identifier();
    [NullableContextAttribute("2")]
public abstract virtual string get_BufferName();
    public abstract virtual int get_BufferSize();
    public abstract virtual bool get_IsSkipped();
    public abstract virtual ModuleSkipReason get_ModuleSkipReason();
    public abstract virtual ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    public abstract virtual IList`1<InstrumentedFunctionMessage> get_InstrumentedFunctionMessages();
    public abstract virtual IList`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    public abstract virtual IList`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    public abstract virtual IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    public abstract virtual bool get_IsMixed();
    public abstract virtual bool get_IsPortablePdb();
    [NullableContextAttribute("2")]
public abstract virtual string get_TargetFramework();
}
public interface Microsoft.CodeCoverage.Instrumentation.IPdbReader {
    public Byte[] IdBytes { get; }
    public string PdbPath { get; }
    public abstract virtual Byte[] get_IdBytes();
    public abstract virtual string get_PdbPath();
    public abstract virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    public abstract virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
}
internal class Microsoft.CodeCoverage.Instrumentation.LibraryHelper : object {
    [NullableContextAttribute("1")]
public sealed virtual bool IsNativeLibrary(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Instrumentation.MessageGenerator : object {
    public static ModuleInstrumentedMessage CreateModuleInstrumentedMessage(AssemblyMetadata assemblyMetadata);
    public static ValueTuple`3<IList`1<FunctionInstrumentedMessage>, IList`1<FunctionSkippedMessage>, IList`1<SourceFileDataMessage>> CreateFunctionMessages(AssemblyMetadata assemblyMetadata);
    public static FunctionSkippedMessage CreateSkippedFunctionMessage(MethodMetadata method);
    public static InstrumentedFunctionMessage CreateInstrumentedFunctionMessage(MethodMetadata method, UInt32 offset);
    private static FunctionInstrumentedMessage CreateFunctionInstrumentedMessage(MethodMetadata method, UInt32 offset, IDictionary`2<string, SourceFileDataMessage> sourceFilesMap);
    private static UInt32 AddSourceFileDataMessage(SequencePointMetadata sequencePoint, IDictionary`2<string, SourceFileDataMessage> sourceFilesMap);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.AssemblyMetadata : object {
    [NullableAttribute("1")]
private static string GeneratedCodeAttribute;
    [NullableAttribute("1")]
internal static string CompilerGeneratedAttribute;
    private ReflectionContainer _reflectionContainer;
    private MetadataReader _metadataReader;
    private bool _disposed;
    private string _name;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TypeDefinitionHandle, TypeMetadata> _typesDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<TypeMetadata> _types;
    private bool _isCodeCoverageEnabledExplicitly;
    [CompilerGeneratedAttribute]
private PEReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdbReader <PdbReader>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCoverageConfig <CodeCoverageConfig>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ModuleId>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCodeCoverageEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSkipReason <ModuleSkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DetailedReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMixed>k__BackingField;
    internal PEReader Reader { get; private set; }
    internal IPdbReader PdbReader { get; private set; }
    internal CodeCoverageConfig CodeCoverageConfig { get; }
    public string Name { get; }
    [NullableAttribute("1")]
public string ModuleId { get; }
    [NullableAttribute("1")]
public string Path { get; }
    public string Id { get; private set; }
    public Byte[] IdBytes { get; private set; }
    public Guid Identifier { get; private set; }
    public UInt32 ImageLinkTime { get; private set; }
    public UInt32 ImageSize { get; private set; }
    public bool IsPdbLoaded { get; }
    public bool IsCodeCoverageEnabled { get; private set; }
    public ModuleSkipReason ModuleSkipReason { get; public set; }
    public string DetailedReason { get; private set; }
    public string TargetFramework { get; private set; }
    public bool IsMixed { get; private set; }
    [NullableAttribute("1")]
public IDictionary`2<TypeDefinitionHandle, TypeMetadata> TypesDictionary { get; }
    [NullableAttribute("1")]
public ICollection`1<TypeMetadata> Types { get; }
    [NullableContextAttribute("1")]
public AssemblyMetadata(string path);
    [NullableContextAttribute("1")]
public AssemblyMetadata(string path, CodeCoverageConfig codeCoverageConfig);
    [NullableContextAttribute("1")]
public AssemblyMetadata(string path, CodeCoverageConfig codeCoverageConfig, ILogger logger);
    [NullableContextAttribute("1")]
private AssemblyMetadata(string path, CodeCoverageConfig codeCoverageConfig, PEStreamOptions streamOptions, MetadataReaderOptions metadataOptions, ILogger logger);
    [CompilerGeneratedAttribute]
internal PEReader get_Reader();
    [CompilerGeneratedAttribute]
private void set_Reader(PEReader value);
    [CompilerGeneratedAttribute]
internal IPdbReader get_PdbReader();
    [CompilerGeneratedAttribute]
private void set_PdbReader(IPdbReader value);
    [CompilerGeneratedAttribute]
internal CodeCoverageConfig get_CodeCoverageConfig();
    public string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_ModuleId();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_IdBytes();
    [CompilerGeneratedAttribute]
private void set_IdBytes(Byte[] value);
    [CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
private void set_Identifier(Guid value);
    [CompilerGeneratedAttribute]
public UInt32 get_ImageLinkTime();
    [CompilerGeneratedAttribute]
private void set_ImageLinkTime(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_ImageSize();
    [CompilerGeneratedAttribute]
private void set_ImageSize(UInt32 value);
    public bool get_IsPdbLoaded();
    [CompilerGeneratedAttribute]
public bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
private void set_IsCodeCoverageEnabled(bool value);
    [CompilerGeneratedAttribute]
public ModuleSkipReason get_ModuleSkipReason();
    [CompilerGeneratedAttribute]
public void set_ModuleSkipReason(ModuleSkipReason value);
    [CompilerGeneratedAttribute]
public string get_DetailedReason();
    [CompilerGeneratedAttribute]
private void set_DetailedReason(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
private void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public bool get_IsMixed();
    [CompilerGeneratedAttribute]
private void set_IsMixed(bool value);
    [NullableContextAttribute("1")]
public IDictionary`2<TypeDefinitionHandle, TypeMetadata> get_TypesDictionary();
    [NullableContextAttribute("1")]
public ICollection`1<TypeMetadata> get_Types();
    private bool IsIncluded();
    [NullableContextAttribute("1")]
private void InitializeMetadata(PEStreamOptions streamOptions, MetadataReaderOptions metadataOptions, ILogger logger);
    public sealed virtual void Dispose();
    private bool IsIncludedInConfig();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Instrumentation.Metadata.CustomAttributeMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public CustomAttributeMetadata(MetadataReader metadataReader, TypeReference definition);
    public CustomAttributeMetadata(MetadataReader metadataReader, TypeDefinition definition);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public string get_FullName();
}
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.EventMetadata : MetadataBase`2<EventDefinition, EventDefinitionHandle> {
    private TypeMetadata _parent;
    private IList`1<MethodMetadata> _methods;
    public IList`1<MethodMetadata> Methods { get; }
    public EventMetadata(ReflectionContainer reflectionContainer, EventDefinition definition, EventDefinitionHandle handle, TypeMetadata parent);
    public IList`1<MethodMetadata> get_Methods();
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeCoverage.Instrumentation.Metadata.MetadataBase`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<CustomAttributeMetadata> _customAttributes;
    private Nullable`1<bool> _isCompilerGenerated;
    [CompilerGeneratedAttribute]
private ReflectionContainer <ReflectionContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private TDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private THandle <Handle>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public ReflectionContainer ReflectionContainer { get; }
    public PEReader Reader { get; }
    public MetadataReader MetadataReader { get; }
    public IPdbReader PdbReader { get; }
    public TDefinition Definition { get; }
    public THandle Handle { get; }
    [NullableAttribute("2")]
public string Name { get; protected set; }
    public IList`1<CustomAttributeMetadata> CustomAttributes { get; }
    public bool IsCompilerGenerated { get; }
    protected MetadataBase`2(ReflectionContainer reflectionContainer, TDefinition definition, THandle handle);
    [CompilerGeneratedAttribute]
public ReflectionContainer get_ReflectionContainer();
    public PEReader get_Reader();
    public MetadataReader get_MetadataReader();
    public IPdbReader get_PdbReader();
    [CompilerGeneratedAttribute]
public TDefinition get_Definition();
    [CompilerGeneratedAttribute]
public THandle get_Handle();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual void set_Name(string value);
    public IList`1<CustomAttributeMetadata> get_CustomAttributes();
    public bool get_IsCompilerGenerated();
    protected abstract virtual CustomAttributeHandleCollection GetCustomAttributes();
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.Metadata.MetadataReaderExtensions : object {
    [NullableAttribute("1")]
private static string PathPattern;
    private static MetadataReaderExtensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string DetectTargetFrameworkId(MetadataReader metadata, string assemblyPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.MethodBlock : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction[] <Instructions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExpressionBreakpointPattern>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Index { get; public set; }
    public Instruction[] Instructions { get; public set; }
    public bool IsExpressionBreakpointPattern { get; public set; }
    public int Offset { get; }
    public MethodBlock(int Index, Instruction[] Instructions);
    [CompilerGeneratedAttribute]
protected MethodBlock(MethodBlock original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Index(int value);
    [CompilerGeneratedAttribute]
public Instruction[] get_Instructions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Instructions(Instruction[] value);
    [CompilerGeneratedAttribute]
public bool get_IsExpressionBreakpointPattern();
    [CompilerGeneratedAttribute]
public void set_IsExpressionBreakpointPattern(bool value);
    public int get_Offset();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MethodBlock left, MethodBlock right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MethodBlock left, MethodBlock right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MethodBlock other);
    [CompilerGeneratedAttribute]
public virtual MethodBlock <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Index, Instruction[]& Instructions);
}
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.MethodMetadata : MetadataBase`2<MethodDefinition, MethodDefinitionHandle> {
    private static int JustMyCodeWithNoSource;
    private TypeMetadata _parent;
    private MethodBlock[] _methodBlocks;
    private SequencePointMetadata[] _sequencePoints;
    private string _fullName;
    private string _parametersString;
    private string _qualifiedName;
    private Nullable`1<bool> _isCodeCoverageEnabled;
    private Nullable`1<bool> _hasSymbolicInformation;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionSkipReason <FunctionSkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private SequencePointMetadata <FirstSequencePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private SequencePointMetadata <LastSequencePoint>k__BackingField;
    public UInt32 Id { get; }
    public UInt32 MetadataToken { get; }
    public string FullName { get; }
    public string ParametersString { get; }
    public string QualifiedName { get; }
    public string TypeName { get; }
    public string NamespaceName { get; }
    public string SourceFile { get; private set; }
    public bool IsConstructor { get; private set; }
    public bool HasSymbolicInformation { get; }
    public bool IsCodeCoverageEnabled { get; }
    public FunctionSkipReason FunctionSkipReason { get; private set; }
    public MethodBlock[] MethodBlocks { get; }
    public SequencePointMetadata[] SequencePoints { get; }
    internal SequencePointMetadata FirstSequencePoint { get; private set; }
    internal SequencePointMetadata LastSequencePoint { get; private set; }
    public MethodMetadata(ReflectionContainer reflectionContainer, MethodDefinition definition, MethodDefinitionHandle handle, TypeMetadata parent);
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    public string get_FullName();
    public string get_ParametersString();
    public string get_QualifiedName();
    public string get_TypeName();
    public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public string get_SourceFile();
    [CompilerGeneratedAttribute]
private void set_SourceFile(string value);
    [CompilerGeneratedAttribute]
public bool get_IsConstructor();
    [CompilerGeneratedAttribute]
private void set_IsConstructor(bool value);
    public bool get_HasSymbolicInformation();
    public bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
public FunctionSkipReason get_FunctionSkipReason();
    [CompilerGeneratedAttribute]
private void set_FunctionSkipReason(FunctionSkipReason value);
    public MethodBlock[] get_MethodBlocks();
    public SequencePointMetadata[] get_SequencePoints();
    [CompilerGeneratedAttribute]
internal SequencePointMetadata get_FirstSequencePoint();
    [CompilerGeneratedAttribute]
private void set_FirstSequencePoint(SequencePointMetadata value);
    [CompilerGeneratedAttribute]
internal SequencePointMetadata get_LastSequencePoint();
    [CompilerGeneratedAttribute]
private void set_LastSequencePoint(SequencePointMetadata value);
    private void PopulateName();
    internal void DisassembleFunction(ReusableContainers reusableContainers, List`1<SequencePointMetadata> rawSequencePoints);
    private void CalculateBlocks(ReusableContainers reusableContainers);
    private void CalculateInstructions(List`1<Instruction> instructions, HashSet`1<int> offsetsStartingBlocks);
    private void CalculateInstructions(List`1<Instruction> instructions, MethodBodyBlock methodBody);
    private ValueTuple`2<Instruction, int> GetInstructionAndSize(BlobReader blob);
    private static ValueTuple`2<Instruction, int> GetBranchInstruction(BlobReader blob, ILOpCode opCode, InstructionTerminationType terminationType, ILOpCodeInfo info, int offset);
    private static ValueTuple`2<Instruction, int> GetSwitchInstruction(BlobReader blob, InstructionTerminationType terminationType, ILOpCodeInfo info, int offset);
    private void MarkTargetInstructionsAsBlockStarters(List`1<Instruction> instructions, HashSet`1<int> offsetsStartingBlocks);
    private void MarkExceptionRegionsAsBlockStarters(MethodBodyBlock methodBody, HashSet`1<int> offsetsStartingBlocks);
    private void CalculateBlocks(ReusableContainers reusableContainers, List`1<Instruction> instructions, HashSet`1<int> offsetsStartingBlocks);
    private void ProcessBlocks(ReusableContainers reusableContainers, List`1<Instruction> instructions, HashSet`1<int> offsetsStartingBlocks);
    private void PopulateSequencePoints(ReusableContainers reusableContainers, List`1<SequencePointMetadata> rawSequencePoints);
    private void PopulateSequencePointForOtherBlocks(List`1<SequencePointMetadata> sequencePoints, SequencePointMetadata point, int upperBound, ISet`1<int> alreadyClearedBlocks);
    private void AppendSequencePoint(List`1<SequencePointMetadata> sequencePoints, SequencePointMetadata sequencePoint, ISet`1<int> alreadyClearedBlocks);
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
    internal void Process(ReusableContainers resusableContainers);
    private bool InternalProcess(ReusableContainers resusableContainers);
    private bool AreSourcesPartOfOtherMethodSources(MethodMetadata other);
}
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.PropertyMetadata : MetadataBase`2<PropertyDefinition, PropertyDefinitionHandle> {
    private TypeMetadata _parent;
    private IList`1<MethodMetadata> _methods;
    public IList`1<MethodMetadata> Methods { get; }
    public PropertyMetadata(ReflectionContainer reflectionContainer, PropertyDefinition definition, PropertyDefinitionHandle handle, TypeMetadata parent);
    public IList`1<MethodMetadata> get_Methods();
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Instrumentation.Metadata.ReflectionContainer : object {
    [CompilerGeneratedAttribute]
private PEReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReader <MetadataReader>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdbReader <PdbReader>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVisualizer <SignatureVisualizer>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCoverageConfig <CodeCoverageConfig>k__BackingField;
    public PEReader Reader { get; }
    public MetadataReader MetadataReader { get; }
    public IPdbReader PdbReader { get; }
    internal SignatureVisualizer SignatureVisualizer { get; }
    public CodeCoverageConfig CodeCoverageConfig { get; }
    public ReflectionContainer(PEReader reader, MetadataReader metadataReader, IPdbReader pdbReaderProvider, CodeCoverageConfig codeCoverageConfig);
    [CompilerGeneratedAttribute]
public PEReader get_Reader();
    [CompilerGeneratedAttribute]
public MetadataReader get_MetadataReader();
    [CompilerGeneratedAttribute]
public IPdbReader get_PdbReader();
    [CompilerGeneratedAttribute]
internal SignatureVisualizer get_SignatureVisualizer();
    [CompilerGeneratedAttribute]
public CodeCoverageConfig get_CodeCoverageConfig();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Instrumentation.Metadata.SequencePointMetadata : object {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentBlockOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NextBlockOffset>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Offset { get; public set; }
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public string SourceFilePath { get; public set; }
    public Byte[] Checksum { get; public set; }
    public Guid ChecksumAlgorithm { get; public set; }
    public bool IsHidden { get; public set; }
    public int CurrentBlockOffset { get; public set; }
    public int NextBlockOffset { get; public set; }
    public SequencePointMetadata(int Offset, int StartLine, int StartColumn, int EndLine, int EndColumn, string SourceFilePath, Byte[] Checksum, Guid ChecksumAlgorithm, bool IsHidden);
    [CompilerGeneratedAttribute]
protected SequencePointMetadata(SequencePointMetadata original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceFilePath(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Checksum(Byte[] value);
    [CompilerGeneratedAttribute]
public Guid get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChecksumAlgorithm(Guid value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsHidden(bool value);
    [CompilerGeneratedAttribute]
public int get_CurrentBlockOffset();
    [CompilerGeneratedAttribute]
public void set_CurrentBlockOffset(int value);
    [CompilerGeneratedAttribute]
public int get_NextBlockOffset();
    [CompilerGeneratedAttribute]
public void set_NextBlockOffset(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SequencePointMetadata left, SequencePointMetadata right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SequencePointMetadata left, SequencePointMetadata right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SequencePointMetadata other);
    [CompilerGeneratedAttribute]
public virtual SequencePointMetadata <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Offset, Int32& StartLine, Int32& StartColumn, Int32& EndLine, Int32& EndColumn, String& SourceFilePath, Byte[]& Checksum, Guid& ChecksumAlgorithm, Boolean& IsHidden);
}
internal class Microsoft.CodeCoverage.Instrumentation.Metadata.TypeMetadata : MetadataBase`2<TypeDefinition, TypeDefinitionHandle> {
    private TypeMetadata _parentType;
    private IList`1<PropertyMetadata> _properties;
    private IList`1<EventMetadata> _events;
    private IList`1<MethodMetadata> _methods;
    private IDictionary`2<UInt32, MethodMetadata> _methodsExcludedByAttribute;
    private string _name;
    private string _namespaceName;
    private string _fullName;
    private string _constructorName;
    private Nullable`1<bool> _isCodeCoverageEnabled;
    [CompilerGeneratedAttribute]
private AssemblyMetadata <ParentAssembly>k__BackingField;
    public string Name { get; protected set; }
    public string ConstructorName { get; }
    public string FullName { get; }
    public string NamespaceName { get; public set; }
    public AssemblyMetadata ParentAssembly { get; }
    public bool IsCodeCoverageEnabled { get; }
    public IList`1<PropertyMetadata> Properties { get; }
    public IList`1<EventMetadata> Events { get; }
    public IList`1<MethodMetadata> Methods { get; }
    public IEnumerable`1<MethodMetadata> MethodsExcludedByAttribute { get; }
    public TypeMetadata(ReflectionContainer reflectionContainer, TypeDefinition definition, TypeDefinitionHandle handle, AssemblyMetadata parent);
    public virtual string get_Name();
    protected virtual void set_Name(string value);
    public string get_ConstructorName();
    public string get_FullName();
    public string get_NamespaceName();
    public void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public AssemblyMetadata get_ParentAssembly();
    public bool get_IsCodeCoverageEnabled();
    protected virtual CustomAttributeHandleCollection GetCustomAttributes();
    public IList`1<PropertyMetadata> get_Properties();
    public IList`1<EventMetadata> get_Events();
    public IList`1<MethodMetadata> get_Methods();
    public IEnumerable`1<MethodMetadata> get_MethodsExcludedByAttribute();
    public bool IsMethodExcludedByAttribute(UInt32 metadataToken);
    internal void AddMethodExcludedByAttribute(MethodMetadata methodMetadata);
    private bool IsIncluded();
    private void PopulateMetadata(TypeDefinition definition, string postfix);
}
internal enum Microsoft.CodeCoverage.Instrumentation.PdbLocation : Enum {
    public int value__;
    public static PdbLocation None;
    public static PdbLocation AssemblyLocation;
    public static PdbLocation SymbolsSearchPaths;
    public static PdbLocation OriginalLocation;
}
internal static class Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider : object {
    private static string LegacyPdbPrefix;
    private static Byte[] Buffer;
    private static PdbReaderProvider();
    public static IPdbReader GetPdbDataProvider(AssemblyMetadata assemblyMetadata, MetadataReaderOptions options, ILogger logger);
    private static bool LoadPortablePdbReader(AssemblyMetadata assemblyMetadata, DebugDirectoryEntry entry, MetadataReaderProvider& provider, String& pdbPath, ILogger logger);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider/<TryFindPdbPath>d__4")]
private static IEnumerable`1<ValueTuple`2<string, Stream>> TryFindPdbPath(AssemblyMetadata assemblyMetadata, DebugDirectoryEntry entry, ILogger logger);
    private static Stream OpenStream(string path);
    private static Byte[] GetIdBytes(PEReader reader, DebugDirectoryEntry entry);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PdbReaderProvider/<<TryFindPdbPath>g__SearchPdbFileName|4_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ValueTuple`2<string, Stream>> <TryFindPdbPath>g__SearchPdbFileName|4_0(string pdbFileName, AssemblyMetadata assemblyMetadata, ILogger logger);
}
internal class Microsoft.CodeCoverage.Instrumentation.PortablePdbReader : object {
    private MetadataReader _metadataReader;
    private MetadataReaderProvider _metadataReaderProvider;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IdBytes>k__BackingField;
    public string PdbPath { get; }
    public Byte[] IdBytes { get; }
    public PortablePdbReader(MetadataReaderProvider metadataReaderProvider, MetadataReaderOptions options, string pdbPath);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_IdBytes();
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.PortablePdbReader/<GetSequencePoints>d__10")]
public sealed virtual IEnumerable`1<SequencePointMetadata> GetSequencePoints(MethodDefinitionHandle handle);
    public sealed virtual int GetStateMachineKickoffMethod(MethodDefinitionHandle handle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.CodeCoverage.Instrumentation.SignatureVisualizer : object {
    private MetadataReader _metadataReader;
    private ConcurrentDictionary`2<EntityHandle, string> _handleNameDictionary;
    public SignatureVisualizer(MetadataReader metadataReader);
    public sealed virtual string GetPrimitiveType(PrimitiveTypeCode typeCode);
    private string RowId(EntityHandle handle);
    public sealed virtual string GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual string GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public sealed virtual string GetTypeFromSpecification(MetadataReader reader, MethodDefinition genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    private string GetFullTypeName(MetadataReader reader, TypeDefinitionHandle handle);
    private string GetFullTypeName(MetadataReader reader, TypeReferenceHandle handle);
    private string GetFullTypeName(string name, string namespaceName, EntityHandle handle);
    public sealed virtual string GetSZArrayType(string elementType);
    public sealed virtual string GetPointerType(string elementType);
    public sealed virtual string GetByReferenceType(string elementType);
    public sealed virtual string GetGenericMethodParameter(MethodDefinition genericContext, int index);
    public sealed virtual string GetGenericTypeParameter(MethodDefinition genericContext, int index);
    public sealed virtual string GetPinnedType(string elementType);
    public sealed virtual string GetGenericInstantiation(string genericType, ImmutableArray`1<string> typeArguments);
    public sealed virtual string GetModifiedType(string modifierType, string unmodifiedType, bool isRequired);
    public sealed virtual string GetArrayType(string elementType, ArrayShape shape);
    public sealed virtual string GetFunctionPointerType(MethodSignature`1<string> signature);
    private static string MethodSignature(MethodSignature`1<string> signature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.AssemblyResolverFactory : object {
    private IDirectoryHelper _directoryHelper;
    private IAssemblyResolver _netStandardAssemblyResolver;
    public AssemblyResolverFactory(IDirectoryHelper directoryHelper);
    public sealed virtual IAssemblyResolver Create(string modulePath, ILogger logger);
    public sealed virtual void Dispose();
    private IAssemblyResolver CreateMonoCecilAssemblyResolver(string modulePath);
    private IAssemblyResolver CreateDependencyAssemblyResolver(string modulePath, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.AssemblyResolversAggregator : object {
    private IAssemblyResolver[] _assemblyResolvers;
    public AssemblyResolversAggregator(IAssemblyResolver[] assemblyResolvers);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    private AssemblyDefinition InternalResolve(AssemblyNameReference name, Func`2<IAssemblyResolver, AssemblyDefinition> resolver);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.DependencyAssemblyResolver : object {
    private string _searchDirectory;
    private ILogger _logger;
    private IDirectoryHelper _directoryHelper;
    private Lazy`1<CompositeCompilationAssemblyResolver> _compositeResolver;
    public DependencyAssemblyResolver(string modulePath, ILogger logger, IDirectoryHelper directoryHelper);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    public sealed virtual void Dispose();
}
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IAssemblyResolverFactory {
    [NullableContextAttribute("1")]
public abstract virtual IAssemblyResolver Create(string modulePath, ILogger logger);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticInstrumenter {
    public abstract virtual StaticInstrumentationResult Instrument(IEnumerable`1<string> additionalDirectories, IEnumerable`1<string> additionalFiles);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticManagedInstrumenter {
    public abstract virtual IModuleCoverageContainer Instrument(string path, string targetPath, string sessionId);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticManagedInstrumenterFactory {
    public abstract virtual IStaticManagedInstrumenter Create(ILogger logger, DataCollectorConfiguration configuration);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticManagedModuleHolder {
    public abstract virtual IModuleCoverageContainer Store(AssemblyMetadata assemblyMetadata, UInt32 blockSize);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Instrumentation.Static.IStaticRestorer {
    public abstract virtual void Restore(StaticInstrumentationResult result);
    public abstract virtual void Restore(IModuleCoverageContainer moduleCoverageContainer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.MonoCecilDefaultAssemblyResolver : BaseAssemblyResolver {
    private ConcurrentDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.NetstandardAssemblyResolver : object {
    [NullableAttribute("2")]
private Assembly _netStandardAssembly;
    [NullableAttribute("2")]
private string _netStandardAssemblyName;
    [NullableAttribute("2")]
private Byte[] _netStandardAssemblyPublicKeyToken;
    [NullableAttribute("2")]
private AssemblyDefinition _netStandardAssemblyDefinition;
    private IAssemblyResolver _assemblyResolver;
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    public sealed virtual void Dispose();
    private bool CheckIfSearchingNetstandard(AssemblyNameReference name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.SingleStaticInstrumentationResult : object {
    [CompilerGeneratedAttribute]
private UInt32 <ResultCode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Elapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsManaged>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public UInt32 ResultCode { get; public set; }
    public TimeSpan Elapsed { get; public set; }
    public bool IsManaged { get; public set; }
    public SingleStaticInstrumentationResult(UInt32 ResultCode, TimeSpan Elapsed, bool IsManaged);
    [CompilerGeneratedAttribute]
protected SingleStaticInstrumentationResult(SingleStaticInstrumentationResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public UInt32 get_ResultCode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ResultCode(UInt32 value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Elapsed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Elapsed(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsManaged();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsManaged(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SingleStaticInstrumentationResult left, SingleStaticInstrumentationResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SingleStaticInstrumentationResult left, SingleStaticInstrumentationResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SingleStaticInstrumentationResult other);
    [CompilerGeneratedAttribute]
public virtual SingleStaticInstrumentationResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(UInt32& ResultCode, TimeSpan& Elapsed, Boolean& IsManaged);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumentationResult : object {
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, SingleStaticInstrumentationResult> <InstrumentationResults>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<string> <NativeInstrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<string> <NativeSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<IModuleCoverageContainer> <ManagedInstrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<string> <ManagedSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<string> <CopiedRuntimeFiles>k__BackingField;
    internal ConcurrentDictionary`2<string, SingleStaticInstrumentationResult> InstrumentationResults { get; }
    internal ConcurrentBag`1<string> NativeInstrumented { get; }
    internal ConcurrentBag`1<string> NativeSkipped { get; }
    internal ConcurrentBag`1<IModuleCoverageContainer> ManagedInstrumented { get; }
    internal ConcurrentBag`1<string> ManagedSkipped { get; }
    internal ConcurrentBag`1<string> CopiedRuntimeFiles { get; }
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, SingleStaticInstrumentationResult> get_InstrumentationResults();
    [CompilerGeneratedAttribute]
internal ConcurrentBag`1<string> get_NativeInstrumented();
    [CompilerGeneratedAttribute]
internal ConcurrentBag`1<string> get_NativeSkipped();
    [CompilerGeneratedAttribute]
internal ConcurrentBag`1<IModuleCoverageContainer> get_ManagedInstrumented();
    [CompilerGeneratedAttribute]
internal ConcurrentBag`1<string> get_ManagedSkipped();
    [CompilerGeneratedAttribute]
internal ConcurrentBag`1<string> get_CopiedRuntimeFiles();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticInstrumenter : object {
    private static ParallelOptions ParallelOptions;
    [NullableAttribute("2")]
private IStaticNativeInstrumenter _nativeInstrumenter;
    private IStaticNativeRuntimeProvider _nativeRuntimeProvider;
    private IStaticManagedInstrumenter _managedInstrumenter;
    private IDirectoryHelper _directoryHelper;
    private ILibraryHelper _libraryHelper;
    private ILogger _logger;
    private DataCollectorConfiguration _dataCollectorConfiguration;
    private string _sessionId;
    [NullableContextAttribute("2")]
public StaticInstrumenter(IStaticNativeInstrumenter nativeInstrumenter, IStaticNativeRuntimeProvider nativeRuntimeProvider, IStaticManagedInstrumenter managedInstrumenter, IDirectoryHelper directoryHelper, ILibraryHelper libraryHelper, ILogger logger, DataCollectorConfiguration dataCollectorConfiguration, string sessionId);
    private static StaticInstrumenter();
    public sealed virtual StaticInstrumentationResult Instrument(IEnumerable`1<string> additionalDirectories, IEnumerable`1<string> additionalFiles);
    private void InstrumentDirectories(List`1<IncludeDirectory> includeDirectories, Dictionary`2<string, ModuleInitialCheckResult> filesToBeInstrumentedMap);
    private void InstrumentFiles(IEnumerable`1<string> candidates, Dictionary`2<string, ModuleInitialCheckResult> filesToBeInstrumentedMap);
    private void InstrumentNativeModules(StaticInstrumentationResult instrumentationResult, List`1<string> additionalDirectoriesList, String[] nativeFilesToBeInstrumented);
    private void InstrumentManagedModules(StaticInstrumentationResult instrumentationResult, String[] managedFilesToBeInstrumented);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenter : object {
    public static string ManagedStaticTrackerNamespace;
    private IFileHelper _fileHelper;
    private IStaticManagedModuleHolder _managedModuleHolder;
    private ILogger _logger;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    private IStaticRestorer _staticRestorer;
    private DataCollectorConfiguration _configuration;
    private WriteStreamMessage _writeStreamMessageTemplate;
    private CloseStreamMessage _closeStreamMessageTemplate;
    private TestCoverageDataMessage _testCoverageDataMessageTemplate;
    public StaticManagedInstrumenter(IFileHelper fileHelper, IStaticManagedModuleHolder managedModuleHolder, ILogger logger, IAssemblyResolverFactory assemblyResolverFactory, IStaticRestorer staticRestorer, DataCollectorConfiguration configuration);
    [NullableContextAttribute("2")]
public sealed virtual IModuleCoverageContainer Instrument(string originPath, string targetPath, string sessionId);
    private IModuleCoverageContainer ProcessAndStoreManagedModuleData(string path);
    private TypeDefinition AddCustomModuleTrackerToModule(ModuleDefinition module, string sessionId, IModuleCoverageContainer moduleCoverageContainer);
    private void InstrumentCustomModuleTrackerConstructor(ModuleDefinition module, IModuleCoverageContainer moduleCoverageContainer, TypeDefinition customTrackerTypeDef);
    private static void InstrumentCustomModuleTrackerModuleLoadedMethod(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition customTrackerTypeDef);
    private void InstrumentCustomModuleTrackerInitializeBufferNameMethod(ModuleDefinition module, string sessionId, IModuleCoverageContainer moduleCoverageContainer, AssemblyDefinition coverageInstrumentationAssembly, TypeDefinition customTrackerTypeDef);
    private TypeDefinition AddPipeHelperToModule(ModuleDefinition module, AssemblyDefinition originAssemblyDef, string identifier, IModuleCoverageContainer moduleCoverageContainer);
    private static void InitializeSessionNameInPipeHelperConstructor(string identifier, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeCreateStreamMessageInPipeHelperConstructor(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeCreateBufferMessageInPipeHelperConstructor(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeCloseStreamMessageInPipeHelperConstructor(TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeMessagesInPipeHelperConstructor(ModuleDefinition module, IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    private void InitializeStatisticsMessageInPipeHelperConstructor(IModuleCoverageContainer moduleCoverageContainer, TypeDefinition pipeHelperTypeDef, ILProcessor ilProcessor, Instruction lastInstr);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenter/<GenerateAllStreamMessages>d__24")]
private IEnumerable`1<string> GenerateAllStreamMessages(IModuleCoverageContainer moduleCoverageContainer);
    private string GenerateMessageAsString(Action`1<BinaryWriter> messageWriter, bool addWriteStreamMessage);
    private Byte[] GenerateMessage(Action`1<BinaryWriter> messageWriter, bool addWriteStreamMessage);
    private TypeDefinition MoveTypeToModule(ModuleDefinition targetModule, AssemblyDefinition originAssemblyDef, string originNamespace, string originTypeName, string identifier);
    private void InstrumentOrAddModuleInitializer(ModuleDefinition moduleDefinition, MethodReference moduleLoadedMethodReference);
    private void Instrument(MethodDefinition method, FieldReference beginFieldReference, IList`1<UInt32> blocks, int offset);
    private static void ReplaceTargetInstructions(ILProcessor processor, Dictionary`2<int, Instruction> targetsMap);
    private static void ReplaceExceptionHandlerBoundaries(ILProcessor processor, Dictionary`2<int, Instruction> targetsMap);
    private static bool IsCollectorBufferInitialized(IModuleCoverageContainer container);
    private static int CalculateMethodOffset(IModuleCoverageContainer container, InstrumentedFunctionMessage instrumentedFunctionMessage);
    [CompilerGeneratedAttribute]
private void <InitializeCloseStreamMessageInPipeHelperConstructor>b__21_1(BinaryWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticManagedInstrumenterFactory : object {
    private IFileHelper _fileHelper;
    private IStaticManagedModuleHolder _staticManagedModuleHolder;
    private IStaticNativeRuntimeProviderFactory _staticNativeRuntimeProviderFactory;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    public StaticManagedInstrumenterFactory(IFileHelper fileHelper, IStaticManagedModuleHolder staticManagedModuleHolder, IStaticNativeRuntimeProviderFactory staticNativeRuntimeProviderFactory, IAssemblyResolverFactory assemblyResolverFactory);
    public sealed virtual IStaticManagedInstrumenter Create(ILogger logger, DataCollectorConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Instrumentation.Static.StaticRestorer : object {
    private IStaticNativeRuntimeProvider _nativeRuntimeProvider;
    private IFileHelper _fileHelper;
    private ILogger _logger;
    private DataCollectorConfiguration _dataCollectorConfiguration;
    public StaticRestorer(IStaticNativeRuntimeProvider nativeRuntimeProvider, IFileHelper fileHelper, ILogger logger, DataCollectorConfiguration dataCollectorConfiguration);
    public sealed virtual void Restore(StaticInstrumentationResult staticInstrumentationResult);
    public sealed virtual void Restore(IModuleCoverageContainer moduleCoverageContainer);
    private void RestoreOrigFile(string instrumentedFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CompilerGeneratedAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.CodeCoverage.Instrumentation.Tracker.PipeHelper : object {
    private static int CommunucationTimeout;
    [NullableAttribute("2")]
public static string SessionName;
    public static string CreateStreamMessage;
    public static string CloseStreamMessage;
    public static string CreateBufferMessage;
    public static string StatisticsMessage;
    public static String[] Messages;
    private static Byte[] _streamIdAsBytes;
    private static bool _streamDiscard;
    private static string _streamBufferName;
    private static PipeHelper();
    public static string ConnectAndSendData();
    public static void Write(Byte[] buffer, PipeStream pipeStream, bool isWindows);
    public static string GetSessionDirectory(string sessionName);
    public static string GetPipeName(string sessionName, bool isWindows);
    public static string GetPipeName(string sessionName, string pipePath);
    public static string GetPipePath(string sessionDirectory);
    public static string GetPipePath(string sessionDirectory, bool isWindows);
    [NullableContextAttribute("2")]
private static string ConnectAndSendData(string sessionName, bool isWindows, int communicationTimeout, Exception previousException);
    private static string ConnectAndSendData(NamedPipeClientStream pipeStream, bool isWindows, int communicationTimeout);
    private static Byte[] GetMessageBytesWithSteamIdUpdated(string message);
    private static void ReadCreateStreamMessageResponse(PipeStream pipeStream, bool isWindows);
    private static Byte[] Read(PipeStream pipeStream, bool isWindows);
    private static Byte[] ReadWindowsMessage(PipeStream pipeStream);
    private static Byte[] ReadNonWindowsMessage(PipeStream pipeStream);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[CompilerGeneratedAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.Tracker.StaticManagedTrackerTemplate : object {
    [NullableAttribute("0")]
public static Byte* Begin;
    private static MemoryMappedFile _file;
    private static MemoryMappedViewAccessor _view;
    private static Byte[] _localArray;
    private static GCHandle _gcHandle;
    public static bool Trace;
    public static string TraceFile;
    public static string OriginalPath;
    public static string BufferName;
    public static int BufferSize;
    private static StaticManagedTrackerTemplate();
    public static void Initialize();
    public static void ModuleLoaded();
    public static void InitializeBufferName();
    private static void InitializeWithSharedMemory();
    private static void InitializeWithArray();
    [NullableContextAttribute("1")]
private static void Log(Exception exception);
    private static bool IsTraceEnabled();
    private static string GetTraceFilePath();
    [NullableContextAttribute("1")]
private static string ConvertToMsg(Exception exception);
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Instrumentation.XmlReportHelper : object {
    [ExtensionAttribute]
public static ModuleWrapper ToCoreLibModule(AssemblyMetadata assemblyMetadata, bool addMessages);
    public static ModuleWrapper ToCoreLibModule(Byte[] streamData);
    [ExtensionAttribute]
public static void PopulateCoverageStatus(ModuleWrapper module, Byte[] coverageBuffer);
    [ExtensionAttribute]
private static void AddMethods(ModuleWrapper module, ICollection`1<TypeMetadata> types, bool addMessages);
    private static void AddMethod(ModuleWrapper module, MethodMetadata method, bool addMessages);
    private static void AddSkippedMethod(ModuleWrapper module, MethodMetadata method, bool addMessages);
    [ExtensionAttribute]
public static FunctionWrapper ToFunction(MethodMetadata method, ModuleWrapper module, bool addMessages);
    [ExtensionAttribute]
private static BlockLineData ToBlockLineData(SequencePointMetadata sequencePoint, UInt32 sourceId);
    [ExtensionAttribute]
private static FunctionInstrumentedMessage ToFunctionInstrumentedMessage(FunctionWrapper function, UInt32 startBlockIndex);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
