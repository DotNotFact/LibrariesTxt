[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeCoverage.Interprocess.Cache : object {
    private ConcurrentDictionary`2<StreamKey, BufferMessage[]> _data;
    public sealed virtual CacheMessage Fetch(FetchCacheMessage message);
    public sealed virtual void Store(CacheMessage message);
}
internal class Microsoft.CodeCoverage.Interprocess.ClientConnectedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <PipeName>k__BackingField;
    public string PipeName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PipeName();
    [CompilerGeneratedAttribute]
public void set_PipeName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Interprocess.Helper : object {
    public static string GetModulePath(string uri, bool getPath);
    public static long GetModuleWriteTimestamp(string path);
    public static StreamKey GetStreamKey(CreateStreamMessage message);
    public static StreamKey GetStreamKey(string prefix, Guid key);
    internal static void WriteStreamToPipe(MemoryStream stream, PipeStream pipeStream, ILogger logger, bool isWindows);
    internal static void Write(Byte[] buffer, PipeStream pipeStream, ILogger logger, bool isWindows);
}
internal interface Microsoft.CodeCoverage.Interprocess.ICache {
    public abstract virtual void Store(CacheMessage message);
    public abstract virtual CacheMessage Fetch(FetchCacheMessage message);
}
public interface Microsoft.CodeCoverage.Interprocess.ILoggerClient {
    public abstract virtual bool IsLoggerAvailable();
    public abstract virtual int GetLoggerProcessId();
    public abstract virtual DataCollectorConfiguration GetDataCollectorConfiguration();
    public abstract virtual void SendShutdownMessage();
    public abstract virtual String[] GenerateReports(string path, bool reset);
}
internal interface Microsoft.CodeCoverage.Interprocess.IMessage {
    public bool Complete { get; }
    public abstract virtual void SetLastReadCount(int count);
    public abstract virtual Byte[] GetNextReadBuffer();
    public abstract virtual Byte[] GetData();
    public abstract virtual bool get_Complete();
}
internal interface Microsoft.CodeCoverage.Interprocess.IPipeClient {
    public UInt32 ProcessId { get; }
    public abstract virtual UInt32 get_ProcessId();
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeCoverage.Interprocess.IStreamCreator {
    [NullableContextAttribute("1")]
public abstract virtual LogStreamBase CreateStream(string sessionName, Guid streamType, Guid identifier, StreamKey key, bool autoClose, string bufferName, UInt32 bufferSize, string bufferHeader);
    public abstract virtual LogStreamBase GetStream(UInt32 streamId);
    public abstract virtual LogStreamBase CloseStream(UInt32 streamId);
}
internal class Microsoft.CodeCoverage.Interprocess.LocalMemoryStream : LogStreamBase {
    private List`1<byte> _bytes;
    public LocalMemoryStream(UInt32 streamId, StreamKey key, Guid streamType, Guid identifier, bool autoClose);
    public virtual void WriteMessage(Byte[] data);
    public virtual ValueTuple`2<StreamHeader, Byte[]> GetModuleBuffer(bool reset);
    public virtual ValueTuple`2<StreamHeader, Byte[]> GetModuleBuffer(Byte[] coverageBuffer);
    public virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferToWriteTo);
    [ExcludeFromCodeCoverageAttribute]
public virtual UInt32 GetBufferSize();
    [ExcludeFromCodeCoverageAttribute]
public virtual bool IsInitialized();
}
internal class Microsoft.CodeCoverage.Interprocess.LoggerBase : object {
    private ManualResetEvent _testHostEvent;
    private int _testHostProcessId;
    [NullableAttribute("1")]
private static string BufferHeader;
    private static int OpenConnectionBackoffInMs;
    private static int OpenConnectionMaxRetries;
    private object _lock;
    protected string SessionName;
    private string _pipeName;
    private IStaticNativeRuntimeProvider _staticNativeRuntimeProvider;
    private DataCollectorConfiguration _dataCollectorConfig;
    private string _dynamicNativeConfig;
    private IList`1<PipeConnection> _pipeConnections;
    private ILogger _logger;
    private IEnvironment _environment;
    private ReportGenerator _reportGenerator;
    private ICache _cache;
    private IStreamCreator _staticStreamCreator;
    private IStaticInstrumenter _staticInstrumenter;
    private IStaticRestorer _staticRestorer;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    private StaticInstrumentationResult _staticInstrumentationResult;
    private ICacheCleaner _cacheCleaner;
    private TimeSpan _instrumentationMaximalTime;
    private TimeSpan _instrumentationLockMaximalTime;
    private bool _shuttingDown;
    private bool _disposed;
    private int _numberOfClientsConnected;
    private int _numberOfModulesCovered;
    private bool _pipesInitialized;
    [CompilerGeneratedAttribute]
private int <ClientsPerPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <OutputCoverageFiles>k__BackingField;
    public int TestHostProcessId { get; public set; }
    public int NumberOfClientsConnected { get; }
    public int NumberOfModulesCovered { get; }
    internal int ClientsPerPipe { get; internal set; }
    public IList`1<string> OutputCoverageFiles { get; private set; }
    internal LoggerBase(string sessionName, string pipePath, string coverageFilePath, DataCollectorConfiguration dataCollectorConfiguration, ILogger logger, IEnvironment environment, IStaticNativeInstrumenter staticNativeInstrumenter, IStaticNativeRuntimeProvider staticNativeRuntimeProvider, IDirectoryHelper directoryHelper);
    private static LoggerBase();
    public int get_TestHostProcessId();
    public void set_TestHostProcessId(int value);
    private void RegisterClient(PipeClient client, RegisterClientMessage message);
    private void RegisterClient(PipeClient client, InitializeClientMessage message);
    private void HandleClientShutdown(PipeClient client);
    private void HandleClientShutdownLogger(PipeClient client);
    private void HandleClientError(PipeClient client, ClientErrorMessage message);
    private void UnregisterClient(PipeClient client);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.LoggerBase/<LoadModuleDataAsync>d__12")]
private Task LoadModuleDataAsync(PipeClient client, LoadModuleDataMessage message);
    [NullableContextAttribute("1")]
private void PreloadModuleData(PipeClient client, PreloadModuleDataMessage message);
    [NullableContextAttribute("1")]
private void HandleCacheMessage(PipeClient client, CacheMessage message);
    [NullableContextAttribute("1")]
private void HandleFetchCacheMessage(PipeClient client, FetchCacheMessage message);
    [NullableContextAttribute("1")]
private void CreateStream(PipeClient client, CreateStreamMessage message);
    [NullableContextAttribute("1")]
private void WriteStream(PipeClient client, WriteStreamMessage message, Byte[] buffer, long offset);
    [NullableContextAttribute("1")]
private void CloseStream(PipeClient client, CloseStreamMessage message);
    [NullableContextAttribute("1")]
private void WriteStreamBuffers(PipeClient client, WriteStreamBuffersMessage message);
    [NullableContextAttribute("1")]
private void WriteCoverageData(GetCoverageDataMessage message);
    [NullableContextAttribute("1")]
private void WriteCoverageData(PipeClient client, SnapshotMessage message);
    [NullableContextAttribute("1")]
private void SendInformation(PipeClient client, GetInformationMessage message);
    [NullableContextAttribute("1")]
private void OnDynamicInstrumentation(AssemblyMetadata assemblyMetadata, TimeSpan elapsed);
    public int get_NumberOfClientsConnected();
    public int get_NumberOfModulesCovered();
    [CompilerGeneratedAttribute]
internal int get_ClientsPerPipe();
    [CompilerGeneratedAttribute]
internal void set_ClientsPerPipe(int value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_OutputCoverageFiles();
    [CompilerGeneratedAttribute]
private void set_OutputCoverageFiles(IList`1<string> value);
    protected virtual void OnClientConnected(UInt32 processId);
    protected virtual void OnClientDisconnected(UInt32 processId, UInt32 errorCode);
    protected virtual void OnCreateStream(UInt32 processId, UInt32 streamId, Guid streamType, UInt32 bufferSize, string bufferHeader, string bufferName, string prefix);
    protected virtual void OnWriteStream(UInt32 processId, UInt32 streamId, Guid streamType, Byte[] buffer, long bufferSize);
    protected virtual void OnCloseStream(UInt32 processId, UInt32 streamId, int streamSize);
    protected virtual void OnFatalException(Exception exception);
    protected virtual void OnShutdown(UInt32 processId);
    protected virtual void OnShutdown();
    protected virtual void OnClientError(UInt32 processId, string message);
    protected virtual void OnWriteStreamBuffers(UInt32 processId, Guid streamType, string bufferHeader, bool resetBuffers);
    protected virtual void OnStaticInstrumentation(string path, UInt32 result, TimeSpan elapsed, bool isManaged);
    protected virtual void OnStaticInstrumentationSkipped(string path, bool isManaged);
    protected virtual void OnInstrumentation(string path, Guid id, Guid coverageBufferId, bool isDynamic, bool isManaged, bool isMixed, bool isPortablePdb, UInt32 imageSize, UInt32 imageLinkTime, int numberOfMethodsInstrumented, int numberOfMethodsSkipped, int numberOfMethodsFailed, TimeSpan elapsed, Dictionary`2<string, string> properties);
    protected virtual void OnInstrumentationSkipped(string path, ModuleSkipReason reason, bool isManaged);
    protected virtual void OnBufferClose(Guid identifier, Byte[] bytes);
    public void Run(IEnumerable`1<string> sourceDirectories, IEnumerable`1<string> sourceFiles);
    public void TestStart(TestStart testInformation);
    public void TestEnd(TestEnd testInformation);
    public void Shutdown();
    private void PerformStaticInstrumentation(IEnumerable`1<string> sourcesDirectories, IEnumerable`1<string> sourceFiles);
    private void OpenConnection(string pipeName);
    private bool OpenConnectionInternal(string pipeName);
    private void OnMessageReceivedEvent(object sender, ServerMessageReceivedEventArgs e);
    private void HandleInstrumentationStatisticsMessage(PipeClient client, InstrumentationStatisticsMessage message);
    private void OnClientConnectedEvent(object sender, ClientConnectedEventArgs e);
    private static string GenerateDynamicNativeConfigString(CodeCoverageConfig codeCoverageConfig);
    private static string AddDynamicNativeExclusions(string configuration);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.Interprocess.LoggerClient : object {
    private NamedPipeClientStream _pipe;
    private ILogger _logger;
    private IEnvironment _environment;
    private int _communucationTimeout;
    public LoggerClient(string sessionName, string pipePath, ILogger logger, IEnvironment environment, int communucationTimeout);
    public sealed virtual bool IsLoggerAvailable();
    public sealed virtual int GetLoggerProcessId();
    public sealed virtual DataCollectorConfiguration GetDataCollectorConfiguration();
    public sealed virtual void SendShutdownMessage();
    public sealed virtual String[] GenerateReports(string path, bool reset);
    public sealed virtual void Dispose();
    private void ConnectPipe();
    private Byte[] ReadMessageFromPipe();
    private String[] ReadPathsFromPipe(Byte[] buffer);
    private GetInformationResponseMessage ParseGetInformationResponseMessage(Byte[] buffer);
    private SuccessMessage ParseSuccessMessage(Byte[] buffer);
    private void SendGetInformationMessage(InformationType configurationType);
}
internal abstract class Microsoft.CodeCoverage.Interprocess.LogStreamBase : object {
    private bool _disposed;
    private StreamKey _key;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discard>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoClose>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    public StreamKey Key { get; }
    public Guid Identifier { get; }
    public UInt32 StreamId { get; }
    public Guid StreamType { get; }
    public bool Discard { get; public set; }
    public bool AutoClose { get; }
    public string BufferName { get; public set; }
    protected LogStreamBase(UInt32 streamId, StreamKey key, Guid streamType, Guid identifier, bool autoClose);
    public StreamKey get_Key();
    [CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public bool get_Discard();
    [CompilerGeneratedAttribute]
public void set_Discard(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoClose();
    [CompilerGeneratedAttribute]
public string get_BufferName();
    [CompilerGeneratedAttribute]
public void set_BufferName(string value);
    public abstract virtual ValueTuple`2<StreamHeader, Byte[]> GetModuleBuffer(bool reset);
    public abstract virtual ValueTuple`2<StreamHeader, Byte[]> GetModuleBuffer(Byte[] coverageBuffer);
    public abstract virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferToWriteTo);
    public abstract virtual void WriteMessage(Byte[] data);
    public abstract virtual UInt32 GetBufferSize();
    public abstract virtual bool IsInitialized();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.CodeCoverage.Interprocess.Message : object {
    private static int BufferSize;
    private IList`1<int> _buffersCount;
    [CompilerGeneratedAttribute]
private IList`1<Byte[]> <Buffers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessageSize>k__BackingField;
    protected IList`1<Byte[]> Buffers { get; private set; }
    protected int MessageSize { get; protected set; }
    public bool Complete { get; }
    [CompilerGeneratedAttribute]
protected IList`1<Byte[]> get_Buffers();
    [CompilerGeneratedAttribute]
private void set_Buffers(IList`1<Byte[]> value);
    [CompilerGeneratedAttribute]
protected int get_MessageSize();
    [CompilerGeneratedAttribute]
protected void set_MessageSize(int value);
    public virtual void SetLastReadCount(int count);
    public virtual Byte[] GetNextReadBuffer();
    public sealed virtual Byte[] GetData();
    public virtual bool get_Complete();
}
internal class Microsoft.CodeCoverage.Interprocess.MessageReceivedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    public Byte[] Buffer { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public void set_Buffer(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.ModuleCoverageContainer : object {
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockSize>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<InstrumentedFunctionMessage> <InstrumentedFunctionMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionInstrumentedMessage> <FunctionInstrumentedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionSkippedMessage> <FunctionSkippedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SourceFileDataMessage> <SourceFileDataMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSkipReason <ModuleSkipReason>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SharedMemoryStream <CoverageDataStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMixed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortablePdb>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    public Guid Identifier { get; private set; }
    public StreamKey Key { get; private set; }
    public UInt32 BlockSize { get; private set; }
    [NullableAttribute("2")]
public string BufferName { get; }
    public int BufferSize { get; }
    [NullableAttribute("2")]
public string PdbPath { get; }
    public ModuleInstrumentedMessage ModuleInstrumentedMessage { get; }
    public IList`1<InstrumentedFunctionMessage> InstrumentedFunctionMessages { get; }
    public IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; }
    public IList`1<FunctionSkippedMessage> FunctionSkippedMessages { get; }
    public IList`1<SourceFileDataMessage> SourceFileDataMessages { get; }
    public bool IsSkipped { get; public set; }
    public ModuleSkipReason ModuleSkipReason { get; public set; }
    [NullableAttribute("2")]
public SharedMemoryStream CoverageDataStream { get; public set; }
    public bool IsMixed { get; }
    public bool IsPortablePdb { get; }
    [NullableAttribute("2")]
public string TargetFramework { get; }
    public ModuleCoverageContainer(ModuleInstrumentedMessage moduleInstrumentedMessage, string pdbPath, Guid identifier, UInt32 blockSize, bool isMixed, bool isPortablePdb, string targetFramework, IList`1<FunctionInstrumentedMessage> functionInstrumentedMessages, IList`1<FunctionSkippedMessage> functionSkippedMessages, IList`1<SourceFileDataMessage> sourceFileDataMessages);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Identifier();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Identifier(Guid value);
    [CompilerGeneratedAttribute]
public StreamKey get_Key();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Key(StreamKey value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_BlockSize();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BlockSize(UInt32 value);
    [NullableContextAttribute("2")]
public sealed virtual string get_BufferName();
    public sealed virtual int get_BufferSize();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    [CompilerGeneratedAttribute]
public sealed virtual ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<InstrumentedFunctionMessage> get_InstrumentedFunctionMessages();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSkipped();
    [CompilerGeneratedAttribute]
public void set_IsSkipped(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ModuleSkipReason get_ModuleSkipReason();
    [CompilerGeneratedAttribute]
public void set_ModuleSkipReason(ModuleSkipReason value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SharedMemoryStream get_CoverageDataStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_CoverageDataStream(SharedMemoryStream value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMixed();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPortablePdb();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_TargetFramework();
}
internal class Microsoft.CodeCoverage.Interprocess.NullStaticManagedModuleHolder : object {
    [NullableContextAttribute("1")]
public sealed virtual IModuleCoverageContainer Store(AssemblyMetadata assemblyMetadata, UInt32 blockSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.PipeClient : object {
    private PipeConnection _server;
    private ILogger _logger;
    private IStreamCreator _streamCreator;
    [CompilerGeneratedAttribute]
private UInt32 <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCodeCoverageEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShutdownRequested>k__BackingField;
    public UInt32 SchemaVersion { get; public set; }
    public UInt32 ProcessId { get; public set; }
    public bool IsCodeCoverageEnabled { get; public set; }
    public bool ShutdownRequested { get; public set; }
    public PipeClient(PipeConnection server, ILogger logger, IStreamCreator streamCreator);
    [CompilerGeneratedAttribute]
public UInt32 get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
public void set_IsCodeCoverageEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShutdownRequested();
    [CompilerGeneratedAttribute]
public void set_ShutdownRequested(bool value);
    public void UpdateClient(RegisterClientMessage message);
    public void UpdateClient(InitializeClientMessage message, bool codeCoverageEnabled);
    internal void SendConfiguration(string configuration);
    internal void SendGetInformationResponseMessage(string information);
    internal void SendInitializeClientResponse(UInt32 communicationTimeout, string updatedPath);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase GetStream(UInt32 streamId);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase CloseStream(UInt32 streamId);
    public sealed virtual LogStreamBase CreateStream(string sessionName, Guid streamType, Guid identifier, StreamKey streamKey, bool autoClose, string bufferName, UInt32 bufferSize, string bufferHeader);
    public void SendCreateStreamResponse(LogStreamBase stream, bool streamExists);
    [NullableContextAttribute("2")]
public void SendInstrumentedModule(SharedMemoryStream stream);
    public void SendInstrumentedFunction(InstrumentedFunctionMessage message);
    public void SendPreloadModuleDataResponse(PreloadModuleDataResponseMessage message);
    public void SendCacheMessageResponse(CacheMessage message);
    public void SendFilePathsMessage(FilePathsMessage message);
    public void SendClientErrorMessage(ClientErrorMessage message);
    public void SendSuccessMessage();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.PipeConnection : object {
    private string _pipeName;
    private ILogger _logger;
    private IEnvironment _environment;
    private static TimeSpan DisconnectionTimeout;
    private bool _disposed;
    private bool _isRunning;
    [NullableAttribute("2")]
private NamedPipeServerStream _server;
    [NullableAttribute("2")]
private PipeClient _client;
    [NullableAttribute("2")]
private PipeConnectionReader _reader;
    [NullableAttribute("2")]
private CancellationTokenSource _readerCts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ServerMessageReceivedEventArgs> MessageReceivedEvent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ClientConnectedEventArgs> ClientConnectedEvent;
    [NullableAttribute("2")]
public PipeClient Client { get; }
    public bool ShutdownRequested { get; }
    [NullableContextAttribute("2")]
public PipeConnection(string pipeName, ILogger logger, IEnvironment environment);
    private static PipeConnection();
    [CompilerGeneratedAttribute]
public void add_MessageReceivedEvent(EventHandler`1<ServerMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MessageReceivedEvent(EventHandler`1<ServerMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClientConnectedEvent(EventHandler`1<ClientConnectedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClientConnectedEvent(EventHandler`1<ClientConnectedEventArgs> value);
    [NullableContextAttribute("2")]
public PipeClient get_Client();
    public bool get_ShutdownRequested();
    public void Start(int clientsPerPipe);
    public void WaitForDisconnection();
    public void Stop();
    private void OnClientConnected(IAsyncResult result);
    private void OnMessageReceivedEvent(object sender, MessageReceivedEventArgs e);
    private void OnReaderDisconnectedEvent(object sender, PipeStreamDisconnectedEventArgs e);
    internal void Write(MemoryStream stream);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.CodeCoverage.Interprocess.PipeConnectionReader : object {
    private ILogger _logger;
    private IEnvironment _environment;
    private PipeStream _pipeStream;
    private bool _isRunning;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageReceivedEventArgs> MessageReceivedEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<PipeStreamDisconnectedEventArgs> DisconnectedEvent;
    public PipeConnectionReader(PipeStream pipeStream, ILogger logger, IEnvironment environment);
    [CompilerGeneratedAttribute]
public void add_MessageReceivedEvent(EventHandler`1<MessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MessageReceivedEvent(EventHandler`1<MessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DisconnectedEvent(EventHandler`1<PipeStreamDisconnectedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DisconnectedEvent(EventHandler`1<PipeStreamDisconnectedEventArgs> value);
    public void Start();
    private void BeginRead(IMessage message);
    private void EndReadCallBack(IAsyncResult result);
    private void OnMessageReceived(IMessage message);
    private IMessage CreateNewMessage();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeCoverage.Interprocess.PipeStreamDisconnectedEventArgs : EventArgs {
}
internal class Microsoft.CodeCoverage.Interprocess.Reports.CoberturaReportGenerator : ReportGeneratorBase {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentBag`1<ValueTuple`2<CoberturaPackage, SharedMemoryStream>> _packageCoverageData;
    public CoberturaReportGenerator(string sessionName, ILogger traceWrapper, IDirectoryHelper directoryHelper);
    public virtual void AddModule(IStreamCreator streamCreator, ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, SharedMemoryStream coverageDataSteam);
    public virtual void AddUnmanagedModuleStream(ValueTuple`2<StreamHeader, Byte[]> streamBuffer, LogStreamBase sharedStream);
    public virtual void AddSkippedModule(string path, ModuleSkipReason moduleSkipReason, string exceptionMessage);
    public virtual IList`1<string> GenerateReport(string coverageFilePath, bool splitCoverageFiles, bool reset, bool perTestCodeCoverage);
    public virtual void TestStart(TestStart testInformation);
    public virtual void TestEnd(TestEnd testInformation);
}
internal class Microsoft.CodeCoverage.Interprocess.Reports.DefaultReportGenerator : ReportGeneratorBase {
    private ConcurrentBag`1<ModuleData> _streamBuffers;
    private ConcurrentDictionary`2<string, ValueTuple`2<ModuleSkipReason, string>> _skippedModules;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ModuleData, ConcurrentDictionary`2<string, ValueTuple`2<ArrayByteSource, List`1<TestInformationBase>>>> _moduleTestBuffers;
    [NullableAttribute("1")]
private ConcurrentBag`1<TestEnd> _testsInformation;
    [NullableAttribute("1")]
private InMemoryArrayByteSourceFactory _inMemoryArrayByteSourceFactory;
    private int _perTestCoverageBuffersCount;
    public DefaultReportGenerator(string sessionName, ILogger logger, IDirectoryHelper directoryHelper);
    public virtual void AddModule(IStreamCreator streamCreator, ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, SharedMemoryStream coverageDataSteam);
    public virtual void AddUnmanagedModuleStream(ValueTuple`2<StreamHeader, Byte[]> dataStream, LogStreamBase bufferStream);
    public virtual void AddSkippedModule(string path, ModuleSkipReason moduleSkipReason, string exceptionMessage);
    public virtual IList`1<string> GenerateReport(string coverageFilePath, bool splitCoverageFiles, bool reset, bool perTestCodeCoverage);
    private IList`1<string> WriteSingleCoverageFile(string coverageFilePath, bool reset, bool perTestCodeCoverage);
    private IList`1<string> WriteSplitCoverageFiles(string coverageFilePath, bool reset);
    private static ValueTuple`2<int, string> WriteModuleCoverageBufferFile(string outputFolder, ValueTuple`2<StreamHeader, Byte[]> coverageStream, string moduleName, UInt32 moduleLinkTime);
    private static string WriteModuleCoverageFile(string outputFolder, ValueTuple`2<StreamHeader, Byte[]> streamBuffer, ValueTuple`2<StreamHeader, Byte[]> coverageStream, string moduleName, UInt32 moduleLinkTime, int blockCount);
    private UInt32 GetStreamCount(bool perTestCodeCoverage);
    [NullableContextAttribute("1")]
private void WritePerTestData(BinaryWriter finalCoverageWriter, ModuleData moduleData);
    [NullableContextAttribute("1")]
private void WriteTestListData(BinaryWriter finalCoverageWriter);
    [NullableContextAttribute("1")]
public virtual void TestStart(TestStart testInformation);
    [NullableContextAttribute("1")]
public virtual void TestEnd(TestEnd testInformation);
}
internal class Microsoft.CodeCoverage.Interprocess.Reports.ReportGenerator : object {
    private static string BufferHeader;
    private string _sessionName;
    private string _outputCoverageFilePath;
    private DataCollectorConfiguration _dataCollectorConfig;
    private CodeCoverageConfig _codeCoverageConfig;
    private ILogger _logger;
    private IDirectoryHelper _directoryHelper;
    private ConcurrentDictionary`2<string, string> _modulesPathIdMap;
    private ConcurrentDictionary`2<string, Task`1<ModuleCoverageContainer>> _moduleProcessingTasks;
    private IDictionary`2<StreamKey, LogStreamBase> _sharedModuleCoverageBuffers;
    private IDictionary`2<StreamKey, Guid> _sharedModuleCoverageBuffersIds;
    private IList`1<LogStreamBase> _abandonedStreams;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private IList`1<ReportGeneratorBase> <ReportGenerators>k__BackingField;
    internal IList`1<ReportGeneratorBase> ReportGenerators { get; }
    public ReportGenerator(string sessionName, string coverageFilePath, DataCollectorConfiguration dataCollectorConfig, ILogger logger, IDirectoryHelper directoryHelper);
    [CompilerGeneratedAttribute]
internal IList`1<ReportGeneratorBase> get_ReportGenerators();
    public Task`1<ModuleCoverageContainer> GetContainerProcessTask(string modulePath);
    public bool TryStoreModuleIdMapping(string modulePath, AssemblyMetadata assemblyMetadata);
    public bool TryAddModuleProcessingTask(string moduleId, Task`1<ModuleCoverageContainer> moduleProcessingTask);
    public ModuleCoverageContainer ProcessManagedModule(AssemblyMetadata assemblyMetadata, UInt32 blockSize, IStreamCreator streamCreator, CancellationToken token);
    private void StoreFunctionMessages(IModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata);
    public ValueTuple`2<bool, LogStreamBase> CreateUnmanagedStream(IPipeClient client, StreamKey key, CreateStreamMessage message);
    public int CloseUnmanagedStream(LogStreamBase stream);
    public void AddSkippedModule(string path, ModuleSkipReason moduleSkipReason, string exceptionMessage);
    public IList`1<string> GenerateReports(bool perTestCodeCoverage);
    public IList`1<string> GenerateReports(string outputCoveragePath, bool reset, bool perTestCodeCoverage);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.Reports.ReportGenerator/<GetSharedMemoryStreams>d__27")]
public IEnumerable`1<SharedMemoryStream> GetSharedMemoryStreams();
    private void LoadGenerators();
    public void TestStart(TestStart testInformation);
    public void TestEnd(TestEnd testInformation);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Interprocess.Reports.ReportGeneratorBase : object {
    [CompilerGeneratedAttribute]
private string <SessionName>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectoryHelper <DirectoryHelper>k__BackingField;
    public string SessionName { get; }
    protected ILogger Logger { get; }
    protected IDirectoryHelper DirectoryHelper { get; }
    protected ReportGeneratorBase(string sessionName, ILogger logger, IDirectoryHelper directoryHelper);
    [CompilerGeneratedAttribute]
public string get_SessionName();
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
protected IDirectoryHelper get_DirectoryHelper();
    public abstract virtual void AddModule(IStreamCreator streamCreator, ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, SharedMemoryStream coverageDataSteam);
    public abstract virtual void AddUnmanagedModuleStream(ValueTuple`2<StreamHeader, Byte[]> streamBuffer, LogStreamBase sharedStream);
    public abstract virtual void AddSkippedModule(string path, ModuleSkipReason moduleSkipReason, string exceptionMessage);
    public abstract virtual IList`1<string> GenerateReport(string coverageFilePath, bool splitCoverageFiles, bool reset, bool perTestCodeCoverage);
    protected void CreateDirectoryIfNeeded(string coverageFilePath);
    public abstract virtual void TestStart(TestStart testInformation);
    public abstract virtual void TestEnd(TestEnd testInformation);
}
internal static class Microsoft.CodeCoverage.Interprocess.Reports.ReportGeneratorFactory : object {
    public static ReportGeneratorBase CreateGenerator(string outputType, string sessionName, ILogger logger, IDirectoryHelper directoryHelper);
}
internal class Microsoft.CodeCoverage.Interprocess.Reports.XmlReportGenerator : ReportGeneratorBase {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentBag`1<ValueTuple`2<ModuleWrapper, SharedMemoryStream>> _moduleCoverageData;
    private ConcurrentDictionary`2<string, SkippedModule> _skippedModules;
    public XmlReportGenerator(string sessionName, ILogger logger, IDirectoryHelper directoryHelper);
    public virtual void AddModule(IStreamCreator streamCreator, ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, SharedMemoryStream coverageDataSteam);
    public virtual void AddSkippedModule(string path, ModuleSkipReason moduleSkipReason, string exceptionMessage);
    public virtual void AddUnmanagedModuleStream(ValueTuple`2<StreamHeader, Byte[]> streamBuffer, LogStreamBase sharedStream);
    public virtual IList`1<string> GenerateReport(string coverageFilePath, bool splitCoverageFiles, bool reset, bool perTestCodeCoverage);
    public virtual void TestStart(TestStart testInformation);
    public virtual void TestEnd(TestEnd testInformation);
}
internal class Microsoft.CodeCoverage.Interprocess.ServerMessageReceivedEventArgs : MessageReceivedEventArgs {
    [CompilerGeneratedAttribute]
private PipeClient <Client>k__BackingField;
    public PipeClient Client { get; public set; }
    [CompilerGeneratedAttribute]
public PipeClient get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(PipeClient value);
}
internal class Microsoft.CodeCoverage.Interprocess.SharedMemoryStream : LogStreamBase {
    private string _bufferHeader;
    private UInt32 _bufferSize;
    private bool _containsInitializationByte;
    private MemoryMappedFile _file;
    private bool _disposed;
    private Byte[] _resetBuffer;
    public SharedMemoryStream(UInt32 streamId, StreamKey key, Guid streamType, Guid identifier, bool autoClose, string bufferName, string bufferHeader, UInt32 bufferSize, bool isWindows, bool initializationByte);
    public virtual void WriteMessage(Byte[] data);
    private ValueTuple`2<StreamHeader, Byte[]> GetModuleBuffer(bool reset, Byte[] coverageBuffer);
    public virtual ValueTuple`2<StreamHeader, Byte[]> GetModuleBuffer(bool reset);
    public virtual ValueTuple`2<StreamHeader, Byte[]> GetModuleBuffer(Byte[] coverageBuffer);
    public virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferCache);
    public virtual bool IsInitialized();
    protected virtual void Dispose(bool disposing);
    public virtual UInt32 GetBufferSize();
    private UInt32 GetInternalFullBufferSize();
    private int GetInternalBufferStart();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.StaticManagedModuleHolder : object {
    private ReportGenerator _reportGenerator;
    private IStreamCreator _streamCreator;
    public StaticManagedModuleHolder(ReportGenerator reportGenerator, IStreamCreator streamCreator);
    public sealed virtual IModuleCoverageContainer Store(AssemblyMetadata assemblyMetadata, UInt32 blockSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.StreamCreator : object {
    private ILogger _logger;
    private IEnvironment _environment;
    private ConcurrentDictionary`2<UInt32, LogStreamBase> _streams;
    private bool _generateStaticStreams;
    private int _lastStreamId;
    private bool _disposed;
    public StreamCreator(ILogger logger, IEnvironment environment, bool generateStaticStreams);
    public sealed virtual LogStreamBase CreateStream(string sessionName, Guid streamType, Guid identifier, StreamKey key, bool autoClose, string bufferName, UInt32 bufferSize, string bufferHeader);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase GetStream(UInt32 streamId);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase CloseStream(UInt32 streamId);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.CodeCoverage.Interprocess.StreamKey : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Guid Id { get; public set; }
    public string Prefix { get; public set; }
    public StreamKey(Guid Id, string Prefix);
    [CompilerGeneratedAttribute]
protected StreamKey(StreamKey original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(Guid value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(StreamKey left, StreamKey right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(StreamKey left, StreamKey right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(StreamKey other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual StreamKey <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Guid& Id, String& Prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.TestEnd : TestInformationBase {
    [CompilerGeneratedAttribute]
private string <Outcome>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Outcome { get; public set; }
    public TestEnd(string Id, string Name, string Outcome);
    [CompilerGeneratedAttribute]
protected TestEnd(TestEnd original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Outcome();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Outcome(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestEnd left, TestEnd right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestEnd left, TestEnd right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TestInformationBase other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestEnd other);
    [CompilerGeneratedAttribute]
public virtual TestInformationBase <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name, String& Outcome);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.TestInformationBase : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public TestInformationBase(string Id, string Name);
    [CompilerGeneratedAttribute]
protected TestInformationBase(TestInformationBase original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestInformationBase left, TestInformationBase right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestInformationBase left, TestInformationBase right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestInformationBase other);
    [CompilerGeneratedAttribute]
public virtual TestInformationBase <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.TestStart : TestInformationBase {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public TestStart(string Id, string Name);
    [CompilerGeneratedAttribute]
protected TestStart(TestStart original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestStart left, TestStart right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestStart left, TestStart right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TestInformationBase other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestStart other);
    [CompilerGeneratedAttribute]
public virtual TestInformationBase <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name);
}
internal class Microsoft.CodeCoverage.Interprocess.UnixMessage : Message {
    private Byte[] _messageSizeBuffer;
    private int _expectedMessageSize;
    public bool Complete { get; }
    public virtual void SetLastReadCount(int count);
    public virtual Byte[] GetNextReadBuffer();
    public virtual bool get_Complete();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
