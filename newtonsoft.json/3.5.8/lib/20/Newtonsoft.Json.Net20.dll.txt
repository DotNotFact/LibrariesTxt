internal class Newtonsoft.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Function;
    public static BsonBinaryType Data;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
internal class Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    private int _maxChars;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(Stream stream);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
internal class Newtonsoft.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; private set; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Byte[] value);
}
internal class Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
public class Newtonsoft.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] _seqRange1;
    private static Byte[] _seqRange2;
    private static Byte[] _seqRange3;
    private static Byte[] _seqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private DateTimeKind _dateTimeKindHandling;
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual Byte[] ReadAsBytes();
    public virtual bool Read();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary();
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
internal class Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; public set; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
    [CompilerGeneratedAttribute]
public void set_IncludeLength(bool value);
}
internal abstract class Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
internal enum Newtonsoft.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
internal class Newtonsoft.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
public class Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Byte[] value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
public enum Newtonsoft.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
public class Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public abstract class Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
public class Newtonsoft.Json.Converters.DataSetConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
}
public class Newtonsoft.Json.Converters.DataTableConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static Type GetColumnDataType(JsonToken tokenType);
    public virtual bool CanConvert(Type valueType);
}
public abstract class Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    private string _dateTimeFormat;
    private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    public string get_DateTimeFormat();
    public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal interface Newtonsoft.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
internal interface Newtonsoft.Json.Converters.IXmlDocument {
    public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceURI);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceURI, string value);
    public abstract virtual IXmlElement get_DocumentElement();
}
internal interface Newtonsoft.Json.Converters.IXmlElement {
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
}
internal interface Newtonsoft.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceURI { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    public abstract virtual IList`1<IXmlNode> get_ChildNodes();
    public abstract virtual IList`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceURI();
    public abstract virtual object get_WrappedNode();
}
public class Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
public enum Newtonsoft.Json.Converters.JsonDateTimeSerializationMode : Enum {
    public int value__;
    public static JsonDateTimeSerializationMode Local;
    public static JsonDateTimeSerializationMode Utc;
    public static JsonDateTimeSerializationMode Unspecified;
    public static JsonDateTimeSerializationMode RoundtripKind;
}
public class Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadBson(BsonReader reader);
    private Regex ReadJson(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
public class Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceURI);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceURI, string value);
    public sealed virtual IXmlElement get_DocumentElement();
}
internal class Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
}
public class Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IXmlNode, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IXmlNode, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    public string DeserializeRootElementName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private IEnumerable`1<IXmlNode> ValueAttributes(IEnumerable`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
    [CompilerGeneratedAttribute]
private static bool <SerializeGroupedNodes>b__0(IXmlNode a);
    [CompilerGeneratedAttribute]
private static bool <ValueAttributes>b__2(IXmlNode a);
}
internal class Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    private XmlNode _node;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public IList`1<IXmlNode> ChildNodes { get; }
    public IList`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string Prefix { get; }
    public string NamespaceURI { get; }
    public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public string get_Name();
    public sealed virtual string get_LocalName();
    public sealed virtual IList`1<IXmlNode> get_ChildNodes();
    private IXmlNode WrapNode(XmlNode node);
    public sealed virtual IList`1<IXmlNode> get_Attributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public string get_Prefix();
    public sealed virtual string get_NamespaceURI();
    [CompilerGeneratedAttribute]
private IXmlNode <get_ChildNodes>b__0(XmlNode n);
    [CompilerGeneratedAttribute]
private IXmlNode <get_Attributes>b__1(XmlAttribute a);
}
public enum Newtonsoft.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
}
public enum Newtonsoft.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
public interface Newtonsoft.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
public class Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("1028")]
public abstract class Newtonsoft.Json.JsonContainerAttribute : Attribute {
    internal Nullable`1<bool> _isReference;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public bool IsReference { get; public set; }
    protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
}
public static class Newtonsoft.Json.JsonConvert : object {
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    internal static long InitialJavaScriptDateTicks;
    private static JsonConvert();
    public static string ToString(DateTime value);
    private static TimeSpan GetUtcOffset(DateTime dateTime);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, TimeSpan offset, DateTimeKind kind);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversialTicksToJavaScriptTicks(long universialTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    public static string ToString(double value);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    public static string ToString(string value);
    public static string ToString(string value, char delimter);
    public static string ToString(object value);
    private static bool IsJsonPrimitiveTypeCode(TypeCode typeCode);
    internal static bool IsJsonPrimitiveType(Type type);
    internal static bool IsJsonPrimitive(object value);
    public static string SerializeObject(object value);
    public static string SerializeObject(object value, Formatting formatting);
    public static string SerializeObject(object value, JsonConverter[] converters);
    public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    public static object DeserializeObject(string value);
    public static object DeserializeObject(string value, Type type);
    public static T DeserializeObject(string value);
    public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static T DeserializeObject(string value, JsonConverter[] converters);
    public static T DeserializeObject(string value, JsonSerializerSettings settings);
    public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static XmlDocument DeserializeXmlNode(string value);
    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
}
public abstract class Newtonsoft.Json.JsonConverter : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual JsonSchema GetSchema();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[AttributeUsageAttribute("1436")]
public class Newtonsoft.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    public Type ConverterType { get; }
    public JsonConverterAttribute(Type converterType);
    public Type get_ConverterType();
    internal static JsonConverter CreateJsonConverterInstance(Type converterType);
}
public class Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("384")]
public class Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
public class Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    public MemberSerialization MemberSerialization { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
}
[AttributeUsageAttribute("384")]
public class Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Required <Required>k__BackingField;
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public string PropertyName { get; public set; }
    public Required Required { get; public set; }
    public JsonPropertyAttribute(string propertyName);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Required get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Required value);
}
public abstract class Newtonsoft.Json.JsonReader : object {
    private JsonToken _token;
    private object _value;
    private Type _valueType;
    private char _quoteChar;
    private State _currentState;
    private JTokenType _currentTypeContext;
    private int _top;
    private List`1<JTokenType> _stack;
    protected State CurrentState { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    protected State get_CurrentState();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    private void Push(JTokenType value);
    private JTokenType Pop();
    private JTokenType Peek();
    public abstract virtual bool Read();
    public abstract virtual Byte[] ReadAsBytes();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected virtual void SetToken(JsonToken newToken, object value);
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    internal static bool IsPrimitiveToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    private JTokenType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
}
public class Newtonsoft.Json.JsonReaderException : Exception {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    internal JsonReaderException(string message, Exception innerException, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
}
public class Newtonsoft.Json.JsonSerializationException : Exception {
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
}
public class Newtonsoft.Json.JsonSerializer : object {
    private TypeNameHandling _typeNameHandling;
    private FormatterAssemblyStyle _typeNameAssemblyFormat;
    private PreserveReferencesHandling _preserveReferencesHandling;
    private ReferenceLoopHandling _referenceLoopHandling;
    private MissingMemberHandling _missingMemberHandling;
    private ObjectCreationHandling _objectCreationHandling;
    private NullValueHandling _nullValueHandling;
    private DefaultValueHandling _defaultValueHandling;
    private ConstructorHandling _constructorHandling;
    private JsonConverterCollection _converters;
    private IContractResolver _contractResolver;
    private IReferenceResolver _referenceResolver;
    private SerializationBinder _binder;
    private StreamingContext _context;
    private EventHandler`1<ErrorEventArgs> Error;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public JsonConverterCollection Converters { get; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public void Populate(TextReader reader, object target);
    public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    public object Deserialize(JsonReader reader);
    public object Deserialize(TextReader reader, Type objectType);
    public T Deserialize(JsonReader reader);
    public object Deserialize(JsonReader reader, Type objectType);
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    public void Serialize(TextWriter textWriter, object value);
    public void Serialize(JsonWriter jsonWriter, object value);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value);
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
public class Newtonsoft.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static FormatterAssemblyStyle DefaultTypeNameAssemblyFormat;
    internal static StreamingContext DefaultContext;
    [CompilerGeneratedAttribute]
private ReferenceLoopHandling <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private MissingMemberHandling <MissingMemberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectCreationHandling <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private NullValueHandling <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private DefaultValueHandling <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private PreserveReferencesHandling <PreserveReferencesHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeNameHandling <TypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatterAssemblyStyle <TypeNameAssemblyFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorHandling <ConstructorHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IReferenceResolver <ReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamingContext <Context>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public IReferenceResolver ReferenceResolver { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    private static JsonSerializerSettings();
    [CompilerGeneratedAttribute]
public ReferenceLoopHandling get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    [CompilerGeneratedAttribute]
public MissingMemberHandling get_MissingMemberHandling();
    [CompilerGeneratedAttribute]
public void set_MissingMemberHandling(MissingMemberHandling value);
    [CompilerGeneratedAttribute]
public ObjectCreationHandling get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(ObjectCreationHandling value);
    [CompilerGeneratedAttribute]
public NullValueHandling get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(NullValueHandling value);
    [CompilerGeneratedAttribute]
public DefaultValueHandling get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(DefaultValueHandling value);
    [CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    [CompilerGeneratedAttribute]
public PreserveReferencesHandling get_PreserveReferencesHandling();
    [CompilerGeneratedAttribute]
public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    [CompilerGeneratedAttribute]
public TypeNameHandling get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(TypeNameHandling value);
    [CompilerGeneratedAttribute]
public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    [CompilerGeneratedAttribute]
public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    [CompilerGeneratedAttribute]
public ConstructorHandling get_ConstructorHandling();
    [CompilerGeneratedAttribute]
public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IReferenceResolver get_ReferenceResolver();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public SerializationBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public StreamingContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(StreamingContext value);
}
public class Newtonsoft.Json.JsonTextReader : JsonReader {
    private static int LineFeedValue;
    private static int CarriageReturnValue;
    private TextReader _reader;
    private StringBuffer _buffer;
    private Nullable`1<char> _lastChar;
    private int _currentLinePosition;
    private int _currentLineNumber;
    private bool _end;
    private ReadType _readType;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    private void ParseString(char quote);
    private void ReadStringIntoBuffer(char quote);
    private JsonReaderException CreateJsonReaderException(string format, Object[] args);
    private void ParseDate(string text);
    private char MoveNext();
    private bool HasNext();
    private int PeekNext();
    public virtual bool Read();
    public virtual Byte[] ReadAsBytes();
    private bool ReadInternal();
    private bool ParsePostValue(char currentChar);
    private bool ParseObject(char currentChar);
    private bool ParseProperty(char firstChar);
    private bool ValidIdentifierChar(char value);
    private char ParseUnquotedProperty(char firstChar);
    private bool ParseValue(char currentChar);
    private bool EatWhitespace(char initialChar, bool oneOrMore, Char& finalChar);
    private void ParseConstructor();
    private void ParseNumber(char firstChar);
    private void ParseComment();
    private bool MatchValue(char firstChar, string value);
    private bool MatchValue(char firstChar, string value, bool noTrailingNonSeperatorCharacters);
    private bool IsSeperator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private void ParseNumberNegativeInfinity();
    private void ParseNumberPositiveInfinity();
    private void ParseNumberNaN();
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
public class Newtonsoft.Json.JsonTextWriter : JsonWriter {
    private TextWriter _writer;
    private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    private Base64Encoder Base64Encoder { get; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    private Base64Encoder get_Base64Encoder();
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
}
public enum Newtonsoft.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
public class Newtonsoft.Json.JsonValidatingReader : JsonReader {
    private JsonReader _reader;
    private Stack`1<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;
    private ValidationEventHandler ValidationEventHandler;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, bool>, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, bool>, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, JsonSchemaModel>, string> CS$<>9__CachedAnonymousMethodDelegate5;
    public object Value { get; }
    public int Depth { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public Type ValueType { get; }
    private JsonSchemaModel CurrentSchema { get; }
    private JsonSchemaModel CurrentMemberSchema { get; }
    public JsonSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JsonValidatingReader(JsonReader reader);
    public void add_ValidationEventHandler(ValidationEventHandler value);
    public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual object get_Value();
    public virtual int get_Depth();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual Type get_ValueType();
    private void Push(SchemaScope scope);
    private SchemaScope Pop();
    private JsonSchemaModel get_CurrentSchema();
    private JsonSchemaModel get_CurrentMemberSchema();
    private void RaiseError(string message, JsonSchemaModel schema);
    private void OnValidationEvent(JsonSchemaException exception);
    public JsonSchema get_Schema();
    public void set_Schema(JsonSchema value);
    public JsonReader get_Reader();
    private void ValidateInEnumAndNotDisallowed(JsonSchemaModel schema);
    private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType();
    public virtual Byte[] ReadAsBytes();
    public virtual bool Read();
    private void ValidateCurrentToken();
    private void ValidateEndObject(JsonSchemaModel schema);
    private void ValidateEndArray(JsonSchemaModel schema);
    private void ValidateNull(JsonSchemaModel schema);
    private void ValidateBoolean(JsonSchemaModel schema);
    private void ValidateString(JsonSchemaModel schema);
    private void ValidateInteger(JsonSchemaModel schema);
    private void ProcessValue();
    private void ValidateFloat(JsonSchemaModel schema);
    private void ValidatePropertyName(JsonSchemaModel schema);
    private bool ValidateArray(JsonSchemaModel schema);
    private bool ValidateObject(JsonSchemaModel schema);
    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    [CompilerGeneratedAttribute]
private static bool <ValidateEndObject>b__0(KeyValuePair`2<string, bool> kv);
    [CompilerGeneratedAttribute]
private static string <ValidateEndObject>b__1(KeyValuePair`2<string, bool> kv);
    [CompilerGeneratedAttribute]
private static string <ValidatePropertyName>b__4(KeyValuePair`2<string, JsonSchemaModel> p);
}
public abstract class Newtonsoft.Json.JsonWriter : object {
    private static State[][] stateArray;
    private int _top;
    private List`1<JTokenType> _stack;
    private State _currentState;
    private Formatting _formatting;
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    public Formatting Formatting { get; public set; }
    private static JsonWriter();
    protected internal int get_Top();
    public WriteState get_WriteState();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    private void Push(JTokenType value);
    private JTokenType Pop();
    private JTokenType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public void WriteEndObject();
    public virtual void WriteStartArray();
    public void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public void WriteEnd();
    public void WriteToken(JsonReader reader);
    internal void WriteToken(JsonReader reader, int initialDepth);
    private void WriteConstructorDate(JsonReader reader);
    private bool IsEndToken(JsonToken token);
    private bool IsStartToken(JsonToken token);
    private void WriteEnd(JTokenType type);
    private void AutoCompleteAll();
    private JTokenType GetTypeForCloseToken(JsonToken token);
    private JsonToken GetCloseTokenForType(JTokenType type);
    private void AutoCompleteClose(JsonToken tokenBeingClosed);
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(object value);
    public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
}
public class Newtonsoft.Json.JsonWriterException : Exception {
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
}
public class Newtonsoft.Json.Linq.ComponentModel.JPropertyDescriptor : PropertyDescriptor {
    private Type _propertyType;
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected int NameHashCode { get; }
    public JPropertyDescriptor(string name, Type propertyType);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
internal class Newtonsoft.Json.Linq.ComponentModel.JTypeDescriptionProvider : TypeDescriptionProvider {
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type type, object instance);
}
public class Newtonsoft.Json.Linq.ComponentModel.JTypeDescriptor : object {
    private JObject _value;
    public JTypeDescriptor(JObject value);
    public virtual PropertyDescriptorCollection GetProperties();
    private static Type GetTokenPropertyType(JToken token);
    public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public sealed virtual AttributeCollection GetAttributes();
    public sealed virtual string GetClassName();
    public sealed virtual string GetComponentName();
    public sealed virtual TypeConverter GetConverter();
    public sealed virtual EventDescriptor GetDefaultEvent();
    public sealed virtual PropertyDescriptor GetDefaultProperty();
    public sealed virtual object GetEditor(Type editorBaseType);
    public sealed virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public sealed virtual EventDescriptorCollection GetEvents();
    public sealed virtual object GetPropertyOwner(PropertyDescriptor pd);
}
[ExtensionAttribute]
public static class Newtonsoft.Json.Linq.Extensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<JObject, IEnumerable`1<JProperty>> CS$<>9__CachedAnonymousMethodDelegate3;
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
internal static U Convert(T token, bool cast);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JToken> <Ancestors>b__0(T j);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JToken> <Descendants>b__1(T j);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JProperty> <Properties>b__2(JObject d);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<JToken> <Children>b__e(T c);
}
[DefaultMemberAttribute("Item")]
public interface Newtonsoft.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JArray : JContainer {
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    public JArray(JArray other);
    public JArray(Object[] content);
    public JArray(object content);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public static JArray Load(JsonReader reader);
    public static JArray Parse(string json);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JConstructor : JContainer {
    private string _name;
    public string Name { get; public set; }
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    public string get_Name();
    public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
}
public abstract class Newtonsoft.Json.Linq.JContainer : JToken {
    private ListChangedEventHandler ListChanged;
    private AddingNewEventHandler AddingNew;
    private JToken _content;
    private object _syncRoot;
    private bool _busy;
    internal JToken Content { get; internal set; }
    public bool HasValues { get; }
    public JToken First { get; }
    public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Count { get; }
    private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    internal JToken get_Content();
    internal void set_Content(JToken value);
    internal void CheckReentrancy();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    public virtual JToken get_First();
    [DebuggerStepThroughAttribute]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    internal IEnumerable`1<JToken> ChildrenInternal();
    public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    internal bool IsMultiContent(object content);
    internal virtual void AddItem(bool isLast, JToken previous, JToken item);
    internal JToken EnsureParentToken(JToken item);
    internal void AddInternal(bool isLast, JToken previous, object content);
    internal int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal virtual int CountItems();
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    public void Add(object content);
    public void AddFirst(object content);
    internal JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal void ReadContentFrom(JsonReader r);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
}
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeDescriptionProviderAttribute("Newtonsoft.Json.Linq.ComponentModel.JTypeDescriptionProvider")]
[DefaultMemberAttribute("Item")]
public class Newtonsoft.Json.Linq.JObject : JContainer {
    private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private static Func`2<JProperty, JToken> CS$<>9__CachedAnonymousMethodDelegate4;
    public JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys { get; }
    private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    public JObject(Object[] content);
    public JObject(object content);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken();
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Parse(string json);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public sealed virtual void Add(string propertyName, JToken value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.ContainsKey(string key);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
private static JToken <PropertyValues>b__3(JProperty p);
}
internal class Newtonsoft.Json.Linq.JPath : object {
    private string _expression;
    private int _currentIndex;
    [CompilerGeneratedAttribute]
private List`1<object> <Parts>k__BackingField;
    public List`1<object> Parts { get; private set; }
    public JPath(string expression);
    [CompilerGeneratedAttribute]
public List`1<object> get_Parts();
    [CompilerGeneratedAttribute]
private void set_Parts(List`1<object> value);
    private void ParseMain();
    private void ParseIndexer(char indexerOpenChar);
    internal JToken Evaluate(JToken root, bool errorWhenNoMatch);
}
public class Newtonsoft.Json.Linq.JProperty : JContainer {
    private string _name;
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    internal virtual void AddItem(bool isLast, JToken previous, JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    internal virtual void InsertItem(int index, JToken item);
    internal virtual bool ContainsItem(JToken item);
    internal virtual void ClearItems();
    public virtual JEnumerable`1<JToken> Children();
    private IEnumerable`1<JToken> GetValueEnumerable();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
}
public class Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    public JRaw(object rawJson);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken();
}
[DefaultMemberAttribute("Item")]
public abstract class Newtonsoft.Json.Linq.JToken : object {
    private JContainer _parent;
    internal JToken _next;
    private static JTokenEqualityComparer _equalityComparer;
    private Nullable`1<int> _lineNumber;
    private Nullable`1<int> _linePosition;
    public static JTokenEqualityComparer EqualityComparer { get; }
    public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    public JToken Next { get; internal set; }
    public JToken Previous { get; }
    public JToken Item { get; public set; }
    public JToken First { get; }
    public JToken Last { get; }
    private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public static JTokenEqualityComparer get_EqualityComparer();
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken();
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public static bool DeepEquals(JToken t1, JToken t2);
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    public void AddAfterSelf(object content);
    public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AfterSelf();
    public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual T Value(object key);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public JEnumerable`1<T> Children();
    public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool IsNullable(JToken o);
    private static bool ValidateFloat(JToken o, bool nullable);
    private static bool ValidateInteger(JToken o, bool nullable);
    private static bool ValidateDate(JToken o, bool nullable);
    private static bool ValidateBoolean(JToken o, bool nullable);
    private static bool ValidateString(JToken o);
    private static bool ValidateBytes(JToken o);
    public static bool op_Explicit(JToken value);
    public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    public static Nullable`1<DateTime> op_Explicit(JToken value);
    public static Nullable`1<decimal> op_Explicit(JToken value);
    public static Nullable`1<double> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static Nullable`1<int> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    public static Nullable`1<long> op_Explicit(JToken value);
    public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    public static Byte[] op_Explicit(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    internal void SetLineInfo(IJsonLineInfo lineInfo);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
}
public class Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    public sealed virtual bool Equals(JToken x, JToken y);
    public sealed virtual int GetHashCode(JToken obj);
}
public class Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    private JToken _root;
    private JToken _parent;
    private JToken _current;
    private bool IsEndElement { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JTokenReader(JToken token);
    public virtual Byte[] ReadAsBytes();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private bool get_IsEndElement();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
public enum Newtonsoft.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
}
public class Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    public JToken Token { get; }
    public JTokenWriter(JContainer container);
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    private void AddValue(object value, JsonToken token);
    internal void AddValue(JValue value, JsonToken token);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Byte[] value);
}
public class Newtonsoft.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(JValue other);
    public JValue(long value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(DateTime value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(object value);
    internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    private static bool Compare(JTokenType valueType, object objA, object objB);
    internal virtual JToken CloneToken();
    public static JValue CreateComment(string value);
    public static JValue CreateString(string value);
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Newtonsoft.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
}
public enum Newtonsoft.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
public enum Newtonsoft.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
public enum Newtonsoft.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
public enum Newtonsoft.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
public enum Newtonsoft.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
public enum Newtonsoft.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
}
[ExtensionAttribute]
public static class Newtonsoft.Json.Schema.Extensions : object {
    [ExtensionAttribute]
public static bool IsValid(JToken source, JsonSchema schema);
    [ExtensionAttribute]
public static void Validate(JToken source, JsonSchema schema);
    [ExtensionAttribute]
public static void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler);
}
public class Newtonsoft.Json.Schema.JsonSchema : object {
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optional>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumDecimals>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<JToken, string> <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <Extends>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<bool> Optional { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Transient { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<JsonSchemaType> Type { get; public set; }
    public string Pattern { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<int> MaximumDecimals { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<JsonSchema> Items { get; public set; }
    public IDictionary`2<string, JsonSchema> Properties { get; public set; }
    public JsonSchema AdditionalProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public string Requires { get; public set; }
    public IList`1<string> Identity { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public IDictionary`2<JToken, string> Options { get; public set; }
    public Nullable`1<JsonSchemaType> Disallow { get; public set; }
    public JToken Default { get; public set; }
    public JsonSchema Extends { get; public set; }
    public string Format { get; public set; }
    internal string InternalId { get; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optional();
    [CompilerGeneratedAttribute]
public void set_Optional(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Transient();
    [CompilerGeneratedAttribute]
public void set_Transient(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumDecimals();
    [CompilerGeneratedAttribute]
public void set_MaximumDecimals(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchema value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<JToken, string> get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(IDictionary`2<JToken, string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [CompilerGeneratedAttribute]
public JsonSchema get_Extends();
    [CompilerGeneratedAttribute]
public void set_Extends(JsonSchema value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    internal string get_InternalId();
    public static JsonSchema Read(JsonReader reader);
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver);
    public static JsonSchema Parse(string json);
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver);
    public void WriteTo(JsonWriter writer);
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver);
    public virtual string ToString();
}
internal class Newtonsoft.Json.Schema.JsonSchemaBuilder : object {
    private JsonReader _reader;
    private IList`1<JsonSchema> _stack;
    private JsonSchemaResolver _resolver;
    private JsonSchema _currentSchema;
    private JsonSchema CurrentSchema { get; }
    public JsonSchemaBuilder(JsonSchemaResolver resolver);
    private void Push(JsonSchema value);
    private JsonSchema Pop();
    private JsonSchema get_CurrentSchema();
    internal JsonSchema Parse(JsonReader reader);
    private JsonSchema BuildSchema();
    private void ProcessSchemaProperty(string propertyName);
    private void ProcessExtends();
    private void ProcessEnum();
    private void ProcessOptions();
    private void ProcessDefault();
    private void ProcessIdentity();
    private void ProcessAdditionalProperties();
    private void ProcessItems();
    private void ProcessProperties();
    private Nullable`1<JsonSchemaType> ProcessType();
    internal static JsonSchemaType MapType(string type);
    internal static string MapType(JsonSchemaType type);
}
internal static class Newtonsoft.Json.Schema.JsonSchemaConstants : object {
    public static string TypePropertyName;
    public static string PropertiesPropertyName;
    public static string ItemsPropertyName;
    public static string OptionalPropertyName;
    public static string AdditionalPropertiesPropertyName;
    public static string RequiresPropertyName;
    public static string IdentityPropertyName;
    public static string MinimumPropertyName;
    public static string MaximumPropertyName;
    public static string MinimumItemsPropertyName;
    public static string MaximumItemsPropertyName;
    public static string PatternPropertyName;
    public static string MaximumLengthPropertyName;
    public static string MinimumLengthPropertyName;
    public static string EnumPropertyName;
    public static string OptionsPropertyName;
    public static string ReadOnlyPropertyName;
    public static string TitlePropertyName;
    public static string DescriptionPropertyName;
    public static string FormatPropertyName;
    public static string DefaultPropertyName;
    public static string TransientPropertyName;
    public static string MaximumDecimalsPropertyName;
    public static string HiddenPropertyName;
    public static string DisallowPropertyName;
    public static string ExtendsPropertyName;
    public static string IdPropertyName;
    public static string OptionValuePropertyName;
    public static string OptionLabelPropertyName;
    public static string ReferencePropertyName;
    public static IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping;
    private static JsonSchemaConstants();
}
public class Newtonsoft.Json.Schema.JsonSchemaException : Exception {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public JsonSchemaException(string message);
    public JsonSchemaException(string message, Exception innerException);
    internal JsonSchemaException(string message, Exception innerException, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
}
public class Newtonsoft.Json.Schema.JsonSchemaGenerator : object {
    private IContractResolver _contractResolver;
    private JsonSchemaResolver _resolver;
    private IList`1<TypeSchema> _stack;
    private JsonSchema _currentSchema;
    [CompilerGeneratedAttribute]
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField;
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    private JsonSchema CurrentSchema { get; }
    [CompilerGeneratedAttribute]
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling();
    [CompilerGeneratedAttribute]
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    private JsonSchema get_CurrentSchema();
    private void Push(TypeSchema typeSchema);
    private TypeSchema Pop();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver);
    public JsonSchema Generate(Type type, bool rootSchemaNullable);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable);
    private string GetTitle(Type type);
    private string GetDescription(Type type);
    private string GetTypeId(Type type, bool explicitOnly);
    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool optional);
    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired);
    private void GenerateObjectSchema(Type type, JsonObjectContract contract);
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract);
    internal static bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag);
    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired);
}
internal class Newtonsoft.Json.Schema.JsonSchemaModel : object {
    [CompilerGeneratedAttribute]
private bool <Optional>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumDecimals>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchemaModel> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Disallow>k__BackingField;
    public bool Optional { get; public set; }
    public JsonSchemaType Type { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<int> MaximumDecimals { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<string> Patterns { get; public set; }
    public IList`1<JsonSchemaModel> Items { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> Properties { get; public set; }
    public JsonSchemaModel AdditionalProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public JsonSchemaType Disallow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Optional();
    [CompilerGeneratedAttribute]
public void set_Optional(bool value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(JsonSchemaType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumDecimals();
    [CompilerGeneratedAttribute]
public void set_MaximumDecimals(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchemaModel> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(JsonSchemaType value);
    public static JsonSchemaModel Create(IList`1<JsonSchema> schemata);
    private static void Combine(JsonSchemaModel model, JsonSchema schema);
}
internal class Newtonsoft.Json.Schema.JsonSchemaModelBuilder : object {
    private JsonSchemaNodeCollection _nodes;
    private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels;
    private JsonSchemaNode _node;
    public JsonSchemaModel Build(JsonSchema schema);
    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema);
    public void AddProperty(JsonSchemaNode parentNode, string propertyName, JsonSchema schema);
    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema);
    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema);
    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node);
}
internal class Newtonsoft.Json.Schema.JsonSchemaNode : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JsonSchemaNode> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<JsonSchema, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public string Id { get; private set; }
    public ReadOnlyCollection`1<JsonSchema> Schemas { get; private set; }
    public Dictionary`2<string, JsonSchemaNode> Properties { get; private set; }
    public List`1<JsonSchemaNode> Items { get; private set; }
    public JsonSchemaNode AdditionalProperties { get; public set; }
    public JsonSchemaNode(JsonSchema schema);
    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<JsonSchema> get_Schemas();
    [CompilerGeneratedAttribute]
private void set_Schemas(ReadOnlyCollection`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public List`1<JsonSchemaNode> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(List`1<JsonSchemaNode> value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaNode value);
    public JsonSchemaNode Combine(JsonSchema schema);
    public static string GetId(IEnumerable`1<JsonSchema> schemata);
    [CompilerGeneratedAttribute]
private static string <GetId>b__0(JsonSchema s);
    [CompilerGeneratedAttribute]
private static string <GetId>b__1(string id);
}
internal class Newtonsoft.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
    protected virtual string GetKeyForItem(JsonSchemaNode item);
}
public class Newtonsoft.Json.Schema.JsonSchemaResolver : object {
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField;
    public IList`1<JsonSchema> LoadedSchemas { get; protected set; }
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_LoadedSchemas();
    [CompilerGeneratedAttribute]
protected void set_LoadedSchemas(IList`1<JsonSchema> value);
    public virtual JsonSchema GetSchema(string id);
}
[FlagsAttribute]
public enum Newtonsoft.Json.Schema.JsonSchemaType : Enum {
    public int value__;
    public static JsonSchemaType None;
    public static JsonSchemaType String;
    public static JsonSchemaType Float;
    public static JsonSchemaType Integer;
    public static JsonSchemaType Boolean;
    public static JsonSchemaType Object;
    public static JsonSchemaType Array;
    public static JsonSchemaType Null;
    public static JsonSchemaType Any;
}
internal class Newtonsoft.Json.Schema.JsonSchemaWriter : object {
    private JsonWriter _writer;
    private JsonSchemaResolver _resolver;
    [CompilerGeneratedAttribute]
private static Func`2<JsonSchemaType, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver);
    private void ReferenceOrWriteSchema(JsonSchema schema);
    public void WriteSchema(JsonSchema schema);
    private void WriteItems(JsonSchema schema);
    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
    [CompilerGeneratedAttribute]
private static bool <WriteType>b__1(JsonSchemaType v);
}
public enum Newtonsoft.Json.Schema.UndefinedSchemaIdHandling : Enum {
    public int value__;
    public static UndefinedSchemaIdHandling None;
    public static UndefinedSchemaIdHandling UseTypeName;
    public static UndefinedSchemaIdHandling UseAssemblyQualifiedName;
}
public class Newtonsoft.Json.Schema.ValidationEventArgs : EventArgs {
    private JsonSchemaException _ex;
    public JsonSchemaException Exception { get; }
    public string Message { get; }
    internal ValidationEventArgs(JsonSchemaException ex);
    public JsonSchemaException get_Exception();
    public string get_Message();
}
public class Newtonsoft.Json.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    private static ThreadSafeStore`2<ICustomAttributeProvider, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    public static T GetAttribute(ICustomAttributeProvider type);
}
public class Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    protected virtual string ResolvePropertyName(string propertyName);
}
public class Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    internal static IContractResolver Instance;
    private static IList`1<JsonConverter> BuiltInConverters;
    private static Dictionary`2<ResolverContractKey, JsonContract> _sharedContractCache;
    private static object _typeContractCacheLock;
    private Dictionary`2<ResolverContractKey, JsonContract> _instanceContractCache;
    private bool _sharedCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    public bool DynamicCodeGeneration { get; }
    public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public DefaultContractResolver(bool shareCache);
    private static DefaultContractResolver();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    private Dictionary`2<ResolverContractKey, JsonContract> GetCache();
    private void UpdateCache(Dictionary`2<ResolverContractKey, JsonContract> cache);
    public virtual JsonContract ResolveContract(Type type);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private ConstructorInfo GetParametrizedConstructor(Type objectType);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(JsonObjectContract contract);
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(JsonObjectContract contract, MemberInfo member);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    protected virtual string ResolvePropertyName(string propertyName);
    [CompilerGeneratedAttribute]
private static bool <GetSerializableMembers>b__0(MemberInfo m);
    [CompilerGeneratedAttribute]
private static bool <GetSerializableMembers>b__1(MemberInfo m);
}
internal class Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> _mappings;
    private BidirectionalDictionary`2<string, object> Mappings { get; }
    private BidirectionalDictionary`2<string, object> get_Mappings();
    public sealed virtual object ResolveReference(string reference);
    public sealed virtual string GetReference(object value);
    public sealed virtual void AddReference(string reference, object value);
    public sealed virtual bool IsReferenced(object value);
}
public class Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    private static DefaultSerializationBinder();
    public virtual Type BindToType(string assemblyName, string typeName);
}
public class Newtonsoft.Json.Serialization.DynamicValueProvider : object {
    private MemberInfo _memberInfo;
    private Func`2<object, object> _getter;
    private Action`2<object, object> _setter;
    public DynamicValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
public class Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    public Exception Error { get; private set; }
    public object OriginalObject { get; private set; }
    public object Member { get; private set; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, Exception error);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public object get_OriginalObject();
    [CompilerGeneratedAttribute]
private void set_OriginalObject(object value);
    [CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(object value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
public class Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    public object CurrentObject { get; private set; }
    public ErrorContext ErrorContext { get; private set; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
private void set_CurrentObject(object value);
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
    [CompilerGeneratedAttribute]
private void set_ErrorContext(ErrorContext value);
}
public interface Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
public interface Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(string reference);
    public abstract virtual string GetReference(object value);
    public abstract virtual bool IsReferenced(object value);
    public abstract virtual void AddReference(string reference, object value);
}
public interface Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
public class Newtonsoft.Json.Serialization.JsonArrayContract : JsonContract {
    private bool _isCollectionItemTypeNullableType;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private MethodCall`2<object, object> _genericWrapperCreator;
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    internal Type CollectionItemType { get; private set; }
    public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
internal Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
private void set_CollectionItemType(Type value);
    internal IWrappedCollection CreateWrapper(object list);
    private bool IsTypeGenericCollectionInterface(Type type);
}
public abstract class Newtonsoft.Json.Serialization.JsonContract : object {
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CreatedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <OnDeserialized>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <OnDeserializing>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <OnSerialized>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <OnSerializing>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <OnError>k__BackingField;
    public Type UnderlyingType { get; private set; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public JsonConverter Converter { get; public set; }
    internal JsonConverter InternalConverter { get; internal set; }
    public MethodInfo OnDeserialized { get; public set; }
    public MethodInfo OnDeserializing { get; public set; }
    public MethodInfo OnSerialized { get; public set; }
    public MethodInfo OnSerializing { get; public set; }
    public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    public MethodInfo OnError { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
private void set_UnderlyingType(Type value);
    [CompilerGeneratedAttribute]
public Type get_CreatedType();
    [CompilerGeneratedAttribute]
public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
internal JsonConverter get_InternalConverter();
    [CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public MethodInfo get_OnDeserialized();
    [CompilerGeneratedAttribute]
public void set_OnDeserialized(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_OnDeserializing();
    [CompilerGeneratedAttribute]
public void set_OnDeserializing(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_OnSerialized();
    [CompilerGeneratedAttribute]
public void set_OnSerialized(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_OnSerializing();
    [CompilerGeneratedAttribute]
public void set_OnSerializing(MethodInfo value);
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    [CompilerGeneratedAttribute]
public MethodInfo get_OnError();
    [CompilerGeneratedAttribute]
public void set_OnError(MethodInfo value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
}
public class Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContract {
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    private MethodCall`2<object, object> _genericWrapperCreator;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    internal Type DictionaryKeyType { get; private set; }
    internal Type DictionaryValueType { get; private set; }
    public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
internal Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
private void set_DictionaryKeyType(Type value);
    [CompilerGeneratedAttribute]
internal Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
private void set_DictionaryValueType(Type value);
    internal IWrappedDictionary CreateWrapper(object dictionary);
    private bool IsTypeGenericDictionaryInterface(Type type);
}
internal class Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializer _serializer;
    public JsonFormatterConverter(JsonSerializer serializer);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
public class Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContract {
    [CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
public class Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    public JsonLinqContract(Type underlyingType);
}
public class Newtonsoft.Json.Serialization.JsonObjectContract : JsonContract {
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ParametrizedConstructor>k__BackingField;
    public MemberSerialization MemberSerialization { get; public set; }
    public JsonPropertyCollection Properties { get; private set; }
    public ConstructorInfo ParametrizedConstructor { get; public set; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(JsonPropertyCollection value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_ParametrizedConstructor();
    [CompilerGeneratedAttribute]
public void set_ParametrizedConstructor(ConstructorInfo value);
}
public class Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    public JsonPrimitiveContract(Type underlyingType);
}
public class Newtonsoft.Json.Serialization.JsonProperty : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <MemberConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Required <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    public string PropertyName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public JsonConverter MemberConverter { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    public Predicate`1<object> ShouldSerialize { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public JsonConverter get_MemberConverter();
    [CompilerGeneratedAttribute]
public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public Required get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    public virtual string ToString();
}
public class Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private JsonObjectContract _contract;
    public JsonPropertyCollection(JsonObjectContract contract);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
internal abstract class Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    private ErrorContext _currentErrorContext;
    [CompilerGeneratedAttribute]
private JsonSerializer <Serializer>k__BackingField;
    internal JsonSerializer Serializer { get; private set; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    [CompilerGeneratedAttribute]
internal JsonSerializer get_Serializer();
    [CompilerGeneratedAttribute]
private void set_Serializer(JsonSerializer value);
    protected ErrorContext GetErrorContext(object currentObject, object member, Exception error);
    protected void ClearErrorContext();
    protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, Exception ex);
}
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    private JsonSerializerProxy _internalSerializer;
    private JsonFormatterConverter _formatterConverter;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, JsonProperty> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, object> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, ParameterInfo> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, object> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<ParameterInfo, object>, string> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, bool> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, JsonProperty> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<JsonProperty, RequiredValue> CS$<>9__CachedAnonymousMethodDelegate14;
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    private JsonContract GetContractSafe(Type type);
    private JsonContract GetContractSafe(Type type, object value);
    public object Deserialize(JsonReader reader, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    private JsonFormatterConverter GetFormatterConverter();
    private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueProperty(JsonReader reader, JsonProperty property, object target, bool gottenCurrentValue, object currentValue);
    private object CreateValueNonProperty(JsonReader reader, Type objectType, JsonContract contract);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue);
    private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue);
    private JsonArrayContract EnsureArrayContract(Type objectType, JsonContract contract);
    private void CheckedRead(JsonReader reader);
    private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string reference);
    private bool HasDefinedType(Type type);
    private object EnsureType(object value, Type targetType);
    private string FormatValueForPrint(object value);
    private void SetPropertyValue(JsonProperty property, JsonReader reader, object target);
    private bool ShouldSetPropertyValue(JsonProperty property, object value);
    private object CreateAndPopulateDictionary(JsonReader reader, JsonDictionaryContract contract, string id);
    private object PopulateDictionary(IWrappedDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, string id);
    private object CreateAndPopulateList(JsonReader reader, string reference, JsonArrayContract contract);
    private object PopulateList(IWrappedCollection wrappedList, JsonReader reader, string reference, JsonArrayContract contract);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, string id);
    private object CreateAndPopulateObject(JsonReader reader, JsonObjectContract contract, string id);
    private object CreateObjectFromNonDefaultConstructor(JsonReader reader, JsonObjectContract contract, string id);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, string id);
    private void SetRequiredProperty(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, RequiredValue> requiredProperties);
    private void HandleError(JsonReader reader, int initialDepth);
    [CompilerGeneratedAttribute]
private static bool <CreateObjectFromNonDefaultConstructor>b__3(JsonProperty p);
    [CompilerGeneratedAttribute]
private static JsonProperty <CreateObjectFromNonDefaultConstructor>b__4(JsonProperty kv);
    [CompilerGeneratedAttribute]
private static object <CreateObjectFromNonDefaultConstructor>b__5(JsonProperty kv);
    [CompilerGeneratedAttribute]
private static ParameterInfo <CreateObjectFromNonDefaultConstructor>b__6(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static object <CreateObjectFromNonDefaultConstructor>b__7(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static string <CreateObjectFromNonDefaultConstructor>b__8(KeyValuePair`2<ParameterInfo, object> kv);
    [CompilerGeneratedAttribute]
private static bool <PopulateObject>b__f(JsonProperty m);
    [CompilerGeneratedAttribute]
private static JsonProperty <PopulateObject>b__10(JsonProperty m);
    [CompilerGeneratedAttribute]
private static RequiredValue <PopulateObject>b__11(JsonProperty m);
}
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    private JsonSerializerProxy _internalSerializer;
    private List`1<object> _serializeStack;
    private List`1<object> SerializeStack { get; }
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    private List`1<object> get_SerializeStack();
    public void Serialize(JsonWriter jsonWriter, object value);
    private JsonSerializerProxy GetInternalSerializer();
    private JsonContract GetContractSafe(object value);
    private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContract collectionValueContract);
    private bool ShouldWriteReference(object value, JsonProperty property, JsonContract contract);
    private void WriteMemberInfoProperty(JsonWriter writer, object memberValue, JsonProperty property, JsonContract contract);
    private bool CheckForCircularReference(object value, Nullable`1<ReferenceLoopHandling> referenceLoopHandling, JsonContract contract);
    private void WriteReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContract collectionValueContract);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract);
    private void SerializeList(JsonWriter writer, IList values, JsonArrayContract contract, JsonProperty member, JsonContract collectionValueContract);
    private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract);
    private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContract collectionValueContract);
    private void SerializeDictionary(JsonWriter writer, IWrappedDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContract collectionValueContract);
    private string GetPropertyName(DictionaryEntry entry);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonProperty property, object target);
}
internal class Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    private JsonSerializerInternalReader _serializerReader;
    private JsonSerializerInternalWriter _serializerWriter;
    private JsonSerializer _serializer;
    public IReferenceResolver ReferenceResolver { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual IReferenceResolver get_ReferenceResolver();
    public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value);
}
public class Newtonsoft.Json.Serialization.JsonStringContract : JsonContract {
    public JsonStringContract(Type underlyingType);
}
internal static class Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    private static ThreadSafeStore`2<ICustomAttributeProvider, Type> JsonConverterTypeCache;
    private static Nullable`1<bool> _dynamicCodeGeneration;
    public static bool DynamicCodeGeneration { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static JsonContainerAttribute GetJsonContainerAttribute(Type type);
    public static JsonObjectAttribute GetJsonObjectAttribute(Type type);
    public static JsonArrayAttribute GetJsonArrayAttribute(Type type);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType);
    private static Type GetJsonConverterType(ICustomAttributeProvider attributeProvider);
    private static Type GetJsonConverterTypeFromAttribute(ICustomAttributeProvider attributeProvider);
    public static JsonConverter GetJsonConverter(ICustomAttributeProvider attributeProvider, Type targetConvertedType);
    public static TypeConverter GetTypeConverter(Type type);
    public static T GetAttribute(ICustomAttributeProvider attributeProvider);
    public static bool get_DynamicCodeGeneration();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
public class Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
public class Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
public class Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Newtonsoft.Json.Serialization.ResolverContractKey : ValueType {
    private Type _resolverType;
    private Type _contractType;
    public ResolverContractKey(Type resolverType, Type contractType);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ResolverContractKey other);
}
[FlagsAttribute]
public enum Newtonsoft.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling Auto;
    public static TypeNameHandling All;
}
internal class Newtonsoft.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    public void Encode(Byte[] buffer, int index, int count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
}
internal class Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public void Add(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.CollectionUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> CastValid(IEnumerable enumerable);
    public static List`1<T> CreateList(T[] values);
    public static bool IsNullOrEmpty(ICollection collection);
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    public static bool IsNullOrEmptyOrDefault(IList`1<T> list);
    public static IList`1<T> Slice(IList`1<T> list, Nullable`1<int> start, Nullable`1<int> end);
    public static IList`1<T> Slice(IList`1<T> list, Nullable`1<int> start, Nullable`1<int> end, Nullable`1<int> step);
    public static Dictionary`2<K, List`1<V>> GroupBy(ICollection`1<V> source, Func`2<V, K> keySelector);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList initial, IEnumerable collection);
    public static List`1<T> Distinct(List`1<T> collection);
    public static List`1<List`1<T>> Flatten(IList`1[] lists);
    private static void Recurse(IList`1<IList`1<T>> global, int current, Dictionary`2<int, T> currentSet, List`1<List`1<T>> flattenedResult);
    public static List`1<T> CreateList(ICollection collection);
    public static bool ListEquals(IList`1<T> a, IList`1<T> b);
    public static bool TryGetSingleItem(IList`1<T> list, T& value);
    public static bool TryGetSingleItem(IList`1<T> list, bool returnDefaultIfEmpty, T& value);
    public static T GetSingleItem(IList`1<T> list);
    public static T GetSingleItem(IList`1<T> list, bool returnDefaultIfEmpty);
    public static IList`1<T> Minus(IList`1<T> list, IList`1<T> minus);
    public static IList CreateGenericList(Type listType);
    public static IDictionary CreateGenericDictionary(Type keyType, Type valueType);
    public static bool IsListType(Type type);
    public static bool IsCollectionType(Type type);
    public static bool IsDictionaryType(Type type);
    public static IWrappedCollection CreateCollectionWrapper(object list);
    public static IWrappedList CreateListWrapper(object list);
    public static IWrappedDictionary CreateDictionaryWrapper(object dictionary);
    public static object CreateAndPopulateList(Type listType, Action`2<IList, bool> populateList);
    public static Array ToArray(Array initial, Type type);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [CompilerGeneratedAttribute]
private static bool <CastValid>b__0(object o);
}
internal class Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    private IList _list;
    private ICollection`1<T> _genericCollection;
    private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void VerifyValueType(object value);
    private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
internal static class Newtonsoft.Json.Utilities.ConvertUtils : object {
    private static ThreadSafeStore`2<TypeConvertKey, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    private static Func`2<object, object> CreateCastConverter(TypeConvertKey t);
    public static bool CanConvertType(Type initialType, Type targetType, bool allowTypeNameToString);
    private static bool IsComponentConverter(TypeConverter converter);
    public static T Convert(object initialValue);
    public static T Convert(object initialValue, CultureInfo culture);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    public static bool TryConvert(object initialValue, T& convertedValue);
    public static bool TryConvert(object initialValue, CultureInfo culture, T& convertedValue);
    public static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& convertedValue);
    public static T ConvertOrCast(object initialValue);
    public static T ConvertOrCast(object initialValue, CultureInfo culture);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    public static bool TryConvertOrCast(object initialValue, T& convertedValue);
    public static bool TryConvertOrCast(object initialValue, CultureInfo culture, T& convertedValue);
    public static bool TryConvertOrCast(object initialValue, CultureInfo culture, Type targetType, Object& convertedValue);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    public static object ToValue(INullable nullableValue);
    internal static TypeConverter GetConverter(Type t);
    public static bool IsInteger(object value);
}
internal class Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DateTimeUtils : object {
    [ExtensionAttribute]
public static string GetLocalOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    private IDictionary _dictionary;
    private IDictionary`2<TKey, TValue> _genericDictionary;
    private object _syncRoot;
    [CompilerGeneratedAttribute]
private static Func`2<DictionaryEntry, KeyValuePair`2<TKey, TValue>> CS$<>9__CachedAnonymousMethodDelegate1;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
    [CompilerGeneratedAttribute]
private static KeyValuePair`2<TKey, TValue> <GetEnumerator>b__0(DictionaryEntry de);
}
internal class Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
    public static DynamicReflectionDelegateFactory Instance;
    private static DynamicReflectionDelegateFactory();
    private static DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
internal static class Newtonsoft.Json.Utilities.DynamicWrapper : object {
    private static object _lock;
    private static WrapperDictionary _wrapperDictionary;
    private static ModuleBuilder _moduleBuilder;
    private static ModuleBuilder ModuleBuilder { get; }
    private static DynamicWrapper();
    private static ModuleBuilder get_ModuleBuilder();
    private static void Init();
    private static Byte[] GetStrongKey();
    public static Type GetWrapper(Type interfaceType, Type realObjectType);
    public static object GetUnderlyingObject(object wrapper);
    private static Type GenerateWrapperType(Type interfaceType, Type underlyingType);
    public static T CreateWrapper(object realObject);
}
internal class Newtonsoft.Json.Utilities.DynamicWrapperBase : object {
    protected internal object UnderlyingObject;
}
internal static class Newtonsoft.Json.Utilities.EnumUtils : object {
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public static T Parse(string enumMemberName);
    public static T Parse(string enumMemberName, bool ignoreCase);
    public static bool TryParse(string enumMemberName, bool ignoreCase, T& value);
    public static IList`1<T> GetFlagsValues(T value);
    public static EnumValues`1<ulong> GetNamesAndValues();
    public static EnumValues`1<TUnderlyingType> GetNamesAndValues();
    public static EnumValues`1<TUnderlyingType> GetNamesAndValues(Type enumType);
    public static IList`1<T> GetValues();
    public static IList`1<object> GetValues(Type enumType);
    public static IList`1<string> GetNames();
    public static IList`1<string> GetNames(Type enumType);
    public static TEnumType GetMaximumValue(Type enumType);
    [CompilerGeneratedAttribute]
private static bool <GetFlagsValues>b__3(EnumValue`1<ulong> v);
    [CompilerGeneratedAttribute]
private static bool <GetValues>b__4(FieldInfo field);
    [CompilerGeneratedAttribute]
private static bool <GetNames>b__6(FieldInfo field);
}
internal class Newtonsoft.Json.Utilities.EnumValue`1 : object {
    private string _name;
    private T _value;
    public string Name { get; }
    public T Value { get; }
    public EnumValue`1(string name, T value);
    public string get_Name();
    public T get_Value();
}
internal class Newtonsoft.Json.Utilities.EnumValues`1 : KeyedCollection`2<string, EnumValue`1<T>> {
    protected virtual string GetKeyForItem(EnumValue`1<T> item);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void PushInstance(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void BoxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void UnboxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void CallMethod(ILGenerator generator, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void Return(ILGenerator generator);
}
internal interface Newtonsoft.Json.Utilities.IWrappedCollection {
    public object UnderlyingCollection { get; }
    public abstract virtual object get_UnderlyingCollection();
}
internal interface Newtonsoft.Json.Utilities.IWrappedDictionary {
    public object UnderlyingDictionary { get; }
    public abstract virtual object get_UnderlyingDictionary();
}
internal interface Newtonsoft.Json.Utilities.IWrappedList {
    public object UnderlyingList { get; }
    public abstract virtual object get_UnderlyingList();
}
internal static class Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    public static void WriteEscapedJavaScriptString(TextWriter writer, string value, char delimiter, bool appendDelimiters);
    public static string ToEscapedJavaScriptString(string value);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters);
}
internal class Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    public static LateBoundReflectionDelegateFactory Instance;
    private static LateBoundReflectionDelegateFactory();
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.ListWrapper`1 : object {
    private IList _list;
    private IList`1<T> _genericList;
    private object _syncRoot;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingList { get; }
    public ListWrapper`1(IList list);
    public ListWrapper`1(IList`1<T> list);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void VerifyValueType(object value);
    private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingList();
}
internal class Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(int i);
    public static int HexToInt(char h);
    public static char IntToHex(int n);
    public static int GetDecimalPlaces(double value);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Min(Nullable`1<double> val1, Nullable`1<double> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
}
internal class Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal static class Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static bool TryAction(Creator`1<T> creator, T& output);
    public static string ToString(object value);
    public static Byte[] HexToBytes(string hex);
    public static string BytesToHex(Byte[] bytes);
    public static string BytesToHex(Byte[] bytes, bool removeDashes);
    public static bool ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
}
internal abstract class Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ReflectionUtils : object {
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, MemberInfo>, <>f__AnonymousType0`2<int, IEnumerable`1<MemberInfo>>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`3<Type, IList`1<object>, object> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<FieldInfo, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat);
    private static string GetSimpleTypeName(Type type);
    public static bool IsInstantiatableType(Type t);
    public static bool HasDefaultConstructor(Type t);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static bool IsUnitializedValue(object value);
    public static object CreateUnitializedValue(Type type);
    public static bool IsPropertyIndexed(PropertyInfo property);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetDictionaryValueType(Type dictionaryType);
    public static Type GetDictionaryKeyType(Type dictionaryType);
    public static bool ItemsUnitializedValue(IList`1<T> list);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsIndexedProperty(MemberInfo member);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic);
    public static List`1<MemberInfo> GetFieldsAndProperties(BindingFlags bindingAttr);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(ICustomAttributeProvider attributeProvider);
    public static T GetAttribute(ICustomAttributeProvider attributeProvider, bool inherit);
    public static T[] GetAttributes(ICustomAttributeProvider attributeProvider, bool inherit);
    public static string GetNameAndAssessmblyName(Type t);
    public static Type MakeGenericType(Type genericTypeDefinition, Type[] innerTypes);
    public static object CreateGeneric(Type genericTypeDefinition, Type innerType, Object[] args);
    public static object CreateGeneric(Type genericTypeDefinition, IList`1<Type> innerTypes, Object[] args);
    public static object CreateGeneric(Type genericTypeDefinition, IList`1<Type> innerTypes, Func`3<Type, IList`1<object>, object> instanceCreator, Object[] args);
    public static bool IsCompatibleValue(object value, Type type);
    public static object CreateInstance(Type type, Object[] args);
    public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, String& typeName, String& assemblyName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<MemberInfo> initialProperties, Type targetType, BindingFlags bindingAttr);
    [CompilerGeneratedAttribute]
private static string <GetFieldsAndProperties>b__0(MemberInfo m);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<int, IEnumerable`1<MemberInfo>> <GetFieldsAndProperties>b__1(IGrouping`2<string, MemberInfo> g);
    [CompilerGeneratedAttribute]
private static object <CreateGeneric>b__8(Type t, IList`1<object> a);
    [CompilerGeneratedAttribute]
private static bool <GetChildPrivateFields>b__a(FieldInfo f);
}
internal class Newtonsoft.Json.Utilities.StringBuffer : object {
    private Char[] _buffer;
    private int _position;
    private static Char[] _emptyBuffer;
    public int Position { get; public set; }
    public StringBuffer(int initalSize);
    private static StringBuffer();
    public int get_Position();
    public void set_Position(int value);
    public void Append(char value);
    public void Clear();
    private void EnsureSize(int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] GetInternalBuffer();
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool ContainsWhiteSpace(string s);
    public static bool IsWhiteSpace(string s);
    public static string EnsureEndsWith(string target, string value);
    public static bool IsNullOrEmptyOrWhiteSpace(string s);
    public static void IfNotNullOrEmpty(string value, Action`1<string> action);
    private static void IfNotNullOrEmpty(string value, Action`1<string> trueAction, Action`1<string> falseAction);
    public static string Indent(string s, int indentation);
    public static string Indent(string s, int indentation, char indentChar);
    private static void ActionTextReaderLine(TextReader textReader, TextWriter textWriter, ActionLine lineAction);
    public static string NumberLines(string s);
    public static string NullEmptyString(string s);
    public static string ReplaceNewLines(string s, string replacement);
    public static string Truncate(string s, int maximumLength);
    public static string Truncate(string s, int maximumLength, string suffix);
    public static StringWriter CreateStringWriter(int capacity);
    public static Nullable`1<int> GetLength(string value);
    public static string ToCharAsUnicode(char c);
    public static void WriteCharAsUnicode(TextWriter writer, char c);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
}
internal class Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    private object _lock;
    private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
    private TValue AddValue(TKey key);
}
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.TypeExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Type, IEnumerable`1<MethodInfo>> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`3<Type, MethodInfo, MethodInfo> CS$<>9__CachedAnonymousMethodDelegate13;
    [ExtensionAttribute]
public static MethodInfo GetGenericMethod(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static bool HasParameters(MethodInfo method, Type[] parameterTypes);
    [ExtensionAttribute]
public static IEnumerable`1<Type> AllInterfaces(Type target);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> AllMethods(Type target);
    [CompilerGeneratedAttribute]
private static Type <HasParameters>b__3(ParameterInfo parameter);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<MethodInfo> <AllMethods>b__10(Type type);
    [CompilerGeneratedAttribute]
private static MethodInfo <AllMethods>b__11(Type type, MethodInfo method);
}
internal static class Newtonsoft.Json.Utilities.ValidationUtils : object {
    public static string EmailAddressRegex;
    public static string CurrencyRegex;
    public static string DateRegex;
    public static string NumericRegex;
    public static void ArgumentNotNullOrEmpty(string value, string parameterName);
    public static void ArgumentNotNullOrEmptyOrWhitespace(string value, string parameterName);
    public static void ArgumentTypeIsEnum(Type enumType, string parameterName);
    public static void ArgumentNotNullOrEmpty(ICollection`1<T> collection, string parameterName);
    public static void ArgumentNotNullOrEmpty(ICollection`1<T> collection, string parameterName, string message);
    public static void ArgumentNotNullOrEmpty(ICollection collection, string parameterName);
    public static void ArgumentNotNullOrEmpty(ICollection collection, string parameterName, string message);
    public static void ArgumentNotNull(object value, string parameterName);
    public static void ArgumentNotNegative(int value, string parameterName);
    public static void ArgumentNotNegative(int value, string parameterName, string message);
    public static void ArgumentNotZero(int value, string parameterName);
    public static void ArgumentNotZero(int value, string parameterName, string message);
    public static void ArgumentIsPositive(T value, string parameterName);
    public static void ArgumentIsPositive(int value, string parameterName, string message);
    public static void ObjectNotDisposed(bool disposed, Type objectType);
    public static void ArgumentConditionTrue(bool condition, string parameterName, string message);
}
internal class Newtonsoft.Json.Utilities.WrapperDictionary : object {
    private Dictionary`2<string, Type> _wrapperTypes;
    private static string GenerateKey(Type interfaceType, Type realObjectType);
    public Type GetType(Type interfaceType, Type realObjectType);
    public void SetType(Type interfaceType, Type realObjectType, Type wrapperType);
}
internal class Newtonsoft.Json.Utilities.WrapperMethodBuilder : object {
    private Type _realObjectType;
    private TypeBuilder _wrapperBuilder;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public WrapperMethodBuilder(Type realObjectType, TypeBuilder proxyBuilder);
    public void Generate(MethodInfo newMethod);
    private static void Return(ILGenerator ilGenerator);
    private void ExecuteMethod(MethodBase newMethod, Type[] parameterTypes, ILGenerator ilGenerator);
    private MethodInfo GetMethod(MethodBase realMethod, Type[] parameterTypes);
    private static void PushParameters(ICollection`1<ParameterInfo> parameters, ILGenerator ilGenerator);
    private static void LoadUnderlyingObject(ILGenerator ilGenerator, FieldInfo srcField);
    [CompilerGeneratedAttribute]
private static Type <Generate>b__0(ParameterInfo parameter);
    [CompilerGeneratedAttribute]
private static string <Generate>b__1(Type arg);
}
public enum Newtonsoft.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
internal class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal interface System.IOrderedEnumerable`1 {
    public abstract virtual IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
}
[ExtensionAttribute]
internal static class System.Linq.Enumerable : object {
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Skip(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> SkipWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Take(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> TakeWhile(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Where(IEnumerable`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
private static TSource Single(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, bool orDefault);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
private static TSource First(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, bool orDefault);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
private static TSource Last(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate, bool orDefault);
    [ExtensionAttribute]
public static TSource ElementAt(IEnumerable`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(IEnumerable`1<TSource> source, int index);
    [ExtensionAttribute]
private static TSource ElementAt(IEnumerable`1<TSource> source, int index, bool orDefault);
    private static void ThrowNoElements();
    private static void ThrowNoMatches();
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> OrderByDescending(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenBy(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<TSource> ThenByDescending(IOrderedEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Reverse(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DefaultIfEmpty(IEnumerable`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<TSource> source, Action`1<TSource> action);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TSource>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<TKey, TElement>> GroupBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    public static IEnumerable`1<int> Range(int start, int count);
    public static IEnumerable`1<TResult> Repeat(TResult element, int count);
    public static IEnumerable`1<TResult> Empty();
    [ExtensionAttribute]
public static double Average(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Average(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static double Average(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static decimal Average(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static int Sum(IEnumerable`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static long Sum(IEnumerable`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static float Sum(IEnumerable`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static double Sum(IEnumerable`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static decimal Sum(IEnumerable`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(IEnumerable`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Min(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static Nullable`1<TSource> Min(IEnumerable`1<Nullable`1<TSource>> source);
    [ExtensionAttribute]
public static TResult Min(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static TSource Max(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static Nullable`1<TSource> Max(IEnumerable`1<Nullable`1<TSource>> source);
    [ExtensionAttribute]
public static TResult Max(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static TSource Aggregate(IEnumerable`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(IEnumerable`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Concat(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Union(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Intersect(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Join(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> GroupJoin(IEnumerable`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static List`1<TSource> ToList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static TSource[] ToArray(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> OfType(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Cast(IEnumerable source);
    [CompilerGeneratedAttribute]
private static bool <Single>b__3c(TSource x);
    [CompilerGeneratedAttribute]
private static bool <SingleOrDefault>b__3d(TSource x);
    [CompilerGeneratedAttribute]
private static bool <First>b__3e(TSource x);
    [CompilerGeneratedAttribute]
private static bool <FirstOrDefault>b__3f(TSource x);
    [CompilerGeneratedAttribute]
private static bool <Last>b__40(TSource x);
    [CompilerGeneratedAttribute]
private static bool <LastOrDefault>b__41(TSource x);
    [CompilerGeneratedAttribute]
private static TSource <GroupBy>b__4e(TSource x);
    [CompilerGeneratedAttribute]
private static TSource <GroupBy>b__4f(TSource x);
    [CompilerGeneratedAttribute]
private static TSource <Min>b__5b(TSource accum, TSource element);
    [CompilerGeneratedAttribute]
private static Nullable`1<TSource> <Min>b__5c(Nullable`1<TSource> accum, Nullable`1<TSource> element);
    [CompilerGeneratedAttribute]
private static TSource <Max>b__5d(TSource accum, TSource element);
    [CompilerGeneratedAttribute]
private static Nullable`1<TSource> <Max>b__5e(Nullable`1<TSource> accum, Nullable`1<TSource> element);
    [CompilerGeneratedAttribute]
private static TAccumulate <Aggregate>b__5f(TAccumulate x);
    [CompilerGeneratedAttribute]
private static bool <Any>b__a0(TSource x);
    [CompilerGeneratedAttribute]
private static TSource <ToDictionary>b__a9(TSource x);
    [CompilerGeneratedAttribute]
private static TSource <ToDictionary>b__aa(TSource x);
    [CompilerGeneratedAttribute]
private static TSource <ToLookup>b__ab(TSource x);
    [CompilerGeneratedAttribute]
private static TSource <ToLookup>b__ac(TSource x);
}
internal class System.Linq.Grouping`2 : ReadOnlyCollection`1<TElement> {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    internal IList`1<TElement> InnerList { get; }
    public TKey Key { get; private set; }
    public Grouping`2(TKey key);
    internal IList`1<TElement> get_InnerList();
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(TKey value);
}
internal interface System.Linq.IGrouping`2 {
    public TKey Key { get; }
    public abstract virtual TKey get_Key();
}
[DefaultMemberAttribute("Item")]
internal interface System.Linq.ILookup`2 {
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(TKey key);
    public abstract virtual IEnumerable`1<TElement> get_Item(TKey key);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Lookup`2 : object {
    private Dictionary`2<TKey, Grouping`2<TKey, TElement>> _groupings;
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    private Lookup`2(IEqualityComparer`1<TKey> comparer);
    internal static Lookup`2<TKey, TElement> Create(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.OrderByEnumerable`2 : object {
    public IEnumerable`1<TElement> Source;
    public Func`2<TElement, TKey> KeySelector;
    public IComparer`1<TKey> Comparer;
    public bool Descending;
    public OrderByEnumerable`2(IEnumerable`1<TElement> source, Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    public sealed virtual IOrderedEnumerable`1<TElement> CreateOrderedEnumerable(Func`2<TElement, TNewKey> keySelector, IComparer`1<TNewKey> comparer, bool descending);
    internal virtual int CompareElements(TElement e1, TElement e2);
    internal virtual IEnumerable`1<TElement> GetElementsToSort();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.ThenByEnumerable`3 : OrderByEnumerable`2<TElement, TKey> {
    public OrderByEnumerable`2<TElement, TLastKey> OrderedSource { get; }
    public ThenByEnumerable`3(OrderByEnumerable`2<TElement, TLastKey> source, Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, bool descending);
    public OrderByEnumerable`2<TElement, TLastKey> get_OrderedSource();
    internal virtual int CompareElements(TElement e1, TElement e2);
    internal virtual IEnumerable`1<TElement> GetElementsToSort();
}
[AttributeUsageAttribute("69")]
internal class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
