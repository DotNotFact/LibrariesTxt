public static class DecompilerVersionInfo : object {
    public static string Major;
    public static string Minor;
    public static string Build;
    public static string Revision;
    public static string VersionName;
    public static string FullVersion;
    public static string FullVersionWithShortCommitHash;
}
internal static class Humanizer.Inflections.Vocabularies : object {
    private static Lazy`1<Vocabulary> Instance;
    public static Vocabulary Default { get; }
    private static Vocabularies();
    public static Vocabulary get_Default();
    private static Vocabulary BuildDefault();
}
internal class Humanizer.Inflections.Vocabulary : object {
    private List`1<Rule> _plurals;
    private List`1<Rule> _singulars;
    private List`1<string> _uncountables;
    public void AddIrregular(string singular, string plural, bool matchEnding);
    public void AddUncountable(string word);
    public void AddPlural(string rule, string replacement);
    public void AddSingular(string rule, string replacement);
    public string Pluralize(string word, bool inputIsKnownToBeSingular);
    public string Singularize(string word, bool inputIsKnownToBePlural, bool skipSimpleWords);
    private string ApplyRules(IList`1<Rule> rules, string word, bool skipFirstRule);
    private bool IsUncountable(string word);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.CSharp.AnnotationExtensions : object {
    [ExtensionAttribute]
internal static ExpressionWithILInstruction WithILInstruction(Expression expression, ILInstruction instruction);
    [ExtensionAttribute]
internal static ExpressionWithILInstruction WithILInstruction(Expression expression, IEnumerable`1<ILInstruction> instructions);
    [ExtensionAttribute]
internal static ExpressionWithILInstruction WithoutILInstruction(Expression expression);
    [ExtensionAttribute]
internal static TranslatedStatement WithILInstruction(Statement statement, ILInstruction instruction);
    [ExtensionAttribute]
internal static TranslatedStatement WithILInstruction(Statement statement, IEnumerable`1<ILInstruction> instructions);
    [ExtensionAttribute]
internal static TranslatedStatement WithoutILInstruction(Statement statement);
    [ExtensionAttribute]
internal static TranslatedExpression WithILInstruction(ExpressionWithResolveResult expression, ILInstruction instruction);
    [ExtensionAttribute]
internal static TranslatedExpression WithILInstruction(ExpressionWithResolveResult expression, IEnumerable`1<ILInstruction> instructions);
    [ExtensionAttribute]
internal static TranslatedExpression WithILInstruction(TranslatedExpression expression, ILInstruction instruction);
    [ExtensionAttribute]
internal static TranslatedExpression WithoutILInstruction(ExpressionWithResolveResult expression);
    [ExtensionAttribute]
internal static ExpressionWithResolveResult WithRR(Expression expression, ResolveResult resolveResult);
    [ExtensionAttribute]
internal static TranslatedExpression WithRR(ExpressionWithILInstruction expression, ResolveResult resolveResult);
    [ExtensionAttribute]
public static ISymbol GetSymbol(AstNode node);
    [ExtensionAttribute]
public static ResolveResult GetResolveResult(AstNode node);
    [ExtensionAttribute]
public static ILVariable GetILVariable(IdentifierExpression expr);
    [ExtensionAttribute]
public static ILVariable GetILVariable(VariableInitializer vi);
    [ExtensionAttribute]
public static ILVariable GetILVariable(ForeachStatement loop);
    [ExtensionAttribute]
public static VariableInitializer WithILVariable(VariableInitializer vi, ILVariable v);
    [ExtensionAttribute]
public static ForeachStatement WithILVariable(ForeachStatement loop, ILVariable v);
    [ExtensionAttribute]
public static T CopyAnnotationsFrom(T node, AstNode other);
    [ExtensionAttribute]
public static T CopyInstructionsFrom(T node, AstNode other);
}
internal class ICSharpCode.Decompiler.CSharp.CallBuilder : ValueType {
    private DecompilerSettings settings;
    private ExpressionBuilder expressionBuilder;
    private CSharpResolver resolver;
    private IDecompilerTypeSystem typeSystem;
    public CallBuilder(ExpressionBuilder expressionBuilder, IDecompilerTypeSystem typeSystem, DecompilerSettings settings);
    public TranslatedExpression Build(CallInstruction inst);
    public ExpressionWithResolveResult Build(OpCode callOpCode, IMethod method, IReadOnlyList`1<ILInstruction> callArguments, IReadOnlyList`1<int> argumentToParameterMap, IType constrainedTo);
    public ExpressionWithResolveResult BuildCollectionInitializerExpression(OpCode callOpCode, IMethod method, InitializedObjectResolveResult target, IReadOnlyList`1<ILInstruction> callArguments);
    public ExpressionWithResolveResult BuildDictionaryInitializerExpression(OpCode callOpCode, IMethod method, InitializedObjectResolveResult target, IReadOnlyList`1<ILInstruction> indices, ILInstruction value);
    private static bool IsInterpolatedStringCreation(IMethod method, ArgumentList argumentList);
    private bool TryGetStringInterpolationTokens(ArgumentList argumentList, String& format, List`1& tokens);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.CallBuilder/<TokenizeFormatString>d__14")]
private IEnumerable`1<ValueTuple`2<TokenKind, string>> TokenizeFormatString(string value);
    private ArgumentList BuildArgumentList(ExpectedTargetDetails expectedTargetDetails, ResolveResult target, IMethod method, int firstParamIndex, IReadOnlyList`1<ILInstruction> callArguments, IReadOnlyList`1<int> argumentToParameterMap);
    private bool IsPrimitiveValueThatShouldBeNamedArgument(TranslatedExpression arg, IMethod method, IParameter p);
    private bool TransformParamsArgument(ExpectedTargetDetails expectedTargetDetails, ResolveResult targetResolveResult, IMethod method, IParameter parameter, TranslatedExpression arg, List`1& expectedParameters, List`1& arguments);
    private bool IsOptionalArgument(IParameter parameter, TranslatedExpression arg);
    private CallTransformation GetRequiredTransformationsForCall(ExpectedTargetDetails expectedTargetDetails, IMethod method, TranslatedExpression& target, ArgumentList& argumentList, CallTransformation allowedTransforms, IParameterizedMember& foundMethod);
    private bool IsPossibleExtensionMethodCallOnNull(IMethod method, IList`1<TranslatedExpression> arguments);
    private static bool CanInferTypeArgumentsFromArguments(IMethod method, ArgumentList argumentList, TypeInference typeInference);
    private void CastArguments(IList`1<TranslatedExpression> arguments, IList`1<IParameter> expectedParameters);
    private static bool IsNullConditional(Expression expr);
    private void ModifyReturnTypeOfLambda(LambdaExpression lambda);
    private void ModifyReturnStatementInsideLambda(IType returnType, AstNode parent);
    private bool IsDelegateEqualityComparison(IMethod method, IList`1<TranslatedExpression> arguments);
    private Expression HandleDelegateEqualityComparison(IMethod method, IList`1<TranslatedExpression> arguments);
    private ExpressionWithResolveResult HandleImplicitConversion(IMethod method, TranslatedExpression argument);
    private OverloadResolutionErrors IsUnambiguousCall(ExpectedTargetDetails expectedTargetDetails, IMethod method, ResolveResult target, IType[] typeArguments, ResolveResult[] arguments, String[] argumentNames, int firstOptionalArgumentIndex, IParameterizedMember& foundMember, Boolean& bestCandidateIsExpandedForm);
    private bool IsUnambiguousAccess(ExpectedTargetDetails expectedTargetDetails, ResolveResult target, IMethod method, IList`1<TranslatedExpression> arguments, String[] argumentNames, IMember& foundMember);
    private ExpressionWithResolveResult HandleAccessorCall(ExpectedTargetDetails expectedTargetDetails, IMethod method, TranslatedExpression target, List`1<TranslatedExpression> arguments, String[] argumentNames);
    private bool IsAppropriateCallTarget(ExpectedTargetDetails expectedTargetDetails, IMember expectedTarget, IMember actualTarget);
    private ExpressionWithResolveResult HandleConstructorCall(ExpectedTargetDetails expectedTargetDetails, ResolveResult target, IMethod method, ArgumentList argumentList);
    private TranslatedExpression HandleDelegateConstruction(CallInstruction inst);
    private bool CanUseDelegateConstruction(IMethod targetMethod, ILInstruction thisArg, IMethod invokeMethod);
    internal TranslatedExpression Build(LdVirtDelegate inst);
    internal ExpressionWithResolveResult BuildMethodReference(IMethod method, bool isVirtual);
    private ExpressionWithResolveResult BuildDelegateReference(IMethod method, IMethod invokeMethod, ExpectedTargetDetails expectedTargetDetails, ILInstruction thisArg);
    private ValueTuple`4<TranslatedExpression, bool, string, ResolveResult> DisambiguateDelegateReference(IMethod method, IMethod invokeMethod, ExpectedTargetDetails expectedTargetDetails, ILInstruction thisArg);
    private TranslatedExpression HandleDelegateConstruction(IType delegateType, IMethod method, ExpectedTargetDetails expectedTargetDetails, ILInstruction thisArg, ILInstruction inst);
    private bool IsUnambiguousMethodReference(ExpectedTargetDetails expectedTargetDetails, IMethod method, ResolveResult target, IReadOnlyList`1<IType> typeArguments, bool isExtensionMethodReference, ResolveResult& result);
    private static MethodGroupResolveResult ToMethodGroup(IMethod method, ILFunction localFunction);
    internal TranslatedExpression CallWithNamedArgs(Block block);
    private bool HandleRangeConstruction(ExpressionWithResolveResult& result, OpCode callOpCode, IMethod method, TranslatedExpression target, ArgumentList argumentList);
    [CompilerGeneratedAttribute]
internal static int <TokenizeFormatString>g__Peek|14_0(int steps, <>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static int <TokenizeFormatString>g__Next|14_1(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static bool <TransformParamsArgument>g__CheckArgument|17_0(Int32& len, IType& t, <>c__DisplayClass17_0& );
}
public class ICSharpCode.Decompiler.CSharp.CSharpDecompiler : object {
    private IDecompilerTypeSystem typeSystem;
    private MetadataModule module;
    private MetadataReader metadata;
    private DecompilerSettings settings;
    private SyntaxTree syntaxTree;
    private List`1<IILTransform> ilTransforms;
    private List`1<IAstTransform> astTransforms;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugInfoProvider <DebugInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentationProvider <DocumentationProvider>k__BackingField;
    private static Regex automaticPropertyBackingFieldRegex;
    private Dictionary`2<TypeDefinitionHandle, PartialTypeInfo> partialTypes;
    public CancellationToken CancellationToken { get; public set; }
    public IDecompilerTypeSystem TypeSystem { get; }
    public IDebugInfoProvider DebugInfoProvider { get; public set; }
    public IDocumentationProvider DocumentationProvider { get; public set; }
    public IList`1<IILTransform> ILTransforms { get; }
    public IList`1<IAstTransform> AstTransforms { get; }
    public CSharpDecompiler(string fileName, DecompilerSettings settings);
    public CSharpDecompiler(string fileName, IAssemblyResolver assemblyResolver, DecompilerSettings settings);
    public CSharpDecompiler(PEFile module, IAssemblyResolver assemblyResolver, DecompilerSettings settings);
    public CSharpDecompiler(DecompilerTypeSystem typeSystem, DecompilerSettings settings);
    private static CSharpDecompiler();
    internal static List`1<IILTransform> EarlyILTransforms(bool aggressivelyDuplicateReturnBlocks);
    public static List`1<IILTransform> GetILTransforms();
    public static List`1<IAstTransform> GetAstTransforms();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    public IDecompilerTypeSystem get_TypeSystem();
    [CompilerGeneratedAttribute]
public IDebugInfoProvider get_DebugInfoProvider();
    [CompilerGeneratedAttribute]
public void set_DebugInfoProvider(IDebugInfoProvider value);
    [CompilerGeneratedAttribute]
public IDocumentationProvider get_DocumentationProvider();
    [CompilerGeneratedAttribute]
public void set_DocumentationProvider(IDocumentationProvider value);
    public IList`1<IILTransform> get_ILTransforms();
    public IList`1<IAstTransform> get_AstTransforms();
    public static bool MemberIsHidden(PEFile module, EntityHandle member, DecompilerSettings settings);
    private static bool IsSwitchOnStringCache(FieldDefinition field, MetadataReader metadata);
    private static bool IsAutomaticPropertyBackingField(FieldDefinition field, MetadataReader metadata, String& propertyName);
    internal static bool IsEventBackingFieldName(string fieldName, string eventName, Int32& suffixLength);
    private static bool IsAnonymousMethodCacheField(FieldDefinition field, MetadataReader metadata);
    private static bool IsClosureType(TypeDefinition type, MetadataReader metadata);
    internal static bool IsTransparentIdentifier(string identifier);
    internal bool RequiresNativeOrdering(ITypeDefinition typeDef);
    internal IEnumerable`1<IMember> GetMembersWithNativeOrdering(ITypeDefinition typeDef);
    private static PEFile LoadPEFile(string fileName, DecompilerSettings settings);
    private static DecompilerTypeSystem CreateTypeSystemFromFile(string fileName, DecompilerSettings settings);
    private static TypeSystemAstBuilder CreateAstBuilder(DecompilerSettings settings);
    private IDocumentationProvider CreateDefaultDocumentationProvider();
    private DecompileRun CreateDecompileRun();
    private void RunTransforms(AstNode rootNode, DecompileRun decompileRun, ITypeResolveContext decompilationContext);
    private string SyntaxTreeToString(SyntaxTree syntaxTree);
    public SyntaxTree DecompileModuleAndAssemblyAttributes();
    public string DecompileModuleAndAssemblyAttributesToString();
    private void DoDecompileModuleAndAssemblyAttributes(DecompileRun decompileRun, ITypeResolveContext decompilationContext, SyntaxTree syntaxTree);
    private void DoDecompileTypes(IEnumerable`1<TypeDefinitionHandle> types, DecompileRun decompileRun, ITypeResolveContext decompilationContext, SyntaxTree syntaxTree);
    public SyntaxTree DecompileWholeModuleAsSingleFile();
    public SyntaxTree DecompileWholeModuleAsSingleFile(bool sortTypes);
    public ILTransformContext CreateILTransformContext(ILFunction function);
    public static CodeMappingInfo GetCodeMappingInfo(PEFile module, EntityHandle member);
    private static void ReadCodeMappingInfo(PEFile module, CodeMappingInfo info, MethodDefinitionHandle parent, MethodDefinitionHandle part, Queue`1<MethodDefinitionHandle> connectedMethods, HashSet`1<TypeDefinitionHandle> processedNestedTypes);
    public string DecompileWholeModuleAsString();
    public SyntaxTree DecompileTypes(IEnumerable`1<TypeDefinitionHandle> types);
    public string DecompileTypesAsString(IEnumerable`1<TypeDefinitionHandle> types);
    public SyntaxTree DecompileType(FullTypeName fullTypeName);
    public string DecompileTypeAsString(FullTypeName fullTypeName);
    public SyntaxTree Decompile(EntityHandle[] definitions);
    public SyntaxTree Decompile(IEnumerable`1<EntityHandle> definitions);
    private ITypeDefinition FindCommonDeclaringTypeDefinition(ITypeDefinition a, ITypeDefinition b);
    public string DecompileAsString(EntityHandle[] definitions);
    public string DecompileAsString(IEnumerable`1<EntityHandle> definitions);
    public void AddPartialTypeDefinition(PartialTypeInfo info);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.CSharpDecompiler/<AddInterfaceImplHelpers>d__70")]
private IEnumerable`1<EntityDeclaration> AddInterfaceImplHelpers(EntityDeclaration memberDecl, IMethod method, TypeSystemAstBuilder astBuilder);
    private Expression ForwardParameter(ParameterDeclaration p);
    private void SetNewModifier(EntityDeclaration member);
    private void FixParameterNames(EntityDeclaration entity);
    private EntityDeclaration DoDecompile(ITypeDefinition typeDef, DecompileRun decompileRun, ITypeResolveContext decompilationContext);
    private EnumValueDisplayMode DetectBestEnumValueDisplayMode(ITypeDefinition typeDef, PEFile module);
    private EntityDeclaration DoDecompile(IMethod method, DecompileRun decompileRun, ITypeResolveContext decompilationContext);
    private bool IsCovariantReturnOverride(IEntity entity);
    internal static bool IsWindowsFormsInitializeComponentMethod(IMethod method);
    private void DecompileBody(IMethod method, EntityDeclaration entityDecl, DecompileRun decompileRun, ITypeResolveContext decompilationContext);
    internal static void AddAnnotationsToDeclaration(IMethod method, EntityDeclaration entityDecl, ILFunction function);
    internal static void CleanUpMethodDeclaration(EntityDeclaration entityDecl, BlockStatement body, ILFunction function, bool decompileBody);
    internal static bool RemoveAttribute(EntityDeclaration entityDecl, KnownAttribute attributeType);
    internal static bool RemoveCompilerFeatureRequiredAttribute(EntityDeclaration entityDecl, string feature);
    internal static bool RemoveObsoleteAttribute(EntityDeclaration entityDecl, string message);
    private bool FindAttribute(EntityDeclaration entityDecl, KnownAttribute attributeType, Attribute& attribute);
    private void AddDefinesForConditionalAttributes(ILFunction function, DecompileRun decompileRun);
    private EntityDeclaration DoDecompile(IField field, DecompileRun decompileRun, ITypeResolveContext decompilationContext);
    internal static bool IsFixedField(IField field, IType& type, Int32& elementCount);
    private EntityDeclaration DoDecompile(IProperty property, DecompileRun decompileRun, ITypeResolveContext decompilationContext);
    private EntityDeclaration DoDecompile(IEvent ev, DecompileRun decompileRun, ITypeResolveContext decompilationContext);
    public Dictionary`2<ILFunction, List`1<SequencePoint>> CreateSequencePoints(SyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
internal static bool <MemberIsHidden>g__IsGetterOnlyProperty|32_0(string propertyName, <>c__DisplayClass32_0& , <>c__DisplayClass32_1& );
    [CompilerGeneratedAttribute]
internal static EntityHandle <GetMembersWithNativeOrdering>g__GetOrderingHandle|41_0(IMember member);
    [CompilerGeneratedAttribute]
private ValueTuple`2<string, string> <DecompileWholeModuleAsSingleFile>b__54_0(TypeDefinitionHandle td);
    [CompilerGeneratedAttribute]
internal static TypeDefinitionHandle <ReadCodeMappingInfo>g__ExtractDeclaringType|57_0(MemberReference memberRef, <>c__DisplayClass57_0& );
    [CompilerGeneratedAttribute]
private Expression <AddInterfaceImplHelpers>b__70_4(ParameterDeclaration p);
    [CompilerGeneratedAttribute]
internal static bool <DoDecompile>g__IsTypeHierarchyKnown|76_0(IType type, <>c__DisplayClass76_0& );
}
internal class ICSharpCode.Decompiler.CSharp.ExpressionBuilder : ILVisitor`2<TranslationContext, TranslatedExpression> {
    internal StatementBuilder statementBuilder;
    private IDecompilerTypeSystem typeSystem;
    internal ITypeResolveContext decompilationContext;
    internal ILFunction currentFunction;
    internal ICompilation compilation;
    internal CSharpResolver resolver;
    internal TypeSystemAstBuilder astBuilder;
    internal TypeInference typeInference;
    internal DecompilerSettings settings;
    private CancellationToken cancellationToken;
    private HashSet`1<ILVariable> loadedVariablesSet;
    public ExpressionBuilder(StatementBuilder statementBuilder, IDecompilerTypeSystem typeSystem, ITypeResolveContext decompilationContext, ILFunction currentFunction, DecompilerSettings settings, CancellationToken cancellationToken);
    public AstType ConvertType(IType type);
    public ExpressionWithResolveResult ConvertConstantValue(ResolveResult rr, bool allowImplicitConversion);
    public ExpressionWithResolveResult ConvertConstantValue(ResolveResult rr, bool allowImplicitConversion, bool displayAsHex);
    public TranslatedExpression Translate(ILInstruction inst, IType typeHint);
    public TranslatedExpression TranslateCondition(ILInstruction condition, bool negate);
    internal ExpressionWithResolveResult ConvertVariable(ILVariable variable);
    internal bool HidesVariableWithName(string name);
    internal static bool HidesVariableWithName(ILFunction currentFunction, string name);
    internal ILFunction ResolveLocalFunction(IMethod method);
    private bool RequiresQualifier(IMember member, TranslatedExpression target);
    private ExpressionWithResolveResult ConvertField(IField field, ILInstruction targetInstruction);
    private TranslatedExpression IsType(IsInst inst);
    protected internal virtual TranslatedExpression VisitIsInst(IsInst inst, TranslationContext context);
    internal static TranslatedExpression UnwrapBoxingConversion(TranslatedExpression arg);
    protected internal virtual TranslatedExpression VisitNewObj(NewObj inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdVirtDelegate(LdVirtDelegate inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitNewArr(NewArr inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLocAlloc(LocAlloc inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLocAllocSpan(LocAllocSpan inst, TranslationContext context);
    private StackAllocExpression TranslateLocAllocSpan(LocAllocSpan inst, IType typeHint, IType& elementType);
    private StackAllocExpression TranslateLocAlloc(LocAlloc inst, IType typeHint, IType& elementType);
    protected internal virtual TranslatedExpression VisitLdcI4(LdcI4 inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdcI8(LdcI8 inst, TranslationContext context);
    private bool ShouldDisplayAsHex(long value, IType type, ILInstruction parent);
    protected internal virtual TranslatedExpression VisitLdcF4(LdcF4 inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdcF8(LdcF8 inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdcDecimal(LdcDecimal inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdStr(LdStr inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdStrUtf8(LdStrUtf8 inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdNull(LdNull inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDefaultValue(DefaultValue inst, TranslationContext context);
    internal ExpressionWithResolveResult GetDefaultValueExpression(IType type);
    protected internal virtual TranslatedExpression VisitSizeOf(SizeOf inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdTypeToken(LdTypeToken inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitBitNot(BitNot inst, TranslationContext context);
    internal ExpressionWithResolveResult LogicNot(TranslatedExpression expr);
    protected internal virtual TranslatedExpression VisitLdLoc(LdLoc inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdLoca(LdLoca inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitStLoc(StLoc inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitComp(Comp inst, TranslationContext context);
    private TranslatedExpression TranslateCeq(Comp inst, Boolean& negateOutput);
    private TranslatedExpression TryUniteEqualityOperandType(TranslatedExpression left, TranslatedExpression right);
    private bool IsSpecialCasedReferenceComparisonWithNull(TranslatedExpression lhs, TranslatedExpression rhs);
    private ExpressionWithResolveResult CreateBuiltinBinaryOperator(TranslatedExpression left, BinaryOperatorType type, TranslatedExpression right, bool checkForOverflow);
    private TranslatedExpression TranslateComp(Comp inst);
    protected internal virtual TranslatedExpression VisitThreeValuedBoolAnd(ThreeValuedBoolAnd inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitThreeValuedBoolOr(ThreeValuedBoolOr inst, TranslationContext context);
    private TranslatedExpression HandleThreeValuedLogic(BinaryInstruction inst, BinaryOperatorType op, ExpressionType eop);
    protected internal virtual TranslatedExpression VisitThrow(Throw inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitUserDefinedLogicOperator(UserDefinedLogicOperator inst, TranslationContext context);
    private ExpressionWithResolveResult Assignment(TranslatedExpression left, TranslatedExpression right);
    protected internal virtual TranslatedExpression VisitBinaryNumericInstruction(BinaryNumericInstruction inst, TranslationContext context);
    private Nullable`1<TranslatedExpression> HandlePointerArithmetic(BinaryNumericInstruction inst, TranslatedExpression left, TranslatedExpression right);
    private Nullable`1<TranslatedExpression> HandleManagedPointerArithmetic(BinaryNumericInstruction inst, TranslatedExpression left, TranslatedExpression right);
    internal TranslatedExpression CallUnsafeIntrinsic(string name, Expression[] arguments, IType returnType, ILInstruction inst, IEnumerable`1<IType> typeArguments);
    private TranslatedExpression EnsureIntegerType(TranslatedExpression expr);
    private Nullable`1<TranslatedExpression> GetPointerArithmeticOffset(ILInstruction byteOffsetInst, TranslatedExpression byteOffsetExpr, IType pointerElementType, bool checkForOverflow, bool unwrapZeroExtension);
    private Nullable`1<TranslatedExpression> HandlePointerSubtraction(BinaryNumericInstruction inst);
    private TranslatedExpression HandleBinaryNumeric(BinaryNumericInstruction inst, BinaryOperatorType op, TranslationContext context);
    private IType FindType(StackType stackType, Sign sign);
    private IType FindArithmeticType(StackType stackType, Sign sign);
    private TranslatedExpression PrepareArithmeticArgument(TranslatedExpression arg, StackType argStackType, Sign sign, bool isLifted);
    private static bool IsCompatibleWithSign(IType type, Sign sign);
    private static bool BinaryOperatorMightCheckForOverflow(BinaryOperatorType op);
    private TranslatedExpression HandleShift(BinaryNumericInstruction inst, BinaryOperatorType op, TranslationContext context);
    protected internal virtual TranslatedExpression VisitUserDefinedCompoundAssign(UserDefinedCompoundAssign inst, TranslationContext context);
    internal static Nullable`1<AssignmentOperatorType> GetAssignmentOperatorTypeFromMetadataName(string name, DecompilerSettings settings);
    internal static Nullable`1<UnaryOperatorType> GetUnaryOperatorTypeFromMetadataName(string name, bool isPostfix);
    protected internal virtual TranslatedExpression VisitNumericCompoundAssign(NumericCompoundAssign inst, TranslationContext context);
    private TranslatedExpression HandleCompoundAssignment(NumericCompoundAssign inst, AssignmentOperatorType op);
    private TranslatedExpression HandleCompoundShift(NumericCompoundAssign inst, AssignmentOperatorType op);
    private static bool AssignmentOperatorMightCheckForOverflow(AssignmentOperatorType op);
    protected internal virtual TranslatedExpression VisitConv(Conv inst, TranslationContext context);
    private bool ValueMightBeOversized(ResolveResult rr, StackType stackType);
    protected internal virtual TranslatedExpression VisitCall(Call inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitCallVirt(CallVirt inst, TranslationContext context);
    private TranslatedExpression WrapInRef(TranslatedExpression expr, IType type);
    internal bool IsCurrentOrContainingType(ITypeDefinition type);
    internal bool IsBaseTypeOfCurrentType(ITypeDefinition type);
    internal ExpressionWithResolveResult TranslateFunction(IType delegateType, ILFunction function);
    protected internal virtual TranslatedExpression VisitILFunction(ILFunction function, TranslationContext context);
    private IType InferReturnType(BlockStatement body);
    private IType GetTaskType(IType resultType);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.ExpressionBuilder/<MakeParameters>d__95")]
private IEnumerable`1<ParameterDeclaration> MakeParameters(IReadOnlyList`1<IParameter> parameters, ILFunction function);
    protected internal virtual TranslatedExpression VisitBlockContainer(BlockContainer container, TranslationContext context);
    internal TranslatedExpression TranslateTarget(ILInstruction target, bool nonVirtualInvocation, bool memberStatic, IType memberDeclaringType);
    private TranslatedExpression EnsureTargetNotNullable(TranslatedExpression expr, ILInstruction inst);
    protected internal virtual TranslatedExpression VisitLdObj(LdObj inst, TranslationContext context);
    private ExpressionWithResolveResult LdObj(ILInstruction address, IType loadType);
    protected internal virtual TranslatedExpression VisitStObj(StObj inst, TranslationContext context);
    private TranslatedExpression StObjViaHelperCall(StObj inst);
    protected internal virtual TranslatedExpression VisitLdLen(LdLen inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdFlda(LdFlda inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdsFlda(LdsFlda inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdElema(LdElema inst, TranslationContext context);
    private TranslatedExpression TranslateArrayIndex(ILInstruction i);
    private TranslatedExpression ConvertArrayIndex(TranslatedExpression input, StackType stackType, bool allowIntPtr);
    internal static bool IsUnboxAnyWithIsInst(UnboxAny unboxAny, IsInst isInst);
    protected internal virtual TranslatedExpression VisitUnboxAny(UnboxAny inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitUnbox(Unbox inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitBox(Box inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitCastClass(CastClass inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitExpressionTreeCast(ExpressionTreeCast inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitArglist(Arglist inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitMakeRefAny(MakeRefAny inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitRefAnyType(RefAnyType inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitRefAnyValue(RefAnyValue inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitBlock(Block block, TranslationContext context);
    private TranslatedExpression TranslateInterpolatedString(Block block);
    private TranslatedExpression TranslateCallWithNamedArgs(Block block);
    private TranslatedExpression TranslateSetterCallAssignment(Block block);
    private TranslatedExpression TranslateObjectAndCollectionInitializer(Block block);
    private ArrayInitializerExpression BuildArrayInitializerExpression(Block block, InitializedObjectResolveResult initObjRR);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.ExpressionBuilder/<GetIndices>d__125")]
private IEnumerable`1<ILInstruction> GetIndices(IEnumerable`1<ILInstruction> indices, Dictionary`2<ILVariable, ILInstruction> indexVariables);
    private TranslatedExpression MakeInitializerAssignment(InitializedObjectResolveResult rr, AccessPathElement memberPath, AccessPathElement valuePath, List`1<TranslatedExpression> values, Dictionary`2<ILVariable, ILInstruction> indexVariables);
    private TranslatedExpression TranslateArrayInitializer(Block block);
    private TranslatedExpression TranslateStackAllocInitializer(Block block, IType typeHint);
    private TranslatedExpression TranslateWithInitializer(Block block);
    private TranslatedExpression AdjustConstantExpressionToType(TranslatedExpression expr, IType typeHint);
    private ResolveResult AdjustConstantToType(ResolveResult rr, IType typeHint);
    protected internal virtual TranslatedExpression VisitNullCoalescingInstruction(NullCoalescingInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitIfInstruction(IfInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitSwitchInstruction(SwitchInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitAddressOf(AddressOf inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitAwait(Await inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitNullableRewrap(NullableRewrap inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitNullableUnwrap(NullableUnwrap inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicConvertInstruction(DynamicConvertInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicGetIndexInstruction(DynamicGetIndexInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicGetMemberInstruction(DynamicGetMemberInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicInvokeConstructorInstruction(DynamicInvokeConstructorInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicInvokeMemberInstruction(DynamicInvokeMemberInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicInvokeInstruction(DynamicInvokeInstruction inst, TranslationContext context);
    private TranslatedExpression TranslateDynamicTarget(ILInstruction inst, CSharpArgumentInfo argumentInfo);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.ExpressionBuilder/<TranslateDynamicArguments>d__147")]
private IEnumerable`1<TranslatedExpression> TranslateDynamicArguments(IEnumerable`1<ILInstruction> arguments, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    private TranslatedExpression TranslateDynamicArgument(ILInstruction argument, CSharpArgumentInfo info);
    internal static TranslatedExpression ChangeDirectionExpressionTo(TranslatedExpression input, ReferenceKind kind);
    protected internal virtual TranslatedExpression VisitDynamicSetIndexInstruction(DynamicSetIndexInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicSetMemberInstruction(DynamicSetMemberInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicBinaryOperatorInstruction(DynamicBinaryOperatorInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicLogicOperatorInstruction(DynamicLogicOperatorInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicUnaryOperatorInstruction(DynamicUnaryOperatorInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDynamicCompoundAssign(DynamicCompoundAssign inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdFtn(LdFtn inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitLdVirtFtn(LdVirtFtn inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitCallIndirect(CallIndirect inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitDeconstructInstruction(DeconstructInstruction inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitMatchInstruction(MatchInstruction inst, TranslationContext context);
    private ExpressionWithILInstruction TranslatePattern(ILInstruction pattern);
    protected internal virtual TranslatedExpression VisitInvalidBranch(InvalidBranch inst, TranslationContext context);
    protected internal virtual TranslatedExpression VisitInvalidExpression(InvalidExpression inst, TranslationContext context);
    protected virtual TranslatedExpression Default(ILInstruction inst, TranslationContext context);
    private static TranslatedExpression ErrorExpression(string message);
    [CompilerGeneratedAttribute]
private bool <ConvertField>g__IsAmbiguousAccess|21_0(MemberResolveResult& result, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
private TranslatedExpression <VisitNewArr>b__27_0(ILInstruction arg);
    [CompilerGeneratedAttribute]
private bool <VisitStLoc>g__CanUseTypeForStackSlot|50_0(ILVariable v, IType type);
    [CompilerGeneratedAttribute]
internal static bool <VisitStLoc>g__IsOtherValueType|50_1(IType type);
    [CompilerGeneratedAttribute]
private bool <VisitStLoc>g__AllStoresUseConsistentType|50_2(IReadOnlyList`1<IStoreInstruction> storeInstructions, IType expectedType);
    [CompilerGeneratedAttribute]
private TranslatedExpression <HandlePointerArithmetic>g__FallBackToBytePointer|64_0(<>c__DisplayClass64_0& );
    [CompilerGeneratedAttribute]
private ByReferenceType <HandleManagedPointerArithmetic>g__GetReferenceType|65_0(IType type);
    [CompilerGeneratedAttribute]
internal static bool <HandlePointerSubtraction>g__IsMatchingPointerType|69_0(IType type, <>c__DisplayClass69_0& );
    [CompilerGeneratedAttribute]
private TranslatedExpression <HandleCompoundAssignment>g__ConvertValue|81_0(TranslatedExpression value, IType targetType, <>c__DisplayClass81_0& );
    [CompilerGeneratedAttribute]
private IType <VisitConv>g__GetType|84_0(KnownTypeCode typeCode, <>c__DisplayClass84_0& );
    [CompilerGeneratedAttribute]
internal static void <InferReturnType>g__CollectReturnExpressions|93_0(AstNode node, <>c__DisplayClass93_0& );
    [CompilerGeneratedAttribute]
private bool <TranslateTarget>g__ShouldUseBaseReference|97_0(<>c__DisplayClass97_0& );
    [CompilerGeneratedAttribute]
private bool <TranslateTarget>g__MatchLdThis|97_1(ILInstruction inst, <>c__DisplayClass97_0& );
    [CompilerGeneratedAttribute]
private Expression <VisitLdElema>b__106_0(ILInstruction i);
    [CompilerGeneratedAttribute]
private Expression <MakeInitializerAssignment>b__126_2(ILInstruction i);
    [CompilerGeneratedAttribute]
private TranslatedExpression <TranslateArrayInitializer>b__128_0(ILInstruction i);
    [CompilerGeneratedAttribute]
private Expression <TranslateArrayInitializer>b__128_3(ILInstruction i);
    [CompilerGeneratedAttribute]
private ResolveResult <TranslateArrayInitializer>b__128_4(ILInstruction i);
    [CompilerGeneratedAttribute]
private Expression <VisitSwitchInstruction>g__TranslateSectionBody|135_0(SwitchSection section, <>c__DisplayClass135_0& );
    [CompilerGeneratedAttribute]
internal static bool <VisitAddressOf>g__CanIgnoreCopy|136_0(<>c__DisplayClass136_0& );
    [CompilerGeneratedAttribute]
private TranslatedExpression <VisitDynamicBinaryOperatorInstruction>g__CreateBinaryOperator|152_0(BinaryOperatorType operatorType, Nullable`1<bool> isChecked, <>c__DisplayClass152_0& );
    [CompilerGeneratedAttribute]
private TranslatedExpression <VisitDynamicUnaryOperatorInstruction>g__CreateUnaryOperator|154_0(UnaryOperatorType operatorType, Nullable`1<bool> isChecked, <>c__DisplayClass154_0& );
    [CompilerGeneratedAttribute]
private TupleExpression <VisitDeconstructInstruction>g__ConstructTuple|159_0(MatchInstruction matchInstruction, <>c__DisplayClass159_0& );
    [CompilerGeneratedAttribute]
private TranslatedExpression <VisitDeconstructInstruction>g__ConstructAssignmentTarget|159_1(ILInstruction assignment, ILVariable value, <>c__DisplayClass159_0& );
    [CompilerGeneratedAttribute]
private void <VisitDeconstructInstruction>g__ReplaceAssignmentTarget|159_2(ILInstruction target, <>c__DisplayClass159_0& );
}
internal class ICSharpCode.Decompiler.CSharp.ExpressionWithILInstruction : ValueType {
    public Expression Expression;
    public IEnumerable`1<ILInstruction> ILInstructions { get; }
    internal ExpressionWithILInstruction(Expression expression);
    public IEnumerable`1<ILInstruction> get_ILInstructions();
    public static Expression op_Implicit(ExpressionWithILInstruction expression);
}
internal class ICSharpCode.Decompiler.CSharp.ExpressionWithResolveResult : ValueType {
    public Expression Expression;
    public ResolveResult ResolveResult;
    public IType Type { get; }
    internal ExpressionWithResolveResult(Expression expression);
    internal ExpressionWithResolveResult(Expression expression, ResolveResult resolveResult);
    public IType get_Type();
    public static Expression op_Implicit(ExpressionWithResolveResult expression);
}
public class ICSharpCode.Decompiler.CSharp.ForeachAnnotation : object {
    public ILInstruction GetEnumeratorCall;
    public ILInstruction MoveNextCall;
    public ILInstruction GetCurrentCall;
    public ForeachAnnotation(ILInstruction getEnumeratorCall, ILInstruction moveNextCall, ILInstruction getCurrentCall);
}
public class ICSharpCode.Decompiler.CSharp.ILVariableResolveResult : ResolveResult {
    public ILVariable Variable;
    public ILVariableResolveResult(ILVariable v);
    public ILVariableResolveResult(ILVariable v, IType type);
}
public class ICSharpCode.Decompiler.CSharp.ImplicitConversionAnnotation : object {
    public ConversionResolveResult ConversionResolveResult;
    public IType TargetType { get; }
    public ImplicitConversionAnnotation(ConversionResolveResult conversionResolveResult);
    public IType get_TargetType();
}
public class ICSharpCode.Decompiler.CSharp.ImplicitReturnAnnotation : object {
    public Leave Leave;
    public ImplicitReturnAnnotation(Leave leave);
}
public enum ICSharpCode.Decompiler.CSharp.LanguageVersion : Enum {
    public int value__;
    public static LanguageVersion CSharp1;
    public static LanguageVersion CSharp2;
    public static LanguageVersion CSharp3;
    public static LanguageVersion CSharp4;
    public static LanguageVersion CSharp5;
    public static LanguageVersion CSharp6;
    public static LanguageVersion CSharp7;
    public static LanguageVersion CSharp7_1;
    public static LanguageVersion CSharp7_2;
    public static LanguageVersion CSharp7_3;
    public static LanguageVersion CSharp8_0;
    public static LanguageVersion CSharp9_0;
    public static LanguageVersion CSharp10_0;
    public static LanguageVersion CSharp11_0;
    public static LanguageVersion Preview;
    public static LanguageVersion Latest;
}
public class ICSharpCode.Decompiler.CSharp.LdTokenAnnotation : object {
}
public enum ICSharpCode.Decompiler.CSharp.OutputVisitor.BraceStyle : Enum {
    public int value__;
    public static BraceStyle EndOfLine;
    public static BraceStyle EndOfLineWithoutSpace;
    public static BraceStyle NextLine;
    public static BraceStyle NextLineShifted;
    public static BraceStyle NextLineShifted2;
    public static BraceStyle BannerStyle;
}
public class ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpAmbience : object {
    [CompilerGeneratedAttribute]
private ConversionFlags <ConversionFlags>k__BackingField;
    public ConversionFlags ConversionFlags { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ConversionFlags get_ConversionFlags();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ConversionFlags(ConversionFlags value);
    public sealed virtual string ConvertSymbol(ISymbol symbol);
    public void ConvertSymbol(ISymbol symbol, TokenWriter writer, CSharpFormattingOptions formattingPolicy);
    private static bool HasParameters(ISymbol e);
    private TypeSystemAstBuilder CreateAstBuilder();
    private void WriteTypeDeclarationName(ITypeDefinition typeDef, TokenWriter writer, CSharpFormattingOptions formattingPolicy);
    private void WriteMemberDeclarationName(IMember member, TokenWriter writer, CSharpFormattingOptions formattingPolicy);
    private void WriteTypeParameters(EntityDeclaration node, TokenWriter writer, CSharpFormattingOptions formattingPolicy);
    private void PrintModifiers(Modifiers modifiers, TokenWriter writer);
    private void WriteQualifiedName(string name, TokenWriter writer, CSharpFormattingOptions formattingPolicy);
    public string ConvertVariable(IVariable v);
    public sealed virtual string ConvertType(IType type);
    public void ConvertType(IType type, TokenWriter writer, CSharpFormattingOptions formattingPolicy);
    public sealed virtual string ConvertConstantValue(object constantValue);
    public sealed virtual string WrapComment(string comment);
    [CompilerGeneratedAttribute]
internal static TypeParameterDeclaration <WriteTypeParameters>g__RemoveVarianceModifier|10_0(TypeParameterDeclaration decl);
}
[TypeConverterAttribute("System.ComponentModel.ExpandableObjectConverter")]
public class ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpFormattingOptions : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuiltIn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndentationString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentNamespaceBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentClassBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentInterfaceBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentStructBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentEnumBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentMethodBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentPropertyBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentEventBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentSwitchBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentCaseBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentBreakStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignEmbeddedStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignElseInIfStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyFormatting <AutoPropertyFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyFormatting <SimplePropertyFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private EmptyLineFormatting <EmptyLineFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentPreprocessorDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignToMemberReferenceDot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentBlocksInsideExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <NamespaceBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <ClassBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <InterfaceBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <StructBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <EnumBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <MethodBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <AnonymousMethodBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <ConstructorBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <DestructorBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <PropertyBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <PropertyGetBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <PropertySetBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyFormatting <SimpleGetBlockFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyFormatting <SimpleSetBlockFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <EventBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <EventAddBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <EventRemoveBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowEventAddBlockInline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowEventRemoveBlockInline>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <StatementBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIfBlockInline>k__BackingField;
    private bool allowOneLinedArrayInitialziers;
    [CompilerGeneratedAttribute]
private NewLinePlacement <ElseNewLinePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <ElseIfNewLinePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <CatchNewLinePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <FinallyNewLinePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <WhileNewLinePlacement>k__BackingField;
    private NewLinePlacement embeddedStatementPlacement;
    [CompilerGeneratedAttribute]
private bool <SpaceBetweenParameterAttributeSections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBetweenEmptyMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeMethodDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterMethodDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceWithinMethodDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBetweenEmptyMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeMethodCallParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterMethodCallParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceWithinMethodCallParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeFieldDeclarationComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterFieldDeclarationComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeLocalVariableDeclarationComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterLocalVariableDeclarationComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeConstructorDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBetweenEmptyConstructorDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeConstructorDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterConstructorDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceWithinConstructorDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLineBeforeConstructorInitializerColon>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLineAfterConstructorInitializerColon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeIndexerDeclarationBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceWithinIndexerDeclarationBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeIndexerDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterIndexerDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeDelegateDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBetweenEmptyDelegateDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeDelegateDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterDelegateDeclarationParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceWithinDelegateDeclarationParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeNewParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeIfParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeWhileParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeForParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeForeachParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeCatchParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeSwitchParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeLockParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeUsingParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundLogicalOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundEqualityOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundRelationalOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundBitwiseOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundAdditiveOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundMultiplicativeOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundShiftOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundNullCoalescingOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterUnsafeAddressOfOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterUnsafeAsteriskOfOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAroundUnsafeArrowOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinIfParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinWhileParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinForParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinForeachParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinCatchParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinSwitchParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinLockParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinUsingParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinCastParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinSizeOfParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeSizeOfParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinTypeOfParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinNewParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesBetweenEmptyNewParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeNewParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterNewParameterComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeTypeOfParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinCheckedExpressionParantheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeConditionalOperatorCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterConditionalOperatorCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeConditionalOperatorSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterConditionalOperatorSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeAnonymousMethodParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceWithinAnonymousMethodParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesWithinBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpacesBeforeBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeBracketComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterBracketComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeForSemicolon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterForSemicolon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceAfterTypecast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeArrayDeclarationBrackets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceInNamedArgumentAfterDoubleColon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveEndOfLineWhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaceBeforeSemicolon>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesBeforeUsings>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesAfterUsings>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesBeforeFirstDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesBetweenTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesBetweenFields>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesBetweenEventFields>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesBetweenMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesAroundRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumBlankLinesInsideRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepCommentsAtFirstColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private Wrapping <ArrayInitializerWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private BraceStyle <ArrayInitializerBraceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Wrapping <ChainedMethodCallWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private Wrapping <MethodCallArgumentWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLineAferMethodCallOpenParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <MethodCallClosingParenthesesOnNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Wrapping <IndexerArgumentWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLineAferIndexerOpenBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <IndexerClosingBracketOnNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Wrapping <MethodDeclarationParameterWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLineAferMethodDeclarationOpenParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <MethodDeclarationClosingParenthesesOnNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Wrapping <IndexerDeclarationParameterWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLineAferIndexerDeclarationOpenBracket>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <IndexerDeclarationClosingBracketOnNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignToFirstIndexerArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignToFirstIndexerDeclarationParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignToFirstMethodCallArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignToFirstMethodDeclarationParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private NewLinePlacement <NewLineBeforeNewQueryClause>k__BackingField;
    [CompilerGeneratedAttribute]
private UsingPlacement <UsingPlacement>k__BackingField;
    public string Name { get; public set; }
    public bool IsBuiltIn { get; public set; }
    public string IndentationString { get; public set; }
    public bool IndentNamespaceBody { get; public set; }
    public bool IndentClassBody { get; public set; }
    public bool IndentInterfaceBody { get; public set; }
    public bool IndentStructBody { get; public set; }
    public bool IndentEnumBody { get; public set; }
    public bool IndentMethodBody { get; public set; }
    public bool IndentPropertyBody { get; public set; }
    public bool IndentEventBody { get; public set; }
    public bool IndentBlocks { get; public set; }
    public bool IndentSwitchBody { get; public set; }
    public bool IndentCaseBody { get; public set; }
    public bool IndentBreakStatements { get; public set; }
    public bool AlignEmbeddedStatements { get; public set; }
    public bool AlignElseInIfStatements { get; public set; }
    public PropertyFormatting AutoPropertyFormatting { get; public set; }
    public PropertyFormatting SimplePropertyFormatting { get; public set; }
    public EmptyLineFormatting EmptyLineFormatting { get; public set; }
    public bool IndentPreprocessorDirectives { get; public set; }
    public bool AlignToMemberReferenceDot { get; public set; }
    public bool IndentBlocksInsideExpressions { get; public set; }
    public BraceStyle NamespaceBraceStyle { get; public set; }
    public BraceStyle ClassBraceStyle { get; public set; }
    public BraceStyle InterfaceBraceStyle { get; public set; }
    public BraceStyle StructBraceStyle { get; public set; }
    public BraceStyle EnumBraceStyle { get; public set; }
    public BraceStyle MethodBraceStyle { get; public set; }
    public BraceStyle AnonymousMethodBraceStyle { get; public set; }
    public BraceStyle ConstructorBraceStyle { get; public set; }
    public BraceStyle DestructorBraceStyle { get; public set; }
    public BraceStyle PropertyBraceStyle { get; public set; }
    public BraceStyle PropertyGetBraceStyle { get; public set; }
    public BraceStyle PropertySetBraceStyle { get; public set; }
    public PropertyFormatting SimpleGetBlockFormatting { get; public set; }
    public PropertyFormatting SimpleSetBlockFormatting { get; public set; }
    public BraceStyle EventBraceStyle { get; public set; }
    public BraceStyle EventAddBraceStyle { get; public set; }
    public BraceStyle EventRemoveBraceStyle { get; public set; }
    public bool AllowEventAddBlockInline { get; public set; }
    public bool AllowEventRemoveBlockInline { get; public set; }
    public BraceStyle StatementBraceStyle { get; public set; }
    public bool AllowIfBlockInline { get; public set; }
    public bool AllowOneLinedArrayInitialziers { get; public set; }
    public NewLinePlacement ElseNewLinePlacement { get; public set; }
    public NewLinePlacement ElseIfNewLinePlacement { get; public set; }
    public NewLinePlacement CatchNewLinePlacement { get; public set; }
    public NewLinePlacement FinallyNewLinePlacement { get; public set; }
    public NewLinePlacement WhileNewLinePlacement { get; public set; }
    public NewLinePlacement EmbeddedStatementPlacement { get; public set; }
    public bool SpaceBetweenParameterAttributeSections { get; public set; }
    public bool SpaceBeforeMethodDeclarationParentheses { get; public set; }
    public bool SpaceBetweenEmptyMethodDeclarationParentheses { get; public set; }
    public bool SpaceBeforeMethodDeclarationParameterComma { get; public set; }
    public bool SpaceAfterMethodDeclarationParameterComma { get; public set; }
    public bool SpaceWithinMethodDeclarationParentheses { get; public set; }
    public bool SpaceBeforeMethodCallParentheses { get; public set; }
    public bool SpaceBetweenEmptyMethodCallParentheses { get; public set; }
    public bool SpaceBeforeMethodCallParameterComma { get; public set; }
    public bool SpaceAfterMethodCallParameterComma { get; public set; }
    public bool SpaceWithinMethodCallParentheses { get; public set; }
    public bool SpaceBeforeFieldDeclarationComma { get; public set; }
    public bool SpaceAfterFieldDeclarationComma { get; public set; }
    public bool SpaceBeforeLocalVariableDeclarationComma { get; public set; }
    public bool SpaceAfterLocalVariableDeclarationComma { get; public set; }
    public bool SpaceBeforeConstructorDeclarationParentheses { get; public set; }
    public bool SpaceBetweenEmptyConstructorDeclarationParentheses { get; public set; }
    public bool SpaceBeforeConstructorDeclarationParameterComma { get; public set; }
    public bool SpaceAfterConstructorDeclarationParameterComma { get; public set; }
    public bool SpaceWithinConstructorDeclarationParentheses { get; public set; }
    public NewLinePlacement NewLineBeforeConstructorInitializerColon { get; public set; }
    public NewLinePlacement NewLineAfterConstructorInitializerColon { get; public set; }
    public bool SpaceBeforeIndexerDeclarationBracket { get; public set; }
    public bool SpaceWithinIndexerDeclarationBracket { get; public set; }
    public bool SpaceBeforeIndexerDeclarationParameterComma { get; public set; }
    public bool SpaceAfterIndexerDeclarationParameterComma { get; public set; }
    public bool SpaceBeforeDelegateDeclarationParentheses { get; public set; }
    public bool SpaceBetweenEmptyDelegateDeclarationParentheses { get; public set; }
    public bool SpaceBeforeDelegateDeclarationParameterComma { get; public set; }
    public bool SpaceAfterDelegateDeclarationParameterComma { get; public set; }
    public bool SpaceWithinDelegateDeclarationParentheses { get; public set; }
    public bool SpaceBeforeNewParentheses { get; public set; }
    public bool SpaceBeforeIfParentheses { get; public set; }
    public bool SpaceBeforeWhileParentheses { get; public set; }
    public bool SpaceBeforeForParentheses { get; public set; }
    public bool SpaceBeforeForeachParentheses { get; public set; }
    public bool SpaceBeforeCatchParentheses { get; public set; }
    public bool SpaceBeforeSwitchParentheses { get; public set; }
    public bool SpaceBeforeLockParentheses { get; public set; }
    public bool SpaceBeforeUsingParentheses { get; public set; }
    public bool SpaceAroundAssignment { get; public set; }
    public bool SpaceAroundLogicalOperator { get; public set; }
    public bool SpaceAroundEqualityOperator { get; public set; }
    public bool SpaceAroundRelationalOperator { get; public set; }
    public bool SpaceAroundBitwiseOperator { get; public set; }
    public bool SpaceAroundAdditiveOperator { get; public set; }
    public bool SpaceAroundMultiplicativeOperator { get; public set; }
    public bool SpaceAroundShiftOperator { get; public set; }
    public bool SpaceAroundNullCoalescingOperator { get; public set; }
    public bool SpaceAfterUnsafeAddressOfOperator { get; public set; }
    public bool SpaceAfterUnsafeAsteriskOfOperator { get; public set; }
    public bool SpaceAroundUnsafeArrowOperator { get; public set; }
    public bool SpacesWithinParentheses { get; public set; }
    public bool SpacesWithinIfParentheses { get; public set; }
    public bool SpacesWithinWhileParentheses { get; public set; }
    public bool SpacesWithinForParentheses { get; public set; }
    public bool SpacesWithinForeachParentheses { get; public set; }
    public bool SpacesWithinCatchParentheses { get; public set; }
    public bool SpacesWithinSwitchParentheses { get; public set; }
    public bool SpacesWithinLockParentheses { get; public set; }
    public bool SpacesWithinUsingParentheses { get; public set; }
    public bool SpacesWithinCastParentheses { get; public set; }
    public bool SpacesWithinSizeOfParentheses { get; public set; }
    public bool SpaceBeforeSizeOfParentheses { get; public set; }
    public bool SpacesWithinTypeOfParentheses { get; public set; }
    public bool SpacesWithinNewParentheses { get; public set; }
    public bool SpacesBetweenEmptyNewParentheses { get; public set; }
    public bool SpaceBeforeNewParameterComma { get; public set; }
    public bool SpaceAfterNewParameterComma { get; public set; }
    public bool SpaceBeforeTypeOfParentheses { get; public set; }
    public bool SpacesWithinCheckedExpressionParantheses { get; public set; }
    public bool SpaceBeforeConditionalOperatorCondition { get; public set; }
    public bool SpaceAfterConditionalOperatorCondition { get; public set; }
    public bool SpaceBeforeConditionalOperatorSeparator { get; public set; }
    public bool SpaceAfterConditionalOperatorSeparator { get; public set; }
    public bool SpaceBeforeAnonymousMethodParentheses { get; public set; }
    public bool SpaceWithinAnonymousMethodParentheses { get; public set; }
    public bool SpacesWithinBrackets { get; public set; }
    public bool SpacesBeforeBrackets { get; public set; }
    public bool SpaceBeforeBracketComma { get; public set; }
    public bool SpaceAfterBracketComma { get; public set; }
    public bool SpaceBeforeForSemicolon { get; public set; }
    public bool SpaceAfterForSemicolon { get; public set; }
    public bool SpaceAfterTypecast { get; public set; }
    public bool SpaceBeforeArrayDeclarationBrackets { get; public set; }
    public bool SpaceInNamedArgumentAfterDoubleColon { get; public set; }
    public bool RemoveEndOfLineWhiteSpace { get; public set; }
    public bool SpaceBeforeSemicolon { get; public set; }
    public int MinimumBlankLinesBeforeUsings { get; public set; }
    public int MinimumBlankLinesAfterUsings { get; public set; }
    public int MinimumBlankLinesBeforeFirstDeclaration { get; public set; }
    public int MinimumBlankLinesBetweenTypes { get; public set; }
    public int MinimumBlankLinesBetweenFields { get; public set; }
    public int MinimumBlankLinesBetweenEventFields { get; public set; }
    public int MinimumBlankLinesBetweenMembers { get; public set; }
    public int MinimumBlankLinesAroundRegion { get; public set; }
    public int MinimumBlankLinesInsideRegion { get; public set; }
    public bool KeepCommentsAtFirstColumn { get; public set; }
    public Wrapping ArrayInitializerWrapping { get; public set; }
    public BraceStyle ArrayInitializerBraceStyle { get; public set; }
    public Wrapping ChainedMethodCallWrapping { get; public set; }
    public Wrapping MethodCallArgumentWrapping { get; public set; }
    public NewLinePlacement NewLineAferMethodCallOpenParentheses { get; public set; }
    public NewLinePlacement MethodCallClosingParenthesesOnNewLine { get; public set; }
    public Wrapping IndexerArgumentWrapping { get; public set; }
    public NewLinePlacement NewLineAferIndexerOpenBracket { get; public set; }
    public NewLinePlacement IndexerClosingBracketOnNewLine { get; public set; }
    public Wrapping MethodDeclarationParameterWrapping { get; public set; }
    public NewLinePlacement NewLineAferMethodDeclarationOpenParentheses { get; public set; }
    public NewLinePlacement MethodDeclarationClosingParenthesesOnNewLine { get; public set; }
    public Wrapping IndexerDeclarationParameterWrapping { get; public set; }
    public NewLinePlacement NewLineAferIndexerDeclarationOpenBracket { get; public set; }
    public NewLinePlacement IndexerDeclarationClosingBracketOnNewLine { get; public set; }
    public bool AlignToFirstIndexerArgument { get; public set; }
    public bool AlignToFirstIndexerDeclarationParameter { get; public set; }
    public bool AlignToFirstMethodCallArgument { get; public set; }
    public bool AlignToFirstMethodDeclarationParameter { get; public set; }
    public NewLinePlacement NewLineBeforeNewQueryClause { get; public set; }
    public UsingPlacement UsingPlacement { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsBuiltIn();
    [CompilerGeneratedAttribute]
public void set_IsBuiltIn(bool value);
    public CSharpFormattingOptions Clone();
    [CompilerGeneratedAttribute]
public string get_IndentationString();
    [CompilerGeneratedAttribute]
public void set_IndentationString(string value);
    [CompilerGeneratedAttribute]
public bool get_IndentNamespaceBody();
    [CompilerGeneratedAttribute]
public void set_IndentNamespaceBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentClassBody();
    [CompilerGeneratedAttribute]
public void set_IndentClassBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentInterfaceBody();
    [CompilerGeneratedAttribute]
public void set_IndentInterfaceBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentStructBody();
    [CompilerGeneratedAttribute]
public void set_IndentStructBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentEnumBody();
    [CompilerGeneratedAttribute]
public void set_IndentEnumBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentMethodBody();
    [CompilerGeneratedAttribute]
public void set_IndentMethodBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentPropertyBody();
    [CompilerGeneratedAttribute]
public void set_IndentPropertyBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentEventBody();
    [CompilerGeneratedAttribute]
public void set_IndentEventBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentBlocks();
    [CompilerGeneratedAttribute]
public void set_IndentBlocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentSwitchBody();
    [CompilerGeneratedAttribute]
public void set_IndentSwitchBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentCaseBody();
    [CompilerGeneratedAttribute]
public void set_IndentCaseBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentBreakStatements();
    [CompilerGeneratedAttribute]
public void set_IndentBreakStatements(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlignEmbeddedStatements();
    [CompilerGeneratedAttribute]
public void set_AlignEmbeddedStatements(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlignElseInIfStatements();
    [CompilerGeneratedAttribute]
public void set_AlignElseInIfStatements(bool value);
    [CompilerGeneratedAttribute]
public PropertyFormatting get_AutoPropertyFormatting();
    [CompilerGeneratedAttribute]
public void set_AutoPropertyFormatting(PropertyFormatting value);
    [CompilerGeneratedAttribute]
public PropertyFormatting get_SimplePropertyFormatting();
    [CompilerGeneratedAttribute]
public void set_SimplePropertyFormatting(PropertyFormatting value);
    [CompilerGeneratedAttribute]
public EmptyLineFormatting get_EmptyLineFormatting();
    [CompilerGeneratedAttribute]
public void set_EmptyLineFormatting(EmptyLineFormatting value);
    [CompilerGeneratedAttribute]
public bool get_IndentPreprocessorDirectives();
    [CompilerGeneratedAttribute]
public void set_IndentPreprocessorDirectives(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlignToMemberReferenceDot();
    [CompilerGeneratedAttribute]
public void set_AlignToMemberReferenceDot(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentBlocksInsideExpressions();
    [CompilerGeneratedAttribute]
public void set_IndentBlocksInsideExpressions(bool value);
    [CompilerGeneratedAttribute]
public BraceStyle get_NamespaceBraceStyle();
    [CompilerGeneratedAttribute]
public void set_NamespaceBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_ClassBraceStyle();
    [CompilerGeneratedAttribute]
public void set_ClassBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_InterfaceBraceStyle();
    [CompilerGeneratedAttribute]
public void set_InterfaceBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_StructBraceStyle();
    [CompilerGeneratedAttribute]
public void set_StructBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_EnumBraceStyle();
    [CompilerGeneratedAttribute]
public void set_EnumBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_MethodBraceStyle();
    [CompilerGeneratedAttribute]
public void set_MethodBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_AnonymousMethodBraceStyle();
    [CompilerGeneratedAttribute]
public void set_AnonymousMethodBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_ConstructorBraceStyle();
    [CompilerGeneratedAttribute]
public void set_ConstructorBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_DestructorBraceStyle();
    [CompilerGeneratedAttribute]
public void set_DestructorBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_PropertyBraceStyle();
    [CompilerGeneratedAttribute]
public void set_PropertyBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_PropertyGetBraceStyle();
    [CompilerGeneratedAttribute]
public void set_PropertyGetBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_PropertySetBraceStyle();
    [CompilerGeneratedAttribute]
public void set_PropertySetBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public PropertyFormatting get_SimpleGetBlockFormatting();
    [CompilerGeneratedAttribute]
public void set_SimpleGetBlockFormatting(PropertyFormatting value);
    [CompilerGeneratedAttribute]
public PropertyFormatting get_SimpleSetBlockFormatting();
    [CompilerGeneratedAttribute]
public void set_SimpleSetBlockFormatting(PropertyFormatting value);
    [CompilerGeneratedAttribute]
public BraceStyle get_EventBraceStyle();
    [CompilerGeneratedAttribute]
public void set_EventBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_EventAddBraceStyle();
    [CompilerGeneratedAttribute]
public void set_EventAddBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public BraceStyle get_EventRemoveBraceStyle();
    [CompilerGeneratedAttribute]
public void set_EventRemoveBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public bool get_AllowEventAddBlockInline();
    [CompilerGeneratedAttribute]
public void set_AllowEventAddBlockInline(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowEventRemoveBlockInline();
    [CompilerGeneratedAttribute]
public void set_AllowEventRemoveBlockInline(bool value);
    [CompilerGeneratedAttribute]
public BraceStyle get_StatementBraceStyle();
    [CompilerGeneratedAttribute]
public void set_StatementBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public bool get_AllowIfBlockInline();
    [CompilerGeneratedAttribute]
public void set_AllowIfBlockInline(bool value);
    public bool get_AllowOneLinedArrayInitialziers();
    public void set_AllowOneLinedArrayInitialziers(bool value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_ElseNewLinePlacement();
    [CompilerGeneratedAttribute]
public void set_ElseNewLinePlacement(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_ElseIfNewLinePlacement();
    [CompilerGeneratedAttribute]
public void set_ElseIfNewLinePlacement(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_CatchNewLinePlacement();
    [CompilerGeneratedAttribute]
public void set_CatchNewLinePlacement(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_FinallyNewLinePlacement();
    [CompilerGeneratedAttribute]
public void set_FinallyNewLinePlacement(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_WhileNewLinePlacement();
    [CompilerGeneratedAttribute]
public void set_WhileNewLinePlacement(NewLinePlacement value);
    public NewLinePlacement get_EmbeddedStatementPlacement();
    public void set_EmbeddedStatementPlacement(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBetweenParameterAttributeSections();
    [CompilerGeneratedAttribute]
public void set_SpaceBetweenParameterAttributeSections(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeMethodDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBetweenEmptyMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBetweenEmptyMethodDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeMethodDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeMethodDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterMethodDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterMethodDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceWithinMethodDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceWithinMethodDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeMethodCallParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeMethodCallParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBetweenEmptyMethodCallParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBetweenEmptyMethodCallParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeMethodCallParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeMethodCallParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterMethodCallParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterMethodCallParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceWithinMethodCallParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceWithinMethodCallParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeFieldDeclarationComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeFieldDeclarationComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterFieldDeclarationComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterFieldDeclarationComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeLocalVariableDeclarationComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeLocalVariableDeclarationComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterLocalVariableDeclarationComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterLocalVariableDeclarationComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeConstructorDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeConstructorDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBetweenEmptyConstructorDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBetweenEmptyConstructorDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeConstructorDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeConstructorDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterConstructorDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterConstructorDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceWithinConstructorDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceWithinConstructorDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLineBeforeConstructorInitializerColon();
    [CompilerGeneratedAttribute]
public void set_NewLineBeforeConstructorInitializerColon(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLineAfterConstructorInitializerColon();
    [CompilerGeneratedAttribute]
public void set_NewLineAfterConstructorInitializerColon(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeIndexerDeclarationBracket();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeIndexerDeclarationBracket(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceWithinIndexerDeclarationBracket();
    [CompilerGeneratedAttribute]
public void set_SpaceWithinIndexerDeclarationBracket(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeIndexerDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeIndexerDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterIndexerDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterIndexerDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeDelegateDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeDelegateDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBetweenEmptyDelegateDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBetweenEmptyDelegateDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeDelegateDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeDelegateDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterDelegateDeclarationParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterDelegateDeclarationParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceWithinDelegateDeclarationParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceWithinDelegateDeclarationParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeNewParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeNewParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeIfParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeIfParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeWhileParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeWhileParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeForParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeForParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeForeachParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeForeachParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeCatchParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeCatchParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeSwitchParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeSwitchParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeLockParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeLockParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeUsingParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeUsingParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundAssignment();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundAssignment(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundLogicalOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundLogicalOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundEqualityOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundEqualityOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundRelationalOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundRelationalOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundBitwiseOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundBitwiseOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundAdditiveOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundAdditiveOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundMultiplicativeOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundMultiplicativeOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundShiftOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundShiftOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundNullCoalescingOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundNullCoalescingOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterUnsafeAddressOfOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterUnsafeAddressOfOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterUnsafeAsteriskOfOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterUnsafeAsteriskOfOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundUnsafeArrowOperator();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundUnsafeArrowOperator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinIfParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinIfParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinWhileParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinWhileParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinForParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinForParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinForeachParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinForeachParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinCatchParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinCatchParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinSwitchParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinSwitchParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinLockParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinLockParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinUsingParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinUsingParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinCastParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinCastParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinSizeOfParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinSizeOfParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeSizeOfParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeSizeOfParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinTypeOfParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinTypeOfParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinNewParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinNewParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesBetweenEmptyNewParentheses();
    [CompilerGeneratedAttribute]
public void set_SpacesBetweenEmptyNewParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeNewParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeNewParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterNewParameterComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterNewParameterComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeTypeOfParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeTypeOfParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinCheckedExpressionParantheses();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinCheckedExpressionParantheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeConditionalOperatorCondition();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeConditionalOperatorCondition(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterConditionalOperatorCondition();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterConditionalOperatorCondition(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeConditionalOperatorSeparator();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeConditionalOperatorSeparator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterConditionalOperatorSeparator();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterConditionalOperatorSeparator(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeAnonymousMethodParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeAnonymousMethodParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceWithinAnonymousMethodParentheses();
    [CompilerGeneratedAttribute]
public void set_SpaceWithinAnonymousMethodParentheses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesWithinBrackets();
    [CompilerGeneratedAttribute]
public void set_SpacesWithinBrackets(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpacesBeforeBrackets();
    [CompilerGeneratedAttribute]
public void set_SpacesBeforeBrackets(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeBracketComma();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeBracketComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterBracketComma();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterBracketComma(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeForSemicolon();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeForSemicolon(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterForSemicolon();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterForSemicolon(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterTypecast();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterTypecast(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeArrayDeclarationBrackets();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeArrayDeclarationBrackets(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceInNamedArgumentAfterDoubleColon();
    [CompilerGeneratedAttribute]
public void set_SpaceInNamedArgumentAfterDoubleColon(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveEndOfLineWhiteSpace();
    [CompilerGeneratedAttribute]
public void set_RemoveEndOfLineWhiteSpace(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpaceBeforeSemicolon();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeSemicolon(bool value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesBeforeUsings();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesBeforeUsings(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesAfterUsings();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesAfterUsings(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesBeforeFirstDeclaration();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesBeforeFirstDeclaration(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesBetweenTypes();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesBetweenTypes(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesBetweenFields();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesBetweenFields(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesBetweenEventFields();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesBetweenEventFields(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesBetweenMembers();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesBetweenMembers(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesAroundRegion();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesAroundRegion(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumBlankLinesInsideRegion();
    [CompilerGeneratedAttribute]
public void set_MinimumBlankLinesInsideRegion(int value);
    [CompilerGeneratedAttribute]
public bool get_KeepCommentsAtFirstColumn();
    [CompilerGeneratedAttribute]
public void set_KeepCommentsAtFirstColumn(bool value);
    [CompilerGeneratedAttribute]
public Wrapping get_ArrayInitializerWrapping();
    [CompilerGeneratedAttribute]
public void set_ArrayInitializerWrapping(Wrapping value);
    [CompilerGeneratedAttribute]
public BraceStyle get_ArrayInitializerBraceStyle();
    [CompilerGeneratedAttribute]
public void set_ArrayInitializerBraceStyle(BraceStyle value);
    [CompilerGeneratedAttribute]
public Wrapping get_ChainedMethodCallWrapping();
    [CompilerGeneratedAttribute]
public void set_ChainedMethodCallWrapping(Wrapping value);
    [CompilerGeneratedAttribute]
public Wrapping get_MethodCallArgumentWrapping();
    [CompilerGeneratedAttribute]
public void set_MethodCallArgumentWrapping(Wrapping value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLineAferMethodCallOpenParentheses();
    [CompilerGeneratedAttribute]
public void set_NewLineAferMethodCallOpenParentheses(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_MethodCallClosingParenthesesOnNewLine();
    [CompilerGeneratedAttribute]
public void set_MethodCallClosingParenthesesOnNewLine(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public Wrapping get_IndexerArgumentWrapping();
    [CompilerGeneratedAttribute]
public void set_IndexerArgumentWrapping(Wrapping value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLineAferIndexerOpenBracket();
    [CompilerGeneratedAttribute]
public void set_NewLineAferIndexerOpenBracket(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_IndexerClosingBracketOnNewLine();
    [CompilerGeneratedAttribute]
public void set_IndexerClosingBracketOnNewLine(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public Wrapping get_MethodDeclarationParameterWrapping();
    [CompilerGeneratedAttribute]
public void set_MethodDeclarationParameterWrapping(Wrapping value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLineAferMethodDeclarationOpenParentheses();
    [CompilerGeneratedAttribute]
public void set_NewLineAferMethodDeclarationOpenParentheses(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_MethodDeclarationClosingParenthesesOnNewLine();
    [CompilerGeneratedAttribute]
public void set_MethodDeclarationClosingParenthesesOnNewLine(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public Wrapping get_IndexerDeclarationParameterWrapping();
    [CompilerGeneratedAttribute]
public void set_IndexerDeclarationParameterWrapping(Wrapping value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLineAferIndexerDeclarationOpenBracket();
    [CompilerGeneratedAttribute]
public void set_NewLineAferIndexerDeclarationOpenBracket(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_IndexerDeclarationClosingBracketOnNewLine();
    [CompilerGeneratedAttribute]
public void set_IndexerDeclarationClosingBracketOnNewLine(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public bool get_AlignToFirstIndexerArgument();
    [CompilerGeneratedAttribute]
public void set_AlignToFirstIndexerArgument(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlignToFirstIndexerDeclarationParameter();
    [CompilerGeneratedAttribute]
public void set_AlignToFirstIndexerDeclarationParameter(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlignToFirstMethodCallArgument();
    [CompilerGeneratedAttribute]
public void set_AlignToFirstMethodCallArgument(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlignToFirstMethodDeclarationParameter();
    [CompilerGeneratedAttribute]
public void set_AlignToFirstMethodDeclarationParameter(bool value);
    [CompilerGeneratedAttribute]
public NewLinePlacement get_NewLineBeforeNewQueryClause();
    [CompilerGeneratedAttribute]
public void set_NewLineBeforeNewQueryClause(NewLinePlacement value);
    [CompilerGeneratedAttribute]
public UsingPlacement get_UsingPlacement();
    [CompilerGeneratedAttribute]
public void set_UsingPlacement(UsingPlacement value);
}
public class ICSharpCode.Decompiler.CSharp.OutputVisitor.CSharpOutputVisitor : object {
    protected TokenWriter writer;
    protected CSharpFormattingOptions policy;
    protected Stack`1<AstNode> containerStack;
    protected bool isAtStartOfLine;
    protected bool isAfterSpace;
    private static HashSet`1<string> unconditionalKeywords;
    private static HashSet`1<string> queryKeywords;
    private static int maxKeywordLength;
    public CSharpOutputVisitor(TextWriter textWriter, CSharpFormattingOptions formattingPolicy);
    public CSharpOutputVisitor(TokenWriter writer, CSharpFormattingOptions formattingPolicy);
    private static CSharpOutputVisitor();
    protected virtual void StartNode(AstNode node);
    protected virtual void EndNode(AstNode node);
    protected virtual void Comma(AstNode nextNode, bool noSpaceAfterComma);
    protected virtual void OptionalComma(AstNode pos);
    protected virtual void OptionalSemicolon(AstNode pos);
    protected virtual void WriteCommaSeparatedList(IEnumerable`1<AstNode> list);
    protected virtual void WriteCommaSeparatedListInParenthesis(IEnumerable`1<AstNode> list, bool spaceWithin);
    protected virtual void WriteCommaSeparatedListInBrackets(IEnumerable`1<ParameterDeclaration> list, bool spaceWithin);
    protected virtual void WriteCommaSeparatedListInBrackets(IEnumerable`1<Expression> list);
    protected virtual void WriteKeyword(TokenRole tokenRole);
    protected virtual void WriteKeyword(string token, Role tokenRole);
    protected virtual void WriteIdentifier(Identifier identifier);
    protected virtual void WriteIdentifier(string identifier);
    protected virtual void WriteToken(TokenRole tokenRole);
    protected virtual void WriteToken(string token, Role tokenRole);
    protected virtual void LPar();
    protected virtual void RPar();
    protected virtual void Semicolon();
    protected virtual void Space(bool addSpace);
    protected virtual void NewLine();
    private int GetCallChainLengthLimited(MemberReferenceExpression expr);
    private int ShouldInsertNewLineWhenInMethodCallChain(MemberReferenceExpression expr);
    protected virtual bool InsertNewLineWhenInMethodCallChain(MemberReferenceExpression expr);
    protected virtual void OpenBrace(BraceStyle style, bool newLine);
    protected virtual void CloseBrace(BraceStyle style, bool unindent);
    public static bool IsKeyword(string identifier, AstNode context);
    protected virtual void WriteTypeArguments(IEnumerable`1<AstType> typeArguments);
    public virtual void WriteTypeParameters(IEnumerable`1<TypeParameterDeclaration> typeParameters);
    protected virtual void WriteModifiers(IEnumerable`1<CSharpModifierToken> modifierTokens);
    protected virtual void WriteQualifiedIdentifier(IEnumerable`1<Identifier> identifiers);
    protected virtual void WriteEmbeddedStatement(Statement embeddedStatement, NewLinePlacement nlp);
    protected virtual void WriteMethodBody(BlockStatement body, BraceStyle style, bool newLine);
    protected virtual void WriteAttributes(IEnumerable`1<AttributeSection> attributes);
    protected virtual void WritePrivateImplementationType(AstType privateImplementationType);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression);
    public virtual void VisitUndocumentedExpression(UndocumentedExpression undocumentedExpression);
    public virtual void VisitArrayCreateExpression(ArrayCreateExpression arrayCreateExpression);
    public virtual void VisitArrayInitializerExpression(ArrayInitializerExpression arrayInitializerExpression);
    protected bool CanBeConfusedWithObjectInitializer(Expression expr);
    protected bool IsObjectOrCollectionInitializer(AstNode node);
    protected virtual void PrintInitializerElements(AstNodeCollection`1<Expression> elements);
    public virtual void VisitAsExpression(AsExpression asExpression);
    public virtual void VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    public virtual void VisitBaseReferenceExpression(BaseReferenceExpression baseReferenceExpression);
    public virtual void VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression);
    public virtual void VisitCastExpression(CastExpression castExpression);
    public virtual void VisitCheckedExpression(CheckedExpression checkedExpression);
    public virtual void VisitConditionalExpression(ConditionalExpression conditionalExpression);
    public virtual void VisitDefaultValueExpression(DefaultValueExpression defaultValueExpression);
    public virtual void VisitDirectionExpression(DirectionExpression directionExpression);
    public virtual void VisitDeclarationExpression(DeclarationExpression declarationExpression);
    public virtual void VisitOutVarDeclarationExpression(OutVarDeclarationExpression outVarDeclarationExpression);
    public virtual void VisitIdentifierExpression(IdentifierExpression identifierExpression);
    public virtual void VisitIndexerExpression(IndexerExpression indexerExpression);
    public virtual void VisitInvocationExpression(InvocationExpression invocationExpression);
    public virtual void VisitIsExpression(IsExpression isExpression);
    public virtual void VisitLambdaExpression(LambdaExpression lambdaExpression);
    protected bool LambdaNeedsParenthesis(LambdaExpression lambdaExpression);
    public virtual void VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public virtual void VisitNamedArgumentExpression(NamedArgumentExpression namedArgumentExpression);
    public virtual void VisitNamedExpression(NamedExpression namedExpression);
    public virtual void VisitNullReferenceExpression(NullReferenceExpression nullReferenceExpression);
    public virtual void VisitObjectCreateExpression(ObjectCreateExpression objectCreateExpression);
    public virtual void VisitAnonymousTypeCreateExpression(AnonymousTypeCreateExpression anonymousTypeCreateExpression);
    public virtual void VisitParenthesizedExpression(ParenthesizedExpression parenthesizedExpression);
    public virtual void VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression);
    public virtual void VisitPrimitiveExpression(PrimitiveExpression primitiveExpression);
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpression interpolatedStringExpression);
    public virtual void VisitInterpolation(Interpolation interpolation);
    public virtual void VisitInterpolatedStringText(InterpolatedStringText interpolatedStringText);
    public virtual void VisitSizeOfExpression(SizeOfExpression sizeOfExpression);
    public virtual void VisitStackAllocExpression(StackAllocExpression stackAllocExpression);
    public virtual void VisitThisReferenceExpression(ThisReferenceExpression thisReferenceExpression);
    public virtual void VisitThrowExpression(ThrowExpression throwExpression);
    public virtual void VisitTupleExpression(TupleExpression tupleExpression);
    public virtual void VisitTypeOfExpression(TypeOfExpression typeOfExpression);
    public virtual void VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression);
    public virtual void VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression);
    private static bool IsPostfixOperator(UnaryOperatorType op);
    public virtual void VisitUncheckedExpression(UncheckedExpression uncheckedExpression);
    public virtual void VisitWithInitializerExpression(WithInitializerExpression withInitializerExpression);
    public virtual void VisitQueryExpression(QueryExpression queryExpression);
    public virtual void VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause);
    public virtual void VisitQueryFromClause(QueryFromClause queryFromClause);
    public virtual void VisitQueryLetClause(QueryLetClause queryLetClause);
    public virtual void VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    public virtual void VisitQueryJoinClause(QueryJoinClause queryJoinClause);
    public virtual void VisitQueryOrderClause(QueryOrderClause queryOrderClause);
    public virtual void VisitQueryOrdering(QueryOrdering queryOrdering);
    public virtual void VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public virtual void VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public virtual void VisitAttribute(Attribute attribute);
    public virtual void VisitAttributeSection(AttributeSection attributeSection);
    public virtual void VisitDelegateDeclaration(DelegateDeclaration delegateDeclaration);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public virtual void VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public virtual void VisitUsingAliasDeclaration(UsingAliasDeclaration usingAliasDeclaration);
    public virtual void VisitUsingDeclaration(UsingDeclaration usingDeclaration);
    public virtual void VisitExternAliasDeclaration(ExternAliasDeclaration externAliasDeclaration);
    public virtual void VisitBlockStatement(BlockStatement blockStatement);
    protected virtual void WriteBlock(BlockStatement blockStatement, BraceStyle style);
    public virtual void VisitBreakStatement(BreakStatement breakStatement);
    public virtual void VisitCheckedStatement(CheckedStatement checkedStatement);
    public virtual void VisitContinueStatement(ContinueStatement continueStatement);
    public virtual void VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public virtual void VisitEmptyStatement(EmptyStatement emptyStatement);
    public virtual void VisitExpressionStatement(ExpressionStatement expressionStatement);
    public virtual void VisitFixedStatement(FixedStatement fixedStatement);
    public virtual void VisitForeachStatement(ForeachStatement foreachStatement);
    public virtual void VisitForStatement(ForStatement forStatement);
    public virtual void VisitGotoCaseStatement(GotoCaseStatement gotoCaseStatement);
    public virtual void VisitGotoDefaultStatement(GotoDefaultStatement gotoDefaultStatement);
    public virtual void VisitGotoStatement(GotoStatement gotoStatement);
    public virtual void VisitIfElseStatement(IfElseStatement ifElseStatement);
    public virtual void VisitLabelStatement(LabelStatement labelStatement);
    public virtual void VisitLockStatement(LockStatement lockStatement);
    public virtual void VisitReturnStatement(ReturnStatement returnStatement);
    public virtual void VisitSwitchStatement(SwitchStatement switchStatement);
    public virtual void VisitSwitchSection(SwitchSection switchSection);
    public virtual void VisitCaseLabel(CaseLabel caseLabel);
    public virtual void VisitSwitchExpression(SwitchExpression switchExpression);
    public virtual void VisitSwitchExpressionSection(SwitchExpressionSection switchExpressionSection);
    public virtual void VisitThrowStatement(ThrowStatement throwStatement);
    public virtual void VisitTryCatchStatement(TryCatchStatement tryCatchStatement);
    public virtual void VisitCatchClause(CatchClause catchClause);
    public virtual void VisitUncheckedStatement(UncheckedStatement uncheckedStatement);
    public virtual void VisitUnsafeStatement(UnsafeStatement unsafeStatement);
    public virtual void VisitUsingStatement(UsingStatement usingStatement);
    public virtual void VisitVariableDeclarationStatement(VariableDeclarationStatement variableDeclarationStatement);
    public virtual void VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatement localFunctionDeclarationStatement);
    public virtual void VisitWhileStatement(WhileStatement whileStatement);
    public virtual void VisitYieldBreakStatement(YieldBreakStatement yieldBreakStatement);
    public virtual void VisitYieldReturnStatement(YieldReturnStatement yieldReturnStatement);
    public virtual void VisitAccessor(Accessor accessor);
    public virtual void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public virtual void VisitConstructorInitializer(ConstructorInitializer constructorInitializer);
    public virtual void VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration);
    public virtual void VisitEventDeclaration(EventDeclaration eventDeclaration);
    public virtual void VisitCustomEventDeclaration(CustomEventDeclaration customEventDeclaration);
    public virtual void VisitFieldDeclaration(FieldDeclaration fieldDeclaration);
    public virtual void VisitFixedFieldDeclaration(FixedFieldDeclaration fixedFieldDeclaration);
    public virtual void VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer);
    public virtual void VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    public virtual void VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public virtual void VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration);
    public virtual void VisitParameterDeclaration(ParameterDeclaration parameterDeclaration);
    public virtual void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public virtual void VisitVariableInitializer(VariableInitializer variableInitializer);
    private void MaybeNewLinesAfterUsings(AstNode node);
    public virtual void VisitSyntaxTree(SyntaxTree syntaxTree);
    public virtual void VisitSimpleType(SimpleType simpleType);
    public virtual void VisitMemberType(MemberType memberType);
    public virtual void VisitTupleType(TupleAstType tupleType);
    public virtual void VisitTupleTypeElement(TupleTypeElement tupleTypeElement);
    public virtual void VisitFunctionPointerType(FunctionPointerAstType functionPointerType);
    public virtual void VisitInvocationType(InvocationAstType invocationType);
    public virtual void VisitComposedType(ComposedType composedType);
    public virtual void VisitArraySpecifier(ArraySpecifier arraySpecifier);
    public virtual void VisitPrimitiveType(PrimitiveType primitiveType);
    public virtual void VisitSingleVariableDesignation(SingleVariableDesignation singleVariableDesignation);
    public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignation parenthesizedVariableDesignation);
    public virtual void VisitComment(Comment comment);
    public virtual void VisitPreProcessorDirective(PreProcessorDirective preProcessorDirective);
    public virtual void VisitTypeParameterDeclaration(TypeParameterDeclaration typeParameterDeclaration);
    public virtual void VisitConstraint(Constraint constraint);
    public virtual void VisitCSharpTokenNode(CSharpTokenNode cSharpTokenNode);
    public virtual void VisitIdentifier(Identifier identifier);
    private sealed virtual override void ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor.VisitNullNode(AstNode nullNode);
    private sealed virtual override void ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor.VisitErrorNode(AstNode errorNode);
    public virtual void VisitPatternPlaceholder(AstNode placeholder, Pattern pattern);
    private void VisitAnyNode(AnyNode anyNode);
    private void VisitBackreference(Backreference backreference);
    private void VisitIdentifierExpressionBackreference(IdentifierExpressionBackreference identifierExpressionBackreference);
    private void VisitChoice(Choice choice);
    private void VisitNamedNode(NamedNode namedNode);
    private void VisitRepeat(Repeat repeat);
    private void VisitOptionalNode(OptionalNode optionalNode);
    private void VisitNodeInPattern(INode childNode);
    public virtual void VisitDocumentationReference(DocumentationReference documentationReference);
    public static string ConvertString(string text);
    [CompilerGeneratedAttribute]
private bool <Semicolon>g__SkipToken|24_0(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
private bool <Semicolon>g__SkipNewLine|24_1(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static bool <PrintInitializerElements>g__IsSimpleExpression|50_1(Expression ex);
    [CompilerGeneratedAttribute]
internal static bool <PrintInitializerElements>g__IsComplexExpression|50_2(Expression ex);
}
public abstract class ICSharpCode.Decompiler.CSharp.OutputVisitor.DecoratingTokenWriter : TokenWriter {
    private TokenWriter decoratedWriter;
    protected DecoratingTokenWriter(TokenWriter decoratedWriter);
    public virtual void StartNode(AstNode node);
    public virtual void EndNode(AstNode node);
    public virtual void WriteIdentifier(Identifier identifier);
    public virtual void WriteKeyword(Role role, string keyword);
    public virtual void WriteToken(Role role, string token);
    public virtual void WritePrimitiveValue(object value, LiteralFormat format);
    public virtual void WritePrimitiveType(string type);
    public virtual void WriteInterpolatedText(string text);
    public virtual void Space();
    public virtual void Indent();
    public virtual void Unindent();
    public virtual void NewLine();
    public virtual void WriteComment(CommentType commentType, string content);
    public virtual void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument);
}
public enum ICSharpCode.Decompiler.CSharp.OutputVisitor.EmptyLineFormatting : Enum {
    public int value__;
    public static EmptyLineFormatting DoNotChange;
    public static EmptyLineFormatting Indent;
    public static EmptyLineFormatting DoNotIndent;
}
public static class ICSharpCode.Decompiler.CSharp.OutputVisitor.FormattingOptionsFactory : object {
    public static CSharpFormattingOptions CreateEmpty();
    public static CSharpFormattingOptions CreateMono();
    public static CSharpFormattingOptions CreateSharpDevelop();
    public static CSharpFormattingOptions CreateKRStyle();
    public static CSharpFormattingOptions CreateAllman();
    public static CSharpFormattingOptions CreateWhitesmiths();
    public static CSharpFormattingOptions CreateGNU();
}
internal class ICSharpCode.Decompiler.CSharp.OutputVisitor.GenericGrammarAmbiguityVisitor : DepthFirstAstVisitor`1<bool> {
    private int genericNestingLevel;
    private bool ambiguityFound;
    public static void ResolveAmbiguities(AstNode rootNode);
    public static bool CausesAmbiguityWithGenerics(BinaryOperatorExpression binaryOperatorExpression);
    protected virtual bool VisitChildren(AstNode node);
    public virtual bool VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression);
    public virtual bool VisitIdentifierExpression(IdentifierExpression identifierExpression);
    public virtual bool VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression);
    public virtual bool VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
}
public interface ICSharpCode.Decompiler.CSharp.OutputVisitor.ILocatable {
    public TextLocation Location { get; }
    public int Length { get; }
    public abstract virtual TextLocation get_Location();
    public abstract virtual int get_Length();
}
internal class ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertMissingTokensDecorator : DecoratingTokenWriter {
    private Stack`1<List`1<AstNode>> nodes;
    private List`1<AstNode> currentList;
    private ILocatable locationProvider;
    public InsertMissingTokensDecorator(TokenWriter writer, ILocatable locationProvider);
    public virtual void StartNode(AstNode node);
    public virtual void EndNode(AstNode node);
    public virtual void WriteToken(Role role, string token);
    public virtual void WriteKeyword(Role role, string keyword);
    public virtual void WriteIdentifier(Identifier identifier);
    public virtual void WritePrimitiveValue(object value, LiteralFormat format);
    public virtual void WritePrimitiveType(string type);
}
public class ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertParenthesesVisitor : DepthFirstAstVisitor {
    [CompilerGeneratedAttribute]
private bool <InsertParenthesesForReadability>k__BackingField;
    public bool InsertParenthesesForReadability { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_InsertParenthesesForReadability();
    [CompilerGeneratedAttribute]
public void set_InsertParenthesesForReadability(bool value);
    private static PrecedenceLevel GetPrecedence(Expression expr);
    private static void ParenthesizeIfRequired(Expression expr, PrecedenceLevel minimumPrecedence);
    private static void Parenthesize(Expression expr);
    public virtual void VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public virtual void VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression);
    public virtual void VisitInvocationExpression(InvocationExpression invocationExpression);
    public virtual void VisitIndexerExpression(IndexerExpression indexerExpression);
    public virtual void VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression);
    public virtual void VisitCastExpression(CastExpression castExpression);
    private static bool TypeCanBeMisinterpretedAsExpression(AstType type);
    public virtual void VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression);
    private static bool IsBitwise(BinaryOperatorType op);
    private Nullable`1<BinaryOperatorType> GetBinaryOperatorType(Expression expr);
    public virtual void VisitIsExpression(IsExpression isExpression);
    public virtual void VisitAsExpression(AsExpression asExpression);
    public virtual void VisitConditionalExpression(ConditionalExpression conditionalExpression);
    private bool IsConditionalRefExpression(ConditionalExpression conditionalExpression);
    public virtual void VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    private void HandleAssignmentRHS(Expression right);
    public virtual void VisitVariableInitializer(VariableInitializer variableInitializer);
    public virtual void VisitQueryExpression(QueryExpression queryExpression);
    public virtual void VisitLambdaExpression(LambdaExpression lambdaExpression);
    private void HandleLambdaOrQuery(Expression expr);
    public virtual void VisitNamedExpression(NamedExpression namedExpression);
    public virtual void VisitSwitchExpression(SwitchExpression switchExpression);
}
internal class ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertRequiredSpacesDecorator : DecoratingTokenWriter {
    private LastWritten lastWritten;
    public InsertRequiredSpacesDecorator(TokenWriter writer);
    public virtual void WriteIdentifier(Identifier identifier);
    public virtual void WriteKeyword(Role role, string keyword);
    public virtual void WriteToken(Role role, string token);
    public virtual void Space();
    public virtual void NewLine();
    public virtual void WriteComment(CommentType commentType, string content);
    public virtual void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument);
    public virtual void WritePrimitiveValue(object value, LiteralFormat format);
    public virtual void WritePrimitiveType(string type);
}
internal class ICSharpCode.Decompiler.CSharp.OutputVisitor.InsertSpecialsDecorator : DecoratingTokenWriter {
    private Stack`1<AstNode> positionStack;
    private int visitorWroteNewLine;
    public InsertSpecialsDecorator(TokenWriter writer);
    public virtual void StartNode(AstNode node);
    public virtual void EndNode(AstNode node);
    public virtual void WriteKeyword(Role role, string keyword);
    public virtual void WriteIdentifier(Identifier identifier);
    public virtual void WriteToken(Role role, string token);
    public virtual void NewLine();
    private void WriteSpecials(AstNode start, AstNode end);
    private void WriteSpecialsUpToRole(Role role);
    private void WriteSpecialsUpToRole(Role role, AstNode nextNode);
    private void WriteSpecialsUpToNode(AstNode node);
}
public enum ICSharpCode.Decompiler.CSharp.OutputVisitor.NewLinePlacement : Enum {
    public int value__;
    public static NewLinePlacement DoNotCare;
    public static NewLinePlacement NewLine;
    public static NewLinePlacement SameLine;
}
public enum ICSharpCode.Decompiler.CSharp.OutputVisitor.PropertyFormatting : Enum {
    public int value__;
    public static PropertyFormatting SingleLine;
    public static PropertyFormatting MultipleLines;
}
public class ICSharpCode.Decompiler.CSharp.OutputVisitor.TextWriterTokenWriter : TokenWriter {
    private TextWriter textWriter;
    private bool needsIndent;
    private bool isAtStartOfLine;
    private int line;
    private int column;
    [CompilerGeneratedAttribute]
private int <Indentation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndentationString>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Indentation { get; public set; }
    public TextLocation Location { get; }
    public string IndentationString { get; public set; }
    public int Length { get; private set; }
    public TextWriterTokenWriter(TextWriter textWriter);
    [CompilerGeneratedAttribute]
public int get_Indentation();
    [CompilerGeneratedAttribute]
public void set_Indentation(int value);
    public sealed virtual TextLocation get_Location();
    [CompilerGeneratedAttribute]
public string get_IndentationString();
    [CompilerGeneratedAttribute]
public void set_IndentationString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    public virtual void WriteIdentifier(Identifier identifier);
    public virtual void WriteKeyword(Role role, string keyword);
    public virtual void WriteToken(Role role, string token);
    public virtual void Space();
    protected void WriteIndentation();
    public virtual void NewLine();
    public virtual void Indent();
    public virtual void Unindent();
    public virtual void WriteComment(CommentType commentType, string content);
    private static void UpdateEndLocation(string content, Int32& line, Int32& column);
    public virtual void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument);
    public static string PrintPrimitiveValue(object value);
    public virtual void WritePrimitiveValue(object value, LiteralFormat format);
    public virtual void WriteInterpolatedText(string text);
    public static string ConvertCharLiteral(char ch);
    private static string ConvertChar(char ch);
    public static string ConvertString(string str);
    public static string EscapeIdentifier(string identifier);
    public static bool ContainsNonPrintableIdentifierChar(string identifier);
    private static bool IsPrintableIdentifierChar(string identifier, int index);
    public virtual void WritePrimitiveType(string type);
    public virtual void StartNode(AstNode node);
    public virtual void EndNode(AstNode node);
}
public abstract class ICSharpCode.Decompiler.CSharp.OutputVisitor.TokenWriter : object {
    public abstract virtual void StartNode(AstNode node);
    public abstract virtual void EndNode(AstNode node);
    public abstract virtual void WriteIdentifier(Identifier identifier);
    public abstract virtual void WriteKeyword(Role role, string keyword);
    public abstract virtual void WriteToken(Role role, string token);
    public abstract virtual void WritePrimitiveValue(object value, LiteralFormat format);
    public abstract virtual void WritePrimitiveType(string type);
    public abstract virtual void WriteInterpolatedText(string text);
    public abstract virtual void Space();
    public abstract virtual void Indent();
    public abstract virtual void Unindent();
    public abstract virtual void NewLine();
    public abstract virtual void WriteComment(CommentType commentType, string content);
    public abstract virtual void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument);
    public static TokenWriter Create(TextWriter writer, string indentation);
    public static TokenWriter CreateWriterThatSetsLocationsInAST(TextWriter writer, string indentation);
    public static TokenWriter InsertRequiredSpaces(TokenWriter writer);
    public static TokenWriter WrapInWriterThatSetsLocationsInAST(TokenWriter writer);
}
public enum ICSharpCode.Decompiler.CSharp.OutputVisitor.UsingPlacement : Enum {
    public int value__;
    public static UsingPlacement TopOfFile;
    public static UsingPlacement InsideNamespace;
}
public enum ICSharpCode.Decompiler.CSharp.OutputVisitor.Wrapping : Enum {
    public int value__;
    public static Wrapping DoNotWrap;
    public static Wrapping WrapAlways;
    public static Wrapping WrapIfTooLong;
}
internal interface ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectFileWriter {
    public abstract virtual void Write(TextWriter target, IProjectInfoProvider project, IEnumerable`1<ProjectItemInfo> files, PEFile module);
}
internal interface ICSharpCode.Decompiler.CSharp.ProjectDecompiler.IProjectInfoProvider {
    public IAssemblyResolver AssemblyResolver { get; }
    public AssemblyReferenceClassifier AssemblyReferenceClassifier { get; }
    public LanguageVersion LanguageVersion { get; }
    public Guid ProjectGuid { get; }
    public string TargetDirectory { get; }
    public string StrongNameKeyFile { get; }
    public abstract virtual IAssemblyResolver get_AssemblyResolver();
    public abstract virtual AssemblyReferenceClassifier get_AssemblyReferenceClassifier();
    public abstract virtual LanguageVersion get_LanguageVersion();
    public abstract virtual Guid get_ProjectGuid();
    public abstract virtual string get_TargetDirectory();
    public abstract virtual string get_StrongNameKeyFile();
}
internal class ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterDefault : object {
    public static IProjectFileWriter Create();
    public sealed virtual void Write(TextWriter target, IProjectInfoProvider project, IEnumerable`1<ProjectItemInfo> files, PEFile module);
}
internal class ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectFileWriterSdkStyle : object {
    private static string AspNetCorePrefix;
    private static string PresentationFrameworkName;
    private static string WindowsFormsName;
    private static string TrueString;
    private static string FalseString;
    private static string AnyCpuString;
    private static HashSet`1<string> ImplicitReferences;
    private static ProjectFileWriterSdkStyle();
    public static IProjectFileWriter Create();
    public sealed virtual void Write(TextWriter target, IProjectInfoProvider project, IEnumerable`1<ProjectItemInfo> files, PEFile module);
    private static void Write(XmlTextWriter xml, IProjectInfoProvider project, IEnumerable`1<ProjectItemInfo> files, PEFile module);
    private static void PlaceIntoTag(string tagName, XmlTextWriter xml, Action content);
    private static void WriteAssemblyInfo(XmlTextWriter xml, PEFile module, IProjectInfoProvider project, ProjectType projectType);
    private static void WriteOutputType(XmlTextWriter xml, bool isDll, Subsystem moduleSubsystem, ProjectType projectType);
    private static void WriteDesktopExtensions(XmlTextWriter xml, ProjectType projectType);
    private static void WriteProjectInfo(XmlTextWriter xml, IProjectInfoProvider project);
    private static void WriteMiscellaneousPropertyGroup(XmlTextWriter xml, IEnumerable`1<ProjectItemInfo> files);
    private static void WriteResources(XmlTextWriter xml, IEnumerable`1<ProjectItemInfo> files);
    private static void WriteReferences(XmlTextWriter xml, PEFile module, IProjectInfoProvider project, ProjectType projectType);
    private static string GetSdkString(ProjectType projectType);
    private static ProjectType GetProjectType(PEFile module);
}
public class ICSharpCode.Decompiler.CSharp.ProjectDecompiler.ProjectItemInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PartialTypeInfo> <PartialTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AdditionalProperties>k__BackingField;
    public string ItemType { get; public set; }
    public string FileName { get; public set; }
    public List`1<PartialTypeInfo> PartialTypes { get; public set; }
    public Dictionary`2<string, string> AdditionalProperties { get; public set; }
    public ProjectItemInfo(string ItemType, string FileName);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public List`1<PartialTypeInfo> get_PartialTypes();
    [CompilerGeneratedAttribute]
public void set_PartialTypes(List`1<PartialTypeInfo> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(Dictionary`2<string, string> value);
    public ProjectItemInfo With(string name, string value);
    public ProjectItemInfo With(IEnumerable`1<KeyValuePair`2<string, string>> pairs);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ProjectItemInfo left, ProjectItemInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ProjectItemInfo left, ProjectItemInfo right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProjectItemInfo other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& ItemType, String& FileName);
}
internal class ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetFramework : object {
    private static string DotNetPortableIdentifier;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Moniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionString>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VersionNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortableClassLibrary>k__BackingField;
    public string Identifier { get; }
    public string Moniker { get; }
    public string VersionString { get; }
    public int VersionNumber { get; }
    public string Profile { get; }
    public bool IsPortableClassLibrary { get; }
    public TargetFramework(string identifier, int version, string profile);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public string get_Moniker();
    [CompilerGeneratedAttribute]
public string get_VersionString();
    [CompilerGeneratedAttribute]
public int get_VersionNumber();
    [CompilerGeneratedAttribute]
public string get_Profile();
    [CompilerGeneratedAttribute]
public bool get_IsPortableClassLibrary();
    private static string GetTargetFrameworkMoniker(string frameworkIdentifier, int version);
    private static string GetVersionString(int version, bool withDots, bool omitMinorWhenZero);
}
internal static class ICSharpCode.Decompiler.CSharp.ProjectDecompiler.TargetServices : object {
    private static string VersionToken;
    private static string ProfileToken;
    private static HashSet`1<string> dotNet30Assemblies;
    private static HashSet`1<string> dotNet35Assemblies;
    private static TargetServices();
    public static TargetFramework DetectTargetFramework(PEFile module);
    public static string GetPlatformName(PEFile module);
    public static TargetFramework DetectTargetFrameworkNET20(PEFile module, IAssemblyResolver assemblyResolver, TargetFramework targetFramework);
    private static void GetFrameworkVersionNET20(PEFile module, IAssemblyResolver assemblyResolver, HashSet`1<string> resolvedAssemblies, Int32& version);
}
public class ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler : object {
    private static int maxSegmentLength;
    [CompilerGeneratedAttribute]
private DecompilerSettings <Settings>k__BackingField;
    private Nullable`1<LanguageVersion> languageVersion;
    [CompilerGeneratedAttribute]
private IAssemblyResolver <AssemblyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyReferenceClassifier <AssemblyReferenceClassifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugInfoProvider <DebugInfoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ProjectGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StrongNameKeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgress`1<DecompilationProgress> <ProgressIndicator>k__BackingField;
    private HashSet`1<string> directories;
    private IProjectFileWriter projectWriter;
    private static int RT_ICON;
    private static int RT_GROUP_ICON;
    private static int RT_MANIFEST;
    public DecompilerSettings Settings { get; }
    public LanguageVersion LanguageVersion { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; }
    public AssemblyReferenceClassifier AssemblyReferenceClassifier { get; }
    public IDebugInfoProvider DebugInfoProvider { get; }
    public Guid ProjectGuid { get; }
    public string TargetDirectory { get; protected set; }
    public string StrongNameKeyFile { get; public set; }
    public int MaxDegreeOfParallelism { get; public set; }
    public IProgress`1<DecompilationProgress> ProgressIndicator { get; public set; }
    public WholeProjectDecompiler(IAssemblyResolver assemblyResolver);
    public WholeProjectDecompiler(DecompilerSettings settings, IAssemblyResolver assemblyResolver, AssemblyReferenceClassifier assemblyReferenceClassifier, IDebugInfoProvider debugInfoProvider);
    protected WholeProjectDecompiler(DecompilerSettings settings, Guid projectGuid, IAssemblyResolver assemblyResolver, AssemblyReferenceClassifier assemblyReferenceClassifier, IDebugInfoProvider debugInfoProvider);
    [CompilerGeneratedAttribute]
public DecompilerSettings get_Settings();
    public sealed virtual LanguageVersion get_LanguageVersion();
    public void set_LanguageVersion(LanguageVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual IAssemblyResolver get_AssemblyResolver();
    [CompilerGeneratedAttribute]
public sealed virtual AssemblyReferenceClassifier get_AssemblyReferenceClassifier();
    [CompilerGeneratedAttribute]
public IDebugInfoProvider get_DebugInfoProvider();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_ProjectGuid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetDirectory();
    [CompilerGeneratedAttribute]
protected void set_TargetDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StrongNameKeyFile();
    [CompilerGeneratedAttribute]
public void set_StrongNameKeyFile(string value);
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public IProgress`1<DecompilationProgress> get_ProgressIndicator();
    [CompilerGeneratedAttribute]
public void set_ProgressIndicator(IProgress`1<DecompilationProgress> value);
    public void DecompileProject(PEFile moduleDefinition, string targetDirectory, CancellationToken cancellationToken);
    public ProjectId DecompileProject(PEFile moduleDefinition, string targetDirectory, TextWriter projectFileWriter, CancellationToken cancellationToken);
    protected virtual bool IncludeTypeWhenDecompilingProject(PEFile module, TypeDefinitionHandle type);
    private CSharpDecompiler CreateDecompiler(DecompilerTypeSystem ts);
    private IEnumerable`1<ProjectItemInfo> WriteAssemblyInfo(DecompilerTypeSystem ts, CancellationToken cancellationToken);
    private IEnumerable`1<ProjectItemInfo> WriteCodeFilesInProject(PEFile module, IList`1<PartialTypeInfo> partialTypes, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler/<WriteResourceFilesInProject>d__47")]
protected virtual IEnumerable`1<ProjectItemInfo> WriteResourceFilesInProject(PEFile module);
    protected virtual IEnumerable`1<ProjectItemInfo> WriteResourceToFile(string fileName, string resourceName, Stream entryStream);
    private string GetFileNameForResource(string fullName);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.ProjectDecompiler.WholeProjectDecompiler/<WriteMiscellaneousFilesInProject>d__50")]
protected virtual IEnumerable`1<ProjectItemInfo> WriteMiscellaneousFilesInProject(PEFile module);
    private static Byte[] CreateApplicationIcon(Win32ResourceDirectory resources);
    private static Byte[] CreateApplicationManifest(Win32ResourceDirectory resources);
    private static bool IsDefaultApplicationManifest(Byte[] appManifest);
    private static string CleanUpApplicationManifest(Byte[] appManifest);
    public static string CleanUpFileName(string text);
    public static string SanitizeFileName(string fileName);
    private static string CleanUpName(string text, bool separateAtDots, bool treatAsFileName);
    public static string CleanUpDirectoryName(string text);
    public static string CleanUpPath(string text);
    private static bool IsReservedFileSystemName(string name);
    public static bool CanUseSdkStyleProjectFormat(PEFile module);
}
public class ICSharpCode.Decompiler.CSharp.QueryGroupClauseAnnotation : object {
    public ILFunction KeyLambda;
    public ILFunction ProjectionLambda;
    public QueryGroupClauseAnnotation(ILFunction key, ILFunction projection);
}
public class ICSharpCode.Decompiler.CSharp.QueryJoinClauseAnnotation : object {
    public ILFunction OnLambda;
    public ILFunction EqualsLambda;
    public QueryJoinClauseAnnotation(ILFunction on, ILFunction equals);
}
internal class ICSharpCode.Decompiler.CSharp.RecordDecompiler : object {
    private IDecompilerTypeSystem typeSystem;
    private ITypeDefinition recordTypeDef;
    private DecompilerSettings settings;
    private CancellationToken cancellationToken;
    private List`1<IMember> orderedMembers;
    private bool isInheritedRecord;
    private bool isStruct;
    private bool isSealed;
    private IMethod primaryCtor;
    private IType baseClass;
    private Dictionary`2<IField, IProperty> backingFieldToAutoProperty;
    private Dictionary`2<IProperty, IField> autoPropertyToBackingField;
    private Dictionary`2<IParameter, IProperty> primaryCtorParameterToAutoProperty;
    private Dictionary`2<IProperty, IParameter> autoPropertyToPrimaryCtorParameter;
    public IEnumerable`1<IMember> FieldsAndProperties { get; }
    public IMethod PrimaryConstructor { get; }
    public bool IsInheritedRecord { get; }
    public RecordDecompiler(IDecompilerTypeSystem dts, ITypeDefinition recordTypeDef, DecompilerSettings settings, CancellationToken cancellationToken);
    private void DetectAutomaticProperties();
    private IMethod DetectPrimaryConstructor();
    private static List`1<IMember> DetectMemberOrder(ITypeDefinition recordTypeDef, Dictionary`2<IField, IProperty> backingFieldToAutoProperty);
    public IEnumerable`1<IMember> get_FieldsAndProperties();
    public IMethod get_PrimaryConstructor();
    public bool get_IsInheritedRecord();
    private bool IsRecordType(IType type);
    public bool MethodIsGenerated(IMethod method);
    internal bool PropertyIsGenerated(IProperty property);
    public bool IsPropertyDeclaredByPrimaryConstructor(IProperty property);
    internal ValueTuple`2<IProperty, IField> GetPropertyInfoByPrimaryConstructorParameter(IParameter parameter);
    public bool IsCopyConstructor(IMethod method);
    private bool IsAllowedAttribute(IAttribute attribute);
    private bool IsGeneratedCopyConstructor(IMethod method);
    private bool IsGeneratedEqualityContract(IProperty property);
    private bool IsGeneratedPrintMembers(IMethod method);
    private bool MatchStringBuilderAppend(ILInstruction inst, ILVariable sb, ILInstruction& val);
    private bool IsGeneratedToString(IMethod method);
    private bool IsGeneratedEquals(IMethod method);
    private static List`1<ILInstruction> UnpackLogicAndChain(ILInstruction rootOfChain);
    private bool MatchGetEqualityContract(ILInstruction inst, ILInstruction& target);
    private static bool IsEqualityComparerGetDefaultCall(ILInstruction inst, IType type);
    private bool MemberConsideredForEquality(IMember member);
    private bool IsGeneratedGetHashCode(IMethod method);
    private bool IsGeneratedDeconstruct(IMethod method);
    private bool MatchMemberAccess(ILInstruction inst, ILInstruction& target, IMember& member);
    private Block DecompileBody(IMethod method);
    [CompilerGeneratedAttribute]
private bool <DetectAutomaticProperties>g__IsAutoProperty|15_0(IProperty p, IField& field);
    [CompilerGeneratedAttribute]
private bool <DetectAutomaticProperties>g__IsAutoGetter|15_1(IMethod method, IField& field);
    [CompilerGeneratedAttribute]
private bool <DetectAutomaticProperties>g__IsAutoSetter|15_2(IMethod method, IField& field);
    [CompilerGeneratedAttribute]
private bool <DetectPrimaryConstructor>g__IsPrimaryConstructor|16_0(IMethod method, IMethod unspecializedMethod);
    [CompilerGeneratedAttribute]
private bool <MethodIsGenerated>b__25_0(IParameter p);
    [CompilerGeneratedAttribute]
private bool <IsGeneratedCopyConstructor>b__31_0(IAttribute attr);
    [CompilerGeneratedAttribute]
private bool <IsGeneratedEquals>b__36_0(IAttribute attr);
    [CompilerGeneratedAttribute]
internal static void <UnpackLogicAndChain>g__Visit|37_0(ILInstruction inst, <>c__DisplayClass37_0& );
}
internal class ICSharpCode.Decompiler.CSharp.RequiredNamespaceCollector : object {
    private static GenericContext genericContext;
    private HashSet`1<string> namespaces;
    private HashSet`1<IType> visitedTypes;
    public RequiredNamespaceCollector(HashSet`1<string> namespaces);
    private static RequiredNamespaceCollector();
    public static void CollectNamespaces(MetadataModule module, HashSet`1<string> namespaces);
    public static void CollectAttributeNamespaces(MetadataModule module, HashSet`1<string> namespaces);
    public static void CollectNamespaces(IEntity entity, MetadataModule module, HashSet`1<string> namespaces);
    private void CollectNamespaces(IEntity entity, MetadataModule module, CodeMappingInfo mappingInfo);
    private void HandleOverrides(ImmutableArray`1<MethodImplementationHandle> immutableArray, MetadataModule module);
    private void CollectNamespacesForTypeReference(IType type);
    public static void CollectNamespaces(EntityHandle entity, MetadataModule module, HashSet`1<string> namespaces);
    private void HandleAttributes(IEnumerable`1<IAttribute> attributes);
    private void HandleAttributeValue(IType type, object value);
    private void HandleTypeParameters(IEnumerable`1<ITypeParameter> typeParameters);
    private void CollectNamespacesFromMethodBody(MethodBodyBlock method, MetadataModule module);
    private void CollectNamespacesForMemberReference(IMember member);
}
public class ICSharpCode.Decompiler.CSharp.Resolver.AliasNamespaceResolveResult : NamespaceResolveResult {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; private set; }
    public AliasNamespaceResolveResult(string alias, NamespaceResolveResult underlyingResult);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
private void set_Alias(string value);
}
public class ICSharpCode.Decompiler.CSharp.Resolver.AliasTypeResolveResult : TypeResolveResult {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; private set; }
    public AliasTypeResolveResult(string alias, TypeResolveResult underlyingResult);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
private void set_Alias(string value);
}
public class ICSharpCode.Decompiler.CSharp.Resolver.AwaitResolveResult : ResolveResult {
    public ResolveResult GetAwaiterInvocation;
    public IType AwaiterType;
    public IProperty IsCompletedProperty;
    public IMethod OnCompletedMethod;
    public IMethod GetResultMethod;
    public bool IsError { get; }
    public AwaitResolveResult(IType resultType, ResolveResult getAwaiterInvocation, IType awaiterType, IProperty isCompletedProperty, IMethod onCompletedMethod, IMethod getResultMethod);
    public virtual bool get_IsError();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.CSharp.Resolver.CSharpConversions : object {
    private ConcurrentDictionary`2<TypePair, Conversion> implicitConversionCache;
    private ICompilation compilation;
    private static Boolean[0...,0...] implicitNumericConversionLookup;
    public CSharpConversions(ICompilation compilation);
    private static CSharpConversions();
    public static CSharpConversions Get(ICompilation compilation);
    private Conversion ImplicitConversion(ResolveResult resolveResult, IType toType, bool allowUserDefined, bool allowTuple);
    private Conversion ImplicitConversion(IType fromType, IType toType, bool allowUserDefined, bool allowTuple);
    public Conversion ImplicitConversion(ResolveResult resolveResult, IType toType);
    public Conversion ImplicitConversion(IType fromType, IType toType);
    public Conversion StandardImplicitConversion(IType fromType, IType toType);
    private Conversion StandardImplicitConversion(IType fromType, IType toType, bool allowTupleConversion);
    public bool IsConstraintConvertible(IType fromType, IType toType);
    public Conversion ExplicitConversion(ResolveResult resolveResult, IType toType);
    public Conversion ExplicitConversion(IType fromType, IType toType);
    private Conversion ExplicitConversionImpl(IType fromType, IType toType);
    public bool IdentityConversion(IType fromType, IType toType);
    private bool ImplicitNumericConversion(IType fromType, IType toType);
    private bool IsNumericType(IType type);
    private bool AnyNumericConversion(IType fromType, IType toType);
    private Conversion ImplicitEnumerationConversion(ResolveResult rr, IType toType);
    private bool ExplicitEnumerationConversion(IType fromType, IType toType);
    private Conversion ImplicitNullableConversion(IType fromType, IType toType);
    private Conversion ExplicitNullableConversion(IType fromType, IType toType);
    private bool NullLiteralConversion(IType fromType, IType toType);
    public bool IsImplicitReferenceConversion(IType fromType, IType toType);
    private bool ImplicitReferenceConversion(IType fromType, IType toType, int subtypeCheckNestingDepth);
    private IType UnpackGenericArrayInterface(IType interfaceType);
    private bool IsSubtypeOf(IType s, IType t, int subtypeCheckNestingDepth);
    private bool IdentityOrVarianceConversion(IType s, IType t, int subtypeCheckNestingDepth);
    private bool ExplicitReferenceConversion(IType fromType, IType toType);
    private bool IsSealedReferenceType(IType type);
    private bool IsBoxingConversion(IType fromType, IType toType);
    public bool IsBoxingConversionOrInvolvingTypeParameter(IType fromType, IType toType);
    private bool UnboxingConversion(IType fromType, IType toType);
    private bool ImplicitConstantExpressionConversion(ResolveResult rr, IType toType);
    private bool ImplicitTypeParameterConversion(IType fromType, IType toType);
    private Conversion ExplicitTypeParameterConversion(IType fromType, IType toType);
    private bool ImplicitPointerConversion(IType fromType, IType toType);
    private bool ExplicitPointerConversion(IType fromType, IType toType);
    private bool IsIntegerType(IType type);
    private bool IsEncompassedBy(IType a, IType b);
    private bool IsEncompassingOrEncompassedBy(IType a, IType b);
    private IType FindMostEncompassedType(IEnumerable`1<IType> candidates);
    private IType FindMostEncompassingType(IEnumerable`1<IType> candidates);
    private Conversion SelectOperator(IType mostSpecificSource, IType mostSpecificTarget, IList`1<OperatorInfo> operators, bool isImplicit, IType source, IType target);
    private Conversion UserDefinedImplicitConversion(ResolveResult fromResult, IType fromType, IType toType);
    private Conversion UserDefinedExplicitConversion(ResolveResult fromResult, IType fromType, IType toType);
    private static IType UnderlyingTypeForConversion(IType type);
    private List`1<OperatorInfo> GetApplicableConversionOperators(ResolveResult fromResult, IType fromType, IType toType, bool isExplicit);
    private Conversion AnonymousFunctionConversion(ResolveResult resolveResult, IType toType);
    private static IType UnpackExpressionTreeType(IType type);
    private Conversion MethodGroupConversion(ResolveResult resolveResult, IType toType);
    public bool IsDelegateCompatible(IMethod method, IType delegateType);
    private bool IsDelegateCompatible(IMethod m, IMethod invoke, bool isExtensionMethodInvocation);
    private Conversion TupleConversion(TupleResolveResult fromRR, IType toType, bool isExplicit);
    private Conversion TupleConversion(IType fromType, IType toType, bool isExplicit);
    public int BetterConversion(ResolveResult resolveResult, IType t1, IType t2);
    private static IType UnpackTask(IType type);
    public int BetterConversion(IType s, IType t1, IType t2);
    private int BetterConversionTarget(IType t1, IType t2);
    private bool IsBetterIntegralType(TypeCode t1, TypeCode t2);
}
public class ICSharpCode.Decompiler.CSharp.Resolver.CSharpInvocationResolveResult : InvocationResolveResult {
    public OverloadResolutionErrors OverloadResolutionErrors;
    public bool IsExtensionMethodInvocation;
    public bool IsDelegateInvocation;
    public bool IsExpandedForm;
    private IReadOnlyList`1<int> argumentToParameterMap;
    public bool IsError { get; }
    public CSharpInvocationResolveResult(ResolveResult targetResult, IParameterizedMember member, IList`1<ResolveResult> arguments, OverloadResolutionErrors overloadResolutionErrors, bool isExtensionMethodInvocation, bool isExpandedForm, bool isDelegateInvocation, IReadOnlyList`1<int> argumentToParameterMap, IList`1<ResolveResult> initializerStatements, IType returnTypeOverride);
    public virtual bool get_IsError();
    public IReadOnlyList`1<int> GetArgumentToParameterMap();
    public virtual IList`1<ResolveResult> GetArgumentsForCall();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.CSharp.Resolver.CSharpOperators : object {
    private ICompilation compilation;
    private IParameter[] normalParameters;
    private IParameter[] nullableParameters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] unaryPlusOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] uncheckedUnaryMinusOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] checkedUnaryMinusOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] logicalNegationOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] bitwiseComplementOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] multiplicationOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] divisionOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] remainderOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] additionOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] subtractionOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] shiftLeftOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] shiftRightOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] unsignedShiftRightOperators;
    private static TypeCode[] valueEqualityOperatorsFor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] valueEqualityOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] valueInequalityOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] referenceEqualityOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] referenceInequalityOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] lessThanOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] lessThanOrEqualOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] greaterThanOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] greaterThanOrEqualOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] logicalAndOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] bitwiseAndOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] logicalOrOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] bitwiseOrOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OperatorMethod[] bitwiseXorOperators;
    public OperatorMethod[] UnaryPlusOperators { get; }
    public OperatorMethod[] UncheckedUnaryMinusOperators { get; }
    public OperatorMethod[] CheckedUnaryMinusOperators { get; }
    public OperatorMethod[] LogicalNegationOperators { get; }
    public OperatorMethod[] BitwiseComplementOperators { get; }
    public OperatorMethod[] MultiplicationOperators { get; }
    public OperatorMethod[] DivisionOperators { get; }
    public OperatorMethod[] RemainderOperators { get; }
    public OperatorMethod[] AdditionOperators { get; }
    public OperatorMethod[] SubtractionOperators { get; }
    public OperatorMethod[] ShiftLeftOperators { get; }
    public OperatorMethod[] ShiftRightOperators { get; }
    public OperatorMethod[] UnsignedShiftRightOperators { get; }
    public OperatorMethod[] ValueEqualityOperators { get; }
    public OperatorMethod[] ValueInequalityOperators { get; }
    public OperatorMethod[] ReferenceEqualityOperators { get; }
    public OperatorMethod[] ReferenceInequalityOperators { get; }
    public OperatorMethod[] LessThanOperators { get; }
    public OperatorMethod[] LessThanOrEqualOperators { get; }
    public OperatorMethod[] GreaterThanOperators { get; }
    public OperatorMethod[] GreaterThanOrEqualOperators { get; }
    public OperatorMethod[] LogicalAndOperators { get; }
    public OperatorMethod[] BitwiseAndOperators { get; }
    public OperatorMethod[] LogicalOrOperators { get; }
    public OperatorMethod[] BitwiseOrOperators { get; }
    public OperatorMethod[] BitwiseXorOperators { get; }
    private CSharpOperators(ICompilation compilation);
    private static CSharpOperators();
    public static CSharpOperators Get(ICompilation compilation);
    private OperatorMethod[] Lift(OperatorMethod[] methods);
    private void InitParameterArrays();
    private IParameter MakeParameter(TypeCode code);
    private IParameter MakeNullableParameter(IParameter normalParameter);
    public OperatorMethod[] get_UnaryPlusOperators();
    public OperatorMethod[] get_UncheckedUnaryMinusOperators();
    public OperatorMethod[] get_CheckedUnaryMinusOperators();
    public OperatorMethod[] get_LogicalNegationOperators();
    public OperatorMethod[] get_BitwiseComplementOperators();
    public OperatorMethod[] get_MultiplicationOperators();
    public OperatorMethod[] get_DivisionOperators();
    public OperatorMethod[] get_RemainderOperators();
    public OperatorMethod[] get_AdditionOperators();
    public OperatorMethod[] get_SubtractionOperators();
    public OperatorMethod[] get_ShiftLeftOperators();
    public OperatorMethod[] get_ShiftRightOperators();
    public OperatorMethod[] get_UnsignedShiftRightOperators();
    public OperatorMethod[] get_ValueEqualityOperators();
    public OperatorMethod[] get_ValueInequalityOperators();
    public OperatorMethod[] get_ReferenceEqualityOperators();
    public OperatorMethod[] get_ReferenceInequalityOperators();
    public OperatorMethod[] get_LessThanOperators();
    public OperatorMethod[] get_LessThanOrEqualOperators();
    public OperatorMethod[] get_GreaterThanOperators();
    public OperatorMethod[] get_GreaterThanOrEqualOperators();
    public OperatorMethod[] get_LogicalAndOperators();
    public OperatorMethod[] get_BitwiseAndOperators();
    public OperatorMethod[] get_LogicalOrOperators();
    public OperatorMethod[] get_BitwiseOrOperators();
    public OperatorMethod[] get_BitwiseXorOperators();
    public static IMethod LiftUserDefinedOperator(IMethod m);
    internal static bool IsComparisonOperator(IMethod m);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private EqualityOperatorMethod <get_ValueEqualityOperators>b__61_0(TypeCode c);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private EqualityOperatorMethod <get_ValueInequalityOperators>b__64_0(TypeCode c);
}
public class ICSharpCode.Decompiler.CSharp.Resolver.CSharpResolver : object {
    private static ResolveResult ErrorResult;
    private ICompilation compilation;
    internal CSharpConversions conversions;
    private CSharpTypeResolveContext context;
    private bool checkForOverflow;
    private bool isWithinLambdaExpression;
    private TypeDefinitionCache currentTypeDefinitionCache;
    private ImmutableStack`1<IVariable> localVariableStack;
    private ObjectInitializerContext objectInitializerStack;
    public ICompilation Compilation { get; }
    public CSharpTypeResolveContext CurrentTypeResolveContext { get; }
    private IModule ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.CurrentModule { get; }
    public bool CheckForOverflow { get; }
    public bool IsWithinLambdaExpression { get; }
    public IMember CurrentMember { get; }
    public ResolvedUsingScope CurrentUsingScope { get; }
    public ITypeDefinition CurrentTypeDefinition { get; }
    public IEnumerable`1<IVariable> LocalVariables { get; }
    public bool IsInObjectInitializer { get; }
    public ResolveResult CurrentObjectInitializer { get; }
    public IType CurrentObjectInitializerType { get; }
    public CSharpResolver(ICompilation compilation);
    public CSharpResolver(CSharpTypeResolveContext context);
    private CSharpResolver(ICompilation compilation, CSharpConversions conversions, CSharpTypeResolveContext context, bool checkForOverflow, bool isWithinLambdaExpression, TypeDefinitionCache currentTypeDefinitionCache, ImmutableStack`1<IVariable> localVariableStack, ObjectInitializerContext objectInitializerStack);
    private static CSharpResolver();
    public sealed virtual ICompilation get_Compilation();
    public CSharpTypeResolveContext get_CurrentTypeResolveContext();
    private sealed virtual override IModule ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.get_CurrentModule();
    private CSharpResolver WithContext(CSharpTypeResolveContext newContext);
    public bool get_CheckForOverflow();
    public CSharpResolver WithCheckForOverflow(bool checkForOverflow);
    public sealed virtual bool get_IsWithinLambdaExpression();
    public CSharpResolver WithIsWithinLambdaExpression(bool isWithinLambdaExpression);
    public sealed virtual IMember get_CurrentMember();
    public CSharpResolver WithCurrentMember(IMember member);
    private sealed virtual override ITypeResolveContext ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.WithCurrentMember(IMember member);
    public ResolvedUsingScope get_CurrentUsingScope();
    public CSharpResolver WithCurrentUsingScope(ResolvedUsingScope usingScope);
    public sealed virtual ITypeDefinition get_CurrentTypeDefinition();
    public CSharpResolver WithCurrentTypeDefinition(ITypeDefinition typeDefinition);
    private sealed virtual override ITypeResolveContext ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.WithCurrentTypeDefinition(ITypeDefinition typeDefinition);
    private CSharpResolver WithLocalVariableStack(ImmutableStack`1<IVariable> stack);
    public CSharpResolver PushBlock();
    public CSharpResolver PopBlock();
    public CSharpResolver AddVariable(IVariable variable);
    public CSharpResolver PopLastVariable();
    public sealed virtual IEnumerable`1<IVariable> get_LocalVariables();
    private CSharpResolver WithObjectInitializerStack(ObjectInitializerContext stack);
    public CSharpResolver PushObjectInitializer(ResolveResult initializedObject);
    public CSharpResolver PopObjectInitializer();
    public bool get_IsInObjectInitializer();
    public ResolveResult get_CurrentObjectInitializer();
    public IType get_CurrentObjectInitializerType();
    public ResolveResult ResolveUnaryOperator(UnaryOperatorType op, ResolveResult expression);
    private OperatorResolveResult UnaryOperatorResolveResult(IType resultType, UnaryOperatorType op, ResolveResult expression, bool isLifted);
    private ResolveResult UnaryNumericPromotion(UnaryOperatorType op, IType& type, bool isNullable, ResolveResult expression);
    private static string GetOverloadableOperatorName(UnaryOperatorType op);
    public ResolveResult ResolveBinaryOperator(BinaryOperatorType op, ResolveResult lhs, ResolveResult rhs);
    private bool IsNullableTypeOrNonValueType(IType type);
    private ResolveResult BinaryOperatorResolveResult(IType resultType, ResolveResult lhs, BinaryOperatorType op, ResolveResult rhs, bool isLifted);
    private BinaryOperatorMethod PointerArithmeticOperator(IType resultType, IType inputType1, KnownTypeCode inputType2);
    private BinaryOperatorMethod PointerArithmeticOperator(IType resultType, KnownTypeCode inputType1, IType inputType2);
    private BinaryOperatorMethod PointerArithmeticOperator(IType resultType, IType inputType1, IType inputType2);
    private IType GetEnumUnderlyingType(IType enumType);
    private ResolveResult HandleEnumComparison(BinaryOperatorType op, IType enumType, bool isNullable, ResolveResult lhs, ResolveResult rhs);
    private ResolveResult HandleEnumSubtraction(bool isNullable, IType enumType, ResolveResult lhs, ResolveResult rhs);
    private ResolveResult HandleEnumOperator(bool isNullable, IType enumType, BinaryOperatorType op, ResolveResult lhs, ResolveResult rhs);
    private IType MakeNullable(IType type, bool isNullable);
    private bool BinaryNumericPromotion(bool isNullable, ResolveResult& lhs, ResolveResult& rhs, bool allowNullableConstants);
    private bool IsSigned(TypeCode code, ResolveResult rr);
    private ResolveResult CastTo(TypeCode targetType, bool isNullable, ResolveResult expression, bool allowNullableConstants);
    private ResolveResult CastTo(IType targetType, bool isNullable, ResolveResult expression, bool allowNullableConstants);
    private static string GetOverloadableOperatorName(BinaryOperatorType op);
    private ResolveResult ResolveNullCoalescingOperator(ResolveResult lhs, ResolveResult rhs);
    public IEnumerable`1<IParameterizedMember> GetUserDefinedOperatorCandidates(IType type, string operatorName);
    private void LiftUserDefinedOperators(List`1<IMethod> operators);
    private ResolveResult CreateResolveResultForUserDefinedOperator(OverloadResolution r, ExpressionType operatorType);
    private bool TryConvert(ResolveResult& rr, IType targetType);
    private bool TryConvertEnum(ResolveResult& rr, IType targetType, Boolean& isNullable, ResolveResult& enumRR, bool allowConversionFromConstantZero);
    private ResolveResult Convert(ResolveResult rr, IType targetType);
    private ResolveResult Convert(ResolveResult rr, IType targetType, Conversion c);
    public ResolveResult ResolveCast(IType targetType, ResolveResult expression);
    internal object CSharpPrimitiveCast(TypeCode targetType, object input);
    public ResolveResult ResolveSimpleName(string identifier, IReadOnlyList`1<IType> typeArguments, bool isInvocationTarget);
    public ResolveResult LookupSimpleNameOrTypeName(string identifier, IReadOnlyList`1<IType> typeArguments, NameLookupMode lookupMode);
    public bool IsVariableReferenceWithSameType(ResolveResult rr, string identifier, TypeResolveResult& trr);
    private ResolveResult LookInCurrentType(string identifier, IReadOnlyList`1<IType> typeArguments, NameLookupMode lookupMode, bool parameterizeResultType);
    private ResolveResult LookInCurrentUsingScope(string identifier, IReadOnlyList`1<IType> typeArguments, bool isInUsingDeclaration, bool parameterizeResultType);
    private ResolveResult LookInUsingScopeNamespace(ResolvedUsingScope usingScope, INamespace n, string identifier, IReadOnlyList`1<IType> typeArguments, bool parameterizeResultType);
    private bool TopLevelTypeDefinitionIsAccessible(ITypeDefinition typeDef);
    public ResolveResult ResolveAlias(string identifier);
    private ResolveResult ResolveExternAlias(string alias);
    public ResolveResult ResolveMemberAccess(ResolveResult target, string identifier, IReadOnlyList`1<IType> typeArguments, NameLookupMode lookupMode);
    private ResolveResult ResolveMemberAccessOnNamespace(NamespaceResolveResult nrr, string identifier, IReadOnlyList`1<IType> typeArguments, bool parameterizeResultType);
    public MemberLookup CreateMemberLookup();
    public MemberLookup CreateMemberLookup(NameLookupMode lookupMode);
    public ResolveResult ResolveIdentifierInObjectInitializer(string identifier);
    public ForEachResolveResult ResolveForeach(ResolveResult expression);
    private void CheckForEnumerableInterface(ResolveResult expression, IType& collectionType, IType& enumeratorType, IType& elementType, ResolveResult& getEnumeratorInvocation);
    public List`1<List`1<IMethod>> GetExtensionMethods(string name, IReadOnlyList`1<IType> typeArguments);
    public List`1<List`1<IMethod>> GetExtensionMethods(IType targetType, string name, IReadOnlyList`1<IType> typeArguments, bool substituteInferredTypes);
    public static bool IsEligibleExtensionMethod(IType targetType, IMethod method, bool useTypeInference, IType[]& outInferredTypes);
    private static bool IsEligibleExtensionMethod(ICompilation compilation, CSharpConversions conversions, IType targetType, IMethod method, bool useTypeInference, IType[]& outInferredTypes);
    private IList`1<List`1<IMethod>> GetAllExtensionMethods(MemberLookup lookup);
    private IEnumerable`1<IMethod> GetExtensionMethods(MemberLookup lookup, INamespace ns);
    private IList`1<ResolveResult> AddArgumentNamesIfNecessary(ResolveResult[] arguments, String[] argumentNames);
    private ResolveResult ResolveInvocation(ResolveResult target, ResolveResult[] arguments, String[] argumentNames, bool allowOptionalParameters);
    public ResolveResult ResolveInvocation(ResolveResult target, ResolveResult[] arguments, String[] argumentNames);
    private List`1<IParameter> CreateParameters(ResolveResult[] arguments, String[] argumentNames);
    private static string GuessParameterName(ResolveResult rr);
    private static string MakeParameterName(string variableName);
    private OverloadResolution CreateOverloadResolution(ResolveResult[] arguments, String[] argumentNames, IType[] typeArguments);
    public ResolveResult ResolveIndexer(ResolveResult target, ResolveResult[] arguments, String[] argumentNames);
    private void AdjustArrayAccessArguments(ResolveResult[] arguments);
    public ResolveResult ResolveObjectCreation(IType type, ResolveResult[] arguments, String[] argumentNames, bool allowProtectedAccess, IList`1<ResolveResult> initializerStatements);
    public ResolveResult ResolveSizeOf(IType type);
    public ResolveResult ResolveThisReference();
    public ResolveResult ResolveBaseReference();
    public ResolveResult ResolveCondition(ResolveResult input);
    public ResolveResult ResolveConditionFalse(ResolveResult input);
    public ResolveResult ResolveConditional(ResolveResult condition, ResolveResult trueExpression, ResolveResult falseExpression);
    private bool IsBetterConditionalConversion(Conversion c1, Conversion c2);
    private bool HasType(ResolveResult r);
    public ResolveResult ResolvePrimitive(object value);
    public ResolveResult ResolveDefaultValue(IType type);
    public static object GetDefaultValue(IType type);
    public ArrayCreateResolveResult ResolveArrayCreation(IType elementType, Int32[] sizeArguments, ResolveResult[] initializerElements);
    public ArrayCreateResolveResult ResolveArrayCreation(IType elementType, ResolveResult[] sizeArguments, ResolveResult[] initializerElements);
    public ResolveResult ResolveTypeOf(IType referencedType);
    public ResolveResult ResolveAssignment(AssignmentOperatorType op, ResolveResult lhs, ResolveResult rhs);
}
internal class ICSharpCode.Decompiler.CSharp.Resolver.DecompiledLambdaResolveResult : LambdaResolveResult {
    private ILFunction function;
    public IType DelegateType;
    public IType InferredReturnType;
    [CompilerGeneratedAttribute]
private bool <HasParameterList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnonymousMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicitlyTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveResult <Body>k__BackingField;
    public bool HasParameterList { get; }
    public bool IsAnonymousMethod { get; }
    public bool IsImplicitlyTyped { get; }
    public bool IsAsync { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ResolveResult Body { get; }
    public DecompiledLambdaResolveResult(ILFunction function, IType delegateType, IType inferredReturnType, bool hasParameterList, bool isAnonymousMethod, bool isImplicitlyTyped);
    [CompilerGeneratedAttribute]
public virtual bool get_HasParameterList();
    [CompilerGeneratedAttribute]
public virtual bool get_IsAnonymousMethod();
    [CompilerGeneratedAttribute]
public virtual bool get_IsImplicitlyTyped();
    public virtual bool get_IsAsync();
    public virtual IReadOnlyList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    [CompilerGeneratedAttribute]
public virtual ResolveResult get_Body();
    public virtual IType GetInferredReturnType(IType[] parameterTypes);
    public virtual Conversion IsValid(IType[] parameterTypes, IType returnType, CSharpConversions conversions);
}
public class ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationResolveResult : ResolveResult {
    public ResolveResult Target;
    public DynamicInvocationType InvocationType;
    public IList`1<ResolveResult> Arguments;
    public IList`1<ResolveResult> InitializerStatements;
    public DynamicInvocationResolveResult(ResolveResult target, DynamicInvocationType invocationType, IList`1<ResolveResult> arguments, IList`1<ResolveResult> initializerStatements);
    public virtual string ToString();
}
public enum ICSharpCode.Decompiler.CSharp.Resolver.DynamicInvocationType : Enum {
    public int value__;
    public static DynamicInvocationType Invocation;
    public static DynamicInvocationType Indexing;
    public static DynamicInvocationType ObjectCreation;
}
public class ICSharpCode.Decompiler.CSharp.Resolver.DynamicMemberResolveResult : ResolveResult {
    public ResolveResult Target;
    public string Member;
    public DynamicMemberResolveResult(ResolveResult target, string member);
    public virtual string ToString();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public interface ICSharpCode.Decompiler.CSharp.Resolver.ILiftedOperator {
    [NullableAttribute("1")]
public IType NonLiftedReturnType { get; }
    [NullableAttribute("1")]
public IReadOnlyList`1<IParameter> NonLiftedParameters { get; }
    [NullableContextAttribute("1")]
public abstract virtual IType get_NonLiftedReturnType();
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyList`1<IParameter> get_NonLiftedParameters();
}
internal class ICSharpCode.Decompiler.CSharp.Resolver.LambdaConversion : Conversion {
    public static LambdaConversion Instance;
    public bool IsAnonymousFunctionConversion { get; }
    public bool IsImplicit { get; }
    private static LambdaConversion();
    public virtual bool get_IsAnonymousFunctionConversion();
    public virtual bool get_IsImplicit();
}
public abstract class ICSharpCode.Decompiler.CSharp.Resolver.LambdaResolveResult : ResolveResult {
    public bool HasParameterList { get; }
    public bool IsAnonymousMethod { get; }
    public bool IsImplicitlyTyped { get; }
    public bool IsAsync { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ResolveResult Body { get; }
    public abstract virtual bool get_HasParameterList();
    public abstract virtual bool get_IsAnonymousMethod();
    public abstract virtual bool get_IsImplicitlyTyped();
    public abstract virtual bool get_IsAsync();
    public abstract virtual IType GetInferredReturnType(IType[] parameterTypes);
    public abstract virtual IReadOnlyList`1<IParameter> get_Parameters();
    public abstract virtual IType get_ReturnType();
    public abstract virtual Conversion IsValid(IType[] parameterTypes, IType returnType, CSharpConversions conversions);
    public abstract virtual ResolveResult get_Body();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
internal static class ICSharpCode.Decompiler.CSharp.Resolver.Log : object {
    private static bool logEnabled;
    [ConditionalAttribute("LOG_DISABLED")]
internal static void WriteLine(string text);
    [ConditionalAttribute("LOG_DISABLED")]
internal static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("LOG_DISABLED")]
internal static void WriteCollection(string text, IEnumerable`1<T> lines);
    [ConditionalAttribute("LOG_DISABLED")]
public static void Indent();
    [ConditionalAttribute("LOG_DISABLED")]
public static void Unindent();
}
public class ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup : object {
    private ITypeDefinition currentTypeDefinition;
    private IModule currentModule;
    private bool isInEnumMemberInitializer;
    public MemberLookup(ITypeDefinition currentTypeDefinition, IModule currentModule, bool isInEnumMemberInitializer);
    public static bool IsInvocable(IMember member);
    public bool IsProtectedAccessAllowed(ResolveResult targetResolveResult);
    public bool IsProtectedAccessAllowed(IType targetType);
    public bool IsAccessible(IEntity entity, bool allowProtectedAccess);
    private bool IsInternalAccessible(IModule module);
    private bool IsProtectedAccessible(bool allowProtectedAccess, IEntity entity);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Resolver.MemberLookup/<GetAccessibleMembers>d__10")]
public IEnumerable`1<IEntity> GetAccessibleMembers(ResolveResult targetResolveResult);
    public ResolveResult LookupType(IType declaringType, string name, IReadOnlyList`1<IType> typeArguments, bool parameterizeResultType);
    private static int InnerTypeParameterCount(IType type);
    public ResolveResult Lookup(ResolveResult targetResolveResult, string name, IReadOnlyList`1<IType> typeArguments, bool isInvocation);
    public IReadOnlyList`1<MethodListWithDeclaringType> LookupIndexers(ResolveResult targetResolveResult);
    private void AddNestedTypes(IType type, IEnumerable`1<IType> nestedTypes, int typeArgumentCount, List`1<LookupGroup> lookupGroups, IEnumerable`1& typeBaseTypes, List`1& newNestedTypes);
    private void AddMembers(IType type, IEnumerable`1<IMember> members, bool allowProtectedAccess, List`1<LookupGroup> lookupGroups, bool treatAllParameterizedMembersAsMethods, IEnumerable`1& typeBaseTypes, List`1& newMethods, IMember& newNonMethod);
    private void RemoveInterfaceMembersHiddenByClassMembers(List`1<LookupGroup> lookupGroups);
    private static bool IsInterfaceOrSystemObject(IType type);
    private ResolveResult CreateResult(ResolveResult targetResolveResult, List`1<LookupGroup> lookupGroups, string name, IReadOnlyList`1<IType> typeArguments);
}
public class ICSharpCode.Decompiler.CSharp.Resolver.MethodGroupResolveResult : ResolveResult {
    private IReadOnlyList`1<MethodListWithDeclaringType> methodLists;
    private IReadOnlyList`1<IType> typeArguments;
    private ResolveResult targetResult;
    private string methodName;
    internal List`1<List`1<IMethod>> extensionMethods;
    internal CSharpResolver resolver;
    public ResolveResult TargetResult { get; }
    public IType TargetType { get; }
    public string MethodName { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<MethodListWithDeclaringType> MethodsGroupedByDeclaringType { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public MethodGroupResolveResult(ResolveResult targetResult, string methodName, IReadOnlyList`1<MethodListWithDeclaringType> methods, IReadOnlyList`1<IType> typeArguments);
    public ResolveResult get_TargetResult();
    public IType get_TargetType();
    public string get_MethodName();
    public IEnumerable`1<IMethod> get_Methods();
    public IEnumerable`1<MethodListWithDeclaringType> get_MethodsGroupedByDeclaringType();
    public IReadOnlyList`1<IType> get_TypeArguments();
    public IEnumerable`1<IEnumerable`1<IMethod>> GetExtensionMethods();
    public IEnumerable`1<IEnumerable`1<IMethod>> GetEligibleExtensionMethods(bool substituteInferredTypes);
    public virtual string ToString();
    public OverloadResolution PerformOverloadResolution(ICompilation compilation, ResolveResult[] arguments, String[] argumentNames, bool allowExtensionMethods, bool allowExpandingParams, bool allowOptionalParameters, bool allowImplicitIn, bool checkForOverflow, CSharpConversions conversions);
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.CSharp.Resolver.MethodListWithDeclaringType : List`1<IParameterizedMember> {
    private IType declaringType;
    public IType DeclaringType { get; }
    public MethodListWithDeclaringType(IType declaringType);
    public MethodListWithDeclaringType(IType declaringType, IEnumerable`1<IParameterizedMember> methods);
    public IType get_DeclaringType();
}
public enum ICSharpCode.Decompiler.CSharp.Resolver.NameLookupMode : Enum {
    public int value__;
    public static NameLookupMode Expression;
    public static NameLookupMode InvocationTarget;
    public static NameLookupMode Type;
    public static NameLookupMode TypeInUsingDeclaration;
    public static NameLookupMode BaseTypeReference;
}
public class ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolution : object {
    private ICompilation compilation;
    private ResolveResult[] arguments;
    private String[] argumentNames;
    private CSharpConversions conversions;
    private Candidate bestCandidate;
    private Candidate bestCandidateAmbiguousWith;
    private IType[] explicitlyGivenTypeArguments;
    private bool bestCandidateWasValidated;
    private OverloadResolutionErrors bestCandidateValidationResult;
    [CompilerGeneratedAttribute]
private bool <IsExtensionMethodInvocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowExpandingParams>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowOptionalParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitIn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckForOverflow>k__BackingField;
    public bool IsExtensionMethodInvocation { get; public set; }
    public bool AllowExpandingParams { get; public set; }
    public bool AllowOptionalParameters { get; public set; }
    public bool AllowImplicitIn { get; public set; }
    public bool CheckForOverflow { get; public set; }
    public IList`1<ResolveResult> Arguments { get; }
    public IParameterizedMember BestCandidate { get; }
    public OverloadResolutionErrors BestCandidateErrors { get; }
    public bool FoundApplicableCandidate { get; }
    public IParameterizedMember BestCandidateAmbiguousWith { get; }
    public bool BestCandidateIsExpandedForm { get; }
    public bool IsAmbiguous { get; }
    public IReadOnlyList`1<IType> InferredTypeArguments { get; }
    public IList`1<Conversion> ArgumentConversions { get; }
    public OverloadResolution(ICompilation compilation, ResolveResult[] arguments, String[] argumentNames, IType[] typeArguments, CSharpConversions conversions);
    [CompilerGeneratedAttribute]
public bool get_IsExtensionMethodInvocation();
    [CompilerGeneratedAttribute]
public void set_IsExtensionMethodInvocation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowExpandingParams();
    [CompilerGeneratedAttribute]
public void set_AllowExpandingParams(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowOptionalParameters();
    [CompilerGeneratedAttribute]
public void set_AllowOptionalParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitIn();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitIn(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckForOverflow();
    [CompilerGeneratedAttribute]
public void set_CheckForOverflow(bool value);
    public IList`1<ResolveResult> get_Arguments();
    public OverloadResolutionErrors AddCandidate(IParameterizedMember member);
    public OverloadResolutionErrors AddCandidate(IParameterizedMember member, OverloadResolutionErrors additionalErrors);
    private bool CalculateCandidate(Candidate candidate);
    private bool ResolveParameterTypes(Candidate candidate, bool useSpecializedParameters);
    public void AddMethodLists(IReadOnlyList`1<MethodListWithDeclaringType> methodLists);
    [ConditionalAttribute("DEBUG")]
internal void LogCandidateAddingResult(string text, IParameterizedMember method, OverloadResolutionErrors errors);
    private void MapCorrespondingParameters(Candidate candidate);
    private void RunTypeInference(Candidate candidate);
    private OverloadResolutionErrors ValidateMethodConstraints(Candidate candidate);
    public static bool ValidateConstraints(ITypeParameter typeParameter, IType typeArgument, TypeVisitor substitution);
    internal static bool ValidateConstraints(ITypeParameter typeParameter, IType typeArgument, TypeVisitor substitution, CSharpConversions conversions);
    public static bool IsApplicable(OverloadResolutionErrors errors);
    private void CheckApplicability(Candidate candidate);
    private int BetterFunctionMember(Candidate c1, Candidate c2);
    private int MoreSpecificFormalParameters(Candidate c1, Candidate c2);
    private static int MoreSpecificFormalParameters(IEnumerable`1<IType> t1, IEnumerable`1<IType> t2);
    private static int MoreSpecificFormalParameter(IType t1, IType t2);
    private void ConsiderIfNewCandidateIsBest(Candidate candidate);
    public IParameterizedMember get_BestCandidate();
    public OverloadResolutionErrors get_BestCandidateErrors();
    public bool get_FoundApplicableCandidate();
    public IParameterizedMember get_BestCandidateAmbiguousWith();
    public bool get_BestCandidateIsExpandedForm();
    public bool get_IsAmbiguous();
    public IReadOnlyList`1<IType> get_InferredTypeArguments();
    public IList`1<Conversion> get_ArgumentConversions();
    public IReadOnlyList`1<int> GetArgumentToParameterMap();
    public IList`1<ResolveResult> GetArgumentsWithConversions();
    public IList`1<ResolveResult> GetArgumentsWithConversionsAndNames();
    private IList`1<ResolveResult> GetArgumentsWithConversions(ResolveResult targetResolveResult, IParameterizedMember bestCandidateForNamedArguments);
    public IParameterizedMember GetBestCandidateWithSubstitutedTypeArguments();
    private TypeParameterSubstitution GetSubstitution(Candidate candidate);
    public CSharpInvocationResolveResult CreateResolveResult(ResolveResult targetResolveResult, IList`1<ResolveResult> initializerStatements, IType returnTypeOverride);
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.CSharp.Resolver.OverloadResolutionErrors : Enum {
    public int value__;
    public static OverloadResolutionErrors None;
    public static OverloadResolutionErrors TooManyPositionalArguments;
    public static OverloadResolutionErrors NoParameterFoundForNamedArgument;
    public static OverloadResolutionErrors TypeInferenceFailed;
    public static OverloadResolutionErrors WrongNumberOfTypeArguments;
    public static OverloadResolutionErrors ConstructedTypeDoesNotSatisfyConstraint;
    public static OverloadResolutionErrors MissingArgumentForRequiredParameter;
    public static OverloadResolutionErrors MultipleArgumentsForSingleParameter;
    public static OverloadResolutionErrors ParameterPassingModeMismatch;
    public static OverloadResolutionErrors ArgumentTypeMismatch;
    public static OverloadResolutionErrors AmbiguousMatch;
    public static OverloadResolutionErrors Inaccessible;
    public static OverloadResolutionErrors MethodConstraintsNotSatisfied;
    public static OverloadResolutionErrors OutVarTypeMismatch;
}
public class ICSharpCode.Decompiler.CSharp.Resolver.TypeInference : object {
    private ICompilation compilation;
    private CSharpConversions conversions;
    private TypeInferenceAlgorithm algorithm;
    private static int maxNestingLevel;
    private int nestingLevel;
    private TP[] typeParameters;
    private IType[] parameterTypes;
    private ResolveResult[] arguments;
    private Boolean[0...,0...] dependencyMatrix;
    private IReadOnlyList`1<IType> classTypeArguments;
    public TypeInferenceAlgorithm Algorithm { get; public set; }
    public TypeInference(ICompilation compilation);
    internal TypeInference(ICompilation compilation, CSharpConversions conversions);
    public TypeInferenceAlgorithm get_Algorithm();
    public void set_Algorithm(TypeInferenceAlgorithm value);
    private TypeInference CreateNestedInstance();
    public IType[] InferTypeArguments(IReadOnlyList`1<ITypeParameter> typeParameters, IReadOnlyList`1<ResolveResult> arguments, IReadOnlyList`1<IType> parameterTypes, Boolean& success, IReadOnlyList`1<IType> classTypeArguments);
    private void Reset();
    public IType[] InferTypeArgumentsFromBounds(IReadOnlyList`1<ITypeParameter> typeParameters, IType targetType, IEnumerable`1<IType> lowerBounds, IEnumerable`1<IType> upperBounds, Boolean& success);
    private void PhaseOne();
    private static bool IsValidType(IType type);
    private bool PhaseTwo();
    private IType[] InputTypes(ResolveResult e, IType t);
    private IType[] OutputTypes(ResolveResult e, IType t);
    private static IMethod GetDelegateOrExpressionTreeSignature(IType t);
    private bool InputTypesContainsUnfixed(ResolveResult argument, IType parameterType);
    private bool OutputTypeContainsUnfixed(ResolveResult argument, IType parameterType);
    private bool AnyTypeContainsUnfixedParameter(IEnumerable`1<IType> types);
    private void CalculateDependencyMatrix();
    private bool DependsOn(TP x, TP y);
    private void MakeOutputTypeInference(ResolveResult e, IType t);
    private TypeParameterSubstitution GetSubstitutionForFixedTPs();
    private void MakeExplicitParameterTypeInference(LambdaResolveResult e, IType t);
    private void MakeExactInference(IType U, IType V);
    private TP GetTPForType(IType v);
    private void MakeLowerBoundInference(IType U, IType V);
    private static bool IsGenericInterfaceImplementedByArray(ParameterizedType rt);
    private void MakeUpperBoundInference(IType U, IType V);
    private bool Fix(TP tp);
    public IType GetBestCommonType(IList`1<ResolveResult> expressions, Boolean& success);
    public IType FindTypeInBounds(IReadOnlyList`1<IType> lowerBounds, IReadOnlyList`1<IType> upperBounds);
    private static IType GetFirstTypePreferNonInterfaces(IReadOnlyList`1<IType> result);
    private IReadOnlyList`1<IType> FindTypesInBounds(IReadOnlyList`1<IType> lowerBounds, IReadOnlyList`1<IType> upperBounds);
}
public enum ICSharpCode.Decompiler.CSharp.Resolver.TypeInferenceAlgorithm : Enum {
    public int value__;
    public static TypeInferenceAlgorithm CSharp4;
    public static TypeInferenceAlgorithm Improved;
    public static TypeInferenceAlgorithm ImprovedReturnAllResults;
}
internal class ICSharpCode.Decompiler.CSharp.SequencePointBuilder : DepthFirstAstVisitor {
    private List`1<ValueTuple`2<ILFunction, SequencePoint>> sequencePoints;
    private HashSet`1<ILInstruction> mappedInstructions;
    private Stack`1<StatePerSequencePoint> outerStates;
    private StatePerSequencePoint current;
    private void VisitAsSequencePoint(AstNode node);
    protected virtual void VisitChildren(AstNode node);
    public virtual void VisitBlockStatement(BlockStatement blockStatement);
    public virtual void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public virtual void VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    public virtual void VisitForStatement(ForStatement forStatement);
    public virtual void VisitSwitchStatement(SwitchStatement switchStatement);
    public virtual void VisitSwitchSection(SwitchSection switchSection);
    public virtual void VisitLambdaExpression(LambdaExpression lambdaExpression);
    public virtual void VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause);
    public virtual void VisitQueryFromClause(QueryFromClause queryFromClause);
    public virtual void VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public virtual void VisitQueryJoinClause(QueryJoinClause queryJoinClause);
    public virtual void VisitQueryLetClause(QueryLetClause queryLetClause);
    public virtual void VisitQueryOrdering(QueryOrdering queryOrdering);
    public virtual void VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public virtual void VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    public virtual void VisitUsingStatement(UsingStatement usingStatement);
    public virtual void VisitForeachStatement(ForeachStatement foreachStatement);
    public virtual void VisitLockStatement(LockStatement lockStatement);
    public virtual void VisitIfElseStatement(IfElseStatement ifElseStatement);
    public virtual void VisitWhileStatement(WhileStatement whileStatement);
    public virtual void VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public virtual void VisitFixedStatement(FixedStatement fixedStatement);
    public virtual void VisitTryCatchStatement(TryCatchStatement tryCatchStatement);
    public virtual void VisitCatchClause(CatchClause catchClause);
    private void StartSequencePoint(AstNode primaryNode);
    private void EndSequencePoint(TextLocation startLocation, TextLocation endLocation);
    private void AddToSequencePointRaw(ILFunction function, IEnumerable`1<Interval> ranges);
    private void AddToSequencePoint(AstNode node);
    private void AddToSequencePoint(ILInstruction inst);
    internal static bool HasUsableILRange(ILInstruction inst);
    internal Dictionary`2<ILFunction, List`1<SequencePoint>> GetSequencePoints();
}
internal class ICSharpCode.Decompiler.CSharp.StatementBuilder : ILVisitor`1<TranslatedStatement> {
    internal ExpressionBuilder exprBuilder;
    private ILFunction currentFunction;
    private IDecompilerTypeSystem typeSystem;
    internal DecompileRun decompileRun;
    private DecompilerSettings settings;
    private CancellationToken cancellationToken;
    internal BlockContainer currentReturnContainer;
    internal IType currentResultType;
    internal bool currentIsIterator;
    private Block continueTarget;
    private int continueCount;
    private Dictionary`2<Block, ConstantResolveResult> caseLabelMapping;
    private BlockContainer breakTarget;
    private Dictionary`2<BlockContainer, string> endContainerLabels;
    private static InvocationExpression getEnumeratorPattern;
    private static InvocationExpression extensionGetEnumeratorPattern;
    private static Expression moveNextConditionPattern;
    private Dictionary`2<Block, string> labels;
    private Dictionary`2<string, int> duplicateLabels;
    public StatementBuilder(IDecompilerTypeSystem typeSystem, ITypeResolveContext decompilationContext, ILFunction currentFunction, DecompilerSettings settings, DecompileRun decompileRun, CancellationToken cancellationToken);
    private static StatementBuilder();
    public Statement Convert(ILInstruction inst);
    public BlockStatement ConvertAsBlock(ILInstruction inst);
    protected virtual TranslatedStatement Default(ILInstruction inst);
    protected internal virtual TranslatedStatement VisitIsInst(IsInst inst);
    protected internal virtual TranslatedStatement VisitStLoc(StLoc inst);
    protected internal virtual TranslatedStatement VisitStObj(StObj inst);
    protected internal virtual TranslatedStatement VisitNop(Nop inst);
    protected internal virtual TranslatedStatement VisitIfInstruction(IfInstruction inst);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.StatementBuilder/<CreateTypedCaseLabel>d__18")]
internal IEnumerable`1<ConstantResolveResult> CreateTypedCaseLabel(long i, IType type, List`1<ValueTuple`2<string, int>> map);
    protected internal virtual TranslatedStatement VisitSwitchInstruction(SwitchInstruction inst);
    private SwitchStatement TranslateSwitch(BlockContainer switchContainer, SwitchInstruction inst);
    private void ConvertSwitchSectionBody(SwitchSection astSection, ILInstruction bodyInst);
    protected internal virtual TranslatedStatement VisitBranch(Branch inst);
    protected internal virtual TranslatedStatement VisitLeave(Leave inst);
    protected internal virtual TranslatedStatement VisitThrow(Throw inst);
    protected internal virtual TranslatedStatement VisitRethrow(Rethrow inst);
    protected internal virtual TranslatedStatement VisitYieldReturn(YieldReturn inst);
    private TryCatchStatement MakeTryCatch(ILInstruction tryBlock);
    protected internal virtual TranslatedStatement VisitTryCatch(TryCatch inst);
    protected internal virtual TranslatedStatement VisitTryFinally(TryFinally inst);
    protected internal virtual TranslatedStatement VisitTryFault(TryFault inst);
    protected internal virtual TranslatedStatement VisitLockInstruction(LockInstruction inst);
    protected internal virtual TranslatedStatement VisitUsingInstruction(UsingInstruction inst);
    private Statement TransformToForeach(UsingInstruction inst, Expression resource);
    internal static VariableDesignation TranslateDeconstructionDesignation(DeconstructInstruction inst, bool isForeach);
    private static bool EqualErasedType(IType a, IType b);
    private bool IsDynamicCastToIEnumerable(Expression expr, Expression& dynamicExpr);
    private BlockContainer UnwrapNestedContainerIfPossible(BlockContainer container, Leave& optionalLeaveInst);
    private RequiredGetCurrentTransformation DetectGetCurrentTransformation(BlockContainer usingContainer, Block loopBody, BlockContainer loopContainer, ILVariable enumerator, ILInstruction moveNextUsage, CallInstruction& singleGetter, ILVariable& foreachVariable);
    private bool CanBeDeconstructedInForeach(DeconstructInstruction deconstruction, ILInstruction singleGetter, BlockContainer usingContainer, BlockContainer loopContainer);
    private bool VariableIsOnlyUsedInBlock(StLoc storeInst, BlockContainer usingContainer, BlockContainer loopContainer);
    private bool CurrentIsStructSetterTarget(ILInstruction inst, CallInstruction singleGetter);
    private bool IsTargetOfSetterCall(ILInstruction inst, IType targetType);
    private bool ParentIsCurrentGetter(ILInstruction inst);
    protected internal virtual TranslatedStatement VisitPinnedRegion(PinnedRegion inst);
    private static bool IsAddressOfMoveableVar(Expression initExpr);
    private static bool IsFixedSizeBuffer(Expression initExpr);
    protected internal virtual TranslatedStatement VisitBlock(Block block);
    protected internal virtual TranslatedStatement VisitBlockContainer(BlockContainer container);
    private Statement ConvertLoop(BlockContainer container);
    private BlockStatement ConvertBlockContainer(BlockContainer container, bool isLoop);
    private void DeclareLocalFunctions(ILFunction currentFunction, BlockContainer container, BlockStatement blockStatement);
    private BlockStatement ConvertBlockContainer(BlockStatement blockStatement, BlockContainer container, IEnumerable`1<Block> blocks, bool isLoop);
    private string EnsureUniqueLabel(Block block);
    private static bool IsFinalLeave(Leave leave);
    protected internal virtual TranslatedStatement VisitInitblk(Initblk inst);
    protected internal virtual TranslatedStatement VisitCpblk(Cpblk inst);
    [CompilerGeneratedAttribute]
internal static bool <VisitUsingInstruction>g__IsValidInCSharp|40_0(UsingInstruction inst, KnownTypeCode code, <>c__DisplayClass40_0& );
    [CompilerGeneratedAttribute]
internal static VariableDesignation <TranslateDeconstructionDesignation>g__ConstructDesignation|42_0(MatchInstruction matchInstruction, <>c__DisplayClass42_0& );
    [CompilerGeneratedAttribute]
private LocalFunctionDeclarationStatement <DeclareLocalFunctions>g__TranslateFunction|60_0(ILFunction function);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.AbstractAnnotatable : object {
    private object annotations;
    public IEnumerable`1<object> Annotations { get; }
    protected void CloneAnnotations();
    public virtual void AddAnnotation(object annotation);
    public virtual void RemoveAnnotations();
    public virtual void RemoveAnnotations(Type type);
    public sealed virtual T Annotation();
    public sealed virtual object Annotation(Type type);
    public sealed virtual IEnumerable`1<object> get_Annotations();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.Accessor : EntityDeclaration {
    public static Accessor Null;
    public NodeType NodeType { get; }
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode Keyword { get; }
    public BlockStatement Body { get; public set; }
    private static Accessor();
    public virtual NodeType get_NodeType();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_Keyword();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.AnonymousMethodExpression : Expression {
    public static TokenRole DelegateKeywordRole;
    public static TokenRole AsyncModifierRole;
    private bool isAsync;
    private bool hasParameterList;
    public bool IsAsync { get; public set; }
    public bool HasParameterList { get; public set; }
    public CSharpTokenNode DelegateToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public CSharpTokenNode RParToken { get; }
    public BlockStatement Body { get; public set; }
    public AnonymousMethodExpression(BlockStatement body, IEnumerable`1<ParameterDeclaration> parameters);
    public AnonymousMethodExpression(BlockStatement body, ParameterDeclaration[] parameters);
    private static AnonymousMethodExpression();
    public bool get_IsAsync();
    public void set_IsAsync(bool value);
    public bool get_HasParameterList();
    public void set_HasParameterList(bool value);
    public CSharpTokenNode get_DelegateToken();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public CSharpTokenNode get_RParToken();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.AnonymousTypeCreateExpression : Expression {
    public static TokenRole NewKeywordRole;
    public CSharpTokenNode NewToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<Expression> Initializers { get; }
    public CSharpTokenNode RParToken { get; }
    public AnonymousTypeCreateExpression(IEnumerable`1<Expression> initializers);
    public AnonymousTypeCreateExpression(Expression[] initializer);
    private static AnonymousTypeCreateExpression();
    public CSharpTokenNode get_NewToken();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<Expression> get_Initializers();
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ArrayCreateExpression : Expression {
    public static TokenRole NewKeywordRole;
    public static Role`1<ArraySpecifier> AdditionalArraySpecifierRole;
    public static Role`1<ArrayInitializerExpression> InitializerRole;
    public CSharpTokenNode NewToken { get; }
    public AstType Type { get; public set; }
    public AstNodeCollection`1<Expression> Arguments { get; }
    public AstNodeCollection`1<ArraySpecifier> AdditionalArraySpecifiers { get; }
    public ArrayInitializerExpression Initializer { get; public set; }
    private static ArrayCreateExpression();
    public CSharpTokenNode get_NewToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public AstNodeCollection`1<Expression> get_Arguments();
    public AstNodeCollection`1<ArraySpecifier> get_AdditionalArraySpecifiers();
    public ArrayInitializerExpression get_Initializer();
    public void set_Initializer(ArrayInitializerExpression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ArrayInitializerExpression : Expression {
    public static ArrayInitializerExpression Null;
    public bool IsSingleElement { get; }
    public CSharpTokenNode LBraceToken { get; }
    public AstNodeCollection`1<Expression> Elements { get; }
    public CSharpTokenNode RBraceToken { get; }
    public ArrayInitializerExpression(IEnumerable`1<Expression> elements);
    public ArrayInitializerExpression(Expression[] elements);
    private static ArrayInitializerExpression();
    public virtual bool get_IsSingleElement();
    public CSharpTokenNode get_LBraceToken();
    public AstNodeCollection`1<Expression> get_Elements();
    public CSharpTokenNode get_RBraceToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public static ArrayInitializerExpression CreateSingleElementInitializer();
    public static ArrayInitializerExpression op_Implicit(Pattern pattern);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ArraySpecifier : AstNode {
    public NodeType NodeType { get; }
    public CSharpTokenNode LBracketToken { get; }
    public int Dimensions { get; public set; }
    public CSharpTokenNode RBracketToken { get; }
    public ArraySpecifier(int dimensions);
    public virtual NodeType get_NodeType();
    public CSharpTokenNode get_LBracketToken();
    public int get_Dimensions();
    public void set_Dimensions(int value);
    public CSharpTokenNode get_RBracketToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual string ToString(CSharpFormattingOptions formattingOptions);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.AsExpression : Expression {
    public static TokenRole AsKeywordRole;
    public Expression Expression { get; public set; }
    public CSharpTokenNode AsToken { get; }
    public AstType Type { get; public set; }
    public AsExpression(Expression expression, AstType type);
    private static AsExpression();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_AsToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.AssignmentExpression : Expression {
    public static Role`1<Expression> LeftRole;
    public static Role`1<Expression> RightRole;
    public static TokenRole AssignRole;
    public static TokenRole AddRole;
    public static TokenRole SubtractRole;
    public static TokenRole MultiplyRole;
    public static TokenRole DivideRole;
    public static TokenRole ModulusRole;
    public static TokenRole ShiftLeftRole;
    public static TokenRole ShiftRightRole;
    public static TokenRole UnsignedShiftRightRole;
    public static TokenRole BitwiseAndRole;
    public static TokenRole BitwiseOrRole;
    public static TokenRole ExclusiveOrRole;
    [CompilerGeneratedAttribute]
private AssignmentOperatorType <Operator>k__BackingField;
    public AssignmentOperatorType Operator { get; public set; }
    public Expression Left { get; public set; }
    public CSharpTokenNode OperatorToken { get; }
    public Expression Right { get; public set; }
    public AssignmentExpression(Expression left, Expression right);
    public AssignmentExpression(Expression left, AssignmentOperatorType op, Expression right);
    private static AssignmentExpression();
    [CompilerGeneratedAttribute]
public AssignmentOperatorType get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(AssignmentOperatorType value);
    public Expression get_Left();
    public void set_Left(Expression value);
    public CSharpTokenNode get_OperatorToken();
    public Expression get_Right();
    public void set_Right(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public static TokenRole GetOperatorRole(AssignmentOperatorType op);
    public static Nullable`1<BinaryOperatorType> GetCorrespondingBinaryOperator(AssignmentOperatorType op);
    public static ExpressionType GetLinqNodeType(AssignmentOperatorType op, bool checkForOverflow);
    public static Nullable`1<AssignmentOperatorType> GetAssignmentOperatorTypeFromExpressionType(ExpressionType expressionType);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.AssignmentOperatorType : Enum {
    public int value__;
    public static AssignmentOperatorType Assign;
    public static AssignmentOperatorType Add;
    public static AssignmentOperatorType Subtract;
    public static AssignmentOperatorType Multiply;
    public static AssignmentOperatorType Divide;
    public static AssignmentOperatorType Modulus;
    public static AssignmentOperatorType ShiftLeft;
    public static AssignmentOperatorType ShiftRight;
    public static AssignmentOperatorType UnsignedShiftRight;
    public static AssignmentOperatorType BitwiseAnd;
    public static AssignmentOperatorType BitwiseOr;
    public static AssignmentOperatorType ExclusiveOr;
    public static AssignmentOperatorType Any;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.AstNode : AbstractAnnotatable {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Role`1<AstNode> RootRole;
    public static AstNode Null;
    [NullableAttribute("2")]
private AstNode parent;
    [NullableAttribute("2")]
private AstNode prevSibling;
    [NullableAttribute("2")]
private AstNode nextSibling;
    [NullableAttribute("2")]
private AstNode firstChild;
    [NullableAttribute("2")]
private AstNode lastChild;
    protected UInt32 flags;
    private static UInt32 roleIndexMask;
    private static UInt32 frozenBit;
    protected static int AstNodeFlagsUsedBits;
    public bool IsFrozen { get; }
    public NodeType NodeType { get; }
    public bool IsNull { get; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    [NullableAttribute("2")]
public AstNode Parent { get; }
    public Role Role { get; public set; }
    internal UInt32 RoleIndex { get; }
    [NullableAttribute("2")]
public AstNode NextSibling { get; }
    [NullableAttribute("2")]
public AstNode PrevSibling { get; }
    [NullableAttribute("2")]
public AstNode FirstChild { get; }
    [NullableAttribute("2")]
public AstNode LastChild { get; }
    public bool HasChildren { get; }
    public IEnumerable`1<AstNode> Children { get; }
    public IEnumerable`1<AstNode> Ancestors { get; }
    public IEnumerable`1<AstNode> AncestorsAndSelf { get; }
    public IEnumerable`1<AstNode> Descendants { get; }
    public IEnumerable`1<AstNode> DescendantsAndSelf { get; }
    [NullableAttribute("2")]
private INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.NextSibling { get; }
    [NullableAttribute("2")]
private INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.FirstChild { get; }
    private static AstNode();
    [NullableContextAttribute("2")]
public static AstNode op_Implicit(Pattern pattern);
    public sealed virtual bool get_IsFrozen();
    public sealed virtual void Freeze();
    protected void ThrowIfFrozen();
    public abstract virtual NodeType get_NodeType();
    public virtual bool get_IsNull();
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    [NullableContextAttribute("2")]
public AstNode get_Parent();
    public sealed virtual Role get_Role();
    public void set_Role(Role value);
    internal UInt32 get_RoleIndex();
    private void SetRole(Role role);
    [NullableContextAttribute("2")]
public AstNode get_NextSibling();
    [NullableContextAttribute("2")]
public AstNode get_PrevSibling();
    [NullableContextAttribute("2")]
public AstNode get_FirstChild();
    [NullableContextAttribute("2")]
public AstNode get_LastChild();
    public bool get_HasChildren();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.AstNode/<get_Children>d__46")]
public IEnumerable`1<AstNode> get_Children();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.AstNode/<get_Ancestors>d__48")]
public IEnumerable`1<AstNode> get_Ancestors();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.AstNode/<get_AncestorsAndSelf>d__50")]
public IEnumerable`1<AstNode> get_AncestorsAndSelf();
    public IEnumerable`1<AstNode> get_Descendants();
    public IEnumerable`1<AstNode> get_DescendantsAndSelf();
    public IEnumerable`1<AstNode> DescendantNodes(Func`2<AstNode, bool> descendIntoChildren);
    public IEnumerable`1<AstNode> DescendantNodesAndSelf(Func`2<AstNode, bool> descendIntoChildren);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.AstNode/<GetDescendantsImpl>d__57")]
private IEnumerable`1<AstNode> GetDescendantsImpl(bool includeSelf, Func`2<AstNode, bool> descendIntoChildren);
    public T GetChildByRole(Role`1<T> role);
    [NullableContextAttribute("0")]
public T GetParent();
    [NullableContextAttribute("2")]
public AstNode GetParent(Func`2<AstNode, bool> pred);
    public AstNodeCollection`1<T> GetChildrenByRole(Role`1<T> role);
    protected void SetChildByRole(Role`1<T> role, T newChild);
    public void AddChild(T child, Role`1<T> role);
    [NullableContextAttribute("2")]
public void AddChildWithExistingRole(AstNode child);
    internal void AddChildUnsafe(AstNode child, Role role);
    public void InsertChildBefore(AstNode nextSibling, T child, Role`1<T> role);
    internal void InsertChildBeforeUnsafe(AstNode nextSibling, AstNode child, Role role);
    public void InsertChildAfter(AstNode prevSibling, T child, Role`1<T> role);
    public void Remove();
    [NullableContextAttribute("2")]
public void ReplaceWith(AstNode newNode);
    [NullableContextAttribute("2")]
public AstNode ReplaceWith(Func`2<AstNode, AstNode> replaceFunction);
    public AstNode Clone();
    private sealed virtual override object System.ICloneable.Clone();
    public abstract virtual void AcceptVisitor(IAstVisitor visitor);
    public abstract virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public abstract virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    [NullableContextAttribute("2")]
protected static bool MatchString(string pattern, string text);
    [NullableContextAttribute("2")]
protected internal abstract virtual bool DoMatch(AstNode other, Match match);
    [NullableContextAttribute("2")]
private sealed virtual override bool ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.DoMatch(INode other, Match match);
    [NullableContextAttribute("2")]
private sealed virtual override bool ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.DoMatchCollection(Role role, INode pos, Match match, BacktrackingInfo backtrackingInfo);
    [NullableContextAttribute("2")]
private sealed virtual override INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.get_NextSibling();
    [NullableContextAttribute("2")]
private sealed virtual override INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.get_FirstChild();
    [NullableContextAttribute("2")]
public AstNode GetNextNode();
    public AstNode GetNextNode(Func`2<AstNode, bool> pred);
    [NullableContextAttribute("2")]
public AstNode GetPrevNode();
    public AstNode GetPrevNode(Func`2<AstNode, bool> pred);
    public AstNode GetCSharpNodeBefore(AstNode node);
    public AstNode GetNextSibling(Func`2<AstNode, bool> pred);
    public AstNode GetPrevSibling(Func`2<AstNode, bool> pred);
    [NullableContextAttribute("2")]
public AstNode GetNodeAt(int line, int column, Predicate`1<AstNode> pred);
    [NullableContextAttribute("2")]
public AstNode GetNodeAt(TextLocation location, Predicate`1<AstNode> pred);
    [NullableContextAttribute("0")]
public T GetNodeAt(int line, int column);
    [NullableContextAttribute("0")]
public T GetNodeAt(TextLocation location);
    [NullableContextAttribute("2")]
public AstNode GetAdjacentNodeAt(int line, int column, Predicate`1<AstNode> pred);
    [NullableContextAttribute("2")]
public AstNode GetAdjacentNodeAt(TextLocation location, Predicate`1<AstNode> pred);
    [NullableContextAttribute("0")]
public T GetAdjacentNodeAt(int line, int column);
    [NullableContextAttribute("0")]
public T GetAdjacentNodeAt(TextLocation location);
    public AstNode GetNodeContaining(TextLocation startLocation, TextLocation endLocation);
    public IEnumerable`1<AstNode> GetNodesBetween(int startLine, int startColumn, int endLine, int endColumn);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.AstNode/<GetNodesBetween>d__102")]
public IEnumerable`1<AstNode> GetNodesBetween(TextLocation start, TextLocation end);
    public virtual string ToString(CSharpFormattingOptions formattingOptions);
    public sealed virtual string ToString();
    public bool Contains(int line, int column);
    public bool Contains(TextLocation location);
    public bool IsInside(int line, int column);
    public bool IsInside(TextLocation location);
    public virtual void AddAnnotation(object annotation);
    internal string DebugToString();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.AstNodeCollection`1 : object {
    private AstNode node;
    private Role`1<T> role;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public AstNodeCollection`1(AstNode node, Role`1<T> role);
    public sealed virtual int get_Count();
    public sealed virtual void Add(T element);
    public void AddRange(IEnumerable`1<T> nodes);
    public void AddRange(T[] nodes);
    public void ReplaceWith(IEnumerable`1<T> nodes);
    public void MoveTo(ICollection`1<T> targetCollection);
    public sealed virtual bool Contains(T element);
    public sealed virtual bool Remove(T element);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual void Clear();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.AstNodeCollection`1/<Detach>d__14")]
public IEnumerable`1<T> Detach();
    public T FirstOrNullObject(Func`2<T, bool> predicate);
    public T LastOrNullObject(Func`2<T, bool> predicate);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.AstNodeCollection`1/<GetEnumerator>d__19")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal bool DoMatch(AstNodeCollection`1<T> other, Match match);
    public void InsertAfter(T existingItem, T newItem);
    public void InsertBefore(T existingItem, T newItem);
    public void AcceptVisitor(IAstVisitor visitor);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.AstType : AstNode {
    public static AstType Null;
    public NodeType NodeType { get; }
    private static AstType();
    public static AstType op_Implicit(Pattern pattern);
    public virtual NodeType get_NodeType();
    public AstType Clone();
    public bool IsVar();
    public ITypeReference ToTypeReference(InterningProvider interningProvider);
    public abstract virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
    public NameLookupMode GetNameLookupMode();
    public virtual AstType MakePointerType();
    public virtual AstType MakeArrayType(int rank);
    public AstType MakeNullableType();
    public virtual AstType MakeRefType();
    public MemberType MemberType(string memberName, AstType[] typeArguments);
    public MemberType MemberType(string memberName, IEnumerable`1<AstType> typeArguments);
    public static AstType Create(string dottedName);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.Attribute : AstNode {
    [CompilerGeneratedAttribute]
private bool <HasArgumentList>k__BackingField;
    public NodeType NodeType { get; }
    public AstType Type { get; public set; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<Expression> Arguments { get; }
    public CSharpTokenNode RParToken { get; }
    public bool HasArgumentList { get; public set; }
    public virtual NodeType get_NodeType();
    public AstType get_Type();
    public void set_Type(AstType value);
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<Expression> get_Arguments();
    public CSharpTokenNode get_RParToken();
    [CompilerGeneratedAttribute]
public bool get_HasArgumentList();
    [CompilerGeneratedAttribute]
public void set_HasArgumentList(bool value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual string ToString(CSharpFormattingOptions formattingOptions);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.AttributeSection : AstNode {
    public NodeType NodeType { get; }
    public CSharpTokenNode LBracketToken { get; }
    public string AttributeTarget { get; public set; }
    public Identifier AttributeTargetToken { get; public set; }
    public AstNodeCollection`1<Attribute> Attributes { get; }
    public CSharpTokenNode RBracketToken { get; }
    public AttributeSection(Attribute attr);
    public static AttributeSection op_Implicit(Pattern pattern);
    public virtual NodeType get_NodeType();
    public CSharpTokenNode get_LBracketToken();
    public string get_AttributeTarget();
    public void set_AttributeTarget(string value);
    public Identifier get_AttributeTargetToken();
    public void set_AttributeTargetToken(Identifier value);
    public AstNodeCollection`1<Attribute> get_Attributes();
    public CSharpTokenNode get_RBracketToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.BaseReferenceExpression : Expression {
    [CompilerGeneratedAttribute]
private TextLocation <Location>k__BackingField;
    public TextLocation Location { get; public set; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    [CompilerGeneratedAttribute]
public TextLocation get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(TextLocation value);
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorExpression : Expression {
    public static TokenRole BitwiseAndRole;
    public static TokenRole BitwiseOrRole;
    public static TokenRole ConditionalAndRole;
    public static TokenRole ConditionalOrRole;
    public static TokenRole ExclusiveOrRole;
    public static TokenRole GreaterThanRole;
    public static TokenRole GreaterThanOrEqualRole;
    public static TokenRole EqualityRole;
    public static TokenRole InEqualityRole;
    public static TokenRole LessThanRole;
    public static TokenRole LessThanOrEqualRole;
    public static TokenRole AddRole;
    public static TokenRole SubtractRole;
    public static TokenRole MultiplyRole;
    public static TokenRole DivideRole;
    public static TokenRole ModulusRole;
    public static TokenRole ShiftLeftRole;
    public static TokenRole ShiftRightRole;
    public static TokenRole UnsignedShiftRightRole;
    public static TokenRole NullCoalescingRole;
    public static TokenRole RangeRole;
    public static TokenRole IsKeywordRole;
    public static Role`1<Expression> LeftRole;
    public static Role`1<Expression> RightRole;
    [CompilerGeneratedAttribute]
private BinaryOperatorType <Operator>k__BackingField;
    public BinaryOperatorType Operator { get; public set; }
    public Expression Left { get; public set; }
    public CSharpTokenNode OperatorToken { get; }
    public Expression Right { get; public set; }
    public BinaryOperatorExpression(Expression left, BinaryOperatorType op, Expression right);
    private static BinaryOperatorExpression();
    [CompilerGeneratedAttribute]
public BinaryOperatorType get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(BinaryOperatorType value);
    public Expression get_Left();
    public void set_Left(Expression value);
    public CSharpTokenNode get_OperatorToken();
    public Expression get_Right();
    public void set_Right(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public static TokenRole GetOperatorRole(BinaryOperatorType op);
    public static ExpressionType GetLinqNodeType(BinaryOperatorType op, bool checkForOverflow);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.BinaryOperatorType : Enum {
    public int value__;
    public static BinaryOperatorType Any;
    public static BinaryOperatorType BitwiseAnd;
    public static BinaryOperatorType BitwiseOr;
    public static BinaryOperatorType ConditionalAnd;
    public static BinaryOperatorType ConditionalOr;
    public static BinaryOperatorType ExclusiveOr;
    public static BinaryOperatorType GreaterThan;
    public static BinaryOperatorType GreaterThanOrEqual;
    public static BinaryOperatorType Equality;
    public static BinaryOperatorType InEquality;
    public static BinaryOperatorType LessThan;
    public static BinaryOperatorType LessThanOrEqual;
    public static BinaryOperatorType Add;
    public static BinaryOperatorType Subtract;
    public static BinaryOperatorType Multiply;
    public static BinaryOperatorType Divide;
    public static BinaryOperatorType Modulus;
    public static BinaryOperatorType ShiftLeft;
    public static BinaryOperatorType ShiftRight;
    public static BinaryOperatorType UnsignedShiftRight;
    public static BinaryOperatorType NullCoalescing;
    public static BinaryOperatorType Range;
    public static BinaryOperatorType IsPattern;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.BlockStatement : Statement {
    public static Role`1<Statement> StatementRole;
    public static BlockStatement Null;
    public CSharpTokenNode LBraceToken { get; }
    public AstNodeCollection`1<Statement> Statements { get; }
    public CSharpTokenNode RBraceToken { get; }
    private static BlockStatement();
    public static BlockStatement op_Implicit(Pattern pattern);
    public CSharpTokenNode get_LBraceToken();
    public AstNodeCollection`1<Statement> get_Statements();
    public CSharpTokenNode get_RBraceToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public void Add(Statement statement);
    public void Add(Expression expression);
    private sealed virtual override IEnumerator`1<Statement> System.Collections.Generic.IEnumerable<ICSharpCode.Decompiler.CSharp.Syntax.Statement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.BreakStatement : Statement {
    public static TokenRole BreakKeywordRole;
    public CSharpTokenNode BreakToken { get; }
    public CSharpTokenNode SemicolonToken { get; }
    private static BreakStatement();
    public CSharpTokenNode get_BreakToken();
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CaseLabel : AstNode {
    public static TokenRole CaseKeywordRole;
    public static TokenRole DefaultKeywordRole;
    public NodeType NodeType { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode ColonToken { get; }
    public CaseLabel(Expression expression);
    private static CaseLabel();
    public virtual NodeType get_NodeType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_ColonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CastExpression : Expression {
    public CSharpTokenNode LParToken { get; }
    public AstType Type { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public Expression Expression { get; public set; }
    public CastExpression(AstType castToType, Expression expression);
    public CSharpTokenNode get_LParToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public CSharpTokenNode get_RParToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CatchClause : AstNode {
    public static TokenRole CatchKeywordRole;
    public static TokenRole WhenKeywordRole;
    public static Role`1<Expression> ConditionRole;
    public static TokenRole CondLPar;
    public static TokenRole CondRPar;
    public static CatchClause Null;
    public NodeType NodeType { get; }
    public CSharpTokenNode CatchToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstType Type { get; public set; }
    public string VariableName { get; public set; }
    public Identifier VariableNameToken { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public CSharpTokenNode WhenToken { get; }
    public CSharpTokenNode CondLParToken { get; }
    public Expression Condition { get; public set; }
    public CSharpTokenNode CondRParToken { get; }
    public BlockStatement Body { get; public set; }
    private static CatchClause();
    public static CatchClause op_Implicit(Pattern pattern);
    public virtual NodeType get_NodeType();
    public CSharpTokenNode get_CatchToken();
    public CSharpTokenNode get_LParToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public string get_VariableName();
    public void set_VariableName(string value);
    public Identifier get_VariableNameToken();
    public void set_VariableNameToken(Identifier value);
    public CSharpTokenNode get_RParToken();
    public CSharpTokenNode get_WhenToken();
    public CSharpTokenNode get_CondLParToken();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public CSharpTokenNode get_CondRParToken();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CheckedExpression : Expression {
    public static TokenRole CheckedKeywordRole;
    public CSharpTokenNode CheckedToken { get; }
    public CSharpTokenNode LParToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public CheckedExpression(Expression expression);
    private static CheckedExpression();
    public CSharpTokenNode get_CheckedToken();
    public CSharpTokenNode get_LParToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CheckedStatement : Statement {
    public static TokenRole CheckedKeywordRole;
    public CSharpTokenNode CheckedToken { get; }
    public BlockStatement Body { get; public set; }
    public CheckedStatement(BlockStatement body);
    private static CheckedStatement();
    public CSharpTokenNode get_CheckedToken();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.ClassType : Enum {
    public int value__;
    public static ClassType Class;
    public static ClassType Struct;
    public static ClassType Interface;
    public static ClassType Enum;
    public static ClassType RecordClass;
    public static ClassType RecordStruct;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.Comment : AstNode {
    private CommentType commentType;
    private bool startsLine;
    private string content;
    private TextLocation startLocation;
    private TextLocation endLocation;
    public NodeType NodeType { get; }
    public CommentType CommentType { get; public set; }
    public bool IsDocumentation { get; }
    public bool StartsLine { get; public set; }
    public string Content { get; public set; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    public Comment(string content, CommentType type);
    public Comment(CommentType commentType, TextLocation startLocation, TextLocation endLocation);
    public virtual NodeType get_NodeType();
    public CommentType get_CommentType();
    public void set_CommentType(CommentType value);
    public bool get_IsDocumentation();
    public bool get_StartsLine();
    public void set_StartsLine(bool value);
    public string get_Content();
    public void set_Content(string value);
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    internal void SetStartLocation(TextLocation value);
    internal void SetEndLocation(TextLocation value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.CommentType : Enum {
    public int value__;
    public static CommentType SingleLine;
    public static CommentType MultiLine;
    public static CommentType Documentation;
    public static CommentType InactiveCode;
    public static CommentType MultiLineDocumentation;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ComposedType : AstType {
    public static Role`1<AttributeSection> AttributeRole;
    public static TokenRole RefRole;
    public static TokenRole ReadonlyRole;
    public static TokenRole NullableRole;
    public static TokenRole PointerRole;
    public static Role`1<ArraySpecifier> ArraySpecifierRole;
    public AstNodeCollection`1<AttributeSection> Attributes { get; }
    public bool HasRefSpecifier { get; public set; }
    public bool HasReadOnlySpecifier { get; public set; }
    public AstType BaseType { get; public set; }
    public bool HasNullableSpecifier { get; public set; }
    public bool HasOnlyNullableSpecifier { get; }
    public CSharpTokenNode NullableSpecifierToken { get; }
    public int PointerRank { get; public set; }
    public AstNodeCollection`1<ArraySpecifier> ArraySpecifiers { get; }
    public AstNodeCollection`1<CSharpTokenNode> PointerTokens { get; }
    private static ComposedType();
    public AstNodeCollection`1<AttributeSection> get_Attributes();
    public bool get_HasRefSpecifier();
    public void set_HasRefSpecifier(bool value);
    public bool get_HasReadOnlySpecifier();
    public void set_HasReadOnlySpecifier(bool value);
    public AstType get_BaseType();
    public void set_BaseType(AstType value);
    public bool get_HasNullableSpecifier();
    public void set_HasNullableSpecifier(bool value);
    public bool get_HasOnlyNullableSpecifier();
    public CSharpTokenNode get_NullableSpecifierToken();
    public int get_PointerRank();
    public void set_PointerRank(int value);
    public AstNodeCollection`1<ArraySpecifier> get_ArraySpecifiers();
    public AstNodeCollection`1<CSharpTokenNode> get_PointerTokens();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual string ToString(CSharpFormattingOptions formattingOptions);
    public virtual AstType MakePointerType();
    public virtual AstType MakeArrayType(int dimensions);
    public virtual AstType MakeRefType();
    public virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ConditionalExpression : Expression {
    public static Role`1<Expression> ConditionRole;
    public static TokenRole QuestionMarkRole;
    public static Role`1<Expression> TrueRole;
    public static TokenRole ColonRole;
    public static Role`1<Expression> FalseRole;
    public Expression Condition { get; public set; }
    public CSharpTokenNode QuestionMarkToken { get; }
    public Expression TrueExpression { get; public set; }
    public CSharpTokenNode ColonToken { get; }
    public Expression FalseExpression { get; public set; }
    public ConditionalExpression(Expression condition, Expression trueExpression, Expression falseExpression);
    private static ConditionalExpression();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public CSharpTokenNode get_QuestionMarkToken();
    public Expression get_TrueExpression();
    public void set_TrueExpression(Expression value);
    public CSharpTokenNode get_ColonToken();
    public Expression get_FalseExpression();
    public void set_FalseExpression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.Constraint : AstNode {
    public NodeType NodeType { get; }
    public CSharpTokenNode WhereKeyword { get; }
    public SimpleType TypeParameter { get; public set; }
    public AstNodeCollection`1<AstType> BaseTypes { get; }
    public virtual NodeType get_NodeType();
    public CSharpTokenNode get_WhereKeyword();
    public SimpleType get_TypeParameter();
    public void set_TypeParameter(SimpleType value);
    public AstNodeCollection`1<AstType> get_BaseTypes();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ConstructorDeclaration : EntityDeclaration {
    public static Role`1<ConstructorInitializer> InitializerRole;
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public CSharpTokenNode RParToken { get; }
    public CSharpTokenNode ColonToken { get; }
    public ConstructorInitializer Initializer { get; public set; }
    public BlockStatement Body { get; public set; }
    private static ConstructorDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public CSharpTokenNode get_RParToken();
    public CSharpTokenNode get_ColonToken();
    public ConstructorInitializer get_Initializer();
    public void set_Initializer(ConstructorInitializer value);
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ConstructorInitializer : AstNode {
    public static TokenRole BaseKeywordRole;
    public static TokenRole ThisKeywordRole;
    public static ConstructorInitializer Null;
    [CompilerGeneratedAttribute]
private ConstructorInitializerType <ConstructorInitializerType>k__BackingField;
    public NodeType NodeType { get; }
    public ConstructorInitializerType ConstructorInitializerType { get; public set; }
    public CSharpTokenNode Keyword { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<Expression> Arguments { get; }
    public CSharpTokenNode RParToken { get; }
    private static ConstructorInitializer();
    public virtual NodeType get_NodeType();
    [CompilerGeneratedAttribute]
public ConstructorInitializerType get_ConstructorInitializerType();
    [CompilerGeneratedAttribute]
public void set_ConstructorInitializerType(ConstructorInitializerType value);
    public CSharpTokenNode get_Keyword();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<Expression> get_Arguments();
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.ConstructorInitializerType : Enum {
    public int value__;
    public static ConstructorInitializerType Any;
    public static ConstructorInitializerType Base;
    public static ConstructorInitializerType This;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ContinueStatement : Statement {
    public static TokenRole ContinueKeywordRole;
    public CSharpTokenNode ContinueToken { get; }
    public CSharpTokenNode SemicolonToken { get; }
    private static ContinueStatement();
    public CSharpTokenNode get_ContinueToken();
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CSharpModifierToken : CSharpTokenNode {
    private Modifiers modifier;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<Modifiers> <AllModifiers>k__BackingField;
    public Modifiers Modifier { get; public set; }
    public TextLocation EndLocation { get; }
    public static ImmutableArray`1<Modifiers> AllModifiers { get; }
    public CSharpModifierToken(TextLocation location, Modifiers modifier);
    private static CSharpModifierToken();
    public Modifiers get_Modifier();
    public void set_Modifier(Modifiers value);
    public virtual TextLocation get_EndLocation();
    public virtual string ToString(CSharpFormattingOptions formattingOptions);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<Modifiers> get_AllModifiers();
    public static string GetModifierName(Modifiers modifier);
    public static int GetModifierLength(Modifiers modifier);
    public static Modifiers GetModifierValue(string modifier);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CSharpTokenNode : AstNode {
    public static CSharpTokenNode Null;
    private TextLocation startLocation;
    public NodeType NodeType { get; }
    public TextLocation StartLocation { get; }
    private int TokenLength { get; }
    public TextLocation EndLocation { get; }
    public CSharpTokenNode(TextLocation location, TokenRole role);
    private static CSharpTokenNode();
    public virtual NodeType get_NodeType();
    public virtual TextLocation get_StartLocation();
    private int get_TokenLength();
    public virtual TextLocation get_EndLocation();
    public virtual string ToString(CSharpFormattingOptions formattingOptions);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.CustomEventDeclaration : EntityDeclaration {
    public static TokenRole EventKeywordRole;
    public static TokenRole AddKeywordRole;
    public static TokenRole RemoveKeywordRole;
    public static Role`1<Accessor> AddAccessorRole;
    public static Role`1<Accessor> RemoveAccessorRole;
    public SymbolKind SymbolKind { get; }
    public AstType PrivateImplementationType { get; public set; }
    public CSharpTokenNode LBraceToken { get; }
    public Accessor AddAccessor { get; public set; }
    public Accessor RemoveAccessor { get; public set; }
    public CSharpTokenNode RBraceToken { get; }
    private static CustomEventDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public AstType get_PrivateImplementationType();
    public void set_PrivateImplementationType(AstType value);
    public CSharpTokenNode get_LBraceToken();
    public Accessor get_AddAccessor();
    public void set_AddAccessor(Accessor value);
    public Accessor get_RemoveAccessor();
    public void set_RemoveAccessor(Accessor value);
    public CSharpTokenNode get_RBraceToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.DeclarationExpression : Expression {
    public AstType Type { get; public set; }
    public VariableDesignation Designation { get; public set; }
    public AstType get_Type();
    public void set_Type(AstType value);
    public VariableDesignation get_Designation();
    public void set_Designation(VariableDesignation value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.DefaultValueExpression : Expression {
    public static TokenRole DefaultKeywordRole;
    public CSharpTokenNode DefaultToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstType Type { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public DefaultValueExpression(AstType type);
    private static DefaultValueExpression();
    public CSharpTokenNode get_DefaultToken();
    public CSharpTokenNode get_LParToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.DelegateDeclaration : EntityDeclaration {
    public NodeType NodeType { get; }
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode DelegateToken { get; }
    public AstNodeCollection`1<TypeParameterDeclaration> TypeParameters { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public CSharpTokenNode RParToken { get; }
    public AstNodeCollection`1<Constraint> Constraints { get; }
    public virtual NodeType get_NodeType();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_DelegateToken();
    public AstNodeCollection`1<TypeParameterDeclaration> get_TypeParameters();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public CSharpTokenNode get_RParToken();
    public AstNodeCollection`1<Constraint> get_Constraints();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.DepthFirstAstVisitor : object {
    protected virtual void VisitChildren(AstNode node);
    public virtual void VisitNullNode(AstNode nullNode);
    public virtual void VisitSyntaxTree(SyntaxTree syntaxTree);
    public virtual void VisitComment(Comment comment);
    public virtual void VisitDocumentationReference(DocumentationReference documentationReference);
    public virtual void VisitPreProcessorDirective(PreProcessorDirective preProcessorDirective);
    public virtual void VisitIdentifier(Identifier identifier);
    public virtual void VisitCSharpTokenNode(CSharpTokenNode token);
    public virtual void VisitPrimitiveType(PrimitiveType primitiveType);
    public virtual void VisitComposedType(ComposedType composedType);
    public virtual void VisitSimpleType(SimpleType simpleType);
    public virtual void VisitMemberType(MemberType memberType);
    public virtual void VisitTupleType(TupleAstType tupleType);
    public virtual void VisitTupleTypeElement(TupleTypeElement tupleTypeElement);
    public virtual void VisitFunctionPointerType(FunctionPointerAstType functionPointerType);
    public virtual void VisitInvocationType(InvocationAstType invocationType);
    public virtual void VisitAttribute(Attribute attribute);
    public virtual void VisitAttributeSection(AttributeSection attributeSection);
    public virtual void VisitDelegateDeclaration(DelegateDeclaration delegateDeclaration);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public virtual void VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public virtual void VisitTypeParameterDeclaration(TypeParameterDeclaration typeParameterDeclaration);
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration);
    public virtual void VisitUsingDeclaration(UsingDeclaration usingDeclaration);
    public virtual void VisitUsingAliasDeclaration(UsingAliasDeclaration usingDeclaration);
    public virtual void VisitExternAliasDeclaration(ExternAliasDeclaration externAliasDeclaration);
    public virtual void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public virtual void VisitConstructorInitializer(ConstructorInitializer constructorInitializer);
    public virtual void VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public virtual void VisitEventDeclaration(EventDeclaration eventDeclaration);
    public virtual void VisitCustomEventDeclaration(CustomEventDeclaration eventDeclaration);
    public virtual void VisitFieldDeclaration(FieldDeclaration fieldDeclaration);
    public virtual void VisitFixedFieldDeclaration(FixedFieldDeclaration fixedFieldDeclaration);
    public virtual void VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer);
    public virtual void VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    public virtual void VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public virtual void VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration);
    public virtual void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public virtual void VisitAccessor(Accessor accessor);
    public virtual void VisitVariableInitializer(VariableInitializer variableInitializer);
    public virtual void VisitParameterDeclaration(ParameterDeclaration parameterDeclaration);
    public virtual void VisitConstraint(Constraint constraint);
    public virtual void VisitBlockStatement(BlockStatement blockStatement);
    public virtual void VisitExpressionStatement(ExpressionStatement expressionStatement);
    public virtual void VisitBreakStatement(BreakStatement breakStatement);
    public virtual void VisitCheckedStatement(CheckedStatement checkedStatement);
    public virtual void VisitContinueStatement(ContinueStatement continueStatement);
    public virtual void VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public virtual void VisitEmptyStatement(EmptyStatement emptyStatement);
    public virtual void VisitFixedStatement(FixedStatement fixedStatement);
    public virtual void VisitForeachStatement(ForeachStatement foreachStatement);
    public virtual void VisitForStatement(ForStatement forStatement);
    public virtual void VisitGotoCaseStatement(GotoCaseStatement gotoCaseStatement);
    public virtual void VisitGotoDefaultStatement(GotoDefaultStatement gotoDefaultStatement);
    public virtual void VisitGotoStatement(GotoStatement gotoStatement);
    public virtual void VisitIfElseStatement(IfElseStatement ifElseStatement);
    public virtual void VisitLabelStatement(LabelStatement labelStatement);
    public virtual void VisitLockStatement(LockStatement lockStatement);
    public virtual void VisitReturnStatement(ReturnStatement returnStatement);
    public virtual void VisitSwitchStatement(SwitchStatement switchStatement);
    public virtual void VisitSwitchSection(SwitchSection switchSection);
    public virtual void VisitCaseLabel(CaseLabel caseLabel);
    public virtual void VisitSwitchExpression(SwitchExpression switchExpression);
    public virtual void VisitSwitchExpressionSection(SwitchExpressionSection switchExpressionSection);
    public virtual void VisitThrowStatement(ThrowStatement throwStatement);
    public virtual void VisitTryCatchStatement(TryCatchStatement tryCatchStatement);
    public virtual void VisitCatchClause(CatchClause catchClause);
    public virtual void VisitUncheckedStatement(UncheckedStatement uncheckedStatement);
    public virtual void VisitUnsafeStatement(UnsafeStatement unsafeStatement);
    public virtual void VisitUsingStatement(UsingStatement usingStatement);
    public virtual void VisitVariableDeclarationStatement(VariableDeclarationStatement variableDeclarationStatement);
    public virtual void VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatement localFunctionDeclarationStatement);
    public virtual void VisitWhileStatement(WhileStatement whileStatement);
    public virtual void VisitYieldBreakStatement(YieldBreakStatement yieldBreakStatement);
    public virtual void VisitYieldReturnStatement(YieldReturnStatement yieldReturnStatement);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression);
    public virtual void VisitLambdaExpression(LambdaExpression lambdaExpression);
    public virtual void VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    public virtual void VisitBaseReferenceExpression(BaseReferenceExpression baseReferenceExpression);
    public virtual void VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression);
    public virtual void VisitCastExpression(CastExpression castExpression);
    public virtual void VisitCheckedExpression(CheckedExpression checkedExpression);
    public virtual void VisitConditionalExpression(ConditionalExpression conditionalExpression);
    public virtual void VisitIdentifierExpression(IdentifierExpression identifierExpression);
    public virtual void VisitIndexerExpression(IndexerExpression indexerExpression);
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpression interpolatedStringExpression);
    public virtual void VisitInterpolation(Interpolation interpolation);
    public virtual void VisitInterpolatedStringText(InterpolatedStringText interpolatedStringText);
    public virtual void VisitInvocationExpression(InvocationExpression invocationExpression);
    public virtual void VisitDirectionExpression(DirectionExpression directionExpression);
    public virtual void VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public virtual void VisitNullReferenceExpression(NullReferenceExpression nullReferenceExpression);
    public virtual void VisitObjectCreateExpression(ObjectCreateExpression objectCreateExpression);
    public virtual void VisitDeclarationExpression(DeclarationExpression declarationExpression);
    public virtual void VisitOutVarDeclarationExpression(OutVarDeclarationExpression outVarDeclarationExpression);
    public virtual void VisitAnonymousTypeCreateExpression(AnonymousTypeCreateExpression anonymousTypeCreateExpression);
    public virtual void VisitArrayCreateExpression(ArrayCreateExpression arrayCreateExpression);
    public virtual void VisitParenthesizedExpression(ParenthesizedExpression parenthesizedExpression);
    public virtual void VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression);
    public virtual void VisitPrimitiveExpression(PrimitiveExpression primitiveExpression);
    public virtual void VisitSizeOfExpression(SizeOfExpression sizeOfExpression);
    public virtual void VisitStackAllocExpression(StackAllocExpression stackAllocExpression);
    public virtual void VisitThisReferenceExpression(ThisReferenceExpression thisReferenceExpression);
    public virtual void VisitThrowExpression(ThrowExpression throwExpression);
    public virtual void VisitTupleExpression(TupleExpression tupleExpression);
    public virtual void VisitTypeOfExpression(TypeOfExpression typeOfExpression);
    public virtual void VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression);
    public virtual void VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression);
    public virtual void VisitUncheckedExpression(UncheckedExpression uncheckedExpression);
    public virtual void VisitQueryExpression(QueryExpression queryExpression);
    public virtual void VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause);
    public virtual void VisitQueryFromClause(QueryFromClause queryFromClause);
    public virtual void VisitQueryLetClause(QueryLetClause queryLetClause);
    public virtual void VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    public virtual void VisitQueryJoinClause(QueryJoinClause queryJoinClause);
    public virtual void VisitQueryOrderClause(QueryOrderClause queryOrderClause);
    public virtual void VisitQueryOrdering(QueryOrdering queryOrdering);
    public virtual void VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public virtual void VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public virtual void VisitAsExpression(AsExpression asExpression);
    public virtual void VisitIsExpression(IsExpression isExpression);
    public virtual void VisitDefaultValueExpression(DefaultValueExpression defaultValueExpression);
    public virtual void VisitUndocumentedExpression(UndocumentedExpression undocumentedExpression);
    public virtual void VisitArrayInitializerExpression(ArrayInitializerExpression arrayInitializerExpression);
    public virtual void VisitArraySpecifier(ArraySpecifier arraySpecifier);
    public virtual void VisitNamedArgumentExpression(NamedArgumentExpression namedArgumentExpression);
    public virtual void VisitNamedExpression(NamedExpression namedExpression);
    public virtual void VisitSingleVariableDesignation(SingleVariableDesignation singleVariableDesignation);
    public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignation parenthesizedVariableDesignation);
    public virtual void VisitErrorNode(AstNode errorNode);
    public virtual void VisitPatternPlaceholder(AstNode placeholder, Pattern pattern);
    public virtual void VisitWithInitializerExpression(WithInitializerExpression withInitializerExpression);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.DepthFirstAstVisitor`1 : object {
    protected virtual T VisitChildren(AstNode node);
    public virtual T VisitNullNode(AstNode nullNode);
    public virtual T VisitSyntaxTree(SyntaxTree unit);
    public virtual T VisitComment(Comment comment);
    public virtual T VisitDocumentationReference(DocumentationReference documentationReference);
    public virtual T VisitPreProcessorDirective(PreProcessorDirective preProcessorDirective);
    public virtual T VisitIdentifier(Identifier identifier);
    public virtual T VisitCSharpTokenNode(CSharpTokenNode token);
    public virtual T VisitPrimitiveType(PrimitiveType primitiveType);
    public virtual T VisitComposedType(ComposedType composedType);
    public virtual T VisitSimpleType(SimpleType simpleType);
    public virtual T VisitMemberType(MemberType memberType);
    public virtual T VisitTupleType(TupleAstType tupleType);
    public virtual T VisitTupleTypeElement(TupleTypeElement tupleTypeElement);
    public virtual T VisitFunctionPointerType(FunctionPointerAstType functionPointerType);
    public virtual T VisitInvocationType(InvocationAstType invocationType);
    public virtual T VisitAttribute(Attribute attribute);
    public virtual T VisitAttributeSection(AttributeSection attributeSection);
    public virtual T VisitDelegateDeclaration(DelegateDeclaration delegateDeclaration);
    public virtual T VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public virtual T VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public virtual T VisitTypeParameterDeclaration(TypeParameterDeclaration typeParameterDeclaration);
    public virtual T VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration);
    public virtual T VisitUsingDeclaration(UsingDeclaration usingDeclaration);
    public virtual T VisitUsingAliasDeclaration(UsingAliasDeclaration usingDeclaration);
    public virtual T VisitExternAliasDeclaration(ExternAliasDeclaration externAliasDeclaration);
    public virtual T VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public virtual T VisitConstructorInitializer(ConstructorInitializer constructorInitializer);
    public virtual T VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public virtual T VisitEventDeclaration(EventDeclaration eventDeclaration);
    public virtual T VisitCustomEventDeclaration(CustomEventDeclaration eventDeclaration);
    public virtual T VisitFieldDeclaration(FieldDeclaration fieldDeclaration);
    public virtual T VisitFixedFieldDeclaration(FixedFieldDeclaration fixedFieldDeclaration);
    public virtual T VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer);
    public virtual T VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    public virtual T VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public virtual T VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration);
    public virtual T VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public virtual T VisitAccessor(Accessor accessor);
    public virtual T VisitVariableInitializer(VariableInitializer variableInitializer);
    public virtual T VisitParameterDeclaration(ParameterDeclaration parameterDeclaration);
    public virtual T VisitConstraint(Constraint constraint);
    public virtual T VisitBlockStatement(BlockStatement blockStatement);
    public virtual T VisitExpressionStatement(ExpressionStatement expressionStatement);
    public virtual T VisitBreakStatement(BreakStatement breakStatement);
    public virtual T VisitCheckedStatement(CheckedStatement checkedStatement);
    public virtual T VisitContinueStatement(ContinueStatement continueStatement);
    public virtual T VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public virtual T VisitEmptyStatement(EmptyStatement emptyStatement);
    public virtual T VisitFixedStatement(FixedStatement fixedStatement);
    public virtual T VisitForeachStatement(ForeachStatement foreachStatement);
    public virtual T VisitForStatement(ForStatement forStatement);
    public virtual T VisitGotoCaseStatement(GotoCaseStatement gotoCaseStatement);
    public virtual T VisitGotoDefaultStatement(GotoDefaultStatement gotoDefaultStatement);
    public virtual T VisitGotoStatement(GotoStatement gotoStatement);
    public virtual T VisitIfElseStatement(IfElseStatement ifElseStatement);
    public virtual T VisitLabelStatement(LabelStatement labelStatement);
    public virtual T VisitLockStatement(LockStatement lockStatement);
    public virtual T VisitReturnStatement(ReturnStatement returnStatement);
    public virtual T VisitSwitchStatement(SwitchStatement switchStatement);
    public virtual T VisitSwitchSection(SwitchSection switchSection);
    public virtual T VisitCaseLabel(CaseLabel caseLabel);
    public virtual T VisitSwitchExpression(SwitchExpression switchExpression);
    public virtual T VisitSwitchExpressionSection(SwitchExpressionSection switchExpressionSection);
    public virtual T VisitThrowStatement(ThrowStatement throwStatement);
    public virtual T VisitTryCatchStatement(TryCatchStatement tryCatchStatement);
    public virtual T VisitCatchClause(CatchClause catchClause);
    public virtual T VisitUncheckedStatement(UncheckedStatement uncheckedStatement);
    public virtual T VisitUnsafeStatement(UnsafeStatement unsafeStatement);
    public virtual T VisitUsingStatement(UsingStatement usingStatement);
    public virtual T VisitVariableDeclarationStatement(VariableDeclarationStatement variableDeclarationStatement);
    public virtual T VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatement localFunctionDeclarationStatement);
    public virtual T VisitWhileStatement(WhileStatement whileStatement);
    public virtual T VisitYieldBreakStatement(YieldBreakStatement yieldBreakStatement);
    public virtual T VisitYieldReturnStatement(YieldReturnStatement yieldReturnStatement);
    public virtual T VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression);
    public virtual T VisitLambdaExpression(LambdaExpression lambdaExpression);
    public virtual T VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    public virtual T VisitBaseReferenceExpression(BaseReferenceExpression baseReferenceExpression);
    public virtual T VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression);
    public virtual T VisitCastExpression(CastExpression castExpression);
    public virtual T VisitCheckedExpression(CheckedExpression checkedExpression);
    public virtual T VisitConditionalExpression(ConditionalExpression conditionalExpression);
    public virtual T VisitIdentifierExpression(IdentifierExpression identifierExpression);
    public virtual T VisitIndexerExpression(IndexerExpression indexerExpression);
    public virtual T VisitInterpolatedStringExpression(InterpolatedStringExpression interpolatedStringExpression);
    public virtual T VisitInterpolation(Interpolation interpolation);
    public virtual T VisitInterpolatedStringText(InterpolatedStringText interpolatedStringText);
    public virtual T VisitInvocationExpression(InvocationExpression invocationExpression);
    public virtual T VisitDirectionExpression(DirectionExpression directionExpression);
    public virtual T VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public virtual T VisitNullReferenceExpression(NullReferenceExpression nullReferenceExpression);
    public virtual T VisitObjectCreateExpression(ObjectCreateExpression objectCreateExpression);
    public virtual T VisitDeclarationExpression(DeclarationExpression declarationExpression);
    public virtual T VisitOutVarDeclarationExpression(OutVarDeclarationExpression outVarDeclarationExpression);
    public virtual T VisitAnonymousTypeCreateExpression(AnonymousTypeCreateExpression anonymousTypeCreateExpression);
    public virtual T VisitArrayCreateExpression(ArrayCreateExpression arrayCreateExpression);
    public virtual T VisitParenthesizedExpression(ParenthesizedExpression parenthesizedExpression);
    public virtual T VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression);
    public virtual T VisitPrimitiveExpression(PrimitiveExpression primitiveExpression);
    public virtual T VisitSizeOfExpression(SizeOfExpression sizeOfExpression);
    public virtual T VisitStackAllocExpression(StackAllocExpression stackAllocExpression);
    public virtual T VisitThisReferenceExpression(ThisReferenceExpression thisReferenceExpression);
    public virtual T VisitThrowExpression(ThrowExpression throwExpression);
    public virtual T VisitTupleExpression(TupleExpression tupleExpression);
    public virtual T VisitTypeOfExpression(TypeOfExpression typeOfExpression);
    public virtual T VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression);
    public virtual T VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression);
    public virtual T VisitUncheckedExpression(UncheckedExpression uncheckedExpression);
    public virtual T VisitQueryExpression(QueryExpression queryExpression);
    public virtual T VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause);
    public virtual T VisitQueryFromClause(QueryFromClause queryFromClause);
    public virtual T VisitQueryLetClause(QueryLetClause queryLetClause);
    public virtual T VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    public virtual T VisitQueryJoinClause(QueryJoinClause queryJoinClause);
    public virtual T VisitQueryOrderClause(QueryOrderClause queryOrderClause);
    public virtual T VisitQueryOrdering(QueryOrdering queryOrdering);
    public virtual T VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public virtual T VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public virtual T VisitAsExpression(AsExpression asExpression);
    public virtual T VisitIsExpression(IsExpression isExpression);
    public virtual T VisitDefaultValueExpression(DefaultValueExpression defaultValueExpression);
    public virtual T VisitUndocumentedExpression(UndocumentedExpression undocumentedExpression);
    public virtual T VisitArrayInitializerExpression(ArrayInitializerExpression arrayInitializerExpression);
    public virtual T VisitArraySpecifier(ArraySpecifier arraySpecifier);
    public virtual T VisitNamedArgumentExpression(NamedArgumentExpression namedArgumentExpression);
    public virtual T VisitNamedExpression(NamedExpression namedExpression);
    public virtual T VisitSingleVariableDesignation(SingleVariableDesignation singleVariableDesignation);
    public virtual T VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignation parenthesizedVariableDesignation);
    public virtual T VisitErrorNode(AstNode errorNode);
    public virtual T VisitPatternPlaceholder(AstNode placeholder, Pattern pattern);
    public virtual T VisitWithInitializerExpression(WithInitializerExpression withInitializerExpression);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.DepthFirstAstVisitor`2 : object {
    protected virtual S VisitChildren(AstNode node, T data);
    public virtual S VisitNullNode(AstNode nullNode, T data);
    public virtual S VisitSyntaxTree(SyntaxTree unit, T data);
    public virtual S VisitComment(Comment comment, T data);
    public virtual S VisitDocumentationReference(DocumentationReference documentationReference, T data);
    public virtual S VisitPreProcessorDirective(PreProcessorDirective preProcessorDirective, T data);
    public virtual S VisitIdentifier(Identifier identifier, T data);
    public virtual S VisitCSharpTokenNode(CSharpTokenNode token, T data);
    public virtual S VisitPrimitiveType(PrimitiveType primitiveType, T data);
    public virtual S VisitComposedType(ComposedType composedType, T data);
    public virtual S VisitSimpleType(SimpleType simpleType, T data);
    public virtual S VisitMemberType(MemberType memberType, T data);
    public virtual S VisitTupleType(TupleAstType tupleType, T data);
    public virtual S VisitTupleTypeElement(TupleTypeElement tupleTypeElement, T data);
    public virtual S VisitFunctionPointerType(FunctionPointerAstType functionPointerType, T data);
    public virtual S VisitInvocationType(InvocationAstType invocationType, T data);
    public virtual S VisitAttribute(Attribute attribute, T data);
    public virtual S VisitAttributeSection(AttributeSection attributeSection, T data);
    public virtual S VisitDelegateDeclaration(DelegateDeclaration delegateDeclaration, T data);
    public virtual S VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration, T data);
    public virtual S VisitTypeDeclaration(TypeDeclaration typeDeclaration, T data);
    public virtual S VisitTypeParameterDeclaration(TypeParameterDeclaration typeParameterDeclaration, T data);
    public virtual S VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration, T data);
    public virtual S VisitUsingDeclaration(UsingDeclaration usingDeclaration, T data);
    public virtual S VisitUsingAliasDeclaration(UsingAliasDeclaration usingDeclaration, T data);
    public virtual S VisitExternAliasDeclaration(ExternAliasDeclaration externAliasDeclaration, T data);
    public virtual S VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration, T data);
    public virtual S VisitConstructorInitializer(ConstructorInitializer constructorInitializer, T data);
    public virtual S VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration, T data);
    public virtual S VisitEventDeclaration(EventDeclaration eventDeclaration, T data);
    public virtual S VisitCustomEventDeclaration(CustomEventDeclaration eventDeclaration, T data);
    public virtual S VisitFieldDeclaration(FieldDeclaration fieldDeclaration, T data);
    public virtual S VisitFixedFieldDeclaration(FixedFieldDeclaration fixedFieldDeclaration, T data);
    public virtual S VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer, T data);
    public virtual S VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration, T data);
    public virtual S VisitMethodDeclaration(MethodDeclaration methodDeclaration, T data);
    public virtual S VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration, T data);
    public virtual S VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration, T data);
    public virtual S VisitAccessor(Accessor accessor, T data);
    public virtual S VisitVariableInitializer(VariableInitializer variableInitializer, T data);
    public virtual S VisitParameterDeclaration(ParameterDeclaration parameterDeclaration, T data);
    public virtual S VisitConstraint(Constraint constraint, T data);
    public virtual S VisitBlockStatement(BlockStatement blockStatement, T data);
    public virtual S VisitExpressionStatement(ExpressionStatement expressionStatement, T data);
    public virtual S VisitBreakStatement(BreakStatement breakStatement, T data);
    public virtual S VisitCheckedStatement(CheckedStatement checkedStatement, T data);
    public virtual S VisitContinueStatement(ContinueStatement continueStatement, T data);
    public virtual S VisitDoWhileStatement(DoWhileStatement doWhileStatement, T data);
    public virtual S VisitEmptyStatement(EmptyStatement emptyStatement, T data);
    public virtual S VisitFixedStatement(FixedStatement fixedStatement, T data);
    public virtual S VisitForeachStatement(ForeachStatement foreachStatement, T data);
    public virtual S VisitForStatement(ForStatement forStatement, T data);
    public virtual S VisitGotoCaseStatement(GotoCaseStatement gotoCaseStatement, T data);
    public virtual S VisitGotoDefaultStatement(GotoDefaultStatement gotoDefaultStatement, T data);
    public virtual S VisitGotoStatement(GotoStatement gotoStatement, T data);
    public virtual S VisitIfElseStatement(IfElseStatement ifElseStatement, T data);
    public virtual S VisitLabelStatement(LabelStatement labelStatement, T data);
    public virtual S VisitLockStatement(LockStatement lockStatement, T data);
    public virtual S VisitReturnStatement(ReturnStatement returnStatement, T data);
    public virtual S VisitSwitchStatement(SwitchStatement switchStatement, T data);
    public virtual S VisitSwitchSection(SwitchSection switchSection, T data);
    public virtual S VisitCaseLabel(CaseLabel caseLabel, T data);
    public virtual S VisitSwitchExpression(SwitchExpression switchExpression, T data);
    public virtual S VisitSwitchExpressionSection(SwitchExpressionSection switchExpressionSection, T data);
    public virtual S VisitThrowStatement(ThrowStatement throwStatement, T data);
    public virtual S VisitTryCatchStatement(TryCatchStatement tryCatchStatement, T data);
    public virtual S VisitCatchClause(CatchClause catchClause, T data);
    public virtual S VisitUncheckedStatement(UncheckedStatement uncheckedStatement, T data);
    public virtual S VisitUnsafeStatement(UnsafeStatement unsafeStatement, T data);
    public virtual S VisitUsingStatement(UsingStatement usingStatement, T data);
    public virtual S VisitVariableDeclarationStatement(VariableDeclarationStatement variableDeclarationStatement, T data);
    public virtual S VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatement localFunctionDeclarationStatement, T data);
    public virtual S VisitWhileStatement(WhileStatement whileStatement, T data);
    public virtual S VisitYieldBreakStatement(YieldBreakStatement yieldBreakStatement, T data);
    public virtual S VisitYieldReturnStatement(YieldReturnStatement yieldReturnStatement, T data);
    public virtual S VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression, T data);
    public virtual S VisitLambdaExpression(LambdaExpression lambdaExpression, T data);
    public virtual S VisitAssignmentExpression(AssignmentExpression assignmentExpression, T data);
    public virtual S VisitBaseReferenceExpression(BaseReferenceExpression baseReferenceExpression, T data);
    public virtual S VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression, T data);
    public virtual S VisitCastExpression(CastExpression castExpression, T data);
    public virtual S VisitCheckedExpression(CheckedExpression checkedExpression, T data);
    public virtual S VisitConditionalExpression(ConditionalExpression conditionalExpression, T data);
    public virtual S VisitIdentifierExpression(IdentifierExpression identifierExpression, T data);
    public virtual S VisitIndexerExpression(IndexerExpression indexerExpression, T data);
    public virtual S VisitInterpolatedStringExpression(InterpolatedStringExpression interpolatedStringExpression, T data);
    public virtual S VisitInterpolation(Interpolation interpolation, T data);
    public virtual S VisitInterpolatedStringText(InterpolatedStringText interpolatedStringText, T data);
    public virtual S VisitInvocationExpression(InvocationExpression invocationExpression, T data);
    public virtual S VisitDirectionExpression(DirectionExpression directionExpression, T data);
    public virtual S VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression, T data);
    public virtual S VisitNullReferenceExpression(NullReferenceExpression nullReferenceExpression, T data);
    public virtual S VisitObjectCreateExpression(ObjectCreateExpression objectCreateExpression, T data);
    public virtual S VisitDeclarationExpression(DeclarationExpression declarationExpression, T data);
    public virtual S VisitOutVarDeclarationExpression(OutVarDeclarationExpression outVarDeclarationExpression, T data);
    public virtual S VisitAnonymousTypeCreateExpression(AnonymousTypeCreateExpression anonymousTypeCreateExpression, T data);
    public virtual S VisitArrayCreateExpression(ArrayCreateExpression arrayCreateExpression, T data);
    public virtual S VisitParenthesizedExpression(ParenthesizedExpression parenthesizedExpression, T data);
    public virtual S VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression, T data);
    public virtual S VisitPrimitiveExpression(PrimitiveExpression primitiveExpression, T data);
    public virtual S VisitSizeOfExpression(SizeOfExpression sizeOfExpression, T data);
    public virtual S VisitStackAllocExpression(StackAllocExpression stackAllocExpression, T data);
    public virtual S VisitThisReferenceExpression(ThisReferenceExpression thisReferenceExpression, T data);
    public virtual S VisitThrowExpression(ThrowExpression throwExpression, T data);
    public virtual S VisitTupleExpression(TupleExpression tupleExpression, T data);
    public virtual S VisitTypeOfExpression(TypeOfExpression typeOfExpression, T data);
    public virtual S VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression, T data);
    public virtual S VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression, T data);
    public virtual S VisitUncheckedExpression(UncheckedExpression uncheckedExpression, T data);
    public virtual S VisitQueryExpression(QueryExpression queryExpression, T data);
    public virtual S VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause, T data);
    public virtual S VisitQueryFromClause(QueryFromClause queryFromClause, T data);
    public virtual S VisitQueryLetClause(QueryLetClause queryLetClause, T data);
    public virtual S VisitQueryWhereClause(QueryWhereClause queryWhereClause, T data);
    public virtual S VisitQueryJoinClause(QueryJoinClause queryJoinClause, T data);
    public virtual S VisitQueryOrderClause(QueryOrderClause queryOrderClause, T data);
    public virtual S VisitQueryOrdering(QueryOrdering queryOrdering, T data);
    public virtual S VisitQuerySelectClause(QuerySelectClause querySelectClause, T data);
    public virtual S VisitQueryGroupClause(QueryGroupClause queryGroupClause, T data);
    public virtual S VisitAsExpression(AsExpression asExpression, T data);
    public virtual S VisitIsExpression(IsExpression isExpression, T data);
    public virtual S VisitDefaultValueExpression(DefaultValueExpression defaultValueExpression, T data);
    public virtual S VisitUndocumentedExpression(UndocumentedExpression undocumentedExpression, T data);
    public virtual S VisitArrayInitializerExpression(ArrayInitializerExpression arrayInitializerExpression, T data);
    public virtual S VisitArraySpecifier(ArraySpecifier arraySpecifier, T data);
    public virtual S VisitNamedArgumentExpression(NamedArgumentExpression namedArgumentExpression, T data);
    public virtual S VisitNamedExpression(NamedExpression namedExpression, T data);
    public virtual S VisitSingleVariableDesignation(SingleVariableDesignation singleVariableDesignation, T data);
    public virtual S VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignation parenthesizedVariableDesignation, T data);
    public virtual S VisitErrorNode(AstNode errorNode, T data);
    public virtual S VisitPatternPlaceholder(AstNode placeholder, Pattern pattern, T data);
    public virtual S VisitWithInitializerExpression(WithInitializerExpression withInitializerExpression, T data);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.DestructorDeclaration : EntityDeclaration {
    public static TokenRole TildeRole;
    public CSharpTokenNode TildeToken { get; }
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode LParToken { get; }
    public CSharpTokenNode RParToken { get; }
    public BlockStatement Body { get; public set; }
    private static DestructorDeclaration();
    public CSharpTokenNode get_TildeToken();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_LParToken();
    public CSharpTokenNode get_RParToken();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.DirectionExpression : Expression {
    public static TokenRole RefKeywordRole;
    public static TokenRole OutKeywordRole;
    public static TokenRole InKeywordRole;
    [CompilerGeneratedAttribute]
private FieldDirection <FieldDirection>k__BackingField;
    public FieldDirection FieldDirection { get; public set; }
    public CSharpTokenNode FieldDirectionToken { get; }
    public Expression Expression { get; public set; }
    public DirectionExpression(FieldDirection direction, Expression expression);
    private static DirectionExpression();
    [CompilerGeneratedAttribute]
public FieldDirection get_FieldDirection();
    [CompilerGeneratedAttribute]
public void set_FieldDirection(FieldDirection value);
    public CSharpTokenNode get_FieldDirectionToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.DocumentationReference : AstNode {
    public static Role`1<AstType> DeclaringTypeRole;
    public static Role`1<AstType> ConversionOperatorReturnTypeRole;
    private SymbolKind symbolKind;
    private OperatorType operatorType;
    private bool hasParameterList;
    public SymbolKind SymbolKind { get; public set; }
    public OperatorType OperatorType { get; public set; }
    public bool HasParameterList { get; public set; }
    public NodeType NodeType { get; }
    public AstType DeclaringType { get; public set; }
    public string MemberName { get; public set; }
    public AstType ConversionOperatorReturnType { get; public set; }
    public AstNodeCollection`1<AstType> TypeArguments { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    private static DocumentationReference();
    public SymbolKind get_SymbolKind();
    public void set_SymbolKind(SymbolKind value);
    public OperatorType get_OperatorType();
    public void set_OperatorType(OperatorType value);
    public bool get_HasParameterList();
    public void set_HasParameterList(bool value);
    public virtual NodeType get_NodeType();
    public AstType get_DeclaringType();
    public void set_DeclaringType(AstType value);
    public string get_MemberName();
    public void set_MemberName(string value);
    public AstType get_ConversionOperatorReturnType();
    public void set_ConversionOperatorReturnType(AstType value);
    public AstNodeCollection`1<AstType> get_TypeArguments();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.DoWhileStatement : Statement {
    public static TokenRole DoKeywordRole;
    public static TokenRole WhileKeywordRole;
    public CSharpTokenNode DoToken { get; }
    public Statement EmbeddedStatement { get; public set; }
    public CSharpTokenNode WhileToken { get; }
    public CSharpTokenNode LParToken { get; }
    public Expression Condition { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public CSharpTokenNode SemicolonToken { get; }
    public DoWhileStatement(Expression condition, Statement embeddedStatement);
    private static DoWhileStatement();
    public CSharpTokenNode get_DoToken();
    public Statement get_EmbeddedStatement();
    public void set_EmbeddedStatement(Statement value);
    public CSharpTokenNode get_WhileToken();
    public CSharpTokenNode get_LParToken();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public CSharpTokenNode get_RParToken();
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.EmptyStatement : Statement {
    [CompilerGeneratedAttribute]
private TextLocation <Location>k__BackingField;
    public TextLocation Location { get; public set; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    [CompilerGeneratedAttribute]
public TextLocation get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(TextLocation value);
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.EntityDeclaration : AstNode {
    public static Role`1<AttributeSection> AttributeRole;
    public static Role`1<CSharpModifierToken> ModifierRole;
    public static Role`1<AstType> PrivateImplementationTypeRole;
    public NodeType NodeType { get; }
    public SymbolKind SymbolKind { get; }
    public AstNodeCollection`1<AttributeSection> Attributes { get; }
    public Modifiers Modifiers { get; public set; }
    public IEnumerable`1<CSharpModifierToken> ModifierTokens { get; }
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public AstType ReturnType { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    private static EntityDeclaration();
    public virtual NodeType get_NodeType();
    public abstract virtual SymbolKind get_SymbolKind();
    public AstNodeCollection`1<AttributeSection> get_Attributes();
    public Modifiers get_Modifiers();
    public void set_Modifiers(Modifiers value);
    public bool HasModifier(Modifiers mod);
    public IEnumerable`1<CSharpModifierToken> get_ModifierTokens();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual Identifier get_NameToken();
    public virtual void set_NameToken(Identifier value);
    public virtual AstType get_ReturnType();
    public virtual void set_ReturnType(AstType value);
    public CSharpTokenNode get_SemicolonToken();
    internal static Modifiers GetModifiers(AstNode node);
    internal static void SetModifiers(AstNode node, Modifiers newValue);
    protected bool MatchAttributesAndModifiers(EntityDeclaration o, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.EnumMemberDeclaration : EntityDeclaration {
    public static Role`1<Expression> InitializerRole;
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode AssignToken { get; }
    public Expression Initializer { get; public set; }
    private static EnumMemberDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_AssignToken();
    public Expression get_Initializer();
    public void set_Initializer(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ErrorExpression : Expression {
    [CompilerGeneratedAttribute]
private TextLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public TextLocation Location { get; public set; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    public string Error { get; private set; }
    public ErrorExpression(string error);
    [CompilerGeneratedAttribute]
public TextLocation get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(TextLocation value);
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(string value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.EventDeclaration : EntityDeclaration {
    public static TokenRole EventKeywordRole;
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode EventToken { get; }
    public AstNodeCollection`1<VariableInitializer> Variables { get; }
    [EditorBrowsableAttribute("1")]
public string Name { get; public set; }
    [EditorBrowsableAttribute("1")]
public Identifier NameToken { get; public set; }
    private static EventDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_EventToken();
    public AstNodeCollection`1<VariableInitializer> get_Variables();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual Identifier get_NameToken();
    public virtual void set_NameToken(Identifier value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.Expression : AstNode {
    public static Expression Null;
    public NodeType NodeType { get; }
    private static Expression();
    public static Expression op_Implicit(Pattern pattern);
    public virtual NodeType get_NodeType();
    public Expression Clone();
    public Expression ReplaceWith(Func`2<Expression, Expression> replaceFunction);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ExpressionStatement : Statement {
    public Expression Expression { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    public ExpressionStatement(Expression expression);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ExternAliasDeclaration : AstNode {
    public NodeType NodeType { get; }
    public CSharpTokenNode ExternToken { get; }
    public CSharpTokenNode AliasToken { get; }
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    public virtual NodeType get_NodeType();
    public CSharpTokenNode get_ExternToken();
    public CSharpTokenNode get_AliasToken();
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.FieldDeclaration : EntityDeclaration {
    public SymbolKind SymbolKind { get; }
    public AstNodeCollection`1<VariableInitializer> Variables { get; }
    [EditorBrowsableAttribute("1")]
public string Name { get; public set; }
    [EditorBrowsableAttribute("1")]
public Identifier NameToken { get; public set; }
    public virtual SymbolKind get_SymbolKind();
    public AstNodeCollection`1<VariableInitializer> get_Variables();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual Identifier get_NameToken();
    public virtual void set_NameToken(Identifier value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.FieldDirection : Enum {
    public int value__;
    public static FieldDirection None;
    public static FieldDirection Out;
    public static FieldDirection Ref;
    public static FieldDirection In;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.FixedFieldDeclaration : EntityDeclaration {
    public static TokenRole FixedKeywordRole;
    public static Role`1<FixedVariableInitializer> VariableRole;
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode FixedToken { get; }
    public AstNodeCollection`1<FixedVariableInitializer> Variables { get; }
    private static FixedFieldDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_FixedToken();
    public AstNodeCollection`1<FixedVariableInitializer> get_Variables();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.FixedStatement : Statement {
    public static TokenRole FixedKeywordRole;
    public CSharpTokenNode FixedToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstType Type { get; public set; }
    public AstNodeCollection`1<VariableInitializer> Variables { get; }
    public CSharpTokenNode RParToken { get; }
    public Statement EmbeddedStatement { get; public set; }
    private static FixedStatement();
    public CSharpTokenNode get_FixedToken();
    public CSharpTokenNode get_LParToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public AstNodeCollection`1<VariableInitializer> get_Variables();
    public CSharpTokenNode get_RParToken();
    public Statement get_EmbeddedStatement();
    public void set_EmbeddedStatement(Statement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.FixedVariableInitializer : AstNode {
    public NodeType NodeType { get; }
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public CSharpTokenNode LBracketToken { get; }
    public Expression CountExpression { get; public set; }
    public CSharpTokenNode RBracketToken { get; }
    public FixedVariableInitializer(string name, Expression initializer);
    public virtual NodeType get_NodeType();
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public CSharpTokenNode get_LBracketToken();
    public Expression get_CountExpression();
    public void set_CountExpression(Expression value);
    public CSharpTokenNode get_RBracketToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ForeachStatement : Statement {
    public static TokenRole AwaitRole;
    public static TokenRole ForeachKeywordRole;
    public static TokenRole InKeywordRole;
    public CSharpTokenNode AwaitToken { get; }
    public bool IsAsync { get; public set; }
    public CSharpTokenNode ForeachToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstType VariableType { get; public set; }
    public VariableDesignation VariableDesignation { get; public set; }
    public CSharpTokenNode InToken { get; }
    public Expression InExpression { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public Statement EmbeddedStatement { get; public set; }
    private static ForeachStatement();
    public CSharpTokenNode get_AwaitToken();
    public bool get_IsAsync();
    public void set_IsAsync(bool value);
    public CSharpTokenNode get_ForeachToken();
    public CSharpTokenNode get_LParToken();
    public AstType get_VariableType();
    public void set_VariableType(AstType value);
    public VariableDesignation get_VariableDesignation();
    public void set_VariableDesignation(VariableDesignation value);
    public CSharpTokenNode get_InToken();
    public Expression get_InExpression();
    public void set_InExpression(Expression value);
    public CSharpTokenNode get_RParToken();
    public Statement get_EmbeddedStatement();
    public void set_EmbeddedStatement(Statement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ForStatement : Statement {
    public static TokenRole ForKeywordRole;
    public static Role`1<Statement> InitializerRole;
    public static Role`1<Statement> IteratorRole;
    public CSharpTokenNode ForToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<Statement> Initializers { get; }
    public Expression Condition { get; public set; }
    public AstNodeCollection`1<Statement> Iterators { get; }
    public CSharpTokenNode RParToken { get; }
    public Statement EmbeddedStatement { get; public set; }
    private static ForStatement();
    public CSharpTokenNode get_ForToken();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<Statement> get_Initializers();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public AstNodeCollection`1<Statement> get_Iterators();
    public CSharpTokenNode get_RParToken();
    public Statement get_EmbeddedStatement();
    public void set_EmbeddedStatement(Statement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.FunctionPointerAstType : AstType {
    public static TokenRole PointerRole;
    public static Role`1<AstType> CallingConventionRole;
    [CompilerGeneratedAttribute]
private bool <HasUnmanagedCallingConvention>k__BackingField;
    public bool HasUnmanagedCallingConvention { get; public set; }
    public AstNodeCollection`1<AstType> CallingConventions { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public AstType ReturnType { get; public set; }
    private static FunctionPointerAstType();
    [CompilerGeneratedAttribute]
public bool get_HasUnmanagedCallingConvention();
    [CompilerGeneratedAttribute]
public void set_HasUnmanagedCallingConvention(bool value);
    public AstNodeCollection`1<AstType> get_CallingConventions();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public AstType get_ReturnType();
    public void set_ReturnType(AstType value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.GotoCaseStatement : Statement {
    public static TokenRole GotoKeywordRole;
    public static TokenRole CaseKeywordRole;
    public CSharpTokenNode GotoToken { get; }
    public CSharpTokenNode CaseToken { get; }
    public Expression LabelExpression { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    private static GotoCaseStatement();
    public CSharpTokenNode get_GotoToken();
    public CSharpTokenNode get_CaseToken();
    public Expression get_LabelExpression();
    public void set_LabelExpression(Expression value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.GotoDefaultStatement : Statement {
    public static TokenRole GotoKeywordRole;
    public static TokenRole DefaultKeywordRole;
    public CSharpTokenNode GotoToken { get; }
    public CSharpTokenNode DefaultToken { get; }
    public CSharpTokenNode SemicolonToken { get; }
    private static GotoDefaultStatement();
    public CSharpTokenNode get_GotoToken();
    public CSharpTokenNode get_DefaultToken();
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.GotoStatement : Statement {
    public static TokenRole GotoKeywordRole;
    public CSharpTokenNode GotoToken { get; }
    public string Label { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    public GotoStatement(string label);
    private static GotoStatement();
    public CSharpTokenNode get_GotoToken();
    public string get_Label();
    public void set_Label(string value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public interface ICSharpCode.Decompiler.CSharp.Syntax.IAnnotatable {
    public IEnumerable`1<object> Annotations { get; }
    public abstract virtual IEnumerable`1<object> get_Annotations();
    public abstract virtual T Annotation();
    public abstract virtual object Annotation(Type type);
    public abstract virtual void AddAnnotation(object annotation);
    public abstract virtual void RemoveAnnotations();
    public abstract virtual void RemoveAnnotations(Type type);
}
public interface ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor {
    public abstract virtual void VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression);
    public abstract virtual void VisitAnonymousTypeCreateExpression(AnonymousTypeCreateExpression anonymousTypeCreateExpression);
    public abstract virtual void VisitArrayCreateExpression(ArrayCreateExpression arrayCreateExpression);
    public abstract virtual void VisitArrayInitializerExpression(ArrayInitializerExpression arrayInitializerExpression);
    public abstract virtual void VisitAsExpression(AsExpression asExpression);
    public abstract virtual void VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    public abstract virtual void VisitBaseReferenceExpression(BaseReferenceExpression baseReferenceExpression);
    public abstract virtual void VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression);
    public abstract virtual void VisitCastExpression(CastExpression castExpression);
    public abstract virtual void VisitCheckedExpression(CheckedExpression checkedExpression);
    public abstract virtual void VisitConditionalExpression(ConditionalExpression conditionalExpression);
    public abstract virtual void VisitDeclarationExpression(DeclarationExpression declarationExpression);
    public abstract virtual void VisitDefaultValueExpression(DefaultValueExpression defaultValueExpression);
    public abstract virtual void VisitDirectionExpression(DirectionExpression directionExpression);
    public abstract virtual void VisitIdentifierExpression(IdentifierExpression identifierExpression);
    public abstract virtual void VisitIndexerExpression(IndexerExpression indexerExpression);
    public abstract virtual void VisitInterpolatedStringExpression(InterpolatedStringExpression interpolatedStringExpression);
    public abstract virtual void VisitInvocationExpression(InvocationExpression invocationExpression);
    public abstract virtual void VisitIsExpression(IsExpression isExpression);
    public abstract virtual void VisitLambdaExpression(LambdaExpression lambdaExpression);
    public abstract virtual void VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public abstract virtual void VisitNamedArgumentExpression(NamedArgumentExpression namedArgumentExpression);
    public abstract virtual void VisitNamedExpression(NamedExpression namedExpression);
    public abstract virtual void VisitNullReferenceExpression(NullReferenceExpression nullReferenceExpression);
    public abstract virtual void VisitObjectCreateExpression(ObjectCreateExpression objectCreateExpression);
    public abstract virtual void VisitOutVarDeclarationExpression(OutVarDeclarationExpression outVarDeclarationExpression);
    public abstract virtual void VisitParenthesizedExpression(ParenthesizedExpression parenthesizedExpression);
    public abstract virtual void VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression);
    public abstract virtual void VisitPrimitiveExpression(PrimitiveExpression primitiveExpression);
    public abstract virtual void VisitSizeOfExpression(SizeOfExpression sizeOfExpression);
    public abstract virtual void VisitStackAllocExpression(StackAllocExpression stackAllocExpression);
    public abstract virtual void VisitThisReferenceExpression(ThisReferenceExpression thisReferenceExpression);
    public abstract virtual void VisitThrowExpression(ThrowExpression throwExpression);
    public abstract virtual void VisitTupleExpression(TupleExpression tupleExpression);
    public abstract virtual void VisitTypeOfExpression(TypeOfExpression typeOfExpression);
    public abstract virtual void VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression);
    public abstract virtual void VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression);
    public abstract virtual void VisitUncheckedExpression(UncheckedExpression uncheckedExpression);
    public abstract virtual void VisitUndocumentedExpression(UndocumentedExpression undocumentedExpression);
    public abstract virtual void VisitWithInitializerExpression(WithInitializerExpression withInitializerExpression);
    public abstract virtual void VisitQueryExpression(QueryExpression queryExpression);
    public abstract virtual void VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause);
    public abstract virtual void VisitQueryFromClause(QueryFromClause queryFromClause);
    public abstract virtual void VisitQueryLetClause(QueryLetClause queryLetClause);
    public abstract virtual void VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    public abstract virtual void VisitQueryJoinClause(QueryJoinClause queryJoinClause);
    public abstract virtual void VisitQueryOrderClause(QueryOrderClause queryOrderClause);
    public abstract virtual void VisitQueryOrdering(QueryOrdering queryOrdering);
    public abstract virtual void VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public abstract virtual void VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public abstract virtual void VisitAttribute(Attribute attribute);
    public abstract virtual void VisitAttributeSection(AttributeSection attributeSection);
    public abstract virtual void VisitDelegateDeclaration(DelegateDeclaration delegateDeclaration);
    public abstract virtual void VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public abstract virtual void VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public abstract virtual void VisitUsingAliasDeclaration(UsingAliasDeclaration usingAliasDeclaration);
    public abstract virtual void VisitUsingDeclaration(UsingDeclaration usingDeclaration);
    public abstract virtual void VisitExternAliasDeclaration(ExternAliasDeclaration externAliasDeclaration);
    public abstract virtual void VisitBlockStatement(BlockStatement blockStatement);
    public abstract virtual void VisitBreakStatement(BreakStatement breakStatement);
    public abstract virtual void VisitCheckedStatement(CheckedStatement checkedStatement);
    public abstract virtual void VisitContinueStatement(ContinueStatement continueStatement);
    public abstract virtual void VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public abstract virtual void VisitEmptyStatement(EmptyStatement emptyStatement);
    public abstract virtual void VisitExpressionStatement(ExpressionStatement expressionStatement);
    public abstract virtual void VisitFixedStatement(FixedStatement fixedStatement);
    public abstract virtual void VisitForeachStatement(ForeachStatement foreachStatement);
    public abstract virtual void VisitForStatement(ForStatement forStatement);
    public abstract virtual void VisitGotoCaseStatement(GotoCaseStatement gotoCaseStatement);
    public abstract virtual void VisitGotoDefaultStatement(GotoDefaultStatement gotoDefaultStatement);
    public abstract virtual void VisitGotoStatement(GotoStatement gotoStatement);
    public abstract virtual void VisitIfElseStatement(IfElseStatement ifElseStatement);
    public abstract virtual void VisitLabelStatement(LabelStatement labelStatement);
    public abstract virtual void VisitLockStatement(LockStatement lockStatement);
    public abstract virtual void VisitReturnStatement(ReturnStatement returnStatement);
    public abstract virtual void VisitSwitchStatement(SwitchStatement switchStatement);
    public abstract virtual void VisitSwitchSection(SwitchSection switchSection);
    public abstract virtual void VisitCaseLabel(CaseLabel caseLabel);
    public abstract virtual void VisitSwitchExpression(SwitchExpression switchExpression);
    public abstract virtual void VisitSwitchExpressionSection(SwitchExpressionSection switchExpressionSection);
    public abstract virtual void VisitThrowStatement(ThrowStatement throwStatement);
    public abstract virtual void VisitTryCatchStatement(TryCatchStatement tryCatchStatement);
    public abstract virtual void VisitCatchClause(CatchClause catchClause);
    public abstract virtual void VisitUncheckedStatement(UncheckedStatement uncheckedStatement);
    public abstract virtual void VisitUnsafeStatement(UnsafeStatement unsafeStatement);
    public abstract virtual void VisitUsingStatement(UsingStatement usingStatement);
    public abstract virtual void VisitVariableDeclarationStatement(VariableDeclarationStatement variableDeclarationStatement);
    public abstract virtual void VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatement localFunctionDeclarationStatement);
    public abstract virtual void VisitWhileStatement(WhileStatement whileStatement);
    public abstract virtual void VisitYieldBreakStatement(YieldBreakStatement yieldBreakStatement);
    public abstract virtual void VisitYieldReturnStatement(YieldReturnStatement yieldReturnStatement);
    public abstract virtual void VisitAccessor(Accessor accessor);
    public abstract virtual void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public abstract virtual void VisitConstructorInitializer(ConstructorInitializer constructorInitializer);
    public abstract virtual void VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public abstract virtual void VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration);
    public abstract virtual void VisitEventDeclaration(EventDeclaration eventDeclaration);
    public abstract virtual void VisitCustomEventDeclaration(CustomEventDeclaration customEventDeclaration);
    public abstract virtual void VisitFieldDeclaration(FieldDeclaration fieldDeclaration);
    public abstract virtual void VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    public abstract virtual void VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public abstract virtual void VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration);
    public abstract virtual void VisitParameterDeclaration(ParameterDeclaration parameterDeclaration);
    public abstract virtual void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public abstract virtual void VisitVariableInitializer(VariableInitializer variableInitializer);
    public abstract virtual void VisitFixedFieldDeclaration(FixedFieldDeclaration fixedFieldDeclaration);
    public abstract virtual void VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer);
    public abstract virtual void VisitSyntaxTree(SyntaxTree syntaxTree);
    public abstract virtual void VisitSimpleType(SimpleType simpleType);
    public abstract virtual void VisitMemberType(MemberType memberType);
    public abstract virtual void VisitTupleType(TupleAstType tupleType);
    public abstract virtual void VisitTupleTypeElement(TupleTypeElement tupleTypeElement);
    public abstract virtual void VisitFunctionPointerType(FunctionPointerAstType functionPointerType);
    public abstract virtual void VisitInvocationType(InvocationAstType invocationType);
    public abstract virtual void VisitComposedType(ComposedType composedType);
    public abstract virtual void VisitArraySpecifier(ArraySpecifier arraySpecifier);
    public abstract virtual void VisitPrimitiveType(PrimitiveType primitiveType);
    public abstract virtual void VisitComment(Comment comment);
    public abstract virtual void VisitPreProcessorDirective(PreProcessorDirective preProcessorDirective);
    public abstract virtual void VisitDocumentationReference(DocumentationReference documentationReference);
    public abstract virtual void VisitTypeParameterDeclaration(TypeParameterDeclaration typeParameterDeclaration);
    public abstract virtual void VisitConstraint(Constraint constraint);
    public abstract virtual void VisitCSharpTokenNode(CSharpTokenNode cSharpTokenNode);
    public abstract virtual void VisitIdentifier(Identifier identifier);
    public abstract virtual void VisitInterpolation(Interpolation interpolation);
    public abstract virtual void VisitInterpolatedStringText(InterpolatedStringText interpolatedStringText);
    public abstract virtual void VisitSingleVariableDesignation(SingleVariableDesignation singleVariableDesignation);
    public abstract virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignation parenthesizedVariableDesignation);
    public abstract virtual void VisitNullNode(AstNode nullNode);
    public abstract virtual void VisitErrorNode(AstNode errorNode);
    public abstract virtual void VisitPatternPlaceholder(AstNode placeholder, Pattern pattern);
}
public interface ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor`1 {
    public abstract virtual S VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression);
    public abstract virtual S VisitAnonymousTypeCreateExpression(AnonymousTypeCreateExpression anonymousTypeCreateExpression);
    public abstract virtual S VisitArrayCreateExpression(ArrayCreateExpression arrayCreateExpression);
    public abstract virtual S VisitArrayInitializerExpression(ArrayInitializerExpression arrayInitializerExpression);
    public abstract virtual S VisitAsExpression(AsExpression asExpression);
    public abstract virtual S VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    public abstract virtual S VisitBaseReferenceExpression(BaseReferenceExpression baseReferenceExpression);
    public abstract virtual S VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression);
    public abstract virtual S VisitCastExpression(CastExpression castExpression);
    public abstract virtual S VisitCheckedExpression(CheckedExpression checkedExpression);
    public abstract virtual S VisitConditionalExpression(ConditionalExpression conditionalExpression);
    public abstract virtual S VisitDeclarationExpression(DeclarationExpression declarationExpression);
    public abstract virtual S VisitDefaultValueExpression(DefaultValueExpression defaultValueExpression);
    public abstract virtual S VisitDirectionExpression(DirectionExpression directionExpression);
    public abstract virtual S VisitIdentifierExpression(IdentifierExpression identifierExpression);
    public abstract virtual S VisitIndexerExpression(IndexerExpression indexerExpression);
    public abstract virtual S VisitInterpolatedStringExpression(InterpolatedStringExpression interpolatedStringExpression);
    public abstract virtual S VisitInvocationExpression(InvocationExpression invocationExpression);
    public abstract virtual S VisitIsExpression(IsExpression isExpression);
    public abstract virtual S VisitLambdaExpression(LambdaExpression lambdaExpression);
    public abstract virtual S VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public abstract virtual S VisitNamedArgumentExpression(NamedArgumentExpression namedArgumentExpression);
    public abstract virtual S VisitNamedExpression(NamedExpression namedExpression);
    public abstract virtual S VisitNullReferenceExpression(NullReferenceExpression nullReferenceExpression);
    public abstract virtual S VisitObjectCreateExpression(ObjectCreateExpression objectCreateExpression);
    public abstract virtual S VisitOutVarDeclarationExpression(OutVarDeclarationExpression outVarDeclarationExpression);
    public abstract virtual S VisitParenthesizedExpression(ParenthesizedExpression parenthesizedExpression);
    public abstract virtual S VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression);
    public abstract virtual S VisitPrimitiveExpression(PrimitiveExpression primitiveExpression);
    public abstract virtual S VisitSizeOfExpression(SizeOfExpression sizeOfExpression);
    public abstract virtual S VisitStackAllocExpression(StackAllocExpression stackAllocExpression);
    public abstract virtual S VisitThisReferenceExpression(ThisReferenceExpression thisReferenceExpression);
    public abstract virtual S VisitThrowExpression(ThrowExpression throwExpression);
    public abstract virtual S VisitTupleExpression(TupleExpression tupleExpression);
    public abstract virtual S VisitTypeOfExpression(TypeOfExpression typeOfExpression);
    public abstract virtual S VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression);
    public abstract virtual S VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression);
    public abstract virtual S VisitUncheckedExpression(UncheckedExpression uncheckedExpression);
    public abstract virtual S VisitUndocumentedExpression(UndocumentedExpression undocumentedExpression);
    public abstract virtual S VisitWithInitializerExpression(WithInitializerExpression withInitializerExpression);
    public abstract virtual S VisitQueryExpression(QueryExpression queryExpression);
    public abstract virtual S VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause);
    public abstract virtual S VisitQueryFromClause(QueryFromClause queryFromClause);
    public abstract virtual S VisitQueryLetClause(QueryLetClause queryLetClause);
    public abstract virtual S VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    public abstract virtual S VisitQueryJoinClause(QueryJoinClause queryJoinClause);
    public abstract virtual S VisitQueryOrderClause(QueryOrderClause queryOrderClause);
    public abstract virtual S VisitQueryOrdering(QueryOrdering queryOrdering);
    public abstract virtual S VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public abstract virtual S VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public abstract virtual S VisitAttribute(Attribute attribute);
    public abstract virtual S VisitAttributeSection(AttributeSection attributeSection);
    public abstract virtual S VisitDelegateDeclaration(DelegateDeclaration delegateDeclaration);
    public abstract virtual S VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public abstract virtual S VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public abstract virtual S VisitUsingAliasDeclaration(UsingAliasDeclaration usingAliasDeclaration);
    public abstract virtual S VisitUsingDeclaration(UsingDeclaration usingDeclaration);
    public abstract virtual S VisitExternAliasDeclaration(ExternAliasDeclaration externAliasDeclaration);
    public abstract virtual S VisitBlockStatement(BlockStatement blockStatement);
    public abstract virtual S VisitBreakStatement(BreakStatement breakStatement);
    public abstract virtual S VisitCheckedStatement(CheckedStatement checkedStatement);
    public abstract virtual S VisitContinueStatement(ContinueStatement continueStatement);
    public abstract virtual S VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public abstract virtual S VisitEmptyStatement(EmptyStatement emptyStatement);
    public abstract virtual S VisitExpressionStatement(ExpressionStatement expressionStatement);
    public abstract virtual S VisitFixedStatement(FixedStatement fixedStatement);
    public abstract virtual S VisitForeachStatement(ForeachStatement foreachStatement);
    public abstract virtual S VisitForStatement(ForStatement forStatement);
    public abstract virtual S VisitGotoCaseStatement(GotoCaseStatement gotoCaseStatement);
    public abstract virtual S VisitGotoDefaultStatement(GotoDefaultStatement gotoDefaultStatement);
    public abstract virtual S VisitGotoStatement(GotoStatement gotoStatement);
    public abstract virtual S VisitIfElseStatement(IfElseStatement ifElseStatement);
    public abstract virtual S VisitLabelStatement(LabelStatement labelStatement);
    public abstract virtual S VisitLockStatement(LockStatement lockStatement);
    public abstract virtual S VisitReturnStatement(ReturnStatement returnStatement);
    public abstract virtual S VisitSwitchStatement(SwitchStatement switchStatement);
    public abstract virtual S VisitSwitchSection(SwitchSection switchSection);
    public abstract virtual S VisitCaseLabel(CaseLabel caseLabel);
    public abstract virtual S VisitSwitchExpression(SwitchExpression switchExpression);
    public abstract virtual S VisitSwitchExpressionSection(SwitchExpressionSection switchExpressionSection);
    public abstract virtual S VisitThrowStatement(ThrowStatement throwStatement);
    public abstract virtual S VisitTryCatchStatement(TryCatchStatement tryCatchStatement);
    public abstract virtual S VisitCatchClause(CatchClause catchClause);
    public abstract virtual S VisitUncheckedStatement(UncheckedStatement uncheckedStatement);
    public abstract virtual S VisitUnsafeStatement(UnsafeStatement unsafeStatement);
    public abstract virtual S VisitUsingStatement(UsingStatement usingStatement);
    public abstract virtual S VisitVariableDeclarationStatement(VariableDeclarationStatement variableDeclarationStatement);
    public abstract virtual S VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatement localFunctionDeclarationStatement);
    public abstract virtual S VisitWhileStatement(WhileStatement whileStatement);
    public abstract virtual S VisitYieldBreakStatement(YieldBreakStatement yieldBreakStatement);
    public abstract virtual S VisitYieldReturnStatement(YieldReturnStatement yieldReturnStatement);
    public abstract virtual S VisitAccessor(Accessor accessor);
    public abstract virtual S VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public abstract virtual S VisitConstructorInitializer(ConstructorInitializer constructorInitializer);
    public abstract virtual S VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public abstract virtual S VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration);
    public abstract virtual S VisitEventDeclaration(EventDeclaration eventDeclaration);
    public abstract virtual S VisitCustomEventDeclaration(CustomEventDeclaration customEventDeclaration);
    public abstract virtual S VisitFieldDeclaration(FieldDeclaration fieldDeclaration);
    public abstract virtual S VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    public abstract virtual S VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public abstract virtual S VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration);
    public abstract virtual S VisitParameterDeclaration(ParameterDeclaration parameterDeclaration);
    public abstract virtual S VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public abstract virtual S VisitVariableInitializer(VariableInitializer variableInitializer);
    public abstract virtual S VisitFixedFieldDeclaration(FixedFieldDeclaration fixedFieldDeclaration);
    public abstract virtual S VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer);
    public abstract virtual S VisitSyntaxTree(SyntaxTree syntaxTree);
    public abstract virtual S VisitSimpleType(SimpleType simpleType);
    public abstract virtual S VisitMemberType(MemberType memberType);
    public abstract virtual S VisitTupleType(TupleAstType tupleType);
    public abstract virtual S VisitTupleTypeElement(TupleTypeElement tupleTypeElement);
    public abstract virtual S VisitFunctionPointerType(FunctionPointerAstType functionPointerType);
    public abstract virtual S VisitInvocationType(InvocationAstType invocationType);
    public abstract virtual S VisitComposedType(ComposedType composedType);
    public abstract virtual S VisitArraySpecifier(ArraySpecifier arraySpecifier);
    public abstract virtual S VisitPrimitiveType(PrimitiveType primitiveType);
    public abstract virtual S VisitComment(Comment comment);
    public abstract virtual S VisitPreProcessorDirective(PreProcessorDirective preProcessorDirective);
    public abstract virtual S VisitDocumentationReference(DocumentationReference documentationReference);
    public abstract virtual S VisitTypeParameterDeclaration(TypeParameterDeclaration typeParameterDeclaration);
    public abstract virtual S VisitConstraint(Constraint constraint);
    public abstract virtual S VisitCSharpTokenNode(CSharpTokenNode cSharpTokenNode);
    public abstract virtual S VisitIdentifier(Identifier identifier);
    public abstract virtual S VisitInterpolation(Interpolation interpolation);
    public abstract virtual S VisitInterpolatedStringText(InterpolatedStringText interpolatedStringText);
    public abstract virtual S VisitSingleVariableDesignation(SingleVariableDesignation singleVariableDesignation);
    public abstract virtual S VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignation parenthesizedVariableDesignation);
    public abstract virtual S VisitNullNode(AstNode nullNode);
    public abstract virtual S VisitErrorNode(AstNode errorNode);
    public abstract virtual S VisitPatternPlaceholder(AstNode placeholder, Pattern pattern);
}
public interface ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor`2 {
    public abstract virtual S VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression, T data);
    public abstract virtual S VisitAnonymousTypeCreateExpression(AnonymousTypeCreateExpression anonymousTypeCreateExpression, T data);
    public abstract virtual S VisitArrayCreateExpression(ArrayCreateExpression arrayCreateExpression, T data);
    public abstract virtual S VisitArrayInitializerExpression(ArrayInitializerExpression arrayInitializerExpression, T data);
    public abstract virtual S VisitAsExpression(AsExpression asExpression, T data);
    public abstract virtual S VisitAssignmentExpression(AssignmentExpression assignmentExpression, T data);
    public abstract virtual S VisitBaseReferenceExpression(BaseReferenceExpression baseReferenceExpression, T data);
    public abstract virtual S VisitBinaryOperatorExpression(BinaryOperatorExpression binaryOperatorExpression, T data);
    public abstract virtual S VisitCastExpression(CastExpression castExpression, T data);
    public abstract virtual S VisitCheckedExpression(CheckedExpression checkedExpression, T data);
    public abstract virtual S VisitConditionalExpression(ConditionalExpression conditionalExpression, T data);
    public abstract virtual S VisitDeclarationExpression(DeclarationExpression declarationExpression, T data);
    public abstract virtual S VisitDefaultValueExpression(DefaultValueExpression defaultValueExpression, T data);
    public abstract virtual S VisitDirectionExpression(DirectionExpression directionExpression, T data);
    public abstract virtual S VisitIdentifierExpression(IdentifierExpression identifierExpression, T data);
    public abstract virtual S VisitIndexerExpression(IndexerExpression indexerExpression, T data);
    public abstract virtual S VisitInterpolatedStringExpression(InterpolatedStringExpression interpolatedStringExpression, T data);
    public abstract virtual S VisitInvocationExpression(InvocationExpression invocationExpression, T data);
    public abstract virtual S VisitIsExpression(IsExpression isExpression, T data);
    public abstract virtual S VisitLambdaExpression(LambdaExpression lambdaExpression, T data);
    public abstract virtual S VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression, T data);
    public abstract virtual S VisitNamedArgumentExpression(NamedArgumentExpression namedArgumentExpression, T data);
    public abstract virtual S VisitNamedExpression(NamedExpression namedExpression, T data);
    public abstract virtual S VisitNullReferenceExpression(NullReferenceExpression nullReferenceExpression, T data);
    public abstract virtual S VisitObjectCreateExpression(ObjectCreateExpression objectCreateExpression, T data);
    public abstract virtual S VisitOutVarDeclarationExpression(OutVarDeclarationExpression outVarDeclarationExpression, T data);
    public abstract virtual S VisitParenthesizedExpression(ParenthesizedExpression parenthesizedExpression, T data);
    public abstract virtual S VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression, T data);
    public abstract virtual S VisitPrimitiveExpression(PrimitiveExpression primitiveExpression, T data);
    public abstract virtual S VisitSizeOfExpression(SizeOfExpression sizeOfExpression, T data);
    public abstract virtual S VisitStackAllocExpression(StackAllocExpression stackAllocExpression, T data);
    public abstract virtual S VisitThisReferenceExpression(ThisReferenceExpression thisReferenceExpression, T data);
    public abstract virtual S VisitThrowExpression(ThrowExpression throwExpression, T data);
    public abstract virtual S VisitTupleExpression(TupleExpression tupleExpression, T data);
    public abstract virtual S VisitTypeOfExpression(TypeOfExpression typeOfExpression, T data);
    public abstract virtual S VisitTypeReferenceExpression(TypeReferenceExpression typeReferenceExpression, T data);
    public abstract virtual S VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression, T data);
    public abstract virtual S VisitUncheckedExpression(UncheckedExpression uncheckedExpression, T data);
    public abstract virtual S VisitUndocumentedExpression(UndocumentedExpression undocumentedExpression, T data);
    public abstract virtual S VisitWithInitializerExpression(WithInitializerExpression withInitializerExpression, T data);
    public abstract virtual S VisitQueryExpression(QueryExpression queryExpression, T data);
    public abstract virtual S VisitQueryContinuationClause(QueryContinuationClause queryContinuationClause, T data);
    public abstract virtual S VisitQueryFromClause(QueryFromClause queryFromClause, T data);
    public abstract virtual S VisitQueryLetClause(QueryLetClause queryLetClause, T data);
    public abstract virtual S VisitQueryWhereClause(QueryWhereClause queryWhereClause, T data);
    public abstract virtual S VisitQueryJoinClause(QueryJoinClause queryJoinClause, T data);
    public abstract virtual S VisitQueryOrderClause(QueryOrderClause queryOrderClause, T data);
    public abstract virtual S VisitQueryOrdering(QueryOrdering queryOrdering, T data);
    public abstract virtual S VisitQuerySelectClause(QuerySelectClause querySelectClause, T data);
    public abstract virtual S VisitQueryGroupClause(QueryGroupClause queryGroupClause, T data);
    public abstract virtual S VisitAttribute(Attribute attribute, T data);
    public abstract virtual S VisitAttributeSection(AttributeSection attributeSection, T data);
    public abstract virtual S VisitDelegateDeclaration(DelegateDeclaration delegateDeclaration, T data);
    public abstract virtual S VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration, T data);
    public abstract virtual S VisitTypeDeclaration(TypeDeclaration typeDeclaration, T data);
    public abstract virtual S VisitUsingAliasDeclaration(UsingAliasDeclaration usingAliasDeclaration, T data);
    public abstract virtual S VisitUsingDeclaration(UsingDeclaration usingDeclaration, T data);
    public abstract virtual S VisitExternAliasDeclaration(ExternAliasDeclaration externAliasDeclaration, T data);
    public abstract virtual S VisitBlockStatement(BlockStatement blockStatement, T data);
    public abstract virtual S VisitBreakStatement(BreakStatement breakStatement, T data);
    public abstract virtual S VisitCheckedStatement(CheckedStatement checkedStatement, T data);
    public abstract virtual S VisitContinueStatement(ContinueStatement continueStatement, T data);
    public abstract virtual S VisitDoWhileStatement(DoWhileStatement doWhileStatement, T data);
    public abstract virtual S VisitEmptyStatement(EmptyStatement emptyStatement, T data);
    public abstract virtual S VisitExpressionStatement(ExpressionStatement expressionStatement, T data);
    public abstract virtual S VisitFixedStatement(FixedStatement fixedStatement, T data);
    public abstract virtual S VisitForeachStatement(ForeachStatement foreachStatement, T data);
    public abstract virtual S VisitForStatement(ForStatement forStatement, T data);
    public abstract virtual S VisitGotoCaseStatement(GotoCaseStatement gotoCaseStatement, T data);
    public abstract virtual S VisitGotoDefaultStatement(GotoDefaultStatement gotoDefaultStatement, T data);
    public abstract virtual S VisitGotoStatement(GotoStatement gotoStatement, T data);
    public abstract virtual S VisitIfElseStatement(IfElseStatement ifElseStatement, T data);
    public abstract virtual S VisitLabelStatement(LabelStatement labelStatement, T data);
    public abstract virtual S VisitLockStatement(LockStatement lockStatement, T data);
    public abstract virtual S VisitReturnStatement(ReturnStatement returnStatement, T data);
    public abstract virtual S VisitSwitchStatement(SwitchStatement switchStatement, T data);
    public abstract virtual S VisitSwitchSection(SwitchSection switchSection, T data);
    public abstract virtual S VisitCaseLabel(CaseLabel caseLabel, T data);
    public abstract virtual S VisitSwitchExpression(SwitchExpression switchExpression, T data);
    public abstract virtual S VisitSwitchExpressionSection(SwitchExpressionSection switchExpressionSection, T data);
    public abstract virtual S VisitThrowStatement(ThrowStatement throwStatement, T data);
    public abstract virtual S VisitTryCatchStatement(TryCatchStatement tryCatchStatement, T data);
    public abstract virtual S VisitCatchClause(CatchClause catchClause, T data);
    public abstract virtual S VisitUncheckedStatement(UncheckedStatement uncheckedStatement, T data);
    public abstract virtual S VisitUnsafeStatement(UnsafeStatement unsafeStatement, T data);
    public abstract virtual S VisitUsingStatement(UsingStatement usingStatement, T data);
    public abstract virtual S VisitVariableDeclarationStatement(VariableDeclarationStatement variableDeclarationStatement, T data);
    public abstract virtual S VisitLocalFunctionDeclarationStatement(LocalFunctionDeclarationStatement localFunctionDeclarationStatement, T data);
    public abstract virtual S VisitWhileStatement(WhileStatement whileStatement, T data);
    public abstract virtual S VisitYieldBreakStatement(YieldBreakStatement yieldBreakStatement, T data);
    public abstract virtual S VisitYieldReturnStatement(YieldReturnStatement yieldReturnStatement, T data);
    public abstract virtual S VisitAccessor(Accessor accessor, T data);
    public abstract virtual S VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration, T data);
    public abstract virtual S VisitConstructorInitializer(ConstructorInitializer constructorInitializer, T data);
    public abstract virtual S VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration, T data);
    public abstract virtual S VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration, T data);
    public abstract virtual S VisitEventDeclaration(EventDeclaration eventDeclaration, T data);
    public abstract virtual S VisitCustomEventDeclaration(CustomEventDeclaration customEventDeclaration, T data);
    public abstract virtual S VisitFieldDeclaration(FieldDeclaration fieldDeclaration, T data);
    public abstract virtual S VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration, T data);
    public abstract virtual S VisitMethodDeclaration(MethodDeclaration methodDeclaration, T data);
    public abstract virtual S VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration, T data);
    public abstract virtual S VisitParameterDeclaration(ParameterDeclaration parameterDeclaration, T data);
    public abstract virtual S VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration, T data);
    public abstract virtual S VisitVariableInitializer(VariableInitializer variableInitializer, T data);
    public abstract virtual S VisitFixedFieldDeclaration(FixedFieldDeclaration fixedFieldDeclaration, T data);
    public abstract virtual S VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer, T data);
    public abstract virtual S VisitSyntaxTree(SyntaxTree syntaxTree, T data);
    public abstract virtual S VisitSimpleType(SimpleType simpleType, T data);
    public abstract virtual S VisitMemberType(MemberType memberType, T data);
    public abstract virtual S VisitTupleType(TupleAstType tupleType, T data);
    public abstract virtual S VisitTupleTypeElement(TupleTypeElement tupleTypeElement, T data);
    public abstract virtual S VisitFunctionPointerType(FunctionPointerAstType functionPointerType, T data);
    public abstract virtual S VisitInvocationType(InvocationAstType invocationType, T data);
    public abstract virtual S VisitComposedType(ComposedType composedType, T data);
    public abstract virtual S VisitArraySpecifier(ArraySpecifier arraySpecifier, T data);
    public abstract virtual S VisitPrimitiveType(PrimitiveType primitiveType, T data);
    public abstract virtual S VisitComment(Comment comment, T data);
    public abstract virtual S VisitPreProcessorDirective(PreProcessorDirective preProcessorDirective, T data);
    public abstract virtual S VisitDocumentationReference(DocumentationReference documentationReference, T data);
    public abstract virtual S VisitTypeParameterDeclaration(TypeParameterDeclaration typeParameterDeclaration, T data);
    public abstract virtual S VisitConstraint(Constraint constraint, T data);
    public abstract virtual S VisitCSharpTokenNode(CSharpTokenNode cSharpTokenNode, T data);
    public abstract virtual S VisitIdentifier(Identifier identifier, T data);
    public abstract virtual S VisitInterpolation(Interpolation interpolation, T data);
    public abstract virtual S VisitInterpolatedStringText(InterpolatedStringText interpolatedStringText, T data);
    public abstract virtual S VisitSingleVariableDesignation(SingleVariableDesignation singleVariableDesignation, T data);
    public abstract virtual S VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignation parenthesizedVariableDesignation, T data);
    public abstract virtual S VisitNullNode(AstNode nullNode, T data);
    public abstract virtual S VisitErrorNode(AstNode errorNode, T data);
    public abstract virtual S VisitPatternPlaceholder(AstNode placeholder, Pattern pattern, T data);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.Identifier : AstNode {
    public static Identifier Null;
    private string name;
    private TextLocation startLocation;
    private static UInt32 verbatimBit;
    public NodeType NodeType { get; }
    public string Name { get; public set; }
    public TextLocation StartLocation { get; }
    public bool IsVerbatim { get; public set; }
    public TextLocation EndLocation { get; }
    protected Identifier(string name, TextLocation location);
    private static Identifier();
    public virtual NodeType get_NodeType();
    public string get_Name();
    public void set_Name(string value);
    public virtual TextLocation get_StartLocation();
    internal void SetStartLocation(TextLocation value);
    public bool get_IsVerbatim();
    public void set_IsVerbatim(bool value);
    public virtual TextLocation get_EndLocation();
    public static Identifier Create(string name);
    public static Identifier Create(string name, TextLocation location);
    public static Identifier Create(string name, TextLocation location, bool isVerbatim);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.IdentifierExpression : Expression {
    public string Identifier { get; public set; }
    public Identifier IdentifierToken { get; public set; }
    public AstNodeCollection`1<AstType> TypeArguments { get; }
    public IdentifierExpression(string identifier);
    public IdentifierExpression(string identifier, TextLocation location);
    public string get_Identifier();
    public void set_Identifier(string value);
    public Identifier get_IdentifierToken();
    public void set_IdentifierToken(Identifier value);
    public AstNodeCollection`1<AstType> get_TypeArguments();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.IdentifierExpressionBackreference : Pattern {
    private string referencedGroupName;
    public string ReferencedGroupName { get; }
    public IdentifierExpressionBackreference(string referencedGroupName);
    public string get_ReferencedGroupName();
    public virtual bool DoMatch(INode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.IfElseStatement : Statement {
    public static TokenRole IfKeywordRole;
    public static Role`1<Expression> ConditionRole;
    public static Role`1<Statement> TrueRole;
    public static TokenRole ElseKeywordRole;
    public static Role`1<Statement> FalseRole;
    public CSharpTokenNode IfToken { get; }
    public CSharpTokenNode LParToken { get; }
    public Expression Condition { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public Statement TrueStatement { get; public set; }
    public CSharpTokenNode ElseToken { get; }
    public Statement FalseStatement { get; public set; }
    public IfElseStatement(Expression condition, Statement trueStatement, Statement falseStatement);
    private static IfElseStatement();
    public CSharpTokenNode get_IfToken();
    public CSharpTokenNode get_LParToken();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public CSharpTokenNode get_RParToken();
    public Statement get_TrueStatement();
    public void set_TrueStatement(Statement value);
    public CSharpTokenNode get_ElseToken();
    public Statement get_FalseStatement();
    public void set_FalseStatement(Statement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.IndexerDeclaration : EntityDeclaration {
    public static TokenRole ThisKeywordRole;
    public static Role`1<Accessor> GetterRole;
    public static Role`1<Accessor> SetterRole;
    public static Role`1<Expression> ExpressionBodyRole;
    public SymbolKind SymbolKind { get; }
    public AstType PrivateImplementationType { get; public set; }
    public string Name { get; public set; }
    [EditorBrowsableAttribute("1")]
public Identifier NameToken { get; public set; }
    public CSharpTokenNode LBracketToken { get; }
    public CSharpTokenNode ThisToken { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public CSharpTokenNode RBracketToken { get; }
    public CSharpTokenNode LBraceToken { get; }
    public Accessor Getter { get; public set; }
    public Accessor Setter { get; public set; }
    public CSharpTokenNode RBraceToken { get; }
    public Expression ExpressionBody { get; public set; }
    private static IndexerDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public AstType get_PrivateImplementationType();
    public void set_PrivateImplementationType(AstType value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual Identifier get_NameToken();
    public virtual void set_NameToken(Identifier value);
    public CSharpTokenNode get_LBracketToken();
    public CSharpTokenNode get_ThisToken();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public CSharpTokenNode get_RBracketToken();
    public CSharpTokenNode get_LBraceToken();
    public Accessor get_Getter();
    public void set_Getter(Accessor value);
    public Accessor get_Setter();
    public void set_Setter(Accessor value);
    public CSharpTokenNode get_RBraceToken();
    public Expression get_ExpressionBody();
    public void set_ExpressionBody(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.IndexerExpression : Expression {
    public Expression Target { get; public set; }
    public CSharpTokenNode LBracketToken { get; }
    public AstNodeCollection`1<Expression> Arguments { get; }
    public CSharpTokenNode RBracketToken { get; }
    public IndexerExpression(Expression target, IEnumerable`1<Expression> arguments);
    public IndexerExpression(Expression target, Expression[] arguments);
    public Expression get_Target();
    public void set_Target(Expression value);
    public CSharpTokenNode get_LBracketToken();
    public AstNodeCollection`1<Expression> get_Arguments();
    public CSharpTokenNode get_RBracketToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.InterpolatedStringContent : AstNode {
    public static InterpolatedStringContent Null;
    public static Role`1<InterpolatedStringContent> Role;
    public NodeType NodeType { get; }
    private static InterpolatedStringContent();
    public virtual NodeType get_NodeType();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.InterpolatedStringExpression : Expression {
    public static TokenRole OpenQuote;
    public static TokenRole CloseQuote;
    public AstNodeCollection`1<InterpolatedStringContent> Content { get; }
    public InterpolatedStringExpression(IList`1<InterpolatedStringContent> content);
    private static InterpolatedStringExpression();
    public AstNodeCollection`1<InterpolatedStringContent> get_Content();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.InterpolatedStringText : InterpolatedStringContent {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    public InterpolatedStringText(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.Interpolation : InterpolatedStringContent {
    public static TokenRole LBrace;
    public static TokenRole RBrace;
    [CompilerGeneratedAttribute]
private int <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public CSharpTokenNode LBraceToken { get; }
    public Expression Expression { get; public set; }
    public int Alignment { get; }
    public string Suffix { get; }
    public CSharpTokenNode RBraceToken { get; }
    public Interpolation(Expression expression, int alignment, string suffix);
    private static Interpolation();
    public CSharpTokenNode get_LBraceToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public int get_Alignment();
    [CompilerGeneratedAttribute]
public string get_Suffix();
    public CSharpTokenNode get_RBraceToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.InvocationAstType : AstType {
    public AstNodeCollection`1<Expression> Arguments { get; }
    public AstType BaseType { get; public set; }
    public AstNodeCollection`1<Expression> get_Arguments();
    public AstType get_BaseType();
    public void set_BaseType(AstType value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.InvocationExpression : Expression {
    public Expression Target { get; public set; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<Expression> Arguments { get; }
    public CSharpTokenNode RParToken { get; }
    public InvocationExpression(Expression target, IEnumerable`1<Expression> arguments);
    public InvocationExpression(Expression target, Expression[] arguments);
    public Expression get_Target();
    public void set_Target(Expression value);
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<Expression> get_Arguments();
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.IsExpression : Expression {
    public static TokenRole IsKeywordRole;
    public Expression Expression { get; public set; }
    public CSharpTokenNode IsToken { get; }
    public AstType Type { get; public set; }
    public IsExpression(Expression expression, AstType type);
    private static IsExpression();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_IsToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.LabelStatement : Statement {
    public string Label { get; public set; }
    public Identifier LabelToken { get; public set; }
    public CSharpTokenNode ColonToken { get; }
    public string get_Label();
    public void set_Label(string value);
    public Identifier get_LabelToken();
    public void set_LabelToken(Identifier value);
    public CSharpTokenNode get_ColonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.LambdaExpression : Expression {
    public static Role`1<AttributeSection> AttributeRole;
    public static TokenRole AsyncModifierRole;
    public static Role`1<AstNode> BodyRole;
    private bool isAsync;
    public AstNodeCollection`1<AttributeSection> Attributes { get; }
    public bool IsAsync { get; public set; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public CSharpTokenNode RParToken { get; }
    public CSharpTokenNode ArrowToken { get; }
    public AstNode Body { get; public set; }
    private static LambdaExpression();
    public AstNodeCollection`1<AttributeSection> get_Attributes();
    public bool get_IsAsync();
    public void set_IsAsync(bool value);
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public CSharpTokenNode get_RParToken();
    public CSharpTokenNode get_ArrowToken();
    public AstNode get_Body();
    public void set_Body(AstNode value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.LinePreprocessorDirective : PreProcessorDirective {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public int LineNumber { get; public set; }
    public string FileName { get; public set; }
    public LinePreprocessorDirective(TextLocation startLocation, TextLocation endLocation);
    public LinePreprocessorDirective(string argument);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.LiteralFormat : Enum {
    public byte value__;
    public static LiteralFormat None;
    public static LiteralFormat DecimalNumber;
    public static LiteralFormat HexadecimalNumber;
    public static LiteralFormat BinaryNumber;
    public static LiteralFormat StringLiteral;
    public static LiteralFormat VerbatimStringLiteral;
    public static LiteralFormat CharLiteral;
    public static LiteralFormat Utf8Literal;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.LocalFunctionDeclarationStatement : Statement {
    public static Role`1<MethodDeclaration> MethodDeclarationRole;
    public MethodDeclaration Declaration { get; public set; }
    public LocalFunctionDeclarationStatement(MethodDeclaration methodDeclaration);
    private static LocalFunctionDeclarationStatement();
    public MethodDeclaration get_Declaration();
    public void set_Declaration(MethodDeclaration value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.LockStatement : Statement {
    public static TokenRole LockKeywordRole;
    public CSharpTokenNode LockToken { get; }
    public CSharpTokenNode LParToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public Statement EmbeddedStatement { get; public set; }
    private static LockStatement();
    public CSharpTokenNode get_LockToken();
    public CSharpTokenNode get_LParToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_RParToken();
    public Statement get_EmbeddedStatement();
    public void set_EmbeddedStatement(Statement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.MemberReferenceExpression : Expression {
    public Expression Target { get; public set; }
    public CSharpTokenNode DotToken { get; }
    public string MemberName { get; public set; }
    public Identifier MemberNameToken { get; public set; }
    public CSharpTokenNode LChevronToken { get; }
    public AstNodeCollection`1<AstType> TypeArguments { get; }
    public CSharpTokenNode RChevronToken { get; }
    public MemberReferenceExpression(Expression target, string memberName, IEnumerable`1<AstType> arguments);
    public MemberReferenceExpression(Expression target, string memberName, AstType[] arguments);
    public Expression get_Target();
    public void set_Target(Expression value);
    public CSharpTokenNode get_DotToken();
    public string get_MemberName();
    public void set_MemberName(string value);
    public Identifier get_MemberNameToken();
    public void set_MemberNameToken(Identifier value);
    public CSharpTokenNode get_LChevronToken();
    public AstNodeCollection`1<AstType> get_TypeArguments();
    public CSharpTokenNode get_RChevronToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.MemberType : AstType {
    public static Role`1<AstType> TargetRole;
    private bool isDoubleColon;
    public bool IsDoubleColon { get; public set; }
    public AstType Target { get; public set; }
    public string MemberName { get; public set; }
    public Identifier MemberNameToken { get; public set; }
    public AstNodeCollection`1<AstType> TypeArguments { get; }
    public MemberType(AstType target, string memberName);
    public MemberType(AstType target, string memberName, IEnumerable`1<AstType> typeArguments);
    public MemberType(AstType target, string memberName, AstType[] typeArguments);
    private static MemberType();
    public bool get_IsDoubleColon();
    public void set_IsDoubleColon(bool value);
    public AstType get_Target();
    public void set_Target(AstType value);
    public string get_MemberName();
    public void set_MemberName(string value);
    public Identifier get_MemberNameToken();
    public void set_MemberNameToken(Identifier value);
    public AstNodeCollection`1<AstType> get_TypeArguments();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.MethodDeclaration : EntityDeclaration {
    public SymbolKind SymbolKind { get; }
    public AstType PrivateImplementationType { get; public set; }
    public AstNodeCollection`1<TypeParameterDeclaration> TypeParameters { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public CSharpTokenNode RParToken { get; }
    public AstNodeCollection`1<Constraint> Constraints { get; }
    public BlockStatement Body { get; public set; }
    public bool IsExtensionMethod { get; }
    public virtual SymbolKind get_SymbolKind();
    public AstType get_PrivateImplementationType();
    public void set_PrivateImplementationType(AstType value);
    public AstNodeCollection`1<TypeParameterDeclaration> get_TypeParameters();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public CSharpTokenNode get_RParToken();
    public AstNodeCollection`1<Constraint> get_Constraints();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public bool get_IsExtensionMethod();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.CSharp.Syntax.Modifiers : Enum {
    public int value__;
    public static Modifiers None;
    public static Modifiers Private;
    public static Modifiers Internal;
    public static Modifiers Protected;
    public static Modifiers Public;
    public static Modifiers Abstract;
    public static Modifiers Virtual;
    public static Modifiers Sealed;
    public static Modifiers Static;
    public static Modifiers Override;
    public static Modifiers Readonly;
    public static Modifiers Const;
    public static Modifiers New;
    public static Modifiers Partial;
    public static Modifiers Extern;
    public static Modifiers Volatile;
    public static Modifiers Unsafe;
    public static Modifiers Async;
    public static Modifiers Ref;
    public static Modifiers Required;
    public static Modifiers VisibilityMask;
    public static Modifiers Any;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.NamedArgumentExpression : Expression {
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public CSharpTokenNode ColonToken { get; }
    public Expression Expression { get; public set; }
    public NamedArgumentExpression(string name, Expression expression);
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public CSharpTokenNode get_ColonToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.NamedExpression : Expression {
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public CSharpTokenNode AssignToken { get; }
    public Expression Expression { get; public set; }
    public NamedExpression(string name, Expression expression);
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public CSharpTokenNode get_AssignToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.NamespaceDeclaration : AstNode {
    public static Role`1<AstNode> MemberRole;
    public static Role`1<AstType> NamespaceNameRole;
    [CompilerGeneratedAttribute]
private bool <IsFileScoped>k__BackingField;
    public NodeType NodeType { get; }
    public bool IsFileScoped { get; public set; }
    public CSharpTokenNode NamespaceToken { get; }
    public AstType NamespaceName { get; public set; }
    public string Name { get; public set; }
    public string FullName { get; }
    public IEnumerable`1<string> Identifiers { get; }
    public CSharpTokenNode LBraceToken { get; }
    public AstNodeCollection`1<AstNode> Members { get; }
    public CSharpTokenNode RBraceToken { get; }
    public NamespaceDeclaration(string name);
    private static NamespaceDeclaration();
    public virtual NodeType get_NodeType();
    [CompilerGeneratedAttribute]
public bool get_IsFileScoped();
    [CompilerGeneratedAttribute]
public void set_IsFileScoped(bool value);
    public CSharpTokenNode get_NamespaceToken();
    public AstType get_NamespaceName();
    public void set_NamespaceName(AstType value);
    public string get_Name();
    public void set_Name(string value);
    private static AstType ConstructType(String[] arr, int i);
    public string get_FullName();
    public IEnumerable`1<string> get_Identifiers();
    public CSharpTokenNode get_LBraceToken();
    public AstNodeCollection`1<AstNode> get_Members();
    public CSharpTokenNode get_RBraceToken();
    public static string BuildQualifiedName(string name1, string name2);
    public void AddMember(AstNode child);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.NodeType : Enum {
    public int value__;
    public static NodeType Unknown;
    public static NodeType TypeReference;
    public static NodeType TypeDeclaration;
    public static NodeType Member;
    public static NodeType Statement;
    public static NodeType Expression;
    public static NodeType Token;
    public static NodeType QueryClause;
    public static NodeType Whitespace;
    public static NodeType Pattern;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.NullReferenceExpression : Expression {
    private TextLocation location;
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    public NullReferenceExpression(TextLocation location);
    public virtual TextLocation get_StartLocation();
    internal void SetStartLocation(TextLocation value);
    public virtual TextLocation get_EndLocation();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ObjectCreateExpression : Expression {
    public static TokenRole NewKeywordRole;
    public static Role`1<ArrayInitializerExpression> InitializerRole;
    public CSharpTokenNode NewToken { get; }
    public AstType Type { get; public set; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<Expression> Arguments { get; }
    public CSharpTokenNode RParToken { get; }
    public ArrayInitializerExpression Initializer { get; public set; }
    public ObjectCreateExpression(AstType type, IEnumerable`1<Expression> arguments);
    public ObjectCreateExpression(AstType type, Expression[] arguments);
    private static ObjectCreateExpression();
    public CSharpTokenNode get_NewToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<Expression> get_Arguments();
    public CSharpTokenNode get_RParToken();
    public ArrayInitializerExpression get_Initializer();
    public void set_Initializer(ArrayInitializerExpression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.OperatorDeclaration : EntityDeclaration {
    public static TokenRole OperatorKeywordRole;
    public static TokenRole CheckedKeywordRole;
    public static TokenRole LogicalNotRole;
    public static TokenRole OnesComplementRole;
    public static TokenRole IncrementRole;
    public static TokenRole DecrementRole;
    public static TokenRole TrueRole;
    public static TokenRole FalseRole;
    public static TokenRole AdditionRole;
    public static TokenRole SubtractionRole;
    public static TokenRole MultiplyRole;
    public static TokenRole DivisionRole;
    public static TokenRole ModulusRole;
    public static TokenRole BitwiseAndRole;
    public static TokenRole BitwiseOrRole;
    public static TokenRole ExclusiveOrRole;
    public static TokenRole LeftShiftRole;
    public static TokenRole RightShiftRole;
    public static TokenRole UnsignedRightShiftRole;
    public static TokenRole EqualityRole;
    public static TokenRole InequalityRole;
    public static TokenRole GreaterThanRole;
    public static TokenRole LessThanRole;
    public static TokenRole GreaterThanOrEqualRole;
    public static TokenRole LessThanOrEqualRole;
    public static TokenRole ExplicitRole;
    public static TokenRole ImplicitRole;
    private static String[][] names;
    private OperatorType operatorType;
    public SymbolKind SymbolKind { get; }
    public OperatorType OperatorType { get; public set; }
    public CSharpTokenNode OperatorToken { get; }
    public CSharpTokenNode OperatorTypeToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<ParameterDeclaration> Parameters { get; }
    public CSharpTokenNode RParToken { get; }
    public BlockStatement Body { get; public set; }
    public string Name { get; public set; }
    [EditorBrowsableAttribute("1")]
public Identifier NameToken { get; public set; }
    private static OperatorDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public OperatorType get_OperatorType();
    public void set_OperatorType(OperatorType value);
    public CSharpTokenNode get_OperatorToken();
    public CSharpTokenNode get_OperatorTypeToken();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<ParameterDeclaration> get_Parameters();
    public CSharpTokenNode get_RParToken();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public static Nullable`1<OperatorType> GetOperatorType(string methodName);
    public static TokenRole GetRole(OperatorType type);
    public static string GetName(Nullable`1<OperatorType> type);
    public static bool IsChecked(OperatorType type);
    public static string GetToken(OperatorType type);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual Identifier get_NameToken();
    public virtual void set_NameToken(Identifier value);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.OperatorType : Enum {
    public int value__;
    public static OperatorType LogicalNot;
    public static OperatorType OnesComplement;
    public static OperatorType Increment;
    public static OperatorType CheckedIncrement;
    public static OperatorType Decrement;
    public static OperatorType CheckedDecrement;
    public static OperatorType True;
    public static OperatorType False;
    public static OperatorType UnaryPlus;
    public static OperatorType UnaryNegation;
    public static OperatorType CheckedUnaryNegation;
    public static OperatorType Addition;
    public static OperatorType CheckedAddition;
    public static OperatorType Subtraction;
    public static OperatorType CheckedSubtraction;
    public static OperatorType Multiply;
    public static OperatorType CheckedMultiply;
    public static OperatorType Division;
    public static OperatorType CheckedDivision;
    public static OperatorType Modulus;
    public static OperatorType BitwiseAnd;
    public static OperatorType BitwiseOr;
    public static OperatorType ExclusiveOr;
    public static OperatorType LeftShift;
    public static OperatorType RightShift;
    public static OperatorType UnsignedRightShift;
    public static OperatorType Equality;
    public static OperatorType Inequality;
    public static OperatorType GreaterThan;
    public static OperatorType LessThan;
    public static OperatorType GreaterThanOrEqual;
    public static OperatorType LessThanOrEqual;
    public static OperatorType Implicit;
    public static OperatorType Explicit;
    public static OperatorType CheckedExplicit;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.OutVarDeclarationExpression : Expression {
    public static TokenRole OutKeywordRole;
    public CSharpTokenNode OutKeywordToken { get; }
    public AstType Type { get; public set; }
    public VariableInitializer Variable { get; public set; }
    public OutVarDeclarationExpression(AstType type, string name);
    private static OutVarDeclarationExpression();
    public CSharpTokenNode get_OutKeywordToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public VariableInitializer get_Variable();
    public void set_Variable(VariableInitializer value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.CSharp.Syntax.ParameterDeclaration : AstNode {
    public static Role`1<AttributeSection> AttributeRole;
    public static TokenRole ThisModifierRole;
    public static TokenRole ScopedRefRole;
    [ObsoleteAttribute("Renamed to ScopedRefRole")]
public static TokenRole RefScopedRole;
    public static TokenRole RefModifierRole;
    public static TokenRole OutModifierRole;
    public static TokenRole InModifierRole;
    [ObsoleteAttribute("C# 11 preview: "ref scoped" no longer supported")]
public static TokenRole ValueScopedRole;
    public static TokenRole ParamsModifierRole;
    private bool hasThisModifier;
    private bool isScopedRef;
    private ParameterModifier parameterModifier;
    private bool hasNullCheck;
    public NodeType NodeType { get; }
    public AstNodeCollection`1<AttributeSection> Attributes { get; }
    public CSharpTokenNode ThisKeyword { get; }
    public bool HasThisModifier { get; public set; }
    public bool IsScopedRef { get; public set; }
    [ObsoleteAttribute("Renamed to IsScopedRef")]
public bool IsRefScoped { get; public set; }
    [ObsoleteAttribute("C# 11 preview: "ref scoped" no longer supported")]
public bool IsValueScoped { get; public set; }
    public ParameterModifier ParameterModifier { get; public set; }
    public AstType Type { get; public set; }
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public CSharpTokenNode DoubleExclamationToken { get; }
    public bool HasNullCheck { get; public set; }
    public CSharpTokenNode AssignToken { get; }
    public Expression DefaultExpression { get; public set; }
    public ParameterDeclaration(AstType type, string name, ParameterModifier modifier);
    public ParameterDeclaration(string name, ParameterModifier modifier);
    private static ParameterDeclaration();
    public static ParameterDeclaration op_Implicit(Pattern pattern);
    public virtual NodeType get_NodeType();
    public AstNodeCollection`1<AttributeSection> get_Attributes();
    public CSharpTokenNode get_ThisKeyword();
    public bool get_HasThisModifier();
    public void set_HasThisModifier(bool value);
    public bool get_IsScopedRef();
    public void set_IsScopedRef(bool value);
    public bool get_IsRefScoped();
    public void set_IsRefScoped(bool value);
    public bool get_IsValueScoped();
    public void set_IsValueScoped(bool value);
    public ParameterModifier get_ParameterModifier();
    public void set_ParameterModifier(ParameterModifier value);
    public AstType get_Type();
    public void set_Type(AstType value);
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public CSharpTokenNode get_DoubleExclamationToken();
    public bool get_HasNullCheck();
    public void set_HasNullCheck(bool value);
    public CSharpTokenNode get_AssignToken();
    public Expression get_DefaultExpression();
    public void set_DefaultExpression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    [NullableContextAttribute("2")]
protected internal virtual bool DoMatch(AstNode other, Match match);
    public ParameterDeclaration Clone();
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.ParameterModifier : Enum {
    public int value__;
    public static ParameterModifier None;
    public static ParameterModifier Ref;
    public static ParameterModifier Out;
    public static ParameterModifier Params;
    public static ParameterModifier In;
    public static ParameterModifier Scoped;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ParenthesizedExpression : Expression {
    public CSharpTokenNode LParToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public ParenthesizedExpression(Expression expr);
    public CSharpTokenNode get_LParToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public static bool ActsAsParenthesizedExpression(AstNode expression);
    public static Expression UnpackParenthesizedExpression(Expression expr);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ParenthesizedVariableDesignation : VariableDesignation {
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<VariableDesignation> VariableDesignations { get; }
    public CSharpTokenNode RParToken { get; }
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<VariableDesignation> get_VariableDesignations();
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.AnyNode : Pattern {
    private string groupName;
    public string GroupName { get; }
    public AnyNode(string groupName);
    public string get_GroupName();
    public virtual bool DoMatch(INode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.AnyNodeOrNull : Pattern {
    private string groupName;
    public string GroupName { get; }
    public AnyNodeOrNull(string groupName);
    public string get_GroupName();
    public virtual bool DoMatch(INode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Backreference : Pattern {
    private string referencedGroupName;
    public string ReferencedGroupName { get; }
    public Backreference(string referencedGroupName);
    public string get_ReferencedGroupName();
    public virtual bool DoMatch(INode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.BacktrackingInfo : object {
    internal Stack`1<PossibleMatch> backtrackingStack;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Choice : Pattern {
    private List`1<INode> alternatives;
    public void Add(string name, INode alternative);
    public void Add(INode alternative);
    public virtual bool DoMatch(INode other, Match match);
    private sealed virtual override IEnumerator`1<INode> System.Collections.Generic.IEnumerable<ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode {
    public Role Role { get; }
    public INode FirstChild { get; }
    public INode NextSibling { get; }
    public bool IsNull { get; }
    public abstract virtual Role get_Role();
    public abstract virtual INode get_FirstChild();
    public abstract virtual INode get_NextSibling();
    public abstract virtual bool get_IsNull();
    public abstract virtual bool DoMatch(INode other, Match match);
    public abstract virtual bool DoMatchCollection(Role role, INode pos, Match match, BacktrackingInfo backtrackingInfo);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Match : ValueType {
    private List`1<KeyValuePair`2<string, INode>> results;
    public bool Success { get; }
    public bool get_Success();
    internal static Match CreateNew();
    internal int CheckPoint();
    internal void RestoreCheckPoint(int checkPoint);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Match/<Get>d__6")]
public IEnumerable`1<INode> Get(string groupName);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Match/<Get>d__7`1")]
public IEnumerable`1<T> Get(string groupName);
    public bool Has(string groupName);
    public void Add(string groupName, INode node);
    internal void AddNull(string groupName);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.NamedNode : Pattern {
    private string groupName;
    private INode childNode;
    public string GroupName { get; }
    public INode ChildNode { get; }
    public NamedNode(string groupName, INode childNode);
    public string get_GroupName();
    public INode get_ChildNode();
    public virtual bool DoMatch(INode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.OptionalNode : Pattern {
    private INode childNode;
    public INode ChildNode { get; }
    public OptionalNode(INode childNode);
    public OptionalNode(string groupName, INode childNode);
    public INode get_ChildNode();
    public virtual bool DoMatchCollection(Role role, INode pos, Match match, BacktrackingInfo backtrackingInfo);
    public virtual bool DoMatch(INode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Pattern : object {
    public static string AnyString;
    private bool ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.IsNull { get; }
    private Role ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.Role { get; }
    private INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.NextSibling { get; }
    private INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.FirstChild { get; }
    private static Pattern();
    public static bool MatchString(string pattern, string text);
    private sealed virtual override bool ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.get_IsNull();
    private sealed virtual override Role ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.get_Role();
    private sealed virtual override INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.get_NextSibling();
    private sealed virtual override INode ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.INode.get_FirstChild();
    public abstract virtual bool DoMatch(INode other, Match match);
    public virtual bool DoMatchCollection(Role role, INode pos, Match match, BacktrackingInfo backtrackingInfo);
    public static bool DoMatchCollection(Role role, INode firstPatternChild, INode firstOtherChild, Match match);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.PatternExtensions : object {
    [ExtensionAttribute]
public static Match Match(INode pattern, INode other);
    [ExtensionAttribute]
public static bool IsMatch(INode pattern, INode other);
    [ExtensionAttribute]
public static AstType ToType(Pattern pattern);
    [ExtensionAttribute]
public static Expression ToExpression(Pattern pattern);
    [ExtensionAttribute]
public static Statement ToStatement(Pattern pattern);
    [ExtensionAttribute]
public static Expression WithName(Expression node, string patternGroupName);
    [ExtensionAttribute]
public static Statement WithName(Statement node, string patternGroupName);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching.Repeat : Pattern {
    private INode childNode;
    [CompilerGeneratedAttribute]
private int <MinCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCount>k__BackingField;
    public int MinCount { get; public set; }
    public int MaxCount { get; public set; }
    public INode ChildNode { get; }
    public Repeat(INode childNode);
    [CompilerGeneratedAttribute]
public int get_MinCount();
    [CompilerGeneratedAttribute]
public void set_MinCount(int value);
    [CompilerGeneratedAttribute]
public int get_MaxCount();
    [CompilerGeneratedAttribute]
public void set_MaxCount(int value);
    public INode get_ChildNode();
    public virtual bool DoMatchCollection(Role role, INode pos, Match match, BacktrackingInfo backtrackingInfo);
    public virtual bool DoMatch(INode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PointerReferenceExpression : Expression {
    public static TokenRole ArrowRole;
    public Expression Target { get; public set; }
    public CSharpTokenNode ArrowToken { get; }
    public string MemberName { get; public set; }
    public Identifier MemberNameToken { get; public set; }
    public AstNodeCollection`1<AstType> TypeArguments { get; }
    private static PointerReferenceExpression();
    public Expression get_Target();
    public void set_Target(Expression value);
    public CSharpTokenNode get_ArrowToken();
    public string get_MemberName();
    public void set_MemberName(string value);
    public Identifier get_MemberNameToken();
    public void set_MemberNameToken(Identifier value);
    public AstNodeCollection`1<AstType> get_TypeArguments();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PragmaWarningPreprocessorDirective : PreProcessorDirective {
    public static Role`1<PrimitiveExpression> WarningRole;
    public static TokenRole PragmaKeywordRole;
    public static TokenRole WarningKeywordRole;
    public static TokenRole DisableKeywordRole;
    public static TokenRole RestoreKeywordRole;
    public bool Disable { get; }
    public CSharpTokenNode PragmaToken { get; }
    public CSharpTokenNode WarningToken { get; }
    public CSharpTokenNode DisableToken { get; }
    public CSharpTokenNode RestoreToken { get; }
    public AstNodeCollection`1<PrimitiveExpression> Warnings { get; }
    public TextLocation EndLocation { get; }
    public PragmaWarningPreprocessorDirective(TextLocation startLocation, TextLocation endLocation);
    public PragmaWarningPreprocessorDirective(string argument);
    private static PragmaWarningPreprocessorDirective();
    public bool get_Disable();
    public CSharpTokenNode get_PragmaToken();
    public CSharpTokenNode get_WarningToken();
    public CSharpTokenNode get_DisableToken();
    public CSharpTokenNode get_RestoreToken();
    public AstNodeCollection`1<PrimitiveExpression> get_Warnings();
    public virtual TextLocation get_EndLocation();
    public bool IsDefined(int pragmaWarning);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PreProcessorDirective : AstNode {
    [CompilerGeneratedAttribute]
private PreProcessorDirectiveType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Take>k__BackingField;
    private TextLocation startLocation;
    private TextLocation endLocation;
    public NodeType NodeType { get; }
    public PreProcessorDirectiveType Type { get; public set; }
    public string Argument { get; public set; }
    public bool Take { get; public set; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    public PreProcessorDirective(PreProcessorDirectiveType type, TextLocation startLocation, TextLocation endLocation);
    public PreProcessorDirective(PreProcessorDirectiveType type, string argument);
    public virtual NodeType get_NodeType();
    [CompilerGeneratedAttribute]
public PreProcessorDirectiveType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PreProcessorDirectiveType value);
    [CompilerGeneratedAttribute]
public string get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(string value);
    [CompilerGeneratedAttribute]
public bool get_Take();
    [CompilerGeneratedAttribute]
public void set_Take(bool value);
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.PreProcessorDirectiveType : Enum {
    public byte value__;
    public static PreProcessorDirectiveType Invalid;
    public static PreProcessorDirectiveType Region;
    public static PreProcessorDirectiveType Endregion;
    public static PreProcessorDirectiveType If;
    public static PreProcessorDirectiveType Endif;
    public static PreProcessorDirectiveType Elif;
    public static PreProcessorDirectiveType Else;
    public static PreProcessorDirectiveType Define;
    public static PreProcessorDirectiveType Undef;
    public static PreProcessorDirectiveType Error;
    public static PreProcessorDirectiveType Warning;
    public static PreProcessorDirectiveType Pragma;
    public static PreProcessorDirectiveType Line;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PrimitiveExpression : Expression {
    public static object AnyValue;
    private TextLocation startLocation;
    private TextLocation endLocation;
    private object value;
    private LiteralFormat format;
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    public object Value { get; public set; }
    public LiteralFormat Format { get; public set; }
    public PrimitiveExpression(object value);
    public PrimitiveExpression(object value, LiteralFormat format);
    private static PrimitiveExpression();
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    internal void SetLocation(TextLocation startLocation, TextLocation endLocation);
    public object get_Value();
    public void set_Value(object value);
    public LiteralFormat get_Format();
    public void set_Format(LiteralFormat value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    private static TextLocation AdvanceLocation(TextLocation startLocation, string str);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PrimitiveType : AstType {
    private TextLocation location;
    private string keyword;
    public string Keyword { get; public set; }
    public KnownTypeCode KnownTypeCode { get; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    public PrimitiveType(string keyword);
    public PrimitiveType(string keyword, TextLocation location);
    public string get_Keyword();
    public void set_Keyword(string value);
    public KnownTypeCode get_KnownTypeCode();
    public virtual TextLocation get_StartLocation();
    internal void SetStartLocation(TextLocation value);
    public virtual TextLocation get_EndLocation();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual string ToString(CSharpFormattingOptions formattingOptions);
    public virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
    public static KnownTypeCode GetTypeCodeForPrimitiveType(string keyword);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.PropertyDeclaration : EntityDeclaration {
    public static TokenRole GetKeywordRole;
    public static TokenRole SetKeywordRole;
    public static TokenRole InitKeywordRole;
    public static Role`1<Accessor> GetterRole;
    public static Role`1<Accessor> SetterRole;
    public static Role`1<Expression> ExpressionBodyRole;
    public SymbolKind SymbolKind { get; }
    public AstType PrivateImplementationType { get; public set; }
    public CSharpTokenNode LBraceToken { get; }
    public Accessor Getter { get; public set; }
    public Accessor Setter { get; public set; }
    public CSharpTokenNode RBraceToken { get; }
    public CSharpTokenNode AssignToken { get; }
    public Expression Initializer { get; public set; }
    public Expression ExpressionBody { get; public set; }
    private static PropertyDeclaration();
    public virtual SymbolKind get_SymbolKind();
    public AstType get_PrivateImplementationType();
    public void set_PrivateImplementationType(AstType value);
    public CSharpTokenNode get_LBraceToken();
    public Accessor get_Getter();
    public void set_Getter(Accessor value);
    public Accessor get_Setter();
    public void set_Setter(Accessor value);
    public CSharpTokenNode get_RBraceToken();
    public CSharpTokenNode get_AssignToken();
    public Expression get_Initializer();
    public void set_Initializer(Expression value);
    public Expression get_ExpressionBody();
    public void set_ExpressionBody(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.QueryClause : AstNode {
    public NodeType NodeType { get; }
    public virtual NodeType get_NodeType();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryContinuationClause : QueryClause {
    public static Role`1<QueryExpression> PrecedingQueryRole;
    public static TokenRole IntoKeywordRole;
    public QueryExpression PrecedingQuery { get; public set; }
    public CSharpTokenNode IntoKeyword { get; }
    public string Identifier { get; public set; }
    public Identifier IdentifierToken { get; }
    private static QueryContinuationClause();
    public QueryExpression get_PrecedingQuery();
    public void set_PrecedingQuery(QueryExpression value);
    public CSharpTokenNode get_IntoKeyword();
    public string get_Identifier();
    public void set_Identifier(string value);
    public Identifier get_IdentifierToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryExpression : Expression {
    public static Role`1<QueryClause> ClauseRole;
    public static QueryExpression Null;
    public AstNodeCollection`1<QueryClause> Clauses { get; }
    private static QueryExpression();
    public AstNodeCollection`1<QueryClause> get_Clauses();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryFromClause : QueryClause {
    public static TokenRole FromKeywordRole;
    public static TokenRole InKeywordRole;
    public CSharpTokenNode FromKeyword { get; }
    public AstType Type { get; public set; }
    public string Identifier { get; public set; }
    public Identifier IdentifierToken { get; }
    public CSharpTokenNode InKeyword { get; }
    public Expression Expression { get; public set; }
    private static QueryFromClause();
    public CSharpTokenNode get_FromKeyword();
    public AstType get_Type();
    public void set_Type(AstType value);
    public string get_Identifier();
    public void set_Identifier(string value);
    public Identifier get_IdentifierToken();
    public CSharpTokenNode get_InKeyword();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryGroupClause : QueryClause {
    public static TokenRole GroupKeywordRole;
    public static Role`1<Expression> ProjectionRole;
    public static TokenRole ByKeywordRole;
    public static Role`1<Expression> KeyRole;
    public CSharpTokenNode GroupKeyword { get; }
    public Expression Projection { get; public set; }
    public CSharpTokenNode ByKeyword { get; }
    public Expression Key { get; public set; }
    private static QueryGroupClause();
    public CSharpTokenNode get_GroupKeyword();
    public Expression get_Projection();
    public void set_Projection(Expression value);
    public CSharpTokenNode get_ByKeyword();
    public Expression get_Key();
    public void set_Key(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryJoinClause : QueryClause {
    public static TokenRole JoinKeywordRole;
    public static Role`1<AstType> TypeRole;
    public static Role`1<Identifier> JoinIdentifierRole;
    public static TokenRole InKeywordRole;
    public static Role`1<Expression> InExpressionRole;
    public static TokenRole OnKeywordRole;
    public static Role`1<Expression> OnExpressionRole;
    public static TokenRole EqualsKeywordRole;
    public static Role`1<Expression> EqualsExpressionRole;
    public static TokenRole IntoKeywordRole;
    public static Role`1<Identifier> IntoIdentifierRole;
    public bool IsGroupJoin { get; }
    public CSharpTokenNode JoinKeyword { get; }
    public AstType Type { get; public set; }
    public string JoinIdentifier { get; public set; }
    public Identifier JoinIdentifierToken { get; }
    public CSharpTokenNode InKeyword { get; }
    public Expression InExpression { get; public set; }
    public CSharpTokenNode OnKeyword { get; }
    public Expression OnExpression { get; public set; }
    public CSharpTokenNode EqualsKeyword { get; }
    public Expression EqualsExpression { get; public set; }
    public CSharpTokenNode IntoKeyword { get; }
    public string IntoIdentifier { get; public set; }
    public Identifier IntoIdentifierToken { get; }
    private static QueryJoinClause();
    public bool get_IsGroupJoin();
    public CSharpTokenNode get_JoinKeyword();
    public AstType get_Type();
    public void set_Type(AstType value);
    public string get_JoinIdentifier();
    public void set_JoinIdentifier(string value);
    public Identifier get_JoinIdentifierToken();
    public CSharpTokenNode get_InKeyword();
    public Expression get_InExpression();
    public void set_InExpression(Expression value);
    public CSharpTokenNode get_OnKeyword();
    public Expression get_OnExpression();
    public void set_OnExpression(Expression value);
    public CSharpTokenNode get_EqualsKeyword();
    public Expression get_EqualsExpression();
    public void set_EqualsExpression(Expression value);
    public CSharpTokenNode get_IntoKeyword();
    public string get_IntoIdentifier();
    public void set_IntoIdentifier(string value);
    public Identifier get_IntoIdentifierToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryLetClause : QueryClause {
    public static TokenRole LetKeywordRole;
    public CSharpTokenNode LetKeyword { get; }
    public string Identifier { get; public set; }
    public Identifier IdentifierToken { get; }
    public CSharpTokenNode AssignToken { get; }
    public Expression Expression { get; public set; }
    private static QueryLetClause();
    public CSharpTokenNode get_LetKeyword();
    public string get_Identifier();
    public void set_Identifier(string value);
    public Identifier get_IdentifierToken();
    public CSharpTokenNode get_AssignToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryOrderClause : QueryClause {
    public static TokenRole OrderbyKeywordRole;
    public static Role`1<QueryOrdering> OrderingRole;
    public CSharpTokenNode OrderbyToken { get; }
    public AstNodeCollection`1<QueryOrdering> Orderings { get; }
    private static QueryOrderClause();
    public CSharpTokenNode get_OrderbyToken();
    public AstNodeCollection`1<QueryOrdering> get_Orderings();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryOrdering : AstNode {
    public static TokenRole AscendingKeywordRole;
    public static TokenRole DescendingKeywordRole;
    [CompilerGeneratedAttribute]
private QueryOrderingDirection <Direction>k__BackingField;
    public NodeType NodeType { get; }
    public Expression Expression { get; public set; }
    public QueryOrderingDirection Direction { get; public set; }
    public CSharpTokenNode DirectionToken { get; }
    private static QueryOrdering();
    public virtual NodeType get_NodeType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public QueryOrderingDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(QueryOrderingDirection value);
    public CSharpTokenNode get_DirectionToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.QueryOrderingDirection : Enum {
    public int value__;
    public static QueryOrderingDirection None;
    public static QueryOrderingDirection Ascending;
    public static QueryOrderingDirection Descending;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QuerySelectClause : QueryClause {
    public static TokenRole SelectKeywordRole;
    public CSharpTokenNode SelectKeyword { get; }
    public Expression Expression { get; public set; }
    private static QuerySelectClause();
    public CSharpTokenNode get_SelectKeyword();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.QueryWhereClause : QueryClause {
    public static TokenRole WhereKeywordRole;
    public CSharpTokenNode WhereKeyword { get; }
    public Expression Condition { get; public set; }
    private static QueryWhereClause();
    public CSharpTokenNode get_WhereKeyword();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ReturnStatement : Statement {
    public static TokenRole ReturnKeywordRole;
    public CSharpTokenNode ReturnToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    public ReturnStatement(Expression returnExpression);
    private static ReturnStatement();
    public CSharpTokenNode get_ReturnToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.Role : object {
    public static int RoleIndexBits;
    private static Role[] roles;
    private static int nextRoleIndex;
    private UInt32 index;
    public UInt32 Index { get; }
    private static Role();
    public UInt32 get_Index();
    public abstract virtual bool IsValid(object node);
    public static Role GetByIndex(UInt32 index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.CSharp.Syntax.Role`1 : Role {
    private string name;
    private T nullObject;
    public T NullObject { get; }
    [ObsoleteAttribute("Use the other overload explicitly specifying the nullObject.")]
public Role`1(string name);
    public Role`1(string name, T nullObject);
    public T get_NullObject();
    public virtual bool IsValid(object node);
    public virtual string ToString();
}
public static class ICSharpCode.Decompiler.CSharp.Syntax.Roles : object {
    public static Role`1<AstNode> Root;
    public static Role`1<Identifier> Identifier;
    public static Role`1<BlockStatement> Body;
    public static Role`1<ParameterDeclaration> Parameter;
    public static Role`1<Expression> Argument;
    public static Role`1<AstType> Type;
    public static Role`1<Expression> Expression;
    public static Role`1<Expression> TargetExpression;
    public static Role`1<Expression> Condition;
    public static Role`1<TypeParameterDeclaration> TypeParameter;
    public static Role`1<AstType> TypeArgument;
    public static Role`1<Constraint> Constraint;
    public static Role`1<VariableInitializer> Variable;
    public static Role`1<Statement> EmbeddedStatement;
    public static Role`1<EntityDeclaration> TypeMemberRole;
    public static Role`1<VariableDesignation> VariableDesignationRole;
    public static TokenRole LPar;
    public static TokenRole RPar;
    public static TokenRole LBracket;
    public static TokenRole RBracket;
    public static TokenRole LBrace;
    public static TokenRole RBrace;
    public static TokenRole LChevron;
    public static TokenRole RChevron;
    public static TokenRole Comma;
    public static TokenRole Dot;
    public static TokenRole Semicolon;
    public static TokenRole Assign;
    public static TokenRole Colon;
    public static TokenRole DoubleColon;
    public static TokenRole Arrow;
    public static TokenRole DoubleExclamation;
    public static Role`1<Comment> Comment;
    public static Role`1<PreProcessorDirective> PreProcessorDirective;
    public static Role`1<AstType> BaseType;
    public static Role`1<Attribute> Attribute;
    public static Role`1<CSharpTokenNode> AttributeTargetRole;
    public static TokenRole WhereKeyword;
    public static Role`1<SimpleType> ConstraintTypeParameter;
    public static TokenRole DelegateKeyword;
    public static TokenRole ExternKeyword;
    public static TokenRole AliasKeyword;
    public static TokenRole NamespaceKeyword;
    public static TokenRole EnumKeyword;
    public static TokenRole InterfaceKeyword;
    public static TokenRole StructKeyword;
    public static TokenRole ClassKeyword;
    public static TokenRole RecordKeyword;
    public static TokenRole RecordStructKeyword;
    private static Roles();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SimpleType : AstType {
    public static SimpleType Null;
    public string Identifier { get; public set; }
    public Identifier IdentifierToken { get; public set; }
    public AstNodeCollection`1<AstType> TypeArguments { get; }
    public SimpleType(string identifier);
    public SimpleType(Identifier identifier);
    public SimpleType(string identifier, TextLocation location);
    public SimpleType(string identifier, IEnumerable`1<AstType> typeArguments);
    public SimpleType(string identifier, AstType[] typeArguments);
    private static SimpleType();
    public string get_Identifier();
    public void set_Identifier(string value);
    public Identifier get_IdentifierToken();
    public void set_IdentifierToken(Identifier value);
    public AstNodeCollection`1<AstType> get_TypeArguments();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SingleVariableDesignation : VariableDesignation {
    public string Identifier { get; public set; }
    public Identifier IdentifierToken { get; public set; }
    public string get_Identifier();
    public void set_Identifier(string value);
    public Identifier get_IdentifierToken();
    public void set_IdentifierToken(Identifier value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SizeOfExpression : Expression {
    public static TokenRole SizeofKeywordRole;
    public CSharpTokenNode SizeOfToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstType Type { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public SizeOfExpression(AstType type);
    private static SizeOfExpression();
    public CSharpTokenNode get_SizeOfToken();
    public CSharpTokenNode get_LParToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.StackAllocExpression : Expression {
    public static TokenRole StackallocKeywordRole;
    public static Role`1<ArrayInitializerExpression> InitializerRole;
    public CSharpTokenNode StackAllocToken { get; }
    public AstType Type { get; public set; }
    public CSharpTokenNode LBracketToken { get; }
    public Expression CountExpression { get; public set; }
    public CSharpTokenNode RBracketToken { get; }
    public ArrayInitializerExpression Initializer { get; public set; }
    private static StackAllocExpression();
    public CSharpTokenNode get_StackAllocToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public CSharpTokenNode get_LBracketToken();
    public Expression get_CountExpression();
    public void set_CountExpression(Expression value);
    public CSharpTokenNode get_RBracketToken();
    public ArrayInitializerExpression get_Initializer();
    public void set_Initializer(ArrayInitializerExpression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.Statement : AstNode {
    public static Statement Null;
    public NodeType NodeType { get; }
    private static Statement();
    public static Statement op_Implicit(Pattern pattern);
    public Statement Clone();
    public Statement ReplaceWith(Func`2<Statement, Statement> replaceFunction);
    public virtual NodeType get_NodeType();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SwitchExpression : Expression {
    public static TokenRole SwitchKeywordRole;
    public static Role`1<SwitchExpressionSection> SwitchSectionRole;
    public Expression Expression { get; public set; }
    public CSharpTokenNode SwitchToken { get; }
    public CSharpTokenNode LBraceToken { get; }
    public AstNodeCollection`1<SwitchExpressionSection> SwitchSections { get; }
    public CSharpTokenNode RBraceToken { get; }
    private static SwitchExpression();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_SwitchToken();
    public CSharpTokenNode get_LBraceToken();
    public AstNodeCollection`1<SwitchExpressionSection> get_SwitchSections();
    public CSharpTokenNode get_RBraceToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SwitchExpressionSection : AstNode {
    public static Role`1<Expression> PatternRole;
    public static Role`1<Expression> BodyRole;
    public Expression Pattern { get; public set; }
    public CSharpTokenNode ArrowToken { get; }
    public Expression Body { get; public set; }
    public NodeType NodeType { get; }
    private static SwitchExpressionSection();
    public Expression get_Pattern();
    public void set_Pattern(Expression value);
    public CSharpTokenNode get_ArrowToken();
    public Expression get_Body();
    public void set_Body(Expression value);
    public virtual NodeType get_NodeType();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SwitchSection : AstNode {
    public static Role`1<CaseLabel> CaseLabelRole;
    public NodeType NodeType { get; }
    public AstNodeCollection`1<CaseLabel> CaseLabels { get; }
    public AstNodeCollection`1<Statement> Statements { get; }
    private static SwitchSection();
    public static SwitchSection op_Implicit(Pattern pattern);
    public virtual NodeType get_NodeType();
    public AstNodeCollection`1<CaseLabel> get_CaseLabels();
    public AstNodeCollection`1<Statement> get_Statements();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SwitchStatement : Statement {
    public static TokenRole SwitchKeywordRole;
    public static Role`1<SwitchSection> SwitchSectionRole;
    public CSharpTokenNode SwitchToken { get; }
    public CSharpTokenNode LParToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public CSharpTokenNode LBraceToken { get; }
    public AstNodeCollection`1<SwitchSection> SwitchSections { get; }
    public CSharpTokenNode RBraceToken { get; }
    private static SwitchStatement();
    public CSharpTokenNode get_SwitchToken();
    public CSharpTokenNode get_LParToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_RParToken();
    public CSharpTokenNode get_LBraceToken();
    public AstNodeCollection`1<SwitchSection> get_SwitchSections();
    public CSharpTokenNode get_RBraceToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.CSharp.Syntax.SyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsComparisonOperator(OperatorType operatorType);
    [ExtensionAttribute]
public static bool IsBitwise(BinaryOperatorType operatorType);
    [ExtensionAttribute]
public static Statement GetNextStatement(Statement statement);
    [ExtensionAttribute]
public static bool IsArgList(AstType type);
    [ExtensionAttribute]
public static void AddNamedArgument(Attribute attribute, string name, Expression argument);
    [ExtensionAttribute]
public static T Detach(T node);
    [ExtensionAttribute]
public static Expression UnwrapInDirectionExpression(Expression expr);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.SyntaxTree : AstNode {
    public static Role`1<AstNode> MemberRole;
    private string fileName;
    private IList`1<string> conditionalSymbols;
    [CompilerGeneratedAttribute]
private AstNode <TopExpression>k__BackingField;
    public NodeType NodeType { get; }
    public string FileName { get; public set; }
    public AstNodeCollection`1<AstNode> Members { get; }
    public IList`1<string> ConditionalSymbols { get; internal set; }
    public AstNode TopExpression { get; internal set; }
    private static SyntaxTree();
    public virtual NodeType get_NodeType();
    public string get_FileName();
    public void set_FileName(string value);
    public AstNodeCollection`1<AstNode> get_Members();
    public IList`1<string> get_ConditionalSymbols();
    internal void set_ConditionalSymbols(IList`1<string> value);
    [CompilerGeneratedAttribute]
public AstNode get_TopExpression();
    [CompilerGeneratedAttribute]
internal void set_TopExpression(AstNode value);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.CSharp.Syntax.SyntaxTree/<GetTypes>d__18")]
public IEnumerable`1<EntityDeclaration> GetTypes(bool includeInnerTypes);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
}
[TypeConverterAttribute("ICSharpCode.Decompiler.CSharp.Syntax.TextLocationConverter")]
public class ICSharpCode.Decompiler.CSharp.Syntax.TextLocation : ValueType {
    public static TextLocation Empty;
    public static int MinLine;
    public static int MinColumn;
    private int column;
    private int line;
    public int Line { get; }
    public int Column { get; }
    public bool IsEmpty { get; }
    public TextLocation(int line, int column);
    private static TextLocation();
    public int get_Line();
    public int get_Column();
    public bool get_IsEmpty();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextLocation other);
    public static bool op_Equality(TextLocation left, TextLocation right);
    public static bool op_Inequality(TextLocation left, TextLocation right);
    public static bool op_LessThan(TextLocation left, TextLocation right);
    public static bool op_GreaterThan(TextLocation left, TextLocation right);
    public static bool op_LessThanOrEqual(TextLocation left, TextLocation right);
    public static bool op_GreaterThanOrEqual(TextLocation left, TextLocation right);
    public sealed virtual int CompareTo(TextLocation other);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TextLocationConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ThisReferenceExpression : Expression {
    [CompilerGeneratedAttribute]
private TextLocation <Location>k__BackingField;
    public TextLocation Location { get; public set; }
    public TextLocation StartLocation { get; }
    public TextLocation EndLocation { get; }
    [CompilerGeneratedAttribute]
public TextLocation get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(TextLocation value);
    public virtual TextLocation get_StartLocation();
    public virtual TextLocation get_EndLocation();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ThrowExpression : Expression {
    public static TokenRole ThrowKeywordRole;
    public CSharpTokenNode ThrowToken { get; }
    public Expression Expression { get; public set; }
    public ThrowExpression(Expression expression);
    private static ThrowExpression();
    public CSharpTokenNode get_ThrowToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.ThrowStatement : Statement {
    public static TokenRole ThrowKeywordRole;
    public CSharpTokenNode ThrowToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    public ThrowStatement(Expression expression);
    private static ThrowStatement();
    public CSharpTokenNode get_ThrowToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TokenRole : Role`1<CSharpTokenNode> {
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public string Token { get; }
    public int Length { get; }
    public TokenRole(string token);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public int get_Length();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TryCatchStatement : Statement {
    public static TokenRole TryKeywordRole;
    public static Role`1<BlockStatement> TryBlockRole;
    public static Role`1<CatchClause> CatchClauseRole;
    public static TokenRole FinallyKeywordRole;
    public static Role`1<BlockStatement> FinallyBlockRole;
    public CSharpTokenNode TryToken { get; }
    public BlockStatement TryBlock { get; public set; }
    public AstNodeCollection`1<CatchClause> CatchClauses { get; }
    public CSharpTokenNode FinallyToken { get; }
    public BlockStatement FinallyBlock { get; public set; }
    private static TryCatchStatement();
    public CSharpTokenNode get_TryToken();
    public BlockStatement get_TryBlock();
    public void set_TryBlock(BlockStatement value);
    public AstNodeCollection`1<CatchClause> get_CatchClauses();
    public CSharpTokenNode get_FinallyToken();
    public BlockStatement get_FinallyBlock();
    public void set_FinallyBlock(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TupleAstType : AstType {
    public static Role`1<TupleTypeElement> ElementRole;
    public AstNodeCollection`1<TupleTypeElement> Elements { get; }
    private static TupleAstType();
    public AstNodeCollection`1<TupleTypeElement> get_Elements();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    public virtual ITypeReference ToTypeReference(NameLookupMode lookupMode, InterningProvider interningProvider);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TupleExpression : Expression {
    public AstNodeCollection`1<Expression> Elements { get; }
    public AstNodeCollection`1<Expression> get_Elements();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TupleTypeElement : AstNode {
    public static TupleTypeElement Null;
    public AstType Type { get; public set; }
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public NodeType NodeType { get; }
    private static TupleTypeElement();
    public AstType get_Type();
    public void set_Type(AstType value);
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public virtual NodeType get_NodeType();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TypeDeclaration : EntityDeclaration {
    private ClassType classType;
    public NodeType NodeType { get; }
    public SymbolKind SymbolKind { get; }
    public CSharpTokenNode TypeKeyword { get; }
    public ClassType ClassType { get; public set; }
    public CSharpTokenNode LChevronToken { get; }
    public AstNodeCollection`1<TypeParameterDeclaration> TypeParameters { get; }
    public CSharpTokenNode RChevronToken { get; }
    public CSharpTokenNode ColonToken { get; }
    public AstNodeCollection`1<AstType> BaseTypes { get; }
    public AstNodeCollection`1<ParameterDeclaration> PrimaryConstructorParameters { get; }
    public AstNodeCollection`1<Constraint> Constraints { get; }
    public CSharpTokenNode LBraceToken { get; }
    public AstNodeCollection`1<EntityDeclaration> Members { get; }
    public CSharpTokenNode RBraceToken { get; }
    public virtual NodeType get_NodeType();
    public virtual SymbolKind get_SymbolKind();
    public CSharpTokenNode get_TypeKeyword();
    public ClassType get_ClassType();
    public void set_ClassType(ClassType value);
    public CSharpTokenNode get_LChevronToken();
    public AstNodeCollection`1<TypeParameterDeclaration> get_TypeParameters();
    public CSharpTokenNode get_RChevronToken();
    public CSharpTokenNode get_ColonToken();
    public AstNodeCollection`1<AstType> get_BaseTypes();
    public AstNodeCollection`1<ParameterDeclaration> get_PrimaryConstructorParameters();
    public AstNodeCollection`1<Constraint> get_Constraints();
    public CSharpTokenNode get_LBraceToken();
    public AstNodeCollection`1<EntityDeclaration> get_Members();
    public CSharpTokenNode get_RBraceToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TypeOfExpression : Expression {
    public static TokenRole TypeofKeywordRole;
    public CSharpTokenNode TypeOfToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstType Type { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public TypeOfExpression(AstType type);
    private static TypeOfExpression();
    public CSharpTokenNode get_TypeOfToken();
    public CSharpTokenNode get_LParToken();
    public AstType get_Type();
    public void set_Type(AstType value);
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TypeParameterDeclaration : AstNode {
    public static Role`1<AttributeSection> AttributeRole;
    public static TokenRole OutVarianceKeywordRole;
    public static TokenRole InVarianceKeywordRole;
    private VarianceModifier variance;
    public NodeType NodeType { get; }
    public AstNodeCollection`1<AttributeSection> Attributes { get; }
    public VarianceModifier Variance { get; public set; }
    public CSharpTokenNode VarianceToken { get; }
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public TypeParameterDeclaration(string name);
    private static TypeParameterDeclaration();
    public virtual NodeType get_NodeType();
    public AstNodeCollection`1<AttributeSection> get_Attributes();
    public VarianceModifier get_Variance();
    public void set_Variance(VarianceModifier value);
    public CSharpTokenNode get_VarianceToken();
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TypeReferenceExpression : Expression {
    public AstType Type { get; public set; }
    public TypeReferenceExpression(AstType type);
    public AstType get_Type();
    public void set_Type(AstType value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.TypeSystemAstBuilder : object {
    private CSharpResolver resolver;
    [CompilerGeneratedAttribute]
private bool <AddTypeReferenceAnnotations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddResolveResultAnnotations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowModifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowBaseTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowTypeParametersForUnboundTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowTypeParameterConstraints>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowParameterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowConstantValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysUseShortTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseKeywordsForBuiltinTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNullableSpecifierForValueTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private NameLookupMode <NameLookupMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateBody>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCustomEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConvertUnboundTypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSpecialConstants>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintIntegralValuesAsHex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportInitAccessors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportRecordClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportRecordStructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportUnsignedRightShift>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportOperatorChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysUseGlobal>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<object, ValueTuple`2<KnownTypeCode, string>> specialConstants;
    private static int MAX_DENOMINATOR_DOUBLE;
    private static int MAX_DENOMINATOR_FLOAT;
    private static float MathF_PI;
    private static float MathF_E;
    public bool AddTypeReferenceAnnotations { get; public set; }
    public bool AddResolveResultAnnotations { get; public set; }
    public bool ShowAccessibility { get; public set; }
    public bool ShowModifiers { get; public set; }
    public bool ShowBaseTypes { get; public set; }
    public bool ShowTypeParameters { get; public set; }
    public bool ShowTypeParametersForUnboundTypes { get; public set; }
    public bool ShowTypeParameterConstraints { get; public set; }
    public bool ShowParameterNames { get; public set; }
    public bool ShowConstantValues { get; public set; }
    public bool ShowAttributes { get; public set; }
    public bool AlwaysUseShortTypeNames { get; public set; }
    public bool UseKeywordsForBuiltinTypes { get; public set; }
    public bool UseNullableSpecifierForValueTypes { get; public set; }
    public NameLookupMode NameLookupMode { get; public set; }
    public bool GenerateBody { get; public set; }
    public bool UseCustomEvents { get; public set; }
    public bool ConvertUnboundTypeArguments { get; public set; }
    public bool UseAliases { get; public set; }
    public bool UseSpecialConstants { get; public set; }
    public bool PrintIntegralValuesAsHex { get; public set; }
    public bool SupportInitAccessors { get; public set; }
    public bool SupportRecordClasses { get; public set; }
    public bool SupportRecordStructs { get; public set; }
    public bool SupportUnsignedRightShift { get; public set; }
    public bool SupportOperatorChecked { get; public set; }
    public bool AlwaysUseGlobal { get; public set; }
    public TypeSystemAstBuilder(CSharpResolver resolver);
    private static TypeSystemAstBuilder();
    private void InitProperties();
    [CompilerGeneratedAttribute]
public bool get_AddTypeReferenceAnnotations();
    [CompilerGeneratedAttribute]
public void set_AddTypeReferenceAnnotations(bool value);
    [CompilerGeneratedAttribute]
public bool get_AddResolveResultAnnotations();
    [CompilerGeneratedAttribute]
public void set_AddResolveResultAnnotations(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowAccessibility();
    [CompilerGeneratedAttribute]
public void set_ShowAccessibility(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowModifiers();
    [CompilerGeneratedAttribute]
public void set_ShowModifiers(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowBaseTypes();
    [CompilerGeneratedAttribute]
public void set_ShowBaseTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowTypeParameters();
    [CompilerGeneratedAttribute]
public void set_ShowTypeParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowTypeParametersForUnboundTypes();
    [CompilerGeneratedAttribute]
public void set_ShowTypeParametersForUnboundTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowTypeParameterConstraints();
    [CompilerGeneratedAttribute]
public void set_ShowTypeParameterConstraints(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowParameterNames();
    [CompilerGeneratedAttribute]
public void set_ShowParameterNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowConstantValues();
    [CompilerGeneratedAttribute]
public void set_ShowConstantValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowAttributes();
    [CompilerGeneratedAttribute]
public void set_ShowAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysUseShortTypeNames();
    [CompilerGeneratedAttribute]
public void set_AlwaysUseShortTypeNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseKeywordsForBuiltinTypes();
    [CompilerGeneratedAttribute]
public void set_UseKeywordsForBuiltinTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseNullableSpecifierForValueTypes();
    [CompilerGeneratedAttribute]
public void set_UseNullableSpecifierForValueTypes(bool value);
    [CompilerGeneratedAttribute]
public NameLookupMode get_NameLookupMode();
    [CompilerGeneratedAttribute]
public void set_NameLookupMode(NameLookupMode value);
    [CompilerGeneratedAttribute]
public bool get_GenerateBody();
    [CompilerGeneratedAttribute]
public void set_GenerateBody(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseCustomEvents();
    [CompilerGeneratedAttribute]
public void set_UseCustomEvents(bool value);
    [CompilerGeneratedAttribute]
public bool get_ConvertUnboundTypeArguments();
    [CompilerGeneratedAttribute]
public void set_ConvertUnboundTypeArguments(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseAliases();
    [CompilerGeneratedAttribute]
public void set_UseAliases(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSpecialConstants();
    [CompilerGeneratedAttribute]
public void set_UseSpecialConstants(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrintIntegralValuesAsHex();
    [CompilerGeneratedAttribute]
public void set_PrintIntegralValuesAsHex(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportInitAccessors();
    [CompilerGeneratedAttribute]
public void set_SupportInitAccessors(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportRecordClasses();
    [CompilerGeneratedAttribute]
public void set_SupportRecordClasses(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportRecordStructs();
    [CompilerGeneratedAttribute]
public void set_SupportRecordStructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportUnsignedRightShift();
    [CompilerGeneratedAttribute]
public void set_SupportUnsignedRightShift(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportOperatorChecked();
    [CompilerGeneratedAttribute]
public void set_SupportOperatorChecked(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysUseGlobal();
    [CompilerGeneratedAttribute]
public void set_AlwaysUseGlobal(bool value);
    public AstType ConvertType(IType type);
    private void AddTypeAnnotation(AstType astType, IType type);
    public AstType ConvertType(FullTypeName fullTypeName);
    private AstType ConvertTypeHelper(IType type);
    private AstType ConvertTypeHelper(IType genericType, IReadOnlyList`1<IType> typeArguments);
    private bool TypeMatches(IType type, ITypeDefinition typeDef, IReadOnlyList`1<IType> typeArguments);
    private bool TypeDefMatches(ITypeDefinition typeDef, IType type);
    private void AddTypeArguments(AstType result, IReadOnlyList`1<ITypeParameter> typeParameters, IReadOnlyList`1<IType> typeArguments, int startIndex, int endIndex);
    public AstType ConvertNamespace(string namespaceName, NamespaceResolveResult& nrr);
    private AstType ConvertNamespace(string namespaceName, NamespaceResolveResult& nrr, bool requiresGlobalPrefix);
    private bool IsValidNamespace(string firstNamespacePart, NamespaceResolveResult& nrr);
    private static SimpleType MakeSimpleType(string name);
    private SimpleType MakeGlobal();
    private static MemberType MakeMemberType(AstType target, string name);
    public Attribute ConvertAttribute(IAttribute attribute);
    private IEnumerable`1<AttributeSection> ConvertAttributes(IEnumerable`1<IAttribute> attributes);
    private IEnumerable`1<AttributeSection> ConvertAttributes(IEnumerable`1<IAttribute> attributes, string target);
    public AstType ConvertAttributeType(IType type);
    private void ApplyShortAttributeNameIfPossible(IType type, AstType astType, string shortName);
    private bool IsAttributeType(IType type);
    private bool IsAttributeType(ResolveResult rr);
    public Expression ConvertConstantValue(ResolveResult rr);
    public Expression ConvertConstantValue(IType type, object constantValue);
    public Expression ConvertConstantValue(IType expectedType, IType type, object constantValue);
    private bool IsSpecialConstant(IType expectedType, object constant, Expression& expression);
    private bool IsFlagsEnum(ITypeDefinition type);
    private Expression ConvertEnumValue(IType type, long val);
    private static bool IsValidFraction(long num, long den);
    private static bool EqualDoubles(Double& val1, Double& val2);
    private static bool EqualFloats(Single& val1, Single& val2);
    private static bool IsEqual(long num, long den, object constantValue, bool isDouble);
    private Expression ConvertFloatingPointLiteral(IType type, object constantValue);
    private Expression MakeConstant(IType type, long c);
    private Expression TryExtractExpression(IType mathType, IType type, object literalValue, string memberName, bool isDouble);
    private static ValueTuple`2<long, long> FractionApprox(double value, int maxDenominator);
    public ParameterDeclaration ConvertParameter(IParameter parameter);
    public AstNode ConvertSymbol(ISymbol symbol);
    public EntityDeclaration ConvertEntity(IEntity entity);
    private EntityDeclaration ConvertTypeDefinition(ITypeDefinition typeDefinition);
    private DelegateDeclaration ConvertDelegate(IMethod invokeMethod, Modifiers modifiers);
    private FieldDeclaration ConvertField(IField field);
    private BlockStatement GenerateBodyBlock();
    private Accessor ConvertAccessor(IMethod accessor, MethodSemanticsAttributes kind, Accessibility ownerAccessibility, bool addParameterAttribute);
    private PropertyDeclaration ConvertProperty(IProperty property);
    private static void MergeReadOnlyModifiers(EntityDeclaration decl, Accessor accessor1, Accessor accessor2);
    private IndexerDeclaration ConvertIndexer(IProperty indexer);
    private EntityDeclaration ConvertEvent(IEvent ev);
    private MethodDeclaration ConvertMethod(IMethod method);
    private EntityDeclaration ConvertOperator(IMethod op);
    private ConstructorDeclaration ConvertConstructor(IMethod ctor);
    private DestructorDeclaration ConvertDestructor(IMethod dtor);
    public static Modifiers ModifierFromAccessibility(Accessibility accessibility);
    private bool NeedsAccessibility(IMember member);
    private Modifiers GetMemberModifiers(IMember member);
    internal TypeParameterDeclaration ConvertTypeParameter(ITypeParameter tp);
    internal Constraint ConvertTypeParameterConstraint(ITypeParameter tp);
    private static bool IsObjectOrValueType(IType type);
    public VariableDeclarationStatement ConvertVariable(IVariable v);
    private NamespaceDeclaration ConvertNamespaceDeclaration(INamespace ns);
    private AstType GetExplicitInterfaceType(IMember member);
    [CompilerGeneratedAttribute]
private AttributeSection <ConvertAttributes>b__127_0(IAttribute a);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<long, IField> <ConvertEnumValue>g__PrepareConstant|139_1(IField field);
    [CompilerGeneratedAttribute]
internal static int <ConvertEnumValue>g__CalculateHammingWeight|139_2(ulong value);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorExpression : Expression {
    public static TokenRole NotRole;
    public static TokenRole BitNotRole;
    public static TokenRole MinusRole;
    public static TokenRole PlusRole;
    public static TokenRole IncrementRole;
    public static TokenRole DecrementRole;
    public static TokenRole DereferenceRole;
    public static TokenRole AddressOfRole;
    public static TokenRole AwaitRole;
    public static TokenRole NullConditionalRole;
    public static TokenRole SuppressNullableWarningRole;
    public static TokenRole IndexFromEndRole;
    [CompilerGeneratedAttribute]
private UnaryOperatorType <Operator>k__BackingField;
    public UnaryOperatorType Operator { get; public set; }
    public CSharpTokenNode OperatorToken { get; }
    public Expression Expression { get; public set; }
    public UnaryOperatorExpression(UnaryOperatorType op, Expression expression);
    private static UnaryOperatorExpression();
    [CompilerGeneratedAttribute]
public UnaryOperatorType get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(UnaryOperatorType value);
    public CSharpTokenNode get_OperatorToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
    public static TokenRole GetOperatorRole(UnaryOperatorType op);
    public static ExpressionType GetLinqNodeType(UnaryOperatorType op, bool checkForOverflow);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.UnaryOperatorType : Enum {
    public int value__;
    public static UnaryOperatorType Any;
    public static UnaryOperatorType Not;
    public static UnaryOperatorType BitNot;
    public static UnaryOperatorType Minus;
    public static UnaryOperatorType Plus;
    public static UnaryOperatorType Increment;
    public static UnaryOperatorType Decrement;
    public static UnaryOperatorType PostIncrement;
    public static UnaryOperatorType PostDecrement;
    public static UnaryOperatorType Dereference;
    public static UnaryOperatorType AddressOf;
    public static UnaryOperatorType Await;
    public static UnaryOperatorType NullConditional;
    public static UnaryOperatorType NullConditionalRewrap;
    public static UnaryOperatorType IsTrue;
    public static UnaryOperatorType SuppressNullableWarning;
    public static UnaryOperatorType IndexFromEnd;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UncheckedExpression : Expression {
    public static TokenRole UncheckedKeywordRole;
    public CSharpTokenNode UncheckedToken { get; }
    public CSharpTokenNode LParToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public UncheckedExpression(Expression expression);
    private static UncheckedExpression();
    public CSharpTokenNode get_UncheckedToken();
    public CSharpTokenNode get_LParToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UncheckedStatement : Statement {
    public static TokenRole UncheckedKeywordRole;
    public CSharpTokenNode UncheckedToken { get; }
    public BlockStatement Body { get; public set; }
    public UncheckedStatement(BlockStatement body);
    private static UncheckedStatement();
    public CSharpTokenNode get_UncheckedToken();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UndocumentedExpression : Expression {
    public static TokenRole ArglistKeywordRole;
    public static TokenRole RefvalueKeywordRole;
    public static TokenRole ReftypeKeywordRole;
    public static TokenRole MakerefKeywordRole;
    [CompilerGeneratedAttribute]
private UndocumentedExpressionType <UndocumentedExpressionType>k__BackingField;
    public UndocumentedExpressionType UndocumentedExpressionType { get; public set; }
    public CSharpTokenNode UndocumentedToken { get; }
    public CSharpTokenNode LParToken { get; }
    public AstNodeCollection`1<Expression> Arguments { get; }
    public CSharpTokenNode RParToken { get; }
    private static UndocumentedExpression();
    [CompilerGeneratedAttribute]
public UndocumentedExpressionType get_UndocumentedExpressionType();
    [CompilerGeneratedAttribute]
public void set_UndocumentedExpressionType(UndocumentedExpressionType value);
    public CSharpTokenNode get_UndocumentedToken();
    public CSharpTokenNode get_LParToken();
    public AstNodeCollection`1<Expression> get_Arguments();
    public CSharpTokenNode get_RParToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public enum ICSharpCode.Decompiler.CSharp.Syntax.UndocumentedExpressionType : Enum {
    public int value__;
    public static UndocumentedExpressionType ArgListAccess;
    public static UndocumentedExpressionType ArgList;
    public static UndocumentedExpressionType RefValue;
    public static UndocumentedExpressionType RefType;
    public static UndocumentedExpressionType MakeRef;
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UnsafeStatement : Statement {
    public static TokenRole UnsafeKeywordRole;
    public CSharpTokenNode UnsafeToken { get; }
    public BlockStatement Body { get; public set; }
    private static UnsafeStatement();
    public CSharpTokenNode get_UnsafeToken();
    public BlockStatement get_Body();
    public void set_Body(BlockStatement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UsingAliasDeclaration : AstNode {
    public static TokenRole UsingKeywordRole;
    public static Role`1<Identifier> AliasRole;
    public static Role`1<AstType> ImportRole;
    public NodeType NodeType { get; }
    public CSharpTokenNode UsingToken { get; }
    public string Alias { get; public set; }
    public CSharpTokenNode AssignToken { get; }
    public AstType Import { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    public UsingAliasDeclaration(string alias, string nameSpace);
    public UsingAliasDeclaration(string alias, AstType import);
    private static UsingAliasDeclaration();
    public virtual NodeType get_NodeType();
    public CSharpTokenNode get_UsingToken();
    public string get_Alias();
    public void set_Alias(string value);
    public CSharpTokenNode get_AssignToken();
    public AstType get_Import();
    public void set_Import(AstType value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UsingDeclaration : AstNode {
    public static TokenRole UsingKeywordRole;
    public static Role`1<AstType> ImportRole;
    public NodeType NodeType { get; }
    public CSharpTokenNode UsingToken { get; }
    public AstType Import { get; public set; }
    public string Namespace { get; }
    public CSharpTokenNode SemicolonToken { get; }
    public UsingDeclaration(string nameSpace);
    public UsingDeclaration(AstType import);
    private static UsingDeclaration();
    public virtual NodeType get_NodeType();
    public CSharpTokenNode get_UsingToken();
    public AstType get_Import();
    public void set_Import(AstType value);
    public string get_Namespace();
    internal static string ConstructNamespace(AstType type);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.UsingStatement : Statement {
    public static TokenRole UsingKeywordRole;
    public static TokenRole AwaitRole;
    public static Role`1<AstNode> ResourceAcquisitionRole;
    [CompilerGeneratedAttribute]
private bool <IsEnhanced>k__BackingField;
    public CSharpTokenNode UsingToken { get; }
    public CSharpTokenNode AwaitToken { get; }
    public bool IsAsync { get; public set; }
    public CSharpTokenNode LParToken { get; }
    public bool IsEnhanced { get; public set; }
    public AstNode ResourceAcquisition { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public Statement EmbeddedStatement { get; public set; }
    private static UsingStatement();
    public CSharpTokenNode get_UsingToken();
    public CSharpTokenNode get_AwaitToken();
    public bool get_IsAsync();
    public void set_IsAsync(bool value);
    public CSharpTokenNode get_LParToken();
    [CompilerGeneratedAttribute]
public bool get_IsEnhanced();
    [CompilerGeneratedAttribute]
public void set_IsEnhanced(bool value);
    public AstNode get_ResourceAcquisition();
    public void set_ResourceAcquisition(AstNode value);
    public CSharpTokenNode get_RParToken();
    public Statement get_EmbeddedStatement();
    public void set_EmbeddedStatement(Statement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.VariableDeclarationStatement : Statement {
    public static Role`1<CSharpModifierToken> ModifierRole;
    public Modifiers Modifiers { get; public set; }
    public AstType Type { get; public set; }
    public AstNodeCollection`1<VariableInitializer> Variables { get; }
    public CSharpTokenNode SemicolonToken { get; }
    public VariableDeclarationStatement(AstType type, string name, Expression initializer);
    private static VariableDeclarationStatement();
    public Modifiers get_Modifiers();
    public void set_Modifiers(Modifiers value);
    public AstType get_Type();
    public void set_Type(AstType value);
    public AstNodeCollection`1<VariableInitializer> get_Variables();
    public CSharpTokenNode get_SemicolonToken();
    public VariableInitializer GetVariable(string name);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public abstract class ICSharpCode.Decompiler.CSharp.Syntax.VariableDesignation : AstNode {
    public static VariableDesignation Null;
    public NodeType NodeType { get; }
    private static VariableDesignation();
    public virtual NodeType get_NodeType();
}
public class ICSharpCode.Decompiler.CSharp.Syntax.VariableInitializer : AstNode {
    public static VariableInitializer Null;
    public NodeType NodeType { get; }
    public string Name { get; public set; }
    public Identifier NameToken { get; public set; }
    public CSharpTokenNode AssignToken { get; }
    public Expression Initializer { get; public set; }
    public VariableInitializer(string name, Expression initializer);
    private static VariableInitializer();
    public static VariableInitializer op_Implicit(Pattern pattern);
    public virtual NodeType get_NodeType();
    public string get_Name();
    public void set_Name(string value);
    public Identifier get_NameToken();
    public void set_NameToken(Identifier value);
    public CSharpTokenNode get_AssignToken();
    public Expression get_Initializer();
    public void set_Initializer(Expression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.WhileStatement : Statement {
    public static TokenRole WhileKeywordRole;
    public CSharpTokenNode WhileToken { get; }
    public CSharpTokenNode LParToken { get; }
    public Expression Condition { get; public set; }
    public CSharpTokenNode RParToken { get; }
    public Statement EmbeddedStatement { get; public set; }
    public WhileStatement(Expression condition, Statement embeddedStatement);
    private static WhileStatement();
    public CSharpTokenNode get_WhileToken();
    public CSharpTokenNode get_LParToken();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public CSharpTokenNode get_RParToken();
    public Statement get_EmbeddedStatement();
    public void set_EmbeddedStatement(Statement value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.WithInitializerExpression : Expression {
    public static TokenRole WithKeywordRole;
    public static Role`1<ArrayInitializerExpression> InitializerRole;
    public Expression Expression { get; public set; }
    public CSharpTokenNode WithToken { get; }
    public ArrayInitializerExpression Initializer { get; public set; }
    private static WithInitializerExpression();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_WithToken();
    public ArrayInitializerExpression get_Initializer();
    public void set_Initializer(ArrayInitializerExpression value);
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.YieldBreakStatement : Statement {
    public static TokenRole YieldKeywordRole;
    public static TokenRole BreakKeywordRole;
    public CSharpTokenNode YieldToken { get; }
    public CSharpTokenNode BreakToken { get; }
    public CSharpTokenNode SemicolonToken { get; }
    private static YieldBreakStatement();
    public CSharpTokenNode get_YieldToken();
    public CSharpTokenNode get_BreakToken();
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Syntax.YieldReturnStatement : Statement {
    public static TokenRole YieldKeywordRole;
    public static TokenRole ReturnKeywordRole;
    public CSharpTokenNode YieldToken { get; }
    public CSharpTokenNode ReturnToken { get; }
    public Expression Expression { get; public set; }
    public CSharpTokenNode SemicolonToken { get; }
    private static YieldReturnStatement();
    public CSharpTokenNode get_YieldToken();
    public CSharpTokenNode get_ReturnToken();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CSharpTokenNode get_SemicolonToken();
    public virtual void AcceptVisitor(IAstVisitor visitor);
    public virtual T AcceptVisitor(IAstVisitor`1<T> visitor);
    public virtual S AcceptVisitor(IAstVisitor`2<T, S> visitor, T data);
    protected internal virtual bool DoMatch(AstNode other, Match match);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.AddCheckedBlocks : object {
    public static object CheckedAnnotation;
    public static object UncheckedAnnotation;
    public static object ExplicitUncheckedAnnotation;
    private static AddCheckedBlocks();
    public sealed virtual void Run(AstNode node, TransformContext context);
    private Result GetResultFromBlock(BlockStatement block);
    private Result GetResult(AstNode node);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.AddXmlDocumentationTransform : object {
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    private static void InsertXmlDocumentation(AstNode node, StringReader r);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.CombineQueryExpressions : object {
    private static InvocationExpression castPattern;
    private static QuerySelectClause selectTransparentIdentifierPattern;
    private static CombineQueryExpressions();
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    private void CombineQueries(AstNode node, Dictionary`2<string, object> fromOrLetIdentifiers);
    private bool TryRemoveTransparentIdentifier(QueryExpression query, QueryFromClause fromClause, QueryExpression innerQuery, Dictionary`2<string, object> letClauses);
    private void RemoveTransparentIdentifierReferences(AstNode node, Dictionary`2<string, object> fromOrLetIdentifiers);
    [CompilerGeneratedAttribute]
internal static void <TryRemoveTransparentIdentifier>g__AddQueryLetClause|4_0(string name, Expression expression, <>c__DisplayClass4_0& );
}
public abstract class ICSharpCode.Decompiler.CSharp.Transforms.ContextTrackingVisitor`1 : DepthFirstAstVisitor`1<TResult> {
    protected ITypeDefinition currentTypeDefinition;
    protected IMethod currentMethod;
    protected void Initialize(TransformContext context);
    protected void Uninitialize();
    public virtual TResult VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public virtual TResult VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public virtual TResult VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public virtual TResult VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public virtual TResult VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration);
    public virtual TResult VisitAccessor(Accessor accessor);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.DecimalConstantTransform : DepthFirstAstVisitor {
    private static PrimitiveType decimalType;
    private static DecimalConstantTransform();
    public virtual void VisitFieldDeclaration(FieldDeclaration fieldDeclaration);
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.DeclareVariables : object {
    private Dictionary`2<ILVariable, VariableToDeclare> variableDict;
    private TransformContext context;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<InsertionPoint, BlockContainer>> scopeTracking;
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    public void Analyze(AstNode rootNode);
    public AstNode GetDeclarationPoint(ILVariable variable);
    public bool WasMerged(ILVariable variable);
    public void ClearAnalysisResults();
    private void EnsureExpressionStatementsAreValid(AstNode rootNode);
    private static bool IsValidInStatementExpression(Expression expr);
    private void FindInsertionPoints(AstNode node, int nodeLevel);
    private static bool IsRelevantScope(BlockContainer scope);
    internal static bool VariableNeedsDeclaration(VariableKind kind);
    private InsertionPoint FindCommonParent(InsertionPoint oldPoint, InsertionPoint newPoint);
    private void ResolveCollisions();
    private void InsertDeconstructionVariableDeclarations();
    private bool IsMatchingAssignment(VariableToDeclare v, AssignmentExpression& assignment);
    private bool CombineDeclarationAndInitializer(VariableToDeclare v, TransformContext context);
    private void InsertVariableDeclarations(TransformContext context);
    private bool CanBeDeclaredAsOutVariable(VariableToDeclare v, DirectionExpression& dirExpr);
    private void UpdateAnnotations(AstNode rootNode);
    [CompilerGeneratedAttribute]
private void <FindInsertionPoints>g__FindInsertionPointForVariable|13_0(ILVariable variable, <>c__DisplayClass13_0& , <>c__DisplayClass13_1& );
}
public class ICSharpCode.Decompiler.CSharp.Transforms.EscapeInvalidIdentifiers : object {
    private bool IsValid(char ch);
    private string ReplaceInvalid(string s);
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    [CompilerGeneratedAttribute]
private string <ReplaceInvalid>b__1_0(char ch);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.FixNameCollisions : object {
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    private string PickNewName(ISet`1<string> memberNames, string name);
}
internal class ICSharpCode.Decompiler.CSharp.Transforms.FlattenSwitchBlocks : object {
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    [CompilerGeneratedAttribute]
internal static bool <Run>g__ContainsLocalDeclaration|0_0(AstNode node);
}
public interface ICSharpCode.Decompiler.CSharp.Transforms.IAstTransform {
    public abstract virtual void Run(AstNode rootNode, TransformContext context);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.IntroduceExtensionMethods : DepthFirstAstVisitor {
    private TransformContext context;
    private CSharpResolver resolver;
    private CSharpConversions conversions;
    private Stack`1<CSharpTypeResolveContext> resolveContextStack;
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    private void InitializeContext(UsingScope usingScope);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public virtual void VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public virtual void VisitInvocationExpression(InvocationExpression invocationExpression);
    private static bool CanTransformToExtensionMethodCall(CSharpResolver resolver, InvocationExpression invocationExpression, MemberReferenceExpression& memberRefExpr, ResolveResult& target, Expression& firstArgument);
    public static bool CanTransformToExtensionMethodCall(CSharpTypeResolveContext resolveContext, InvocationExpression invocationExpression);
    public static bool CanTransformToExtensionMethodCall(CSharpResolver resolver, IMethod method, IReadOnlyList`1<IType> typeArguments, ResolveResult target, ResolveResult[] arguments, String[] argumentNames);
    public static bool CanTransformToExtensionMethodCall(IMethod method, CSharpTypeResolveContext resolveContext, bool ignoreTypeArguments, bool ignoreArgumentNames);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.IntroduceQueryExpressions : object {
    private TransformContext context;
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    private bool IsDegenerateQuery(QueryExpression query);
    private void DecompileQueries(AstNode node);
    private bool CanUseDiscardAssignment();
    private QueryExpression DecompileQuery(InvocationExpression invocation);
    private static bool IsComplexQuery(MemberReferenceExpression mre);
    private QueryFromClause MakeFromClause(ParameterDeclaration parameter, Expression body);
    private bool IsNullConditional(Expression target);
    private Expression WrapExpressionInParenthesesIfNecessary(Expression expression, string parameterName);
    private bool ValidateThenByChain(InvocationExpression invocation, string expectedParameterName);
    private bool MatchSimpleLambda(Expression expr, ParameterDeclaration& parameter, Expression& body);
    private static bool ValidateParameter(ParameterDeclaration p);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.IntroduceUnsafeModifier : DepthFirstAstVisitor`1<bool> {
    public sealed virtual void Run(AstNode compilationUnit, TransformContext context);
    public static bool IsUnsafe(AstNode node);
    protected virtual bool VisitChildren(AstNode node);
    public virtual bool VisitPointerReferenceExpression(PointerReferenceExpression pointerReferenceExpression);
    public virtual bool VisitSizeOfExpression(SizeOfExpression sizeOfExpression);
    public virtual bool VisitComposedType(ComposedType composedType);
    public virtual bool VisitFunctionPointerType(FunctionPointerAstType functionPointerType);
    public virtual bool VisitUnaryOperatorExpression(UnaryOperatorExpression unaryOperatorExpression);
    public virtual bool VisitMemberReferenceExpression(MemberReferenceExpression memberReferenceExpression);
    public virtual bool VisitIdentifierExpression(IdentifierExpression identifierExpression);
    public virtual bool VisitStackAllocExpression(StackAllocExpression stackAllocExpression);
    public virtual bool VisitInvocationExpression(InvocationExpression invocationExpression);
    public virtual bool VisitFixedVariableInitializer(FixedVariableInitializer fixedVariableInitializer);
    private bool HasUnsafeResolveResult(AstNode node);
    private bool IsUnsafeType(IType type);
    [CompilerGeneratedAttribute]
private bool <HasUnsafeResolveResult>b__13_0(IParameter p);
    [CompilerGeneratedAttribute]
private bool <HasUnsafeResolveResult>b__13_1(IParameter p);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.IntroduceUsingDeclarations : object {
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
}
internal class ICSharpCode.Decompiler.CSharp.Transforms.LdTokenPattern : Pattern {
    private AnyNode childNode;
    public LdTokenPattern(string groupName);
    public virtual bool DoMatch(INode other, Match match);
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.CSharp.Transforms.LetIdentifierAnnotation : object {
}
internal class ICSharpCode.Decompiler.CSharp.Transforms.NormalizeBlockStatements : DepthFirstAstVisitor {
    private TransformContext context;
    private bool hasNamespace;
    private NamespaceDeclaration singleNamespaceDeclaration;
    private static PropertyDeclaration CalculatedGetterOnlyPropertyPattern;
    private static IndexerDeclaration CalculatedGetterOnlyIndexerPattern;
    private static Modifiers movableModifiers;
    private static NormalizeBlockStatements();
    public virtual void VisitSyntaxTree(SyntaxTree syntaxTree);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public virtual void VisitIfElseStatement(IfElseStatement ifElseStatement);
    public virtual void VisitWhileStatement(WhileStatement whileStatement);
    public virtual void VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    public virtual void VisitForeachStatement(ForeachStatement foreachStatement);
    public virtual void VisitForStatement(ForStatement forStatement);
    public virtual void VisitFixedStatement(FixedStatement fixedStatement);
    public virtual void VisitLockStatement(LockStatement lockStatement);
    public virtual void VisitUsingStatement(UsingStatement usingStatement);
    private void DoTransform(Statement statement, Statement parent);
    private bool IsElseIf(Statement statement, Statement parent);
    private static void InsertBlock(Statement statement);
    private bool IsAllowedAsEmbeddedStatement(Statement statement, Statement parent);
    private sealed virtual override void ICSharpCode.Decompiler.CSharp.Transforms.IAstTransform.Run(AstNode rootNode, TransformContext context);
    public virtual void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public virtual void VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    private void SimplifyPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    private void SimplifyIndexerDeclaration(IndexerDeclaration indexerDeclaration);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.PatternStatementTransform : ContextTrackingVisitor`1<AstNode> {
    private DeclareVariables declareVariables;
    private TransformContext context;
    private static AstNode variableAssignPattern;
    private static WhileStatement forPattern;
    private static ForStatement forOnArrayPattern;
    private static ForStatement forOnArrayMultiDimPattern;
    private static AstNode variableAssignUpperBoundPattern;
    private static ExpressionStatement variableAssignLowerBoundPattern;
    private static ExpressionStatement foreachVariableOnMultArrayAssignPattern;
    private static PropertyDeclaration automaticPropertyPattern;
    private static PropertyDeclaration automaticReadonlyPropertyPattern;
    private static Regex automaticPropertyBackingFieldNameRegex;
    private static Expression fieldReferencePattern;
    private static Accessor automaticEventPatternV2;
    private static Accessor automaticEventPatternV4;
    private static Accessor automaticEventPatternV4AggressivelyInlined;
    private static Accessor automaticEventPatternV4MCS;
    private static String[] attributeTypesToRemoveFromAutoEvents;
    internal static String[] attributeTypesToRemoveFromAutoProperties;
    private static BlockStatement destructorBodyPattern;
    private static MethodDeclaration destructorPattern;
    private static TryCatchStatement tryCatchFinallyPattern;
    private static IfElseStatement cascadingIfElsePattern;
    private static Expression addressOfPinnableReference;
    private static PatternStatementTransform();
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
    protected virtual AstNode VisitChildren(AstNode node);
    public virtual AstNode VisitExpressionStatement(ExpressionStatement expressionStatement);
    public virtual AstNode VisitForStatement(ForStatement forStatement);
    public virtual AstNode VisitIfElseStatement(IfElseStatement ifElseStatement);
    public virtual AstNode VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public virtual AstNode VisitCustomEventDeclaration(CustomEventDeclaration eventDeclaration);
    public virtual AstNode VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public virtual AstNode VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public virtual AstNode VisitTryCatchStatement(TryCatchStatement tryCatchStatement);
    public ForStatement TransformFor(ExpressionStatement node);
    private bool DescendIntoStatement(AstNode node);
    private bool ForStatementUsesVariable(ForStatement statement, ILVariable variable);
    private bool IteratorVariablesDeclaredInsideLoopBody(Statement iteratorStatement);
    private bool VariableCanBeUsedAsForeachLocal(ILVariable itemVar, Statement loop);
    private static bool AddressUsedForSingleCall(ILVariable v, BlockContainer loop);
    private Statement TransformForeachOnArray(ForStatement forStatement);
    private bool MatchLowerBound(int indexNum, ILVariable& index, ILVariable collection, Statement statement);
    private bool MatchForeachOnMultiDimArray(ILVariable[] upperBounds, ILVariable collection, Statement firstInitializerStatement, IdentifierExpression& foreachVariable, IList`1& statements, ILVariable[]& lowerBounds);
    private Statement TransformForeachOnMultiDimArray(ExpressionStatement expressionStatement);
    private bool CanTransformToAutomaticProperty(IProperty property, bool accessorsMustBeCompilerGenerated);
    private PropertyDeclaration TransformAutomaticProperty(PropertyDeclaration propertyDeclaration);
    private void RemoveCompilerGeneratedAttribute(AstNodeCollection`1<AttributeSection> attributeSections);
    private void RemoveCompilerGeneratedAttribute(AstNodeCollection`1<AttributeSection> attributeSections, String[] attributesToRemove);
    public virtual AstNode VisitIdentifier(Identifier identifier);
    internal static bool IsBackingFieldOfAutomaticProperty(IField field, IProperty& property);
    private static bool NameCouldBeBackingFieldOfAutomaticProperty(string name, String& propertyName);
    private Identifier ReplaceBackingFieldUsage(Identifier identifier);
    private Identifier ReplaceEventFieldAnnotation(Identifier identifier);
    private bool CheckAutomaticEventMatch(Match m, CustomEventDeclaration ev, bool isAddAccessor);
    private bool CheckAutomaticEventV4(CustomEventDeclaration ev);
    private bool CheckAutomaticEventV4AggressivelyInlined(CustomEventDeclaration ev);
    private bool CheckAutomaticEventV2(CustomEventDeclaration ev);
    private bool CheckAutomaticEventV4MCS(CustomEventDeclaration ev);
    private EventDeclaration TransformAutomaticEvents(CustomEventDeclaration ev);
    private DestructorDeclaration TransformDestructor(MethodDeclaration methodDef);
    private DestructorDeclaration TransformDestructorBody(DestructorDeclaration dtorDef);
    private TryCatchStatement TransformTryCatchFinally(TryCatchStatement tryFinally);
    private AstNode SimplifyCascadingIfElseStatements(IfElseStatement node);
    public virtual AstNode VisitBinaryOperatorExpression(BinaryOperatorExpression expr);
    public virtual AstNode VisitFixedStatement(FixedStatement fixedStatement);
    public virtual AstNode VisitUsingStatement(UsingStatement usingStatement);
}
internal class ICSharpCode.Decompiler.CSharp.Transforms.PrettifyAssignments : DepthFirstAstVisitor {
    private TransformContext context;
    public virtual void VisitAssignmentExpression(AssignmentExpression assignment);
    public static AssignmentOperatorType GetAssignmentOperatorForBinaryOperator(BinaryOperatorType bop);
    private static bool CanConvertToCompoundAssignment(Expression left);
    private static bool IsWithoutSideEffects(Expression left);
    private sealed virtual override void ICSharpCode.Decompiler.CSharp.Transforms.IAstTransform.Run(AstNode node, TransformContext context);
    [CompilerGeneratedAttribute]
private bool <VisitAssignmentExpression>g__IsImplicitlyConvertible|1_0(Expression rhs, IType expectedType);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.RemoveCLSCompliantAttribute : object {
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.RemoveCompilerGeneratedAssemblyAttributes : object {
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.RemoveEmbeddedAttributes : DepthFirstAstVisitor {
    internal static HashSet`1<string> attributeNames;
    private static RemoveEmbeddedAttributes();
    public virtual void VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    public sealed virtual void Run(AstNode rootNode, TransformContext context);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.ReplaceMethodCallsWithOperators : DepthFirstAstVisitor {
    private static MemberReferenceExpression typeHandleOnTypeOfPattern;
    private TransformContext context;
    private static Pattern ToStringCallPattern;
    private static Expression getMethodOrConstructorFromHandlePattern;
    private static ReplaceMethodCallsWithOperators();
    public virtual void VisitInvocationExpression(InvocationExpression invocationExpression);
    private void ProcessInvocationExpression(InvocationExpression invocationExpression);
    internal static bool HasCheckedEquivalent(IMethod method);
    private bool IsInstantiableTypeParameter(IType type);
    private bool CheckArgumentsForStringConcat(Expression[] arguments);
    private bool IsStringConcat(IParameterizedMember member);
    internal static Expression RemoveRedundantToStringInConcat(Expression expr, IMethod concatMethod, bool isLastArgument);
    private static bool ToStringIsKnownEffectFree(IType type);
    private static Nullable`1<BinaryOperatorType> GetBinaryOperatorTypeFromMetadataName(string name, Boolean& isChecked, DecompilerSettings settings);
    private static Nullable`1<UnaryOperatorType> GetUnaryOperatorTypeFromMetadataName(string name, Boolean& isChecked, DecompilerSettings settings);
    public virtual void VisitCastExpression(CastExpression castExpression);
    private sealed virtual override void ICSharpCode.Decompiler.CSharp.Transforms.IAstTransform.Run(AstNode rootNode, TransformContext context);
    [CompilerGeneratedAttribute]
internal static bool <RemoveRedundantToStringInConcat>g__IsStringParameter|9_0(IParameter p);
    [CompilerGeneratedAttribute]
private TypeReferenceExpression <VisitCastExpression>b__14_0(IParameter p);
}
public class ICSharpCode.Decompiler.CSharp.Transforms.TransformContext : object {
    public IDecompilerTypeSystem TypeSystem;
    public CancellationToken CancellationToken;
    public TypeSystemAstBuilder TypeSystemAstBuilder;
    public DecompilerSettings Settings;
    internal DecompileRun DecompileRun;
    private ITypeResolveContext decompilationContext;
    public IMember CurrentMember { get; }
    public ITypeDefinition CurrentTypeDefinition { get; }
    public IModule CurrentModule { get; }
    public IImmutableSet`1<string> RequiredNamespacesSuperset { get; }
    internal TransformContext(IDecompilerTypeSystem typeSystem, DecompileRun decompileRun, ITypeResolveContext decompilationContext, TypeSystemAstBuilder typeSystemAstBuilder);
    public IMember get_CurrentMember();
    public ITypeDefinition get_CurrentTypeDefinition();
    public IModule get_CurrentModule();
    public IImmutableSet`1<string> get_RequiredNamespacesSuperset();
}
public class ICSharpCode.Decompiler.CSharp.Transforms.TransformFieldAndConstructorInitializers : DepthFirstAstVisitor {
    private TransformContext context;
    private static ExpressionStatement fieldInitializerPattern;
    private static AstNode thisCallPattern;
    private static TransformFieldAndConstructorInitializers();
    public sealed virtual void Run(AstNode node, TransformContext context);
    public virtual void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public virtual void VisitTypeDeclaration(TypeDeclaration typeDeclaration);
    private void HandleInstanceFieldInitializers(IEnumerable`1<AstNode> members);
    private bool IsPropertyDeclaredByPrimaryCtor(IProperty p, RecordDecompiler record);
    private void RemoveSingleEmptyConstructor(IEnumerable`1<AstNode> members, ITypeDefinition contextTypeDefinition);
    private void HandleStaticFieldInitializers(IEnumerable`1<AstNode> members);
    private bool TryEvaluateDecimalConstant(ResolveResult expression, Decimal& value);
}
internal class ICSharpCode.Decompiler.CSharp.Transforms.TypeOfPattern : Pattern {
    private INode childNode;
    public TypeOfPattern(string groupName);
    public virtual bool DoMatch(INode other, Match match);
    public virtual string ToString();
}
internal class ICSharpCode.Decompiler.CSharp.Transforms.TypePattern : Pattern {
    private string ns;
    private string name;
    public TypePattern(Type type);
    public virtual bool DoMatch(INode other, Match match);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{Expression} : {ResolveResult}")]
internal class ICSharpCode.Decompiler.CSharp.TranslatedExpression : ValueType {
    public Expression Expression;
    public ResolveResult ResolveResult;
    public IEnumerable`1<ILInstruction> ILInstructions { get; }
    public IType Type { get; }
    internal TranslatedExpression(Expression expression);
    internal TranslatedExpression(Expression expression, ResolveResult resolveResult);
    public IEnumerable`1<ILInstruction> get_ILInstructions();
    public IType get_Type();
    public static Expression op_Implicit(TranslatedExpression expression);
    public static ExpressionWithResolveResult op_Implicit(TranslatedExpression expression);
    public static ExpressionWithILInstruction op_Implicit(TranslatedExpression expression);
    public TranslatedExpression UnwrapChild(Expression descendant);
    public TranslatedExpression ConvertTo(IType targetType, ExpressionBuilder expressionBuilder, bool checkForOverflow, bool allowImplicitConversion);
    private bool IsFixedVariable();
    private bool CastCanBeMadeImplicit(CSharpConversions conversions, Conversion conversion, IType inputType, IType oldTargetType, IType newTargetType);
    private TranslatedExpression LdcI4(ICompilation compilation, int val);
    public TranslatedExpression UnwrapImplicitBoolConversion(Func`2<IType, bool> typeFilter);
    public TranslatedExpression ConvertToBoolean(ExpressionBuilder expressionBuilder, bool negate);
}
[DebuggerDisplayAttribute("{Statement}")]
internal class ICSharpCode.Decompiler.CSharp.TranslatedStatement : ValueType {
    public Statement Statement;
    public IEnumerable`1<ILInstruction> ILInstructions { get; }
    internal TranslatedStatement(Statement statement);
    public IEnumerable`1<ILInstruction> get_ILInstructions();
    public static Statement op_Implicit(TranslatedStatement statement);
}
public class ICSharpCode.Decompiler.CSharp.TranslationContext : ValueType {
    public IType TypeHint;
}
public class ICSharpCode.Decompiler.CSharp.TypeSystem.AliasNamespaceReference : TypeOrNamespaceReference {
    private string identifier;
    public string Identifier { get; }
    public AliasNamespaceReference(string identifier);
    public string get_Identifier();
    public virtual ResolveResult Resolve(CSharpResolver resolver);
    public virtual IType ResolveType(CSharpResolver resolver);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public class ICSharpCode.Decompiler.CSharp.TypeSystem.CSharpTypeResolveContext : object {
    private IModule module;
    private ResolvedUsingScope currentUsingScope;
    private ITypeDefinition currentTypeDefinition;
    private IMember currentMember;
    private String[] methodTypeParameterNames;
    public ResolvedUsingScope CurrentUsingScope { get; }
    public ICompilation Compilation { get; }
    public IModule CurrentModule { get; }
    public ITypeDefinition CurrentTypeDefinition { get; }
    public IMember CurrentMember { get; }
    public CSharpTypeResolveContext(IModule module, ResolvedUsingScope usingScope, ITypeDefinition typeDefinition, IMember member);
    private CSharpTypeResolveContext(IModule module, ResolvedUsingScope usingScope, ITypeDefinition typeDefinition, IMember member, String[] methodTypeParameterNames);
    public ResolvedUsingScope get_CurrentUsingScope();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual IModule get_CurrentModule();
    public sealed virtual ITypeDefinition get_CurrentTypeDefinition();
    public sealed virtual IMember get_CurrentMember();
    public CSharpTypeResolveContext WithCurrentTypeDefinition(ITypeDefinition typeDefinition);
    private sealed virtual override ITypeResolveContext ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.WithCurrentTypeDefinition(ITypeDefinition typeDefinition);
    public CSharpTypeResolveContext WithCurrentMember(IMember member);
    private sealed virtual override ITypeResolveContext ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext.WithCurrentMember(IMember member);
    public CSharpTypeResolveContext WithUsingScope(ResolvedUsingScope usingScope);
}
public class ICSharpCode.Decompiler.CSharp.TypeSystem.MemberTypeOrNamespaceReference : TypeOrNamespaceReference {
    private TypeOrNamespaceReference target;
    private string identifier;
    private IList`1<ITypeReference> typeArguments;
    private NameLookupMode lookupMode;
    public string Identifier { get; }
    public TypeOrNamespaceReference Target { get; }
    public IList`1<ITypeReference> TypeArguments { get; }
    public NameLookupMode LookupMode { get; }
    public MemberTypeOrNamespaceReference(TypeOrNamespaceReference target, string identifier, IList`1<ITypeReference> typeArguments, NameLookupMode lookupMode);
    public string get_Identifier();
    public TypeOrNamespaceReference get_Target();
    public IList`1<ITypeReference> get_TypeArguments();
    public NameLookupMode get_LookupMode();
    public MemberTypeOrNamespaceReference AddSuffix(string suffix);
    public virtual ResolveResult Resolve(CSharpResolver resolver);
    public virtual IType ResolveType(CSharpResolver resolver);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public class ICSharpCode.Decompiler.CSharp.TypeSystem.ResolvedUsingScope : object {
    private CSharpTypeResolveContext parentContext;
    private UsingScope usingScope;
    internal ConcurrentDictionary`2<string, ResolveResult> ResolveCache;
    internal List`1<List`1<IMethod>> AllExtensionMethods;
    private INamespace namespace;
    private IList`1<INamespace> usings;
    private IList`1<KeyValuePair`2<string, ResolveResult>> usingAliases;
    public UsingScope UnresolvedUsingScope { get; }
    public INamespace Namespace { get; }
    public ResolvedUsingScope Parent { get; }
    public IList`1<INamespace> Usings { get; }
    public IList`1<KeyValuePair`2<string, ResolveResult>> UsingAliases { get; }
    public IList`1<string> ExternAliases { get; }
    public ResolvedUsingScope(CSharpTypeResolveContext context, UsingScope usingScope);
    public UsingScope get_UnresolvedUsingScope();
    public INamespace get_Namespace();
    public ResolvedUsingScope get_Parent();
    public IList`1<INamespace> get_Usings();
    public IList`1<KeyValuePair`2<string, ResolveResult>> get_UsingAliases();
    public IList`1<string> get_ExternAliases();
    public bool HasAlias(string identifier);
}
public class ICSharpCode.Decompiler.CSharp.TypeSystem.SimpleTypeOrNamespaceReference : TypeOrNamespaceReference {
    private string identifier;
    private IList`1<ITypeReference> typeArguments;
    private NameLookupMode lookupMode;
    public string Identifier { get; }
    public IList`1<ITypeReference> TypeArguments { get; }
    public NameLookupMode LookupMode { get; }
    public SimpleTypeOrNamespaceReference(string identifier, IList`1<ITypeReference> typeArguments, NameLookupMode lookupMode);
    public string get_Identifier();
    public IList`1<ITypeReference> get_TypeArguments();
    public NameLookupMode get_LookupMode();
    public SimpleTypeOrNamespaceReference AddSuffix(string suffix);
    public virtual ResolveResult Resolve(CSharpResolver resolver);
    public virtual IType ResolveType(CSharpResolver resolver);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public abstract class ICSharpCode.Decompiler.CSharp.TypeSystem.TypeOrNamespaceReference : object {
    public abstract virtual ResolveResult Resolve(CSharpResolver resolver);
    public abstract virtual IType ResolveType(CSharpResolver resolver);
    public INamespace ResolveNamespace(CSharpResolver resolver);
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.ITypeReference.Resolve(ITypeResolveContext context);
}
public class ICSharpCode.Decompiler.CSharp.TypeSystem.UsingScope : AbstractFreezable {
    private UsingScope parent;
    private string shortName;
    private IList`1<TypeOrNamespaceReference> usings;
    private IList`1<KeyValuePair`2<string, TypeOrNamespaceReference>> usingAliases;
    private IList`1<string> externAliases;
    public UsingScope Parent { get; }
    public string ShortNamespaceName { get; }
    public string NamespaceName { get; }
    public IList`1<TypeOrNamespaceReference> Usings { get; }
    public IList`1<KeyValuePair`2<string, TypeOrNamespaceReference>> UsingAliases { get; }
    public IList`1<string> ExternAliases { get; }
    public UsingScope(UsingScope parent, string shortName);
    protected virtual void FreezeInternal();
    public UsingScope get_Parent();
    public string get_ShortNamespaceName();
    public string get_NamespaceName();
    public IList`1<TypeOrNamespaceReference> get_Usings();
    public IList`1<KeyValuePair`2<string, TypeOrNamespaceReference>> get_UsingAliases();
    public IList`1<string> get_ExternAliases();
    public bool HasAlias(string identifier);
    public ResolvedUsingScope Resolve(ICompilation compilation);
}
public class ICSharpCode.Decompiler.CSharp.UseImplicitlyTypedOutAnnotation : object {
    public static UseImplicitlyTypedOutAnnotation Instance;
    private static UseImplicitlyTypedOutAnnotation();
}
[IsReadOnlyAttribute]
public class ICSharpCode.Decompiler.DebugInfo.AsyncDebugInfo : ValueType {
    public int CatchHandlerOffset;
    public ImmutableArray`1<Await> Awaits;
    public AsyncDebugInfo(int catchHandlerOffset, ImmutableArray`1<Await> awaits);
    public BlobBuilder BuildBlob(MethodDefinitionHandle moveNext);
}
internal class ICSharpCode.Decompiler.DebugInfo.DebugInfoGenerator : DepthFirstAstVisitor {
    private static KeyComparer`2<ILVariable, int> ILVariableKeyComparer;
    private IDecompilerTypeSystem typeSystem;
    private ImportScopeInfo globalImportScope;
    private ImportScopeInfo currentImportScope;
    private List`1<ImportScopeInfo> importScopes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`5<MethodDefinitionHandle, ImportScopeInfo, int, int, HashSet`1<ILVariable>>> <LocalScopes>k__BackingField;
    private List`1<ILFunction> functions;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<ValueTuple`5<MethodDefinitionHandle, ImportScopeInfo, int, int, HashSet`1<ILVariable>>> LocalScopes { get; }
    public IReadOnlyList`1<ILFunction> Functions { get; }
    public DebugInfoGenerator(IDecompilerTypeSystem typeSystem);
    private static DebugInfoGenerator();
    [CompilerGeneratedAttribute]
internal List`1<ValueTuple`5<MethodDefinitionHandle, ImportScopeInfo, int, int, HashSet`1<ILVariable>>> get_LocalScopes();
    public IReadOnlyList`1<ILFunction> get_Functions();
    public void GenerateImportScopes(MetadataBuilder metadata, ImportScopeHandle globalImportScope);
    private static BlobHandle EncodeImports(MetadataBuilder metadata, ImportScopeInfo scope);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclaration namespaceDeclaration);
    public virtual void VisitUsingDeclaration(UsingDeclaration usingDeclaration);
    public virtual void VisitMethodDeclaration(MethodDeclaration methodDeclaration);
    public virtual void VisitAccessor(Accessor accessor);
    public virtual void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration);
    public virtual void VisitDestructorDeclaration(DestructorDeclaration destructorDeclaration);
    public virtual void VisitOperatorDeclaration(OperatorDeclaration operatorDeclaration);
    public virtual void VisitLambdaExpression(LambdaExpression lambdaExpression);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpression anonymousMethodExpression);
    public virtual void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration);
    public virtual void VisitIndexerDeclaration(IndexerDeclaration indexerDeclaration);
    public virtual void VisitQueryFromClause(QueryFromClause queryFromClause);
    public virtual void VisitQueryGroupClause(QueryGroupClause queryGroupClause);
    public virtual void VisitQueryJoinClause(QueryJoinClause queryJoinClause);
    public virtual void VisitQueryLetClause(QueryLetClause queryLetClause);
    public virtual void VisitQueryOrdering(QueryOrdering queryOrdering);
    public virtual void VisitQuerySelectClause(QuerySelectClause querySelectClause);
    public virtual void VisitQueryWhereClause(QueryWhereClause queryWhereClause);
    private void HandleMethod(AstNode node);
    private void HandleMethod(AstNode node, ILFunction function);
    private void HandleMethodBody(ILFunction function, MethodBodyBlock methodBody);
}
public interface ICSharpCode.Decompiler.DebugInfo.IDebugInfoProvider {
    public string Description { get; }
    public string SourceFileName { get; }
    public abstract virtual string get_Description();
    public abstract virtual IList`1<SequencePoint> GetSequencePoints(MethodDefinitionHandle method);
    public abstract virtual IList`1<Variable> GetVariables(MethodDefinitionHandle method);
    public abstract virtual bool TryGetName(MethodDefinitionHandle method, int index, String& name);
    public abstract virtual string get_SourceFileName();
}
internal class ICSharpCode.Decompiler.DebugInfo.ImportScopeInfo : object {
    public ImportScopeInfo Parent;
    public ImportScopeHandle Handle;
    public HashSet`1<string> Imports;
    public ImportScopeInfo(ImportScopeInfo parent);
}
public static class ICSharpCode.Decompiler.DebugInfo.KnownGuids : object {
    public static Guid CSharpLanguageGuid;
    public static Guid VBLanguageGuid;
    public static Guid FSharpLanguageGuid;
    public static Guid StateMachineHoistedLocalScopes;
    public static Guid DynamicLocalVariables;
    public static Guid DefaultNamespaces;
    public static Guid EditAndContinueLocalSlotMap;
    public static Guid EditAndContinueLambdaAndClosureMap;
    public static Guid EncStateMachineStateMap;
    public static Guid EmbeddedSource;
    public static Guid SourceLink;
    public static Guid MethodSteppingInformation;
    public static Guid CompilationOptions;
    public static Guid CompilationMetadataReferences;
    public static Guid TupleElementNames;
    public static Guid TypeDefinitionDocuments;
    public static Guid HashAlgorithmSHA1;
    public static Guid HashAlgorithmSHA256;
    private static KnownGuids();
}
public class ICSharpCode.Decompiler.DebugInfo.PortablePdbWriter : object {
    private static FileVersionInfo decompilerVersion;
    private static PortablePdbWriter();
    public static bool HasCodeViewDebugDirectoryEntry(PEFile file);
    private static bool IncludeTypeWhenGeneratingPdb(PEFile module, TypeDefinitionHandle type, DecompilerSettings settings);
    public static void WritePdb(PEFile file, CSharpDecompiler decompiler, DecompilerSettings settings, Stream targetStream, bool noLogo, Nullable`1<BlobContentId> pdbId, IProgress`1<DecompilationProgress> progress);
    private static BlobBuilder BuildStateMachineHoistedLocalScopes(ILFunction function);
    private static BlobHandle WriteSourceToBlob(MetadataBuilder metadata, string sourceText, Byte[]& sourceCheckSum);
    private static BlobHandle EncodeSequencePoints(MetadataBuilder metadata, int localSignatureRowId, List`1<SequencePoint> sequencePoints);
    private static ImmutableArray`1<int> GetRowCounts(MetadataReader reader);
    private static string SyntaxTreeToString(SyntaxTree syntaxTree, DecompilerSettings settings);
}
[DebuggerDisplayAttribute("SequencePoint IL_{Offset,h}-IL_{EndOffset,h}, {StartLine}:{StartColumn}-{EndLine}:{EndColumn}, IsHidden={IsHidden}")]
public class ICSharpCode.Decompiler.DebugInfo.SequencePoint : object {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentUrl>k__BackingField;
    public int Offset { get; public set; }
    public int EndOffset { get; public set; }
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public bool IsHidden { get; }
    public string DocumentUrl { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_EndOffset();
    [CompilerGeneratedAttribute]
public void set_EndOffset(int value);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public void set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public void set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(int value);
    public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public string get_DocumentUrl();
    [CompilerGeneratedAttribute]
public void set_DocumentUrl(string value);
    internal void SetHidden();
}
public class ICSharpCode.Decompiler.DebugInfo.Variable : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public int Index { get; }
    public string Name { get; }
    public Variable(int index, string name);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.DecompilationProgress : ValueType {
    public int TotalUnits;
    public int UnitsCompleted;
    public string Status;
    public string Title;
}
public class ICSharpCode.Decompiler.DecompilerException : Exception {
    [CompilerGeneratedAttribute]
private IEntity <DecompiledEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private IModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private PEFile <File>k__BackingField;
    public string AssemblyName { get; }
    public string FileName { get; }
    public IEntity DecompiledEntity { get; }
    public IModule Module { get; }
    public PEFile File { get; }
    public string StackTrace { get; }
    public DecompilerException(MetadataModule module, IEntity decompiledEntity, Exception innerException, string message);
    public DecompilerException(PEFile file, string message, Exception innerException);
    protected DecompilerException(SerializationInfo info, StreamingContext context);
    public string get_AssemblyName();
    public string get_FileName();
    [CompilerGeneratedAttribute]
public IEntity get_DecompiledEntity();
    [CompilerGeneratedAttribute]
public IModule get_Module();
    [CompilerGeneratedAttribute]
public PEFile get_File();
    private static string GetDefaultMessage(IEntity entity);
    public virtual string get_StackTrace();
    public virtual string ToString();
    private string ToString(Exception exception);
    private static string GetTypeName(Exception exception);
    private static string GetStackTrace(Exception exception);
}
public class ICSharpCode.Decompiler.DecompilerSettings : object {
    private bool nativeIntegers;
    private bool numericIntPtr;
    private bool covariantReturns;
    private bool initAccessors;
    private bool recordClasses;
    private bool recordStructs;
    private bool withExpressions;
    private bool usePrimaryConstructorSyntax;
    private bool functionPointers;
    private bool scopedRef;
    private bool requiredMembers;
    private bool switchExpressions;
    private bool fileScopedNamespaces;
    private bool parameterNullCheck;
    private bool anonymousMethods;
    private bool anonymousTypes;
    private bool useLambdaSyntax;
    private bool expressionTrees;
    private bool yieldReturn;
    private bool dynamic;
    private bool asyncAwait;
    private bool awaitInCatchFinally;
    private bool asyncEnumerator;
    private bool decimalConstants;
    private bool fixedBuffers;
    private bool stringConcat;
    private bool liftNullables;
    private bool nullPropagation;
    private bool automaticProperties;
    private bool getterOnlyAutomaticProperties;
    private bool automaticEvents;
    private bool usingStatement;
    private bool useEnhancedUsing;
    private bool alwaysUseBraces;
    private bool forEachStatement;
    private bool forEachWithGetEnumeratorExtension;
    private bool lockStatement;
    private bool switchStatementOnString;
    private bool sparseIntegerSwitch;
    private bool usingDeclarations;
    private bool extensionMethods;
    private bool queryExpressions;
    private bool useImplicitMethodGroupConversion;
    private bool alwaysCastTargetsOfExplicitInterfaceImplementationCalls;
    private bool alwaysQualifyMemberReferences;
    private bool alwaysShowEnumMemberValues;
    private bool useDebugSymbols;
    private bool arrayInitializers;
    private bool objectCollectionInitializers;
    private bool dictionaryInitializers;
    private bool extensionMethodsInCollectionInitializers;
    private bool useRefLocalsForAccurateOrderOfEvaluation;
    private bool refExtensionMethods;
    private bool stringInterpolation;
    private bool utf8StringLiterals;
    private bool unsignedRightShift;
    private bool checkedOperators;
    private bool showXmlDocumentation;
    private bool foldBraces;
    private bool expandMemberDefinitions;
    private bool expandUsingDeclarations;
    private bool decompileMemberBodies;
    private bool useExpressionBodyForCalculatedGetterOnlyProperties;
    private bool outVariables;
    private bool discards;
    private bool introduceRefModifiersOnStructs;
    private bool introduceReadonlyAndInModifiers;
    private bool readOnlyMethods;
    private bool asyncUsingAndForEachStatement;
    private bool introduceUnmanagedConstraint;
    private bool stackAllocInitializers;
    private bool patternBasedFixedStatement;
    private bool tupleTypes;
    private bool throwExpressions;
    private bool tupleConversions;
    private bool tupleComparisons;
    private bool namedArguments;
    private bool nonTrailingNamedArguments;
    private bool optionalArguments;
    private bool localFunctions;
    private bool deconstruction;
    private bool patternMatching;
    private bool staticLocalFunctions;
    private bool ranges;
    private bool nullableReferenceTypes;
    private bool showDebugInfo;
    private bool assumeArrayLengthFitsIntoInt32;
    private bool introduceIncrementAndDecrement;
    private bool makeAssignmentExpressions;
    private bool removeDeadCode;
    private bool removeDeadStores;
    private bool loadInMemory;
    private bool throwOnAssemblyResolveErrors;
    private bool applyWindowsRuntimeProjections;
    private bool forStatement;
    private bool doWhileStatement;
    private bool separateLocalVariableDeclarations;
    private bool useSdkStyleProjectFormat;
    private bool useNestedDirectoriesForNamespaces;
    private bool aggressiveScalarReplacementOfAggregates;
    private bool aggressiveInlining;
    private bool alwaysUseGlobal;
    private CSharpFormattingOptions csharpFormattingOptions;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.NativeIntegers")]
public bool NativeIntegers { get; public set; }
    [CategoryAttribute("C# 11.0 / VS 2022.4")]
[DescriptionAttribute("DecompilerSettings.NumericIntPtr")]
public bool NumericIntPtr { get; public set; }
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.CovariantReturns")]
public bool CovariantReturns { get; public set; }
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.InitAccessors")]
public bool InitAccessors { get; public set; }
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.RecordClasses")]
public bool RecordClasses { get; public set; }
    [CategoryAttribute("C# 10.0 / VS 2022")]
[DescriptionAttribute("DecompilerSettings.RecordStructs")]
public bool RecordStructs { get; public set; }
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.WithExpressions")]
public bool WithExpressions { get; public set; }
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.UsePrimaryConstructorSyntax")]
public bool UsePrimaryConstructorSyntax { get; public set; }
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.FunctionPointers")]
public bool FunctionPointers { get; public set; }
    [CategoryAttribute("C# 11.0 / VS 2022.4")]
[DescriptionAttribute("DecompilerSettings.ScopedRef")]
public bool ScopedRef { get; public set; }
    [ObsoleteAttribute("Renamed to ScopedRef. This property will be removed in a future version of the decompiler.")]
[BrowsableAttribute("False")]
public bool LifetimeAnnotations { get; public set; }
    [CategoryAttribute("C# 11.0 / VS 2022.4")]
[DescriptionAttribute("DecompilerSettings.RequiredMembers")]
public bool RequiredMembers { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.SwitchExpressions")]
public bool SwitchExpressions { get; public set; }
    [CategoryAttribute("C# 10.0 / VS 2022")]
[DescriptionAttribute("DecompilerSettings.FileScopedNamespaces")]
public bool FileScopedNamespaces { get; public set; }
    [CategoryAttribute("C# 11.0 / VS 2022.4")]
[DescriptionAttribute("DecompilerSettings.ParameterNullCheck")]
[BrowsableAttribute("False")]
[ObsoleteAttribute("This feature did not make it into C# 11, and may be removed in a future version of the decompiler.")]
public bool ParameterNullCheck { get; public set; }
    [CategoryAttribute("C# 2.0 / VS 2005")]
[DescriptionAttribute("DecompilerSettings.DecompileAnonymousMethodsLambdas")]
public bool AnonymousMethods { get; public set; }
    [CategoryAttribute("C# 3.0 / VS 2008")]
[DescriptionAttribute("DecompilerSettings.DecompileAnonymousTypes")]
public bool AnonymousTypes { get; public set; }
    [CategoryAttribute("C# 3.0 / VS 2008")]
[DescriptionAttribute("DecompilerSettings.UseLambdaSyntaxIfPossible")]
public bool UseLambdaSyntax { get; public set; }
    [CategoryAttribute("C# 3.0 / VS 2008")]
[DescriptionAttribute("DecompilerSettings.DecompileExpressionTrees")]
public bool ExpressionTrees { get; public set; }
    [CategoryAttribute("C# 2.0 / VS 2005")]
[DescriptionAttribute("DecompilerSettings.DecompileEnumeratorsYieldReturn")]
public bool YieldReturn { get; public set; }
    [CategoryAttribute("C# 4.0 / VS 2010")]
[DescriptionAttribute("DecompilerSettings.DecompileUseOfTheDynamicType")]
public bool Dynamic { get; public set; }
    [CategoryAttribute("C# 5.0 / VS 2012")]
[DescriptionAttribute("DecompilerSettings.DecompileAsyncMethods")]
public bool AsyncAwait { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.DecompileAwaitInCatchFinallyBlocks")]
public bool AwaitInCatchFinally { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.AsyncEnumerator")]
public bool AsyncEnumerator { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DecompileDecimalConstantAsSimpleLiteralValues")]
public bool DecimalConstants { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DecompileC10PublicUnsafeFixedIntArr10Members")]
public bool FixedBuffers { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.StringConcat")]
public bool StringConcat { get; public set; }
    [CategoryAttribute("C# 2.0 / VS 2005")]
[DescriptionAttribute("DecompilerSettings.UseLiftedOperatorsForNullables")]
public bool LiftNullables { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.NullPropagation")]
public bool NullPropagation { get; public set; }
    [CategoryAttribute("C# 3.0 / VS 2008")]
[DescriptionAttribute("DecompilerSettings.DecompileAutomaticProperties")]
public bool AutomaticProperties { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.GetterOnlyAutomaticProperties")]
public bool GetterOnlyAutomaticProperties { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DecompileAutomaticEvents")]
public bool AutomaticEvents { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DetectUsingStatements")]
public bool UsingStatement { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.UseEnhancedUsing")]
public bool UseEnhancedUsing { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.AlwaysUseBraces")]
public bool AlwaysUseBraces { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DetectForeachStatements")]
public bool ForEachStatement { get; public set; }
    [CategoryAttribute("C# 9.0 / VS 2019.8")]
[DescriptionAttribute("DecompilerSettings.DecompileForEachWithGetEnumeratorExtension")]
public bool ForEachWithGetEnumeratorExtension { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DetectLockStatements")]
public bool LockStatement { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DetectSwitchOnString")]
public bool SwitchStatementOnString { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.SparseIntegerSwitch")]
public bool SparseIntegerSwitch { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.InsertUsingDeclarations")]
public bool UsingDeclarations { get; public set; }
    [CategoryAttribute("C# 3.0 / VS 2008")]
[DescriptionAttribute("DecompilerSettings.UseExtensionMethodSyntax")]
public bool ExtensionMethods { get; public set; }
    [CategoryAttribute("C# 3.0 / VS 2008")]
[DescriptionAttribute("DecompilerSettings.UseLINQExpressionSyntax")]
public bool QueryExpressions { get; public set; }
    [CategoryAttribute("C# 2.0 / VS 2005")]
[DescriptionAttribute("DecompilerSettings.UseImplicitMethodGroupConversions")]
public bool UseImplicitMethodGroupConversion { get; public set; }
    [CategoryAttribute("Other")]
[DescriptionAttribute("DecompilerSettings.AlwaysCastTargetsOfExplicitInterfaceImplementationCalls")]
public bool AlwaysCastTargetsOfExplicitInterfaceImplementationCalls { get; public set; }
    [CategoryAttribute("Other")]
[DescriptionAttribute("DecompilerSettings.AlwaysQualifyMemberReferences")]
public bool AlwaysQualifyMemberReferences { get; public set; }
    [CategoryAttribute("Other")]
[DescriptionAttribute("DecompilerSettings.AlwaysShowEnumMemberValues")]
public bool AlwaysShowEnumMemberValues { get; public set; }
    [CategoryAttribute("Other")]
[DescriptionAttribute("DecompilerSettings.UseVariableNamesFromDebugSymbolsIfAvailable")]
public bool UseDebugSymbols { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.ArrayInitializerExpressions")]
public bool ArrayInitializers { get; public set; }
    [CategoryAttribute("C# 3.0 / VS 2008")]
[DescriptionAttribute("DecompilerSettings.ObjectCollectionInitializerExpressions")]
public bool ObjectOrCollectionInitializers { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.DictionaryInitializerExpressions")]
public bool DictionaryInitializers { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.AllowExtensionAddMethodsInCollectionInitializerExpressions")]
public bool ExtensionMethodsInCollectionInitializers { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.UseRefLocalsForAccurateOrderOfEvaluation")]
public bool UseRefLocalsForAccurateOrderOfEvaluation { get; public set; }
    [CategoryAttribute("C# 7.2 / VS 2017.4")]
[DescriptionAttribute("DecompilerSettings.AllowExtensionMethodSyntaxOnRef")]
public bool RefExtensionMethods { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.UseStringInterpolation")]
public bool StringInterpolation { get; public set; }
    [CategoryAttribute("C# 11.0 / VS 2022.4")]
[DescriptionAttribute("DecompilerSettings.Utf8StringLiterals")]
public bool Utf8StringLiterals { get; public set; }
    [CategoryAttribute("C# 11.0 / VS 2022.4")]
[DescriptionAttribute("DecompilerSettings.UnsignedRightShift")]
public bool UnsignedRightShift { get; public set; }
    [CategoryAttribute("C# 11.0 / VS 2022.4")]
[DescriptionAttribute("DecompilerSettings.CheckedOperators")]
public bool CheckedOperators { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.IncludeXMLDocumentationCommentsInTheDecompiledCode")]
public bool ShowXmlDocumentation { get; public set; }
    [BrowsableAttribute("False")]
public bool FoldBraces { get; public set; }
    [BrowsableAttribute("False")]
public bool ExpandMemberDefinitions { get; public set; }
    [BrowsableAttribute("False")]
public bool ExpandUsingDeclarations { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[BrowsableAttribute("False")]
public bool DecompileMemberBodies { get; public set; }
    [CategoryAttribute("C# 6.0 / VS 2015")]
[DescriptionAttribute("DecompilerSettings.UseExpressionBodiedMemberSyntaxForGetOnlyProperties")]
public bool UseExpressionBodyForCalculatedGetterOnlyProperties { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.UseOutVariableDeclarations")]
public bool OutVariables { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.UseDiscards")]
public bool Discards { get; public set; }
    [CategoryAttribute("C# 7.2 / VS 2017.4")]
[DescriptionAttribute("DecompilerSettings.IsByRefLikeAttributeShouldBeReplacedWithRefModifiersOnStructs")]
public bool IntroduceRefModifiersOnStructs { get; public set; }
    [CategoryAttribute("C# 7.2 / VS 2017.4")]
[DescriptionAttribute("DecompilerSettings.IsReadOnlyAttributeShouldBeReplacedWithReadonlyInModifiersOnStructsParameters")]
public bool IntroduceReadonlyAndInModifiers { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.ReadOnlyMethods")]
public bool ReadOnlyMethods { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.DetectAsyncUsingAndForeachStatements")]
public bool AsyncUsingAndForEachStatement { get; public set; }
    [CategoryAttribute("C# 7.3 / VS 2017.7")]
[DescriptionAttribute("DecompilerSettings.IsUnmanagedAttributeOnTypeParametersShouldBeReplacedWithUnmanagedConstraints")]
public bool IntroduceUnmanagedConstraint { get; public set; }
    [CategoryAttribute("C# 7.3 / VS 2017.7")]
[DescriptionAttribute("DecompilerSettings.UseStackallocInitializerSyntax")]
public bool StackAllocInitializers { get; public set; }
    [CategoryAttribute("C# 7.3 / VS 2017.7")]
[DescriptionAttribute("DecompilerSettings.UsePatternBasedFixedStatement")]
public bool PatternBasedFixedStatement { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.UseTupleTypeSyntax")]
public bool TupleTypes { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.UseThrowExpressions")]
public bool ThrowExpressions { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.UseImplicitConversionsBetweenTupleTypes")]
public bool TupleConversions { get; public set; }
    [CategoryAttribute("C# 7.3 / VS 2017.7")]
[DescriptionAttribute("DecompilerSettings.DetectTupleComparisons")]
public bool TupleComparisons { get; public set; }
    [CategoryAttribute("C# 4.0 / VS 2010")]
[DescriptionAttribute("DecompilerSettings.UseNamedArguments")]
public bool NamedArguments { get; public set; }
    [CategoryAttribute("C# 7.2 / VS 2017.4")]
[DescriptionAttribute("DecompilerSettings.UseNonTrailingNamedArguments")]
public bool NonTrailingNamedArguments { get; public set; }
    [CategoryAttribute("C# 4.0 / VS 2010")]
[DescriptionAttribute("DecompilerSettings.RemoveOptionalArgumentsIfPossible")]
public bool OptionalArguments { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.IntroduceLocalFunctions")]
public bool LocalFunctions { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.Deconstruction")]
public bool Deconstruction { get; public set; }
    [CategoryAttribute("C# 7.0 / VS 2017")]
[DescriptionAttribute("DecompilerSettings.PatternMatching")]
public bool PatternMatching { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.IntroduceStaticLocalFunctions")]
public bool StaticLocalFunctions { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.Ranges")]
public bool Ranges { get; public set; }
    [CategoryAttribute("C# 8.0 / VS 2019")]
[DescriptionAttribute("DecompilerSettings.NullableReferenceTypes")]
public bool NullableReferenceTypes { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.ShowInfoFromDebugSymbolsIfAvailable")]
[BrowsableAttribute("False")]
public bool ShowDebugInfo { get; public set; }
    [CategoryAttribute("DecompilerSettings.VBSpecificOptions")]
[BrowsableAttribute("False")]
public bool AssumeArrayLengthFitsIntoInt32 { get; public set; }
    [CategoryAttribute("DecompilerSettings.VBSpecificOptions")]
[BrowsableAttribute("False")]
public bool IntroduceIncrementAndDecrement { get; public set; }
    [CategoryAttribute("DecompilerSettings.VBSpecificOptions")]
[BrowsableAttribute("False")]
public bool MakeAssignmentExpressions { get; public set; }
    [CategoryAttribute("DecompilerSettings.FSpecificOptions")]
[DescriptionAttribute("DecompilerSettings.RemoveDeadAndSideEffectFreeCodeUseWithCaution")]
public bool RemoveDeadCode { get; public set; }
    [CategoryAttribute("DecompilerSettings.FSpecificOptions")]
[DescriptionAttribute("DecompilerSettings.RemoveDeadStores")]
public bool RemoveDeadStores { get; public set; }
    [BrowsableAttribute("False")]
public bool LoadInMemory { get; public set; }
    [BrowsableAttribute("False")]
public bool ThrowOnAssemblyResolveErrors { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.ApplyWindowsRuntimeProjectionsOnLoadedAssemblies")]
public bool ApplyWindowsRuntimeProjections { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.ForStatement")]
public bool ForStatement { get; public set; }
    [CategoryAttribute("C# 1.0 / VS .NET")]
[DescriptionAttribute("DecompilerSettings.DoWhileStatement")]
public bool DoWhileStatement { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.SeparateLocalVariableDeclarations")]
public bool SeparateLocalVariableDeclarations { get; public set; }
    [CategoryAttribute("DecompilerSettings.ProjectExport")]
[DescriptionAttribute("DecompilerSettings.UseSdkStyleProjectFormat")]
public bool UseSdkStyleProjectFormat { get; public set; }
    [CategoryAttribute("DecompilerSettings.ProjectExport")]
[DescriptionAttribute("DecompilerSettings.UseNestedDirectoriesForNamespaces")]
public bool UseNestedDirectoriesForNamespaces { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.AggressiveScalarReplacementOfAggregates")]
[BrowsableAttribute("False")]
public bool AggressiveScalarReplacementOfAggregates { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.AggressiveInlining")]
public bool AggressiveInlining { get; public set; }
    [CategoryAttribute("DecompilerSettings.Other")]
[DescriptionAttribute("DecompilerSettings.AlwaysUseGlobal")]
public bool AlwaysUseGlobal { get; public set; }
    [BrowsableAttribute("False")]
public CSharpFormattingOptions CSharpFormattingOptions { get; public set; }
    public DecompilerSettings(LanguageVersion languageVersion);
    public void SetLanguageVersion(LanguageVersion languageVersion);
    public LanguageVersion GetMinimumRequiredVersion();
    public bool get_NativeIntegers();
    public void set_NativeIntegers(bool value);
    public bool get_NumericIntPtr();
    public void set_NumericIntPtr(bool value);
    public bool get_CovariantReturns();
    public void set_CovariantReturns(bool value);
    public bool get_InitAccessors();
    public void set_InitAccessors(bool value);
    public bool get_RecordClasses();
    public void set_RecordClasses(bool value);
    public bool get_RecordStructs();
    public void set_RecordStructs(bool value);
    public bool get_WithExpressions();
    public void set_WithExpressions(bool value);
    public bool get_UsePrimaryConstructorSyntax();
    public void set_UsePrimaryConstructorSyntax(bool value);
    public bool get_FunctionPointers();
    public void set_FunctionPointers(bool value);
    public bool get_ScopedRef();
    public void set_ScopedRef(bool value);
    public bool get_LifetimeAnnotations();
    public void set_LifetimeAnnotations(bool value);
    public bool get_RequiredMembers();
    public void set_RequiredMembers(bool value);
    public bool get_SwitchExpressions();
    public void set_SwitchExpressions(bool value);
    public bool get_FileScopedNamespaces();
    public void set_FileScopedNamespaces(bool value);
    public bool get_ParameterNullCheck();
    public void set_ParameterNullCheck(bool value);
    public bool get_AnonymousMethods();
    public void set_AnonymousMethods(bool value);
    public bool get_AnonymousTypes();
    public void set_AnonymousTypes(bool value);
    public bool get_UseLambdaSyntax();
    public void set_UseLambdaSyntax(bool value);
    public bool get_ExpressionTrees();
    public void set_ExpressionTrees(bool value);
    public bool get_YieldReturn();
    public void set_YieldReturn(bool value);
    public bool get_Dynamic();
    public void set_Dynamic(bool value);
    public bool get_AsyncAwait();
    public void set_AsyncAwait(bool value);
    public bool get_AwaitInCatchFinally();
    public void set_AwaitInCatchFinally(bool value);
    public bool get_AsyncEnumerator();
    public void set_AsyncEnumerator(bool value);
    public bool get_DecimalConstants();
    public void set_DecimalConstants(bool value);
    public bool get_FixedBuffers();
    public void set_FixedBuffers(bool value);
    public bool get_StringConcat();
    public void set_StringConcat(bool value);
    public bool get_LiftNullables();
    public void set_LiftNullables(bool value);
    public bool get_NullPropagation();
    public void set_NullPropagation(bool value);
    public bool get_AutomaticProperties();
    public void set_AutomaticProperties(bool value);
    public bool get_GetterOnlyAutomaticProperties();
    public void set_GetterOnlyAutomaticProperties(bool value);
    public bool get_AutomaticEvents();
    public void set_AutomaticEvents(bool value);
    public bool get_UsingStatement();
    public void set_UsingStatement(bool value);
    public bool get_UseEnhancedUsing();
    public void set_UseEnhancedUsing(bool value);
    public bool get_AlwaysUseBraces();
    public void set_AlwaysUseBraces(bool value);
    public bool get_ForEachStatement();
    public void set_ForEachStatement(bool value);
    public bool get_ForEachWithGetEnumeratorExtension();
    public void set_ForEachWithGetEnumeratorExtension(bool value);
    public bool get_LockStatement();
    public void set_LockStatement(bool value);
    public bool get_SwitchStatementOnString();
    public void set_SwitchStatementOnString(bool value);
    public bool get_SparseIntegerSwitch();
    public void set_SparseIntegerSwitch(bool value);
    public bool get_UsingDeclarations();
    public void set_UsingDeclarations(bool value);
    public bool get_ExtensionMethods();
    public void set_ExtensionMethods(bool value);
    public bool get_QueryExpressions();
    public void set_QueryExpressions(bool value);
    public bool get_UseImplicitMethodGroupConversion();
    public void set_UseImplicitMethodGroupConversion(bool value);
    public bool get_AlwaysCastTargetsOfExplicitInterfaceImplementationCalls();
    public void set_AlwaysCastTargetsOfExplicitInterfaceImplementationCalls(bool value);
    public bool get_AlwaysQualifyMemberReferences();
    public void set_AlwaysQualifyMemberReferences(bool value);
    public bool get_AlwaysShowEnumMemberValues();
    public void set_AlwaysShowEnumMemberValues(bool value);
    public bool get_UseDebugSymbols();
    public void set_UseDebugSymbols(bool value);
    public bool get_ArrayInitializers();
    public void set_ArrayInitializers(bool value);
    public bool get_ObjectOrCollectionInitializers();
    public void set_ObjectOrCollectionInitializers(bool value);
    public bool get_DictionaryInitializers();
    public void set_DictionaryInitializers(bool value);
    public bool get_ExtensionMethodsInCollectionInitializers();
    public void set_ExtensionMethodsInCollectionInitializers(bool value);
    public bool get_UseRefLocalsForAccurateOrderOfEvaluation();
    public void set_UseRefLocalsForAccurateOrderOfEvaluation(bool value);
    public bool get_RefExtensionMethods();
    public void set_RefExtensionMethods(bool value);
    public bool get_StringInterpolation();
    public void set_StringInterpolation(bool value);
    public bool get_Utf8StringLiterals();
    public void set_Utf8StringLiterals(bool value);
    public bool get_UnsignedRightShift();
    public void set_UnsignedRightShift(bool value);
    public bool get_CheckedOperators();
    public void set_CheckedOperators(bool value);
    public bool get_ShowXmlDocumentation();
    public void set_ShowXmlDocumentation(bool value);
    public bool get_FoldBraces();
    public void set_FoldBraces(bool value);
    public bool get_ExpandMemberDefinitions();
    public void set_ExpandMemberDefinitions(bool value);
    public bool get_ExpandUsingDeclarations();
    public void set_ExpandUsingDeclarations(bool value);
    public bool get_DecompileMemberBodies();
    public void set_DecompileMemberBodies(bool value);
    public bool get_UseExpressionBodyForCalculatedGetterOnlyProperties();
    public void set_UseExpressionBodyForCalculatedGetterOnlyProperties(bool value);
    public bool get_OutVariables();
    public void set_OutVariables(bool value);
    public bool get_Discards();
    public void set_Discards(bool value);
    public bool get_IntroduceRefModifiersOnStructs();
    public void set_IntroduceRefModifiersOnStructs(bool value);
    public bool get_IntroduceReadonlyAndInModifiers();
    public void set_IntroduceReadonlyAndInModifiers(bool value);
    public bool get_ReadOnlyMethods();
    public void set_ReadOnlyMethods(bool value);
    public bool get_AsyncUsingAndForEachStatement();
    public void set_AsyncUsingAndForEachStatement(bool value);
    public bool get_IntroduceUnmanagedConstraint();
    public void set_IntroduceUnmanagedConstraint(bool value);
    public bool get_StackAllocInitializers();
    public void set_StackAllocInitializers(bool value);
    public bool get_PatternBasedFixedStatement();
    public void set_PatternBasedFixedStatement(bool value);
    public bool get_TupleTypes();
    public void set_TupleTypes(bool value);
    public bool get_ThrowExpressions();
    public void set_ThrowExpressions(bool value);
    public bool get_TupleConversions();
    public void set_TupleConversions(bool value);
    public bool get_TupleComparisons();
    public void set_TupleComparisons(bool value);
    public bool get_NamedArguments();
    public void set_NamedArguments(bool value);
    public bool get_NonTrailingNamedArguments();
    public void set_NonTrailingNamedArguments(bool value);
    public bool get_OptionalArguments();
    public void set_OptionalArguments(bool value);
    public bool get_LocalFunctions();
    public void set_LocalFunctions(bool value);
    public bool get_Deconstruction();
    public void set_Deconstruction(bool value);
    public bool get_PatternMatching();
    public void set_PatternMatching(bool value);
    public bool get_StaticLocalFunctions();
    public void set_StaticLocalFunctions(bool value);
    public bool get_Ranges();
    public void set_Ranges(bool value);
    public bool get_NullableReferenceTypes();
    public void set_NullableReferenceTypes(bool value);
    public bool get_ShowDebugInfo();
    public void set_ShowDebugInfo(bool value);
    public bool get_AssumeArrayLengthFitsIntoInt32();
    public void set_AssumeArrayLengthFitsIntoInt32(bool value);
    public bool get_IntroduceIncrementAndDecrement();
    public void set_IntroduceIncrementAndDecrement(bool value);
    public bool get_MakeAssignmentExpressions();
    public void set_MakeAssignmentExpressions(bool value);
    public bool get_RemoveDeadCode();
    public void set_RemoveDeadCode(bool value);
    public bool get_RemoveDeadStores();
    public void set_RemoveDeadStores(bool value);
    public bool get_LoadInMemory();
    public void set_LoadInMemory(bool value);
    public bool get_ThrowOnAssemblyResolveErrors();
    public void set_ThrowOnAssemblyResolveErrors(bool value);
    public bool get_ApplyWindowsRuntimeProjections();
    public void set_ApplyWindowsRuntimeProjections(bool value);
    public bool get_ForStatement();
    public void set_ForStatement(bool value);
    public bool get_DoWhileStatement();
    public void set_DoWhileStatement(bool value);
    public bool get_SeparateLocalVariableDeclarations();
    public void set_SeparateLocalVariableDeclarations(bool value);
    public bool get_UseSdkStyleProjectFormat();
    public void set_UseSdkStyleProjectFormat(bool value);
    public bool get_UseNestedDirectoriesForNamespaces();
    public void set_UseNestedDirectoriesForNamespaces(bool value);
    public bool get_AggressiveScalarReplacementOfAggregates();
    public void set_AggressiveScalarReplacementOfAggregates(bool value);
    public bool get_AggressiveInlining();
    public void set_AggressiveInlining(bool value);
    public bool get_AlwaysUseGlobal();
    public void set_AlwaysUseGlobal(bool value);
    public CSharpFormattingOptions get_CSharpFormattingOptions();
    public void set_CSharpFormattingOptions(CSharpFormattingOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(string propertyName);
    public DecompilerSettings Clone();
}
internal class ICSharpCode.Decompiler.DecompileRun : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <DefinedSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private DecompilerSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentationProvider <DocumentationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITypeDefinition, RecordDecompiler> <RecordDecompilers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ITypeDefinition, bool> <TypeHierarchyIsKnown>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<EnumValueDisplayMode> <EnumValueDisplayMode>k__BackingField;
    public HashSet`1<string> DefinedSymbols { get; }
    public HashSet`1<string> Namespaces { get; }
    public CancellationToken CancellationToken { get; public set; }
    public DecompilerSettings Settings { get; }
    public IDocumentationProvider DocumentationProvider { get; public set; }
    public Dictionary`2<ITypeDefinition, RecordDecompiler> RecordDecompilers { get; }
    public Dictionary`2<ITypeDefinition, bool> TypeHierarchyIsKnown { get; }
    private Lazy`1<UsingScope> usingScope { get; }
    public UsingScope UsingScope { get; }
    public Nullable`1<EnumValueDisplayMode> EnumValueDisplayMode { get; public set; }
    public DecompileRun(DecompilerSettings settings);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_DefinedSymbols();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Namespaces();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public DecompilerSettings get_Settings();
    [CompilerGeneratedAttribute]
public IDocumentationProvider get_DocumentationProvider();
    [CompilerGeneratedAttribute]
public void set_DocumentationProvider(IDocumentationProvider value);
    [CompilerGeneratedAttribute]
public Dictionary`2<ITypeDefinition, RecordDecompiler> get_RecordDecompilers();
    [CompilerGeneratedAttribute]
public Dictionary`2<ITypeDefinition, bool> get_TypeHierarchyIsKnown();
    private Lazy`1<UsingScope> get_usingScope();
    public UsingScope get_UsingScope();
    private UsingScope CreateUsingScope(HashSet`1<string> requiredNamespacesSuperset);
    [CompilerGeneratedAttribute]
public Nullable`1<EnumValueDisplayMode> get_EnumValueDisplayMode();
    [CompilerGeneratedAttribute]
public void set_EnumValueDisplayMode(Nullable`1<EnumValueDisplayMode> value);
    [CompilerGeneratedAttribute]
private UsingScope <get_usingScope>b__24_0();
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Disassembler.DisassemblerHelpers : object {
    private static Char[] _validNonLetterIdentifierCharacter;
    private static DisassemblerHelpers();
    public static string OffsetToString(int offset);
    public static string OffsetToString(long offset);
    public static void WriteOffsetReference(ITextOutput writer, Nullable`1<int> offset);
    [ExtensionAttribute]
public static void WriteTo(ExceptionRegion exceptionHandler, PEFile module, MetadataGenericContext context, ITextOutput writer);
    private static string ToInvariantCultureString(object value);
    private static bool IsValidIdentifierCharacter(char c);
    private static bool IsValidIdentifier(string identifier);
    public static string Escape(string identifier);
    public static void WriteParameterReference(ITextOutput writer, MetadataReader metadata, MethodDefinitionHandle handle, int index);
    public static void WriteVariableReference(ITextOutput writer, MetadataReader metadata, MethodDefinitionHandle handle, int index);
    public static void WriteOperand(ITextOutput writer, object operand);
    public static void WriteOperand(ITextOutput writer, long val);
    public static void WriteOperand(ITextOutput writer, float val);
    public static void WriteOperand(ITextOutput writer, double val);
    public static void WriteOperand(ITextOutput writer, string operand);
    public static string EscapeString(string str);
    public static string PrimitiveTypeName(string fullName);
    [CompilerGeneratedAttribute]
internal static string <WriteParameterReference>g__GetParameterName|9_0(int parameterNumber, <>c__DisplayClass9_0& );
}
public class ICSharpCode.Decompiler.Disassembler.DisassemblerSignatureTypeProvider : object {
    private PEFile module;
    private MetadataReader metadata;
    private ITextOutput output;
    public DisassemblerSignatureTypeProvider(PEFile module, ITextOutput output);
    public sealed virtual Action`1<ILNameSyntax> GetArrayType(Action`1<ILNameSyntax> elementType, ArrayShape shape);
    public sealed virtual Action`1<ILNameSyntax> GetByReferenceType(Action`1<ILNameSyntax> elementType);
    public sealed virtual Action`1<ILNameSyntax> GetFunctionPointerType(MethodSignature`1<Action`1<ILNameSyntax>> signature);
    public sealed virtual Action`1<ILNameSyntax> GetGenericInstantiation(Action`1<ILNameSyntax> genericType, ImmutableArray`1<Action`1<ILNameSyntax>> typeArguments);
    public sealed virtual Action`1<ILNameSyntax> GetGenericMethodParameter(MetadataGenericContext genericContext, int index);
    public sealed virtual Action`1<ILNameSyntax> GetGenericTypeParameter(MetadataGenericContext genericContext, int index);
    private void WriteTypeParameter(GenericParameterHandle paramRef, int index, ILNameSyntax syntax);
    public sealed virtual Action`1<ILNameSyntax> GetModifiedType(Action`1<ILNameSyntax> modifier, Action`1<ILNameSyntax> unmodifiedType, bool isRequired);
    public sealed virtual Action`1<ILNameSyntax> GetPinnedType(Action`1<ILNameSyntax> elementType);
    public sealed virtual Action`1<ILNameSyntax> GetPointerType(Action`1<ILNameSyntax> elementType);
    public sealed virtual Action`1<ILNameSyntax> GetPrimitiveType(PrimitiveTypeCode typeCode);
    public sealed virtual Action`1<ILNameSyntax> GetSZArrayType(Action`1<ILNameSyntax> elementType);
    public sealed virtual Action`1<ILNameSyntax> GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual Action`1<ILNameSyntax> GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public sealed virtual Action`1<ILNameSyntax> GetTypeFromSpecification(MetadataReader reader, MetadataGenericContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_0(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_1(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_2(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_3(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_4(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_5(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_6(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_7(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_8(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_9(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_10(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_11(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_12(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_13(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_14(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_15(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_16(ILNameSyntax syntax);
    [CompilerGeneratedAttribute]
private void <GetPrimitiveType>b__14_17(ILNameSyntax syntax);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.Disassembler.IEntityProcessor {
    public abstract virtual IReadOnlyCollection`1<InterfaceImplementationHandle> Process(PEFile module, IReadOnlyCollection`1<InterfaceImplementationHandle> items);
    public abstract virtual IReadOnlyCollection`1<TypeDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<TypeDefinitionHandle> items);
    public abstract virtual IReadOnlyCollection`1<MethodDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<MethodDefinitionHandle> items);
    public abstract virtual IReadOnlyCollection`1<PropertyDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<PropertyDefinitionHandle> items);
    public abstract virtual IReadOnlyCollection`1<EventDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<EventDefinitionHandle> items);
    public abstract virtual IReadOnlyCollection`1<FieldDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<FieldDefinitionHandle> items);
    public abstract virtual IReadOnlyCollection`1<CustomAttributeHandle> Process(PEFile module, IReadOnlyCollection`1<CustomAttributeHandle> items);
}
public enum ICSharpCode.Decompiler.Disassembler.ILNameSyntax : Enum {
    public int value__;
    public static ILNameSyntax Signature;
    public static ILNameSyntax SignatureNoNamedTypeParameters;
    public static ILNameSyntax TypeName;
    public static ILNameSyntax ShortTypeName;
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Disassembler.ILParser : object {
    [ExtensionAttribute]
public static ILOpCode DecodeOpCode(BlobReader& blob);
    [ExtensionAttribute]
public static void SkipOperand(BlobReader& blob, ILOpCode opCode);
    [ExtensionAttribute]
public static int DecodeBranchTarget(BlobReader& blob, ILOpCode opCode);
    [ExtensionAttribute]
public static Int32[] DecodeSwitchTargets(BlobReader& blob);
    [ExtensionAttribute]
public static string DecodeUserString(BlobReader& blob, MetadataReader metadata);
    [ExtensionAttribute]
public static int DecodeIndex(BlobReader& blob, ILOpCode opCode);
    [ExtensionAttribute]
public static bool IsReturn(ILOpCode opCode);
    public static int GetHeaderSize(BlobReader bodyBlockReader);
    public static void SetBranchTargets(BlobReader& blob, BitSet branchTargets);
}
public class ICSharpCode.Decompiler.Disassembler.ILStructure : object {
    public PEFile Module;
    public MethodDefinitionHandle MethodHandle;
    public MetadataGenericContext GenericContext;
    public ILStructureType Type;
    public int StartOffset;
    public int EndOffset;
    public ExceptionRegion ExceptionHandler;
    public int LoopEntryPointOffset;
    public List`1<ILStructure> Children;
    public ILStructure(PEFile module, MethodDefinitionHandle handle, MetadataGenericContext genericContext, MethodBodyBlock body);
    public ILStructure(PEFile module, MethodDefinitionHandle handle, MetadataGenericContext genericContext, ILStructureType type, int startOffset, int endOffset, ExceptionRegion handler);
    public ILStructure(PEFile module, MethodDefinitionHandle handle, MetadataGenericContext genericContext, ILStructureType type, int startOffset, int endOffset, int loopEntryPoint);
    private bool AddNestedStructure(ILStructure newStructure);
    private ValueTuple`2<List`1<Branch>, BitSet> FindAllBranches(BlobReader body);
    private static bool IsUnconditionalBranch(ILOpCode opCode);
    private void SortChildren();
    public ILStructure GetInnermost(int offset);
}
public enum ICSharpCode.Decompiler.Disassembler.ILStructureType : Enum {
    public int value__;
    public static ILStructureType Root;
    public static ILStructureType Loop;
    public static ILStructureType Try;
    public static ILStructureType Handler;
    public static ILStructureType Filter;
}
public class ICSharpCode.Decompiler.Disassembler.MethodBodyDisassembler : object {
    private ITextOutput output;
    private CancellationToken cancellationToken;
    [CompilerGeneratedAttribute]
private bool <DetectControlStructure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowSequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowMetadataTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowMetadataTokensInBase10>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowRawRVAOffsetAndBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugInfoProvider <DebugInfo>k__BackingField;
    private IList`1<SequencePoint> sequencePoints;
    private int nextSequencePointIndex;
    private PEFile module;
    private MetadataReader metadata;
    private MetadataGenericContext genericContext;
    private DisassemblerSignatureTypeProvider signatureDecoder;
    public bool DetectControlStructure { get; public set; }
    public bool ShowSequencePoints { get; public set; }
    public bool ShowMetadataTokens { get; public set; }
    public bool ShowMetadataTokensInBase10 { get; public set; }
    public bool ShowRawRVAOffsetAndBytes { get; public set; }
    public IDebugInfoProvider DebugInfo { get; public set; }
    public MethodBodyDisassembler(ITextOutput output, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public bool get_DetectControlStructure();
    [CompilerGeneratedAttribute]
public void set_DetectControlStructure(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowSequencePoints();
    [CompilerGeneratedAttribute]
public void set_ShowSequencePoints(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowMetadataTokens();
    [CompilerGeneratedAttribute]
public void set_ShowMetadataTokens(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowMetadataTokensInBase10();
    [CompilerGeneratedAttribute]
public void set_ShowMetadataTokensInBase10(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowRawRVAOffsetAndBytes();
    [CompilerGeneratedAttribute]
public void set_ShowRawRVAOffsetAndBytes(bool value);
    [CompilerGeneratedAttribute]
public IDebugInfoProvider get_DebugInfo();
    [CompilerGeneratedAttribute]
public void set_DebugInfo(IDebugInfoProvider value);
    public virtual void Disassemble(PEFile module, MethodDefinitionHandle handle);
    private void DisassembleLocalsBlock(MethodDefinitionHandle method, MethodBodyBlock body);
    internal void WriteExceptionHandlers(PEFile module, MethodDefinitionHandle handle, MethodBodyBlock body);
    private void WriteStructureHeader(ILStructure s);
    private void WriteStructureBody(ILStructure s, BitSet branchTargets, BlobReader& body, int methodRva);
    private void WriteStructureFooter(ILStructure s);
    protected virtual void WriteInstruction(ITextOutput output, MetadataReader metadata, MethodDefinitionHandle methodHandle, BlobReader& blob, int methodRva);
    private void WriteRVA(BlobReader blob, int offset, ILOpCode opCode);
    private void WriteOpCode(ILOpCode opCode);
    private void WriteMetadataToken(EntityHandle handle, bool spaceBefore);
    private void WriteMetadataToken(Nullable`1<Handle> handle, int metadataToken, bool spaceBefore);
}
public class ICSharpCode.Decompiler.Disassembler.OpCodeInfo : ValueType {
    public ILOpCode Code;
    public string Name;
    private string encodedName;
    public string Link { get; }
    public string EncodedName { get; }
    public OpCodeInfo(ILOpCode code, string name);
    public sealed virtual bool Equals(OpCodeInfo other);
    public static bool op_Equality(OpCodeInfo lhs, OpCodeInfo rhs);
    public static bool op_Inequality(OpCodeInfo lhs, OpCodeInfo rhs);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Link();
    public string get_EncodedName();
}
public class ICSharpCode.Decompiler.Disassembler.ReflectionDisassembler : object {
    private ITextOutput output;
    private CancellationToken cancellationToken;
    private bool isInType;
    private MethodBodyDisassembler methodBodyDisassembler;
    [CompilerGeneratedAttribute]
private bool <ExpandMemberDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblyResolver <AssemblyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEntityProcessor <EntityProcessor>k__BackingField;
    private EnumNameCollection`1<MethodAttributes> methodAttributeFlags;
    private EnumNameCollection`1<MethodAttributes> methodVisibility;
    private EnumNameCollection`1<SignatureCallingConvention> callingConvention;
    private EnumNameCollection`1<MethodImplAttributes> methodCodeType;
    private EnumNameCollection`1<MethodImplAttributes> methodImpl;
    private EnumNameCollection`1<FieldAttributes> fieldVisibility;
    private EnumNameCollection`1<FieldAttributes> fieldAttributes;
    private EnumNameCollection`1<PropertyAttributes> propertyAttributes;
    private EnumNameCollection`1<EventAttributes> eventAttributes;
    private EnumNameCollection`1<TypeAttributes> typeVisibility;
    private EnumNameCollection`1<TypeAttributes> typeLayout;
    private EnumNameCollection`1<TypeAttributes> typeStringFormat;
    private EnumNameCollection`1<TypeAttributes> typeAttributes;
    public bool DetectControlStructure { get; public set; }
    public bool ShowSequencePoints { get; public set; }
    public bool ShowMetadataTokens { get; public set; }
    public bool ShowMetadataTokensInBase10 { get; public set; }
    public bool ShowRawRVAOffsetAndBytes { get; public set; }
    public IDebugInfoProvider DebugInfo { get; public set; }
    public bool ExpandMemberDefinitions { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IEntityProcessor EntityProcessor { get; public set; }
    public ReflectionDisassembler(ITextOutput output, CancellationToken cancellationToken);
    public ReflectionDisassembler(ITextOutput output, MethodBodyDisassembler methodBodyDisassembler, CancellationToken cancellationToken);
    public bool get_DetectControlStructure();
    public void set_DetectControlStructure(bool value);
    public bool get_ShowSequencePoints();
    public void set_ShowSequencePoints(bool value);
    public bool get_ShowMetadataTokens();
    public void set_ShowMetadataTokens(bool value);
    public bool get_ShowMetadataTokensInBase10();
    public void set_ShowMetadataTokensInBase10(bool value);
    public bool get_ShowRawRVAOffsetAndBytes();
    public void set_ShowRawRVAOffsetAndBytes(bool value);
    public IDebugInfoProvider get_DebugInfo();
    public void set_DebugInfo(IDebugInfoProvider value);
    [CompilerGeneratedAttribute]
public bool get_ExpandMemberDefinitions();
    [CompilerGeneratedAttribute]
public void set_ExpandMemberDefinitions(bool value);
    [CompilerGeneratedAttribute]
public IAssemblyResolver get_AssemblyResolver();
    [CompilerGeneratedAttribute]
public void set_AssemblyResolver(IAssemblyResolver value);
    [CompilerGeneratedAttribute]
public IEntityProcessor get_EntityProcessor();
    [CompilerGeneratedAttribute]
public void set_EntityProcessor(IEntityProcessor value);
    public void DisassembleMethod(PEFile module, MethodDefinitionHandle handle);
    public void DisassembleMethodHeader(PEFile module, MethodDefinitionHandle handle);
    private void DisassembleMethodHeaderInternal(PEFile module, MethodDefinitionHandle handle, MetadataGenericContext genericContext);
    internal static void WriteMetadataToken(ITextOutput output, PEFile module, Nullable`1<Handle> handle, int metadataToken, bool spaceAfter, bool spaceBefore, bool showMetadataTokens, bool base10);
    private void DisassembleMethodBlock(PEFile module, MethodDefinitionHandle handle, MetadataGenericContext genericContext);
    private void WriteSecurityDeclarations(PEFile module, DeclarativeSecurityAttributeHandleCollection secDeclProvider);
    private void TryDecodeSecurityDeclaration(TextOutputWithRollback output, BlobReader blob, PEFile module);
    private void WriteValue(ITextOutput output, ValueTuple`2<PrimitiveTypeCode, string> type, object value);
    private static void WriteSimpleValue(ITextOutput output, object value, string typeName);
    private static string PrimitiveTypeCodeToString(PrimitiveTypeCode typeCode);
    private void WriteMarshalInfo(BlobReader marshalInfo);
    private void WriteNativeType(BlobReader& blob);
    private void WriteParameters(MetadataReader metadata, IEnumerable`1<ParameterHandle> parameters, MethodSignature`1<Action`1<ILNameSyntax>> signature);
    private void WriteGenericParameterAttributes(PEFile module, MetadataGenericContext context, GenericParameterHandle handle);
    private void WriteParameterAttributes(PEFile module, ParameterHandle handle);
    private void WriteConstant(MetadataReader metadata, Constant constant);
    public void DisassembleField(PEFile module, FieldDefinitionHandle handle);
    public void DisassembleFieldHeader(PEFile module, FieldDefinitionHandle handle);
    private char DisassembleFieldHeaderInternal(PEFile module, FieldDefinitionHandle handle, MetadataReader metadata, FieldDefinition fieldDefinition);
    private char GetRVASectionPrefix(PEHeaders headers, int rva);
    public void DisassembleProperty(PEFile module, PropertyDefinitionHandle property);
    public void DisassemblePropertyHeader(PEFile module, PropertyDefinitionHandle property);
    private PropertyAccessors DisassemblePropertyHeaderInternal(PEFile module, PropertyDefinitionHandle handle, MetadataReader metadata, PropertyDefinition propertyDefinition);
    private void WriteNestedMethod(string keyword, PEFile module, MethodDefinitionHandle method);
    public void DisassembleEvent(PEFile module, EventDefinitionHandle handle);
    public void DisassembleEventHeader(PEFile module, EventDefinitionHandle handle);
    private void DisassembleEventHeaderInternal(PEFile module, EventDefinitionHandle handle, EventDefinition eventDefinition, EventAccessors accessors);
    public void DisassembleType(PEFile module, TypeDefinitionHandle type);
    public void DisassembleTypeHeader(PEFile module, TypeDefinitionHandle type);
    private void DisassembleTypeHeaderInternal(PEFile module, TypeDefinitionHandle handle, TypeDefinition typeDefinition, MetadataGenericContext genericContext);
    private void WriteTypeParameters(ITextOutput output, PEFile module, MetadataGenericContext context, GenericParameterHandleCollection p);
    private IReadOnlyCollection`1<InterfaceImplementationHandle> Process(PEFile module, IReadOnlyCollection`1<InterfaceImplementationHandle> items);
    private IReadOnlyCollection`1<TypeDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<TypeDefinitionHandle> items);
    private IReadOnlyCollection`1<MethodDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<MethodDefinitionHandle> items);
    private IReadOnlyCollection`1<PropertyDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<PropertyDefinitionHandle> items);
    private IReadOnlyCollection`1<EventDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<EventDefinitionHandle> items);
    private IReadOnlyCollection`1<FieldDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<FieldDefinitionHandle> items);
    private IReadOnlyCollection`1<CustomAttributeHandle> Process(PEFile module, IReadOnlyCollection`1<CustomAttributeHandle> items);
    private void WriteAttributes(PEFile module, CustomAttributeHandleCollection attributes);
    private void WriteBlob(BlobHandle blob, MetadataReader metadata);
    private void WriteBlob(BlobReader reader);
    private void OpenBlock(bool defaultCollapsed);
    private void CloseBlock(string comment);
    private void WriteFlags(T flags, EnumNameCollection`1<T> flagNames);
    private void WriteEnum(T enumValue, EnumNameCollection`1<T> enumNames);
    public void DisassembleNamespace(string nameSpace, PEFile module, IEnumerable`1<TypeDefinitionHandle> types);
    public void WriteAssemblyHeader(PEFile module);
    public void WriteAssemblyReferences(MetadataReader metadata);
    public void WriteModuleHeader(PEFile module, bool skipMVID);
    public void WriteModuleContents(PEFile module);
    [CompilerGeneratedAttribute]
private void <WriteModuleHeader>g__WriteExportedType|99_0(ExportedType exportedType, <>c__DisplayClass99_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Disassembler.SortByNameProcessor : object {
    public sealed virtual IReadOnlyCollection`1<InterfaceImplementationHandle> Process(PEFile module, IReadOnlyCollection`1<InterfaceImplementationHandle> items);
    public sealed virtual IReadOnlyCollection`1<TypeDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<TypeDefinitionHandle> items);
    public sealed virtual IReadOnlyCollection`1<MethodDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<MethodDefinitionHandle> items);
    public sealed virtual IReadOnlyCollection`1<PropertyDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<PropertyDefinitionHandle> items);
    public sealed virtual IReadOnlyCollection`1<EventDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<EventDefinitionHandle> items);
    public sealed virtual IReadOnlyCollection`1<FieldDefinitionHandle> Process(PEFile module, IReadOnlyCollection`1<FieldDefinitionHandle> items);
    public sealed virtual IReadOnlyCollection`1<CustomAttributeHandle> Process(PEFile module, IReadOnlyCollection`1<CustomAttributeHandle> items);
    private static string GetSortKey(TypeDefinitionHandle handle, PEFile module);
    private static string GetSortKey(MethodDefinitionHandle handle, PEFile module);
    private static string GetSortKey(InterfaceImplementationHandle handle, PEFile module);
    private static string GetSortKey(FieldDefinitionHandle handle, PEFile module);
    private static string GetSortKey(PropertyDefinitionHandle handle, PEFile module);
    private static string GetSortKey(EventDefinitionHandle handle, PEFile module);
    private static string GetSortKey(CustomAttributeHandle handle, PEFile module);
}
public class ICSharpCode.Decompiler.Documentation.GetPotentiallyNestedClassTypeReference : object {
    private string typeName;
    private int typeParameterCount;
    public GetPotentiallyNestedClassTypeReference(string typeName, int typeParameterCount);
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public EntityHandle ResolveInPEFile(PEFile module);
    [CompilerGeneratedAttribute]
internal static bool <ResolveInPEFile>g__IsEqualShortName|4_0(TypeDefinitionHandle h, MetadataReader metadata, string name);
}
public interface ICSharpCode.Decompiler.Documentation.IDocumentationProvider {
    public abstract virtual string GetDocumentation(IEntity entity);
}
internal class ICSharpCode.Decompiler.Documentation.IdStringMemberReference : object {
    private ITypeReference declaringTypeReference;
    private char memberType;
    private string memberIdString;
    public ITypeReference DeclaringTypeReference { get; }
    public IdStringMemberReference(ITypeReference declaringTypeReference, char memberType, string memberIdString);
    private bool CanMatch(IMember member);
    public sealed virtual ITypeReference get_DeclaringTypeReference();
    public sealed virtual IMember Resolve(ITypeResolveContext context);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Documentation.IdStringProvider : object {
    [ExtensionAttribute]
public static string GetIdString(IEntity entity);
    public static string GetTypeName(IType type);
    private static void AppendTypeName(StringBuilder b, IType type, bool explicitInterfaceImpl);
    private static void AppendTypeParameters(StringBuilder b, IType type, int outerTypeParameterCount, bool explicitInterfaceImpl);
    public static IMemberReference ParseMemberIdString(string memberIdString);
    public static ITypeReference ParseTypeName(string typeName);
    private static bool IsIDStringSpecialCharacter(char c);
    private static ITypeReference ParseTypeName(string typeName, Int32& pos);
    private static string ReadTypeName(string typeName, Int32& pos, bool allowDottedName, Int32& typeParameterCount, List`1<ITypeReference> typeArguments);
    public static IEntity FindEntity(string idString, ITypeResolveContext context);
}
public static class ICSharpCode.Decompiler.Documentation.XmlDocLoader : object {
    private static Lazy`1<XmlDocumentationProvider> mscorlibDocumentation;
    private static ConditionalWeakTable`2<PEFile, XmlDocumentationProvider> cache;
    private static string referenceAssembliesPath;
    private static string frameworkPath;
    public static XmlDocumentationProvider MscorlibDocumentation { get; }
    private static XmlDocLoader();
    private static XmlDocumentationProvider LoadMscorlibDocumentation();
    public static XmlDocumentationProvider get_MscorlibDocumentation();
    public static XmlDocumentationProvider LoadDocumentation(PEFile module);
    private static string FindXmlDocumentation(string assemblyFileName, TargetRuntime runtime);
    internal static string LookupLocalizedXmlDoc(string fileName);
    private static string GetLocalizedName(string fileName, string language);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Documentation.XmlDocumentationElement : object {
    [NullableAttribute("2")]
private XElement element;
    [NullableAttribute("2")]
private IEntity declaringEntity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<string, IEntity> crefResolver;
    [NullableAttribute("2")]
private String modreq(System.Runtime.CompilerServices.IsVolatile) textContent;
    private int nestingLevel;
    [NullableAttribute("2")]
private IEntity referencedEntity;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) referencedEntityInitialized;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<XmlDocumentationElement> children;
    private static String[] doNotInheritIfAlreadyPresent;
    [NullableAttribute("2")]
public IEntity DeclaringEntity { get; }
    [NullableAttribute("2")]
public IEntity ReferencedEntity { get; }
    public string Name { get; }
    public bool IsTextNode { get; }
    public string TextContent { get; }
    public IList`1<XmlDocumentationElement> Children { get; }
    public XmlDocumentationElement(XElement element, IEntity declaringEntity, Func`2<string, IEntity> crefResolver);
    public XmlDocumentationElement(string text, IEntity declaringEntity);
    private static XmlDocumentationElement();
    [NullableContextAttribute("2")]
public IEntity get_DeclaringEntity();
    [NullableContextAttribute("2")]
public IEntity get_ReferencedEntity();
    public string get_Name();
    [NullableContextAttribute("2")]
public string GetAttribute(string name);
    public bool get_IsTextNode();
    public string get_TextContent();
    public IList`1<XmlDocumentationElement> get_Children();
    private static List`1<XmlDocumentationElement> CreateElements(IEnumerable`1<XObject> childObjects, IEntity declaringEntity, Func`2<string, IEntity> crefResolver, int nestingLevel);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IList`1<XmlDocumentationElement> <get_Children>b__22_0();
}
public class ICSharpCode.Decompiler.Documentation.XmlDocumentationProvider : object {
    private XmlDocumentationCache cache;
    private string fileName;
    private Encoding encoding;
    private IndexEntry[] modreq(System.Runtime.CompilerServices.IsVolatile) index;
    public XmlDocumentationProvider(string fileName);
    private static string GetRedirectionTarget(string xmlFileName, string target);
    private static string AppendDirectorySeparator(string dir);
    private void ReadXmlDoc(XmlTextReader reader);
    private static void ReadMembersSection(XmlTextReader reader, LinePositionMapper linePosMapper, List`1<IndexEntry> indexList);
    private static int GetHashCode(string key);
    public string GetDocumentation(string key);
    public sealed virtual string GetDocumentation(IEntity entity);
    private string GetDocumentation(string key, bool allowReload);
    private string ReloadAndGetDocumentation(string key);
    private string LoadDocumentation(string key, int positionInFile);
    public virtual void OnDeserialization(object sender);
}
internal enum ICSharpCode.Decompiler.EnumValueDisplayMode : Enum {
    public int value__;
    public static EnumValueDisplayMode None;
    public static EnumValueDisplayMode All;
    public static EnumValueDisplayMode AllHex;
    public static EnumValueDisplayMode FirstOnly;
}
[DebuggerDisplayAttribute("CFG UserIndex={UserIndex}, UserData={UserData}")]
public class ICSharpCode.Decompiler.FlowAnalysis.ControlFlowNode : object {
    public int UserIndex;
    public object UserData;
    public bool Visited;
    public int PostOrderNumber;
    [CompilerGeneratedAttribute]
private ControlFlowNode <ImmediateDominator>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ControlFlowNode> <DominatorTreeChildren>k__BackingField;
    public List`1<ControlFlowNode> Predecessors;
    public List`1<ControlFlowNode> Successors;
    public bool IsReachable { get; }
    public ControlFlowNode ImmediateDominator { get; internal set; }
    public List`1<ControlFlowNode> DominatorTreeChildren { get; internal set; }
    public bool get_IsReachable();
    [CompilerGeneratedAttribute]
public ControlFlowNode get_ImmediateDominator();
    [CompilerGeneratedAttribute]
internal void set_ImmediateDominator(ControlFlowNode value);
    [CompilerGeneratedAttribute]
public List`1<ControlFlowNode> get_DominatorTreeChildren();
    [CompilerGeneratedAttribute]
internal void set_DominatorTreeChildren(List`1<ControlFlowNode> value);
    public void AddEdgeTo(ControlFlowNode target);
    public void TraversePreOrder(Func`2<ControlFlowNode, IEnumerable`1<ControlFlowNode>> children, Action`1<ControlFlowNode> visitAction);
    public void TraversePostOrder(Func`2<ControlFlowNode, IEnumerable`1<ControlFlowNode>> children, Action`1<ControlFlowNode> visitAction);
    public bool Dominates(ControlFlowNode node);
}
public abstract class ICSharpCode.Decompiler.FlowAnalysis.DataFlowVisitor`1 : ILVisitor {
    private State bottomState;
    protected State state;
    protected State currentStateOnException;
    private bool initialized;
    protected InstructionFlags flagsRequiringManualImpl;
    private Dictionary`2<Block, State> stateOnBranch;
    private Dictionary`2<BlockContainer, State> stateOnLeave;
    private Dictionary`2<BlockContainer, SortedSet`1<int>> workLists;
    private List`1<ValueTuple`2<IBranchOrLeaveInstruction, State>> branchesTriggeringFinally;
    private Dictionary`2<TryInstruction, State> stateOnException;
    private State stateOnNullableRewrap;
    protected void Initialize(State initialState);
    [ConditionalAttribute("DEBUG")]
protected void DebugStartPoint(ILInstruction inst);
    [ConditionalAttribute("DEBUG")]
protected void DebugEndPoint(ILInstruction inst);
    protected sealed virtual void Default(ILInstruction inst);
    protected void PropagateStateOnException();
    protected void MarkUnreachable();
    private State GetBlockInputState(Block block);
    protected internal virtual void VisitBlockContainer(BlockContainer container);
    protected internal virtual void VisitBranch(Branch inst);
    private void MergeBranchStateIntoTargetBlock(Branch inst, State branchState);
    protected internal virtual void VisitLeave(Leave inst);
    private void MergeBranchStateIntoStateOnLeave(Leave inst, State branchState);
    protected internal virtual void VisitThrow(Throw inst);
    protected internal virtual void VisitRethrow(Rethrow inst);
    protected internal virtual void VisitInvalidBranch(InvalidBranch inst);
    protected State HandleTryBlock(TryInstruction inst);
    protected internal virtual void VisitTryCatch(TryCatch inst);
    protected virtual void BeginTryCatchHandler(TryCatchHandler inst);
    protected internal sealed virtual void VisitTryCatchHandler(TryCatchHandler inst);
    protected internal virtual void VisitTryFinally(TryFinally inst);
    private void ProcessBranchesLeavingTryFinally(TryFinally tryFinally, int branchesTriggeringFinallyOldCount);
    protected internal virtual void VisitTryFault(TryFault inst);
    protected internal virtual void VisitIfInstruction(IfInstruction inst);
    private ValueTuple`2<State, State> EvaluateCondition(ILInstruction inst);
    protected internal virtual void VisitMatchInstruction(MatchInstruction inst);
    private ValueTuple`2<State, State> EvaluateMatch(MatchInstruction inst);
    protected abstract virtual void HandleMatchStore(MatchInstruction inst);
    protected internal virtual void VisitNullCoalescingInstruction(NullCoalescingInstruction inst);
    protected internal virtual void VisitDynamicLogicOperatorInstruction(DynamicLogicOperatorInstruction inst);
    protected internal virtual void VisitUserDefinedLogicOperator(UserDefinedLogicOperator inst);
    private void HandleBinaryWithOptionalEvaluation(ILInstruction parent, ILInstruction left, ILInstruction right);
    protected internal virtual void VisitNullableRewrap(NullableRewrap inst);
    protected internal virtual void VisitNullableUnwrap(NullableUnwrap inst);
    protected internal virtual void VisitSwitchInstruction(SwitchInstruction inst);
    protected internal virtual void VisitYieldReturn(YieldReturn inst);
    protected internal virtual void VisitUsingInstruction(UsingInstruction inst);
    protected internal virtual void VisitLockInstruction(LockInstruction inst);
    protected internal virtual void VisitILFunction(ILFunction function);
}
internal class ICSharpCode.Decompiler.FlowAnalysis.DefiniteAssignmentVisitor : DataFlowVisitor`1<State> {
    private CancellationToken cancellationToken;
    private ILFunction scope;
    private BitSet variablesWithUninitializedUsage;
    private Dictionary`2<IMethod, State> stateOfLocalFunctionUse;
    private HashSet`1<IMethod> localFunctionsNeedingAnalysis;
    public DefiniteAssignmentVisitor(ILFunction scope, CancellationToken cancellationToken);
    public bool IsPotentiallyUsedUninitialized(ILVariable v);
    private void HandleStore(ILVariable v);
    private void EnsureInitialized(ILVariable v);
    protected internal virtual void VisitStLoc(StLoc inst);
    protected virtual void HandleMatchStore(MatchInstruction inst);
    protected virtual void BeginTryCatchHandler(TryCatchHandler inst);
    protected internal virtual void VisitPinnedRegion(PinnedRegion inst);
    protected internal virtual void VisitLdLoc(LdLoc inst);
    protected internal virtual void VisitLdLoca(LdLoca inst);
    protected internal virtual void VisitCall(Call inst);
    protected internal virtual void VisitCallVirt(CallVirt inst);
    protected internal virtual void VisitNewObj(NewObj inst);
    protected internal virtual void VisitILFunction(ILFunction inst);
    private void HandleCall(CallInstruction call);
    private void HandleLocalFunctionUse(IMethod method);
    protected internal virtual void VisitLdFtn(LdFtn inst);
}
public static class ICSharpCode.Decompiler.FlowAnalysis.Dominance : object {
    public static void ComputeDominance(ControlFlowNode entryPoint, CancellationToken cancellationToken);
    public static ControlFlowNode FindCommonDominator(ControlFlowNode a, ControlFlowNode b);
    public static BitSet MarkNodesWithReachableExits(ControlFlowNode[] cfg);
}
public interface ICSharpCode.Decompiler.FlowAnalysis.IDataFlowState`1 {
    public bool IsBottom { get; }
    public abstract virtual bool LessThanOrEqual(Self otherState);
    public abstract virtual Self Clone();
    public abstract virtual void ReplaceWith(Self newContent);
    public abstract virtual void JoinWith(Self incomingState);
    public abstract virtual void TriggerFinally(Self finallyState);
    public abstract virtual bool get_IsBottom();
    public abstract virtual void ReplaceWithBottom();
}
internal class ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor : DataFlowVisitor`1<State> {
    private static int ReachableBit;
    private static int FirstStoreIndex;
    protected CancellationToken cancellationToken;
    protected ILFunction scope;
    private ILInstruction[] allStores;
    private Dictionary`2<ILInstruction, int> storeIndexMap;
    private Int32[] firstStoreIndexForVariable;
    private BitSet analyzedVariables;
    public ReachingDefinitionsVisitor(ILFunction scope, Predicate`1<ILVariable> pred, CancellationToken cancellationToken);
    public ReachingDefinitionsVisitor(ILFunction scope, BitSet analyzedVariables, CancellationToken cancellationToken);
    private static BitSet GetActiveVariableBitSet(ILFunction scope, Predicate`1<ILVariable> pred);
    private static List`1[] FindAllStoresByVariable(ILFunction scope, BitSet activeVariables, CancellationToken cancellationToken);
    private State CreateInitialState();
    private void HandleStore(ILInstruction inst, ILVariable v);
    protected internal virtual void VisitStLoc(StLoc inst);
    protected virtual void HandleMatchStore(MatchInstruction inst);
    protected virtual void BeginTryCatchHandler(TryCatchHandler inst);
    protected internal virtual void VisitPinnedRegion(PinnedRegion inst);
    public bool IsAnalyzedVariable(ILVariable v);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.FlowAnalysis.ReachingDefinitionsVisitor/<GetStores>d__20")]
protected IEnumerable`1<ILInstruction> GetStores(State state, ILVariable v);
    protected bool IsPotentiallyUninitialized(State state, ILVariable v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.AddressOf : ILInstruction {
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    private IType type;
    public ILInstruction Value { get; public set; }
    public StackType ResultType { get; }
    public IType Type { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public AddressOf(ILInstruction value, IType type);
    private static AddressOf();
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    public IType get_Type();
    public void set_Type(IType value);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Arglist : SimpleInstruction {
    public StackType ResultType { get; }
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Await : ILInstruction {
    [NullableAttribute("2")]
public IMethod GetAwaiterMethod;
    [NullableAttribute("2")]
public IMethod GetResultMethod;
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    public ILInstruction Value { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Await(ILInstruction value);
    private static Await();
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.BinaryInstruction : ILInstruction {
    public static SlotInfo LeftSlot;
    private ILInstruction left;
    public static SlotInfo RightSlot;
    private ILInstruction right;
    public ILInstruction Left { get; public set; }
    public ILInstruction Right { get; public set; }
    public InstructionFlags DirectFlags { get; }
    protected BinaryInstruction(OpCode opCode, ILInstruction left, ILInstruction right);
    private static BinaryInstruction();
    public ILInstruction get_Left();
    public void set_Left(ILInstruction value);
    public ILInstruction get_Right();
    public void set_Right(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.BinaryNumericInstruction : BinaryInstruction {
    public bool CheckForOverflow;
    public Sign Sign;
    public StackType LeftInputType;
    public StackType RightInputType;
    public BinaryNumericOperator Operator;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    private StackType resultType;
    public bool IsLifted { get; }
    public StackType UnderlyingResultType { get; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public BinaryNumericInstruction(BinaryNumericOperator op, ILInstruction left, ILInstruction right, bool checkForOverflow, Sign sign);
    public BinaryNumericInstruction(BinaryNumericOperator op, ILInstruction left, ILInstruction right, StackType leftInputType, StackType rightInputType, bool checkForOverflow, Sign sign, bool isLifted);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    internal static StackType ComputeResultType(BinaryNumericOperator op, StackType left, StackType right);
    public sealed virtual StackType get_UnderlyingResultType();
    public sealed virtual StackType get_ResultType();
    internal virtual void CheckInvariant(ILPhase phase);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    internal static string GetOperatorName(BinaryNumericOperator operator);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
public enum ICSharpCode.Decompiler.IL.BinaryNumericOperator : Enum {
    public byte value__;
    public static BinaryNumericOperator None;
    public static BinaryNumericOperator Add;
    public static BinaryNumericOperator Sub;
    public static BinaryNumericOperator Mul;
    public static BinaryNumericOperator Div;
    public static BinaryNumericOperator Rem;
    public static BinaryNumericOperator BitAnd;
    public static BinaryNumericOperator BitOr;
    public static BinaryNumericOperator BitXor;
    public static BinaryNumericOperator ShiftLeft;
    public static BinaryNumericOperator ShiftRight;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.BitNot : UnaryInstruction {
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    [CompilerGeneratedAttribute]
private StackType <UnderlyingResultType>k__BackingField;
    public bool IsLifted { get; }
    public StackType UnderlyingResultType { get; }
    public StackType ResultType { get; }
    public BitNot(ILInstruction arg);
    public BitNot(ILInstruction arg, bool isLifted, StackType stackType);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    [CompilerGeneratedAttribute]
public sealed virtual StackType get_UnderlyingResultType();
    public virtual StackType get_ResultType();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Block : ILInstruction {
    public static SlotInfo InstructionSlot;
    public static SlotInfo FinalInstructionSlot;
    public BlockKind Kind;
    public InstructionCollection`1<ILInstruction> Instructions;
    private ILInstruction finalInstruction;
    [CompilerGeneratedAttribute]
private int <IncomingEdgeCount>k__BackingField;
    public int IncomingEdgeCount { get; internal set; }
    public ILInstruction FinalInstruction { get; public set; }
    public StackType ResultType { get; }
    public string Label { get; }
    public InstructionFlags DirectFlags { get; }
    public Block(BlockKind kind);
    private static Block();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public int get_IncomingEdgeCount();
    [CompilerGeneratedAttribute]
internal void set_IncomingEdgeCount(int value);
    public ILInstruction get_FinalInstruction();
    public void set_FinalInstruction(ILInstruction value);
    protected internal virtual void InstructionCollectionUpdateComplete();
    public virtual ILInstruction Clone();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    public string get_Label();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    protected virtual int GetChildCount();
    protected virtual ILInstruction GetChild(int index);
    protected virtual void SetChild(int index, ILInstruction value);
    protected virtual SlotInfo GetChildSlot(int index);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public void Remove();
    public void RunTransforms(IEnumerable`1<IBlockTransform> transforms, BlockTransformContext context);
    public static ILInstruction GetPredecessor(ILInstruction inst);
    [NullableContextAttribute("2")]
public static ILInstruction Unwrap(ILInstruction inst);
    [NullableContextAttribute("2")]
public static Block FindClosestBlock(ILInstruction inst);
    [NullableContextAttribute("2")]
public bool MatchInlineAssignBlock(CallInstruction& call, ILInstruction& value);
    [NullableContextAttribute("2")]
public bool MatchIfAtEndOfBlock(ILInstruction& condition, ILInstruction& trueInst, ILInstruction& falseInst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.IL.BlockBuilder : object {
    private MethodBodyBlock body;
    private Dictionary`2<ExceptionRegion, ILVariable> variableByExceptionHandler;
    private ICompilation compilation;
    public bool CreateExtendedBlocks;
    private List`1<TryInstruction> tryInstructionList;
    private Dictionary`2<int, BlockContainer> handlerContainers;
    private int currentTryIndex;
    [NullableAttribute("2")]
private TryInstruction nextTry;
    [NullableAttribute("2")]
private BlockContainer currentContainer;
    private Stack`1<BlockContainer> containerStack;
    private Dictionary`2<TryCatch, OnErrorDispatch> onErrorDispatchers;
    public IEnumerable`1<ILVariable> OnErrorDispatcherVariables { get; }
    internal BlockBuilder(MethodBodyBlock body, Dictionary`2<ExceptionRegion, ILVariable> variableByExceptionHandler, ICompilation compilation);
    private void CreateContainerStructure();
    public void CreateBlocks(BlockContainer mainContainer, IEnumerable`1<Block> basicBlocks, CancellationToken cancellationToken);
    private void ConnectBranches(ILInstruction inst, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private Block FindBranchTarget(int targetILOffset);
    private Block CreateBranchTargetForOnErrorJump(TryCatch tryCatch, int targetILOffset);
    public IEnumerable`1<ILVariable> get_OnErrorDispatcherVariables();
    private void CreateOnErrorDispatchers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.BlockContainer : ILInstruction {
    public static SlotInfo BlockSlot;
    public InstructionCollection`1<Block> Blocks;
    [CompilerGeneratedAttribute]
private ContainerKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private StackType <ExpectedResultType>k__BackingField;
    private int leaveCount;
    [NullableAttribute("2")]
private Block entryPoint;
    public StackType ResultType { get; }
    public ContainerKind Kind { get; public set; }
    public StackType ExpectedResultType { get; public set; }
    public int LeaveCount { get; internal set; }
    public Block EntryPoint { get; private set; }
    public InstructionFlags DirectFlags { get; }
    public BlockContainer(ContainerKind kind, StackType expectedResultType);
    private static BlockContainer();
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public ContainerKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(ContainerKind value);
    [CompilerGeneratedAttribute]
public StackType get_ExpectedResultType();
    [CompilerGeneratedAttribute]
public void set_ExpectedResultType(StackType value);
    public int get_LeaveCount();
    internal void set_LeaveCount(int value);
    public Block get_EntryPoint();
    private void set_EntryPoint(Block value);
    public virtual ILInstruction Clone();
    protected internal virtual void InstructionCollectionUpdateComplete();
    protected virtual void Connected();
    protected virtual void Disconnected();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    protected virtual int GetChildCount();
    protected virtual ILInstruction GetChild(int index);
    [NullableContextAttribute("2")]
protected virtual void SetChild(int index, ILInstruction value);
    protected virtual SlotInfo GetChildSlot(int index);
    internal virtual void CheckInvariant(ILPhase phase);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    internal virtual bool CanInlineIntoSlot(int childIndex, ILInstruction expressionBeingMoved);
    internal virtual bool PrepareExtract(int childIndex, ExtractionContext ctx);
    public List`1<Block> TopologicalSort(bool deleteUnreachableBlocks);
    public void SortBlocks(bool deleteUnreachableBlocks);
    [NullableContextAttribute("2")]
public static BlockContainer FindClosestContainer(ILInstruction inst);
    [NullableContextAttribute("2")]
public static BlockContainer FindClosestSwitchContainer(ILInstruction inst);
    [NullableContextAttribute("2")]
public bool MatchConditionBlock(Block block, ILInstruction& condition, Block& bodyStartBlock);
    public bool MatchIncrementBlock(Block block);
    public ILInstruction SingleInstruction();
    [CompilerGeneratedAttribute]
private void <TopologicalSort>g__Visit|40_0(Block block, <>c__DisplayClass40_0& );
}
public enum ICSharpCode.Decompiler.IL.BlockKind : Enum {
    public int value__;
    public static BlockKind ControlFlow;
    public static BlockKind ArrayInitializer;
    public static BlockKind CollectionInitializer;
    public static BlockKind ObjectInitializer;
    public static BlockKind StackAllocInitializer;
    public static BlockKind CallInlineAssign;
    public static BlockKind CallWithNamedArgs;
    public static BlockKind DeconstructionConversions;
    public static BlockKind DeconstructionAssignments;
    public static BlockKind WithInitializer;
    public static BlockKind InterpolatedString;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Box : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Box(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Branch : SimpleInstruction {
    private int targetILOffset;
    [NullableAttribute("2")]
private Block targetBlock;
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public int TargetILOffset { get; }
    public Block TargetBlock { get; public set; }
    public BlockContainer TargetContainer { get; }
    public string TargetLabel { get; }
    public bool TriggersFinallyBlock { get; }
    public Branch(int targetILOffset);
    public Branch(Block targetBlock);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public int get_TargetILOffset();
    public Block get_TargetBlock();
    public void set_TargetBlock(Block value);
    public sealed virtual BlockContainer get_TargetContainer();
    protected virtual void Connected();
    protected virtual void Disconnected();
    public string get_TargetLabel();
    public bool get_TriggersFinallyBlock();
    [NullableContextAttribute("2")]
internal static bool GetExecutesFinallyBlock(ILInstruction inst, BlockContainer container);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Call : CallInstruction {
    public bool IsLifted { get; }
    public StackType UnderlyingResultType { get; }
    public Call(IMethod method);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    public sealed virtual bool get_IsLifted();
    public sealed virtual StackType get_UnderlyingResultType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.CallIndirect : ILInstruction {
    public static SlotInfo FunctionPointerSlot;
    public static SlotInfo ArgumentSlot;
    private ILInstruction functionPointer;
    public InstructionCollection`1<ILInstruction> Arguments;
    [CompilerGeneratedAttribute]
private bool <IsInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExplicitThis>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionPointerType <FunctionPointerType>k__BackingField;
    public bool IsInstance { get; }
    public bool HasExplicitThis { get; }
    public FunctionPointerType FunctionPointerType { get; }
    public ILInstruction FunctionPointer { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public CallIndirect(bool isInstance, bool hasExplicitThis, FunctionPointerType functionPointerType, ILInstruction functionPointer, IEnumerable`1<ILInstruction> arguments);
    private static CallIndirect();
    [CompilerGeneratedAttribute]
public bool get_IsInstance();
    [CompilerGeneratedAttribute]
public bool get_HasExplicitThis();
    [CompilerGeneratedAttribute]
public FunctionPointerType get_FunctionPointerType();
    public ILInstruction get_FunctionPointer();
    public void set_FunctionPointer(ILInstruction value);
    public virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    protected virtual int GetChildCount();
    protected virtual ILInstruction GetChild(int index);
    protected virtual void SetChild(int index, ILInstruction value);
    protected virtual SlotInfo GetChildSlot(int index);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    private bool EqualSignature(CallIndirect other);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.CallInstruction : ILInstruction {
    public static SlotInfo ArgumentsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Arguments>k__BackingField;
    public IMethod Method;
    public bool IsTail;
    [NullableAttribute("2")]
public IType ConstrainedTo;
    public bool ILStackWasEmpty;
    public InstructionCollection`1<ILInstruction> Arguments { get; private set; }
    public InstructionFlags DirectFlags { get; }
    public bool IsInstanceCall { get; }
    public StackType ResultType { get; }
    protected CallInstruction(OpCode opCode, IMethod method);
    private static CallInstruction();
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public static CallInstruction Create(OpCode opCode, IMethod method);
    public bool get_IsInstanceCall();
    [NullableContextAttribute("2")]
public IParameter GetParameter(int argumentIndex);
    public virtual StackType get_ResultType();
    internal static StackType ExpectedTypeForThisPointer(IType type);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    [NullableContextAttribute("2")]
protected internal sealed virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.CallVirt : CallInstruction {
    public CallVirt(IMethod method);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.CastClass : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public CastClass(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Ckfinite : UnaryInstruction {
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Ckfinite(ILInstruction argument);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Comp : BinaryInstruction {
    private ComparisonKind kind;
    public ComparisonLiftingKind LiftingKind;
    public StackType InputType;
    public Sign Sign;
    public ComparisonKind Kind { get; public set; }
    public StackType ResultType { get; }
    public bool IsLifted { get; }
    public StackType UnderlyingResultType { get; }
    public Comp(ComparisonKind kind, Sign sign, ILInstruction left, ILInstruction right);
    public Comp(ComparisonKind kind, ComparisonLiftingKind lifting, StackType inputType, Sign sign, ILInstruction left, ILInstruction right);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public ComparisonKind get_Kind();
    public void set_Kind(ComparisonKind value);
    public virtual StackType get_ResultType();
    public sealed virtual bool get_IsLifted();
    public sealed virtual StackType get_UnderlyingResultType();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public static Comp LogicNot(ILInstruction arg);
    public static Comp LogicNot(ILInstruction arg, bool isLifted);
}
public enum ICSharpCode.Decompiler.IL.ComparisonKind : Enum {
    public byte value__;
    public static ComparisonKind Equality;
    public static ComparisonKind Inequality;
    public static ComparisonKind LessThan;
    public static ComparisonKind LessThanOrEqual;
    public static ComparisonKind GreaterThan;
    public static ComparisonKind GreaterThanOrEqual;
}
[ExtensionAttribute]
internal static class ICSharpCode.Decompiler.IL.ComparisonKindExtensions : object {
    [ExtensionAttribute]
public static bool IsEqualityOrInequality(ComparisonKind kind);
    [ExtensionAttribute]
public static ComparisonKind Negate(ComparisonKind kind);
    [ExtensionAttribute]
public static BinaryOperatorType ToBinaryOperatorType(ComparisonKind kind);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetToken(ComparisonKind kind);
}
public enum ICSharpCode.Decompiler.IL.ComparisonLiftingKind : Enum {
    public int value__;
    public static ComparisonLiftingKind None;
    public static ComparisonLiftingKind CSharp;
    public static ComparisonLiftingKind ThreeValuedLogic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.CompoundAssignmentInstruction : ILInstruction {
    public static SlotInfo TargetSlot;
    private ILInstruction target;
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    public CompoundEvalMode EvalMode;
    public CompoundTargetKind TargetKind;
    public ILInstruction Target { get; public set; }
    public ILInstruction Value { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public CompoundAssignmentInstruction(OpCode opCode, CompoundEvalMode evalMode, ILInstruction target, CompoundTargetKind targetKind, ILInstruction value);
    private static CompoundAssignmentInstruction();
    public ILInstruction get_Target();
    public void set_Target(ILInstruction value);
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    internal virtual void CheckInvariant(ILPhase phase);
    [ConditionalAttribute("DEBUG")]
private void CheckValidTarget();
    protected void WriteSuffix(ITextOutput output);
}
public enum ICSharpCode.Decompiler.IL.CompoundEvalMode : Enum {
    public byte value__;
    public static CompoundEvalMode EvaluatesToOldValue;
    public static CompoundEvalMode EvaluatesToNewValue;
}
public enum ICSharpCode.Decompiler.IL.CompoundTargetKind : Enum {
    public byte value__;
    public static CompoundTargetKind Address;
    public static CompoundTargetKind Property;
    public static CompoundTargetKind Dynamic;
}
public enum ICSharpCode.Decompiler.IL.ContainerKind : Enum {
    public int value__;
    public static ContainerKind Normal;
    public static ContainerKind Loop;
    public static ContainerKind Switch;
    public static ContainerKind While;
    public static ContainerKind DoWhile;
    public static ContainerKind For;
}
public class ICSharpCode.Decompiler.IL.ControlFlow.AsyncAwaitDecompiler : object {
    private ILTransformContext context;
    private IType taskType;
    private IType underlyingReturnType;
    private AsyncMethodType methodType;
    private ITypeDefinition stateMachineType;
    private IType builderType;
    private IField builderField;
    private IField stateField;
    private int initialState;
    private Dictionary`2<IField, ILVariable> fieldToParameterMap;
    private Dictionary`2<ILVariable, ILVariable> cachedFieldToParameterMap;
    private IField disposeModeField;
    private ILFunction moveNextFunction;
    private ILVariable cachedStateVar;
    private TryCatch mainTryCatch;
    private Block setResultReturnBlock;
    private int finalState;
    private bool finalStateKnown;
    private ILVariable resultVar;
    private Block setResultYieldBlock;
    private ILVariable doFinallyBodies;
    private int smallestAwaiterVarIndex;
    private HashSet`1<Leave> moveNextLeaves;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Block, ValueTuple`2<ILVariable, IField>> awaitBlocks;
    private bool isVisualBasicStateMachine;
    private int catchHandlerOffset;
    private List`1<Await> awaitDebugInfos;
    private bool IsAsyncEnumerator { get; }
    internal static bool IsCompilerGeneratedStateMachine(TypeDefinitionHandle type, MetadataReader metadata);
    internal static bool IsCompilerGeneratedMainMethod(PEFile module, MethodDefinitionHandle method);
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private void CleanUpBodyOfMoveNext(ILFunction function);
    private bool MatchTaskCreationPattern(ILFunction function);
    private bool IsPotentialVisualBasicStateMachineInitialiation(ILInstruction inst, ILVariable stateMachineVar);
    private bool MatchVisualBasicStateMachineFieldAssignements(IList`1<ILInstruction> body, ILVariable stateMachineVar);
    private static bool MatchCall(ILInstruction inst, string name, InstructionCollection`1& args);
    private static bool MatchStFld(ILInstruction stfld, ILVariable stateMachineVar, IField& field, ILInstruction& value);
    private bool MatchAsyncEnumeratorCreationPattern(ILFunction function);
    private static bool MatchEnumeratorCreationNewObj(ILInstruction inst, ILTransformContext context, Int32& initialState, ITypeDefinition& stateMachineType);
    public static bool IsCompilerGeneratorAsyncEnumerator(TypeDefinitionHandle type, MetadataReader metadata);
    private static void AnalyzeEnumeratorCtor(IMethod ctor, ILTransformContext context, IField& builderField, IType& builderType, IField& stateField);
    private void ResolveIEnumerableIEnumeratorFieldMapping();
    private void AnalyzeMoveNext();
    private bool get_IsAsyncEnumerator();
    private bool MatchYieldBlock(BlockContainer blockContainer, int pos);
    private Block CheckSetResultReturnBlock(BlockContainer blockContainer, int setResultReturnBlockIndex, Boolean[] blocksAnalyzed);
    private bool MatchDisposeCombinedTokens(BlockContainer blockContainer, ILInstruction condition, ILInstruction trueInst, ILInstruction falseInst, Boolean[] blocksAnalyzed, Block& setResultAndExitBlock);
    private void MatchHoistedLocalCleanup(Block block, Int32& pos);
    private void CheckSetResultAndExit(BlockContainer blockContainer, Block block, Int32& pos);
    private void ValidateCatchBlock();
    private void MatchCompleteCall(Block block, Int32& pos);
    private bool IsBuilderFieldOnThis(ILInstruction inst);
    private bool IsBuilderOrPromiseFieldOnThis(ILInstruction inst);
    private bool MatchStateAssignment(ILInstruction inst, Int32& newState);
    private void AnalyzeDisposeAsync();
    private void InlineBodyOfMoveNext(ILFunction function);
    private void FinalizeInlineMoveNext(ILFunction function);
    private void AnalyzeStateMachine(ILFunction function);
    private bool TransformYieldBreak(Block block);
    private ILInstruction FindYieldBreakTarget(Block block);
    private bool SimplifyIfDisposeMode(Block block);
    private bool AnalyzeAwaitBlock(Block block, ILVariable& awaiter, IField& awaiterField, Int32& state, Int32& yieldOffset);
    private static ILInstruction StackSlotValue(ILInstruction inst);
    private bool AnalyzeYieldReturn(Block block, ILInstruction& yieldValue, Int32& newState);
    private bool MatchCurrentAssignment(ILInstruction inst, ILInstruction& value);
    private void DetectAwaitPattern(ILFunction function);
    private void DetectAwaitPattern(Block block);
    private static ILInstruction UnwrapConvUnknown(ILInstruction inst);
    private bool CheckAwaitBlock(Block block, Block& resumeBlock, IField& stackField);
    private bool CheckResumeBlock(Block block, ILVariable awaiterVar, IField awaiterField, Block completedBlock, IField stackField);
    private bool RestoreStack(Block block, Int32& pos, IField stackField);
    private void CleanDoFinallyBodies(ILFunction function);
    internal static Block GetBodyEntryPoint(BlockContainer body);
    private void TranslateCachedFieldsToLocals();
    [CompilerGeneratedAttribute]
private bool <CleanUpBodyOfMoveNext>b__31_1(StLoc s);
    [CompilerGeneratedAttribute]
private bool <SimplifyIfDisposeMode>g__MatchLdDisposeMode|61_0(ILInstruction inst);
    [CompilerGeneratedAttribute]
private bool <CheckResumeBlock>g__MatchStoreToAwaiterVariable|70_0(ILInstruction instr, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
private void <CheckResumeBlock>g__MatchResetAwaiterField|70_1(Block block, Int32& pos, <>c__DisplayClass70_0& );
    [CompilerGeneratedAttribute]
private bool <CheckResumeBlock>g__MatchStateFieldAssignement|70_2(Block block, Int32& pos, <>c__DisplayClass70_0& );
}
internal class ICSharpCode.Decompiler.IL.ControlFlow.AwaitInCatchTransform : object {
    public static void Run(ILFunction function, ILTransformContext context);
    private static void TransformAsyncThrowToThrow(ILTransformContext context, HashSet`1<Block> removedBlocks, Block block);
    private static void MoveBlock(Block block, BlockContainer target);
    private static bool AnalyzeHandlers(InstructionCollection`1<TryCatchHandler> handlers, ILVariable& catchHandlerIdentifier, List`1& transformableCatchBlocks);
    private static bool MatchAwaitCatchHandler(TryCatchHandler handler, Int32& id, ILVariable& identifierVariable, Block& realEntryPoint, ILInstruction& nextBlockOrExitContainer, ILInstruction& jumpTableEntry, ILVariable& objectVariable);
    internal static bool MatchExceptionCaptureBlock(ILTransformContext context, Block block, ILVariable& objectVariable, StLoc& typedExceptionVariableStore, Block& captureBlock, Block& throwBlock);
    [CompilerGeneratedAttribute]
internal static bool <MatchAwaitCatchHandler>g__ParseSwitchJumpTable|5_0(int id, SwitchInstruction jumpTable, ILVariable identifierVariable, Block& realEntryPoint, ILInstruction& nextBlockOrExitContainer, ILInstruction& jumpTableEntry);
    [CompilerGeneratedAttribute]
internal static bool <MatchAwaitCatchHandler>g__ParseIfJumpTable|5_1(int id, Block jumpTableEntryBlock, ILVariable identifierVariable, Block& realEntryPoint, ILInstruction& nextBlockOrExitContainer, ILInstruction& jumpTableEntry);
    [CompilerGeneratedAttribute]
internal static bool <MatchExceptionCaptureBlock>g__DerivesFromException|6_0(IType t);
    [CompilerGeneratedAttribute]
internal static bool <MatchExceptionCaptureBlock>g__MatchCaptureThrowCalls|6_1(ILInstruction inst, <>c__DisplayClass6_0& );
}
internal class ICSharpCode.Decompiler.IL.ControlFlow.AwaitInFinallyTransform : object {
    public static void Run(ILFunction function, ILTransformContext context);
    private static bool ValidateStateVariable(ILVariable stateVariable, StLoc initializer, TryCatch tryCatch, Block entryPointOfFinally);
    private static ValueTuple`3<Block, Block, ILVariable> FindBlockAfterFinally(ILTransformContext context, Block block, ILVariable objectVariable);
    [CompilerGeneratedAttribute]
internal static void <Run>g__MoveDominatedBlocksToContainer|0_0(Block newEntryPoint, Block endBlock, ControlFlowGraph graph, BlockContainer targetContainer);
    [CompilerGeneratedAttribute]
internal static void <Run>g__MoveBlock|0_1(Block block, BlockContainer target);
    [CompilerGeneratedAttribute]
internal static void <Run>g__SimplifyEndOfFinally|0_2(ILTransformContext context, ILVariable objectVariable, Block beforeExceptionCaptureBlock, ILVariable objectVariableCopy, BlockContainer finallyContainer);
}
public class ICSharpCode.Decompiler.IL.ControlFlow.ConditionDetection : object {
    private BlockTransformContext context;
    private ControlFlowNode cfgNode;
    private BlockContainer currentContainer;
    public sealed virtual void Run(Block block, BlockTransformContext context);
    private void HandleIfInstruction(Block block, IfInstruction ifInst);
    private bool InlineTrueBranch(Block block, IfInstruction ifInst);
    private bool InlineExitBranch(Block block);
    private bool CanInline(ILInstruction exitInst);
    private void MergeCommonBranches(Block block, IfInstruction ifInst);
    private void AddExits(ILInstruction searchInst, int startIndex, IList`1<ILInstruction> exits);
    private bool ProduceExit(ILInstruction searchInst, int startIndex, ILInstruction targetExit);
    private bool WillShortCircuit(Block block, IfInstruction ifInst, ILInstruction elseExit);
    private void InvertIf(Block block, IfInstruction ifInst);
    internal static void InvertIf(Block block, IfInstruction ifInst, ILTransformContext context);
    private void SwapEmptyThen(IfInstruction ifInst);
    private void IntroduceShortCircuit(IfInstruction ifInst);
    private void OrderIfBlocks(IfInstruction ifInst);
    public static int GetStartILOffset(ILInstruction inst, Boolean& isEmpty);
    private void PickBetterBlockExit(Block block, IfInstruction ifInst);
    private int CompareBlockExitPriority(ILInstruction exit1, ILInstruction exit2, bool strongly);
    private bool IsKeywordExit(ILInstruction exitInst, Keyword& keyword);
    private static bool TryGetExit(ILInstruction inst, ILInstruction& exitInst);
    private static ILInstruction GetExit(ILInstruction inst);
    private static bool IsEmpty(ILInstruction inst);
    private static bool IsContinueBlock(BlockContainer container, Block block);
    internal static Block ExtractBlock(Block block, int startIndex, int endIndex);
    [CompilerGeneratedAttribute]
internal static bool <WillShortCircuit>g__ThenInstIsSingleExit|12_0(ILInstruction inst);
}
public class ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowGraph : object {
    private BlockContainer container;
    internal ControlFlowNode[] cfg;
    private Dictionary`2<Block, ControlFlowNode> dict;
    private BitSet nodeHasDirectExitOutOfContainer;
    private BitSet nodeHasReachableExit;
    public BlockContainer Container { get; }
    public ControlFlowGraph(BlockContainer container, CancellationToken cancellationToken);
    public BlockContainer get_Container();
    private void CreateEdges(CancellationToken cancellationToken);
    private BitSet FindNodesWithExitsOutOfContainer();
    public ControlFlowNode GetNode(Block block);
    public bool HasReachableExit(ControlFlowNode node);
    public bool HasDirectExitOutOfContainer(ControlFlowNode node);
}
public class ICSharpCode.Decompiler.IL.ControlFlow.ControlFlowSimplification : object {
    internal bool aggressivelyDuplicateReturnBlocks;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static void RemoveNopInstructions(Block block);
    private static void RemoveDeadStackStores(Block block, ILTransformContext context);
    private void InlineVariableInReturnBlock(Block block, ILTransformContext context);
    private void SimplifyBranchChains(ILFunction function, ILTransformContext context);
    private void CleanUpEmptyBlocks(ILFunction function, ILTransformContext context);
    private bool IsBranchToReturnBlock(Branch branch);
    private static bool CombineBlockWithNextBlock(BlockContainer container, Block block, ILTransformContext context);
    private static bool IsDeadTrueStore(Block block);
    [CompilerGeneratedAttribute]
internal static bool <RemoveDeadStackStores>g__IsSimple|3_0(ILInstruction inst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ControlFlow.DetectExitPoints : ILVisitor {
    private static Nop ExitNotYetDetermined;
    private static Nop NoExit;
    private CancellationToken cancellationToken;
    private List`1<Block> blocksPotentiallyMadeUnreachable;
    private Stack`1<ContainerContext> containerStack;
    private static DetectExitPoints();
    internal static ILInstruction GetExit(ILInstruction inst);
    internal static bool CompatibleExitInstruction(ILInstruction exit1, ILInstruction exit2);
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static bool IsInfiniteLoop(Block block);
    protected virtual void Default(ILInstruction inst);
    protected internal virtual void VisitBlockContainer(BlockContainer container);
    private static ILInstruction ChooseExit(IEnumerable`1<ILInstruction> potentialExits);
    protected internal virtual void VisitBlock(Block block);
    protected internal virtual void VisitBranch(Branch inst);
    protected internal virtual void VisitLeave(Leave inst);
}
public class ICSharpCode.Decompiler.IL.ControlFlow.DetectPinnedRegions : object {
    private ILTransformContext context;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private void SplitBlocksAtWritesToPinnedLocals(BlockContainer container);
    private void DetectNullSafeArrayToPointerOrCustomRefPin(BlockContainer container);
    private bool IsCustomRefPinPattern(Block block, ILInstruction& ldlocMem, CallInstruction& callGPR, ILVariable& v, StLoc& ptrAssign, Block& targetBlock, Block& nullBlock, Block& notNullBlock);
    private bool IsNullSafeArrayToPointerPattern(Block block, ILVariable& v, ILVariable& p, Block& targetBlock);
    private bool IsNullSafeArrayToPointerNotNullBlock(Block block, ILVariable v, ILVariable p, Block nullOrEmptyBlock, Block targetBlock);
    private bool IsNullSafeArrayToPointerNotNullAndNotEmptyBlock(Block block, ILVariable v, ILVariable p, Block targetBlock);
    private bool IsNullSafeArrayToPointerNullOrEmptyBlock(Block block, ILVariable& p, Block& targetBlock);
    private bool DetectPinnedRegion(Block block);
    private bool CreatePinnedRegion(Block block, StLoc stLoc);
    private static bool IsNullOrZero(ILInstruction inst);
    private void ProcessPinnedRegion(PinnedRegion pinnedRegion);
    private void MoveArrayToPointerToPinnedRegionInit(PinnedRegion pinnedRegion);
    private void ReplacePinnedVar(ILVariable oldVar, ILVariable newVar, ILInstruction inst);
    private bool IsSlotAcceptingBothManagedAndUnmanagedPointers(SlotInfo slotInfo);
    private bool IsBranchOnNull(ILInstruction condBranch, ILVariable nativeVar, Block& targetBlock);
    private void HandleStringToPointer(PinnedRegion pinnedRegion);
    private bool IsOffsetToStringDataBlock(Block block, ILVariable nativeVar, Block targetBlock);
    private bool IsOffsetToStringDataCall(ILInstruction inst);
    private void UseExistingVariableForPinnedRegion(PinnedRegion pinnedRegion);
}
public class ICSharpCode.Decompiler.IL.ControlFlow.LoopDetection : object {
    private BlockTransformContext context;
    private BlockContainer currentBlockContainer;
    private bool isSwitch;
    private LoopContext loopContext;
    private static ControlFlowNode NoExitPoint;
    private static LoopDetection();
    public sealed virtual void Run(Block block, BlockTransformContext context);
    private void IncludeNestedContainers(List`1<ControlFlowNode> loop);
    private void ExtendLoop(ControlFlowNode loopHead, List`1<ControlFlowNode> loop, ControlFlowNode& exitPoint);
    internal ControlFlowNode FindExitPoint(ControlFlowNode loopHead, IReadOnlyList`1<ControlFlowNode> naturalLoop);
    private bool ValidateExitPoint(ControlFlowNode loopHead, ControlFlowNode exitPoint);
    private bool HasReachableExit(ControlFlowNode node);
    private IEnumerable`1<ControlFlowNode> DominatorTreeChildren(ControlFlowNode n, ControlFlowNode exitPoint);
    private void PickExitPoint(ControlFlowNode node, ControlFlowNode& exitPoint, Int32& exitPointILOffset);
    private static void ConsiderReturnAsExitPoint(Block block, ControlFlowNode& exitPoint, Int32& exitPointILOffset);
    private ControlFlowNode[] PrepareReverseCFG(ControlFlowNode loopHead, Int32& exitNodeArity);
    private static bool IsPossibleForeachLoop(Block loopHead, Branch& exitBranch);
    private void ExtendLoopHeuristic(ControlFlowNode loopHead, List`1<ControlFlowNode> loop, ControlFlowNode candidate);
    private bool IsExitPoint(ControlFlowNode node);
    private void ConstructLoop(List`1<ControlFlowNode> loop, ControlFlowNode exitPoint);
    private void MoveBlocksIntoContainer(List`1<ControlFlowNode> loop, BlockContainer loopContainer);
    private void DetectSwitchBody(Block block, SwitchInstruction switchInst);
    [CompilerGeneratedAttribute]
private void <IncludeNestedContainers>g__IncludeBlock|5_0(Block block, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <ValidateExitPoint>g__IsValid|9_0(ControlFlowNode node, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
private bool <ExtendLoopHeuristic>b__16_3(ControlFlowNode n);
}
internal class ICSharpCode.Decompiler.IL.ControlFlow.RemoveRedundantReturn : object {
    [NullableContextAttribute("1")]
public sealed virtual void Run(ILFunction function, ILTransformContext context);
    [NullableContextAttribute("2")]
private static bool ConvertReturnToFallthrough(ILInstruction inst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.IL.ControlFlow.StateRangeAnalysis : object {
    public CancellationToken CancellationToken;
    private StateRangeAnalysisMode mode;
    [NullableAttribute("2")]
private IField stateField;
    private bool legacyVisualBasic;
    private SymbolicEvaluationContext evalContext;
    private Dictionary`2<Block, LongSet> ranges;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<BlockContainer, LongSet> rangesForLeave;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<IMethod, LongSet> finallyMethodToStateRange;
    [NullableAttribute("2")]
internal ILVariable doFinallyBodies;
    [NullableAttribute("2")]
internal ILVariable skipFinallyBodies;
    public IEnumerable`1<ILVariable> CachedStateVars { get; }
    [NullableContextAttribute("2")]
public StateRangeAnalysis(StateRangeAnalysisMode mode, IField stateField, ILVariable cachedStateVar, bool legacyVisualBasic);
    public IEnumerable`1<ILVariable> get_CachedStateVars();
    internal StateRangeAnalysis CreateNestedAnalysis();
    public LongSet AssignStateRanges(ILInstruction inst, LongSet stateRange);
    private void AddStateRange(Block block, LongSet stateRange);
    private void AddStateRangeForLeave(BlockContainer target, LongSet stateRange);
    public LongDict`1<Block> GetBlockStateSetMapping(BlockContainer container);
    public LongDict`1<BlockContainer> GetBlockStateSetMappingForLeave();
}
internal enum ICSharpCode.Decompiler.IL.ControlFlow.StateRangeAnalysisMode : Enum {
    public int value__;
    public static StateRangeAnalysisMode IteratorMoveNext;
    public static StateRangeAnalysisMode IteratorDispose;
    public static StateRangeAnalysisMode AsyncMoveNext;
    public static StateRangeAnalysisMode AwaitInFinally;
}
internal class ICSharpCode.Decompiler.IL.ControlFlow.SwitchAnalysis : object {
    private ILVariable switchVar;
    [CompilerGeneratedAttribute]
private bool <ContainsILSwitch>k__BackingField;
    public List`1<KeyValuePair`2<LongSet, ILInstruction>> Sections;
    private Dictionary`2<Block, int> targetBlockToSectionIndex;
    private Dictionary`2<BlockContainer, int> targetContainerToSectionIndex;
    public List`1<Block> InnerBlocks;
    [CompilerGeneratedAttribute]
private Block <RootBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnreachableCases>k__BackingField;
    public ILVariable SwitchVariable { get; }
    public bool ContainsILSwitch { get; private set; }
    public Block RootBlock { get; private set; }
    public bool AllowUnreachableCases { get; public set; }
    public ILVariable get_SwitchVariable();
    [CompilerGeneratedAttribute]
public bool get_ContainsILSwitch();
    [CompilerGeneratedAttribute]
private void set_ContainsILSwitch(bool value);
    [CompilerGeneratedAttribute]
public Block get_RootBlock();
    [CompilerGeneratedAttribute]
private void set_RootBlock(Block value);
    [CompilerGeneratedAttribute]
public bool get_AllowUnreachableCases();
    [CompilerGeneratedAttribute]
public void set_AllowUnreachableCases(bool value);
    public bool AnalyzeBlock(Block block);
    private bool AnalyzeBlock(Block block, LongSet inputValues, bool tailOnly);
    private bool AnalyzeSwitch(SwitchInstruction inst, LongSet inputValues);
    private void AddSection(LongSet values, ILInstruction inst);
    private bool MatchSwitchVar(ILInstruction inst);
    private bool MatchSwitchVar(ILInstruction inst, Int64& sub);
    private bool AnalyzeCondition(ILInstruction condition, LongSet& trueValues);
    internal static LongSet MakeSetWhereComparisonIsTrue(ComparisonKind kind, long val, Sign sign);
    private static LongSet MakeGreaterThanOrEqualSet(long val, Sign sign);
    private static LongSet MakeLessThanOrEqualSet(long val, Sign sign);
}
public class ICSharpCode.Decompiler.IL.ControlFlow.SwitchDetection : object {
    private SwitchAnalysis analysis;
    private ILTransformContext context;
    private BlockContainer currentContainer;
    private ControlFlowGraph controlFlowGraph;
    private LoopContext loopContext;
    private static ulong MaxValuesPerSection;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private void ProcessBlock(Block block, Boolean& blockContainerNeedsCleanup);
    internal static void SimplifySwitchInstruction(Block block, ILTransformContext context);
    private static void SortSwitchSections(SwitchInstruction sw);
    private static void AdjustLabels(SwitchInstruction sw, ILTransformContext context);
    private bool UseCSharpSwitch(KeyValuePair`2& defaultSection);
    private bool MatchRoslynSwitchOnString();
    private ValueTuple`2<List`1<ControlFlowNode>, List`1<ControlFlowNode>> AnalyzeControlFlow();
    private bool SwitchUsesGoto(List`1<ControlFlowNode> flowNodes, List`1<ControlFlowNode> caseNodes, Block& breakBlock);
    private void AddNullCase(List`1<ControlFlowNode> flowNodes, List`1<ControlFlowNode> caseNodes);
    private static bool IsShortCircuit(ControlFlowNode parent, int side);
    private static bool IsFlowNode(ControlFlowNode n);
    private bool IsSingleCondition(List`1<ControlFlowNode> flowNodes, List`1<ControlFlowNode> caseNodes);
    private static void ResetVisited(IEnumerable`1<ControlFlowNode> nodes);
}
internal class ICSharpCode.Decompiler.IL.ControlFlow.SymbolicAnalysisFailedException : Exception {
    public SymbolicAnalysisFailedException(string message);
}
internal class ICSharpCode.Decompiler.IL.ControlFlow.SymbolicEvaluationContext : object {
    private IField stateField;
    private bool legacyVisualBasic;
    private List`1<ILVariable> stateVariables;
    private static SymbolicValue Failed;
    public IEnumerable`1<ILVariable> StateVariables { get; }
    public SymbolicEvaluationContext(IField stateField, bool legacyVisualBasic);
    private static SymbolicEvaluationContext();
    public void AddStateVariable(ILVariable v);
    public IEnumerable`1<ILVariable> get_StateVariables();
    public SymbolicValue Eval(ILInstruction inst);
}
internal class ICSharpCode.Decompiler.IL.ControlFlow.SymbolicValue : ValueType {
    public int Constant;
    public SymbolicValueType Type;
    public LongSet ValueSet;
    public SymbolicValue(SymbolicValueType type, int constant);
    public SymbolicValue(SymbolicValueType type, LongSet valueSet);
    public SymbolicValue AsBool();
    public virtual string ToString();
}
internal enum ICSharpCode.Decompiler.IL.ControlFlow.SymbolicValueType : Enum {
    public int value__;
    public static SymbolicValueType Unknown;
    public static SymbolicValueType IntegerConstant;
    public static SymbolicValueType State;
    public static SymbolicValueType This;
    public static SymbolicValueType StateInSet;
}
public class ICSharpCode.Decompiler.IL.ControlFlow.YieldReturnDecompiler : object {
    private ILTransformContext context;
    private MetadataReader metadata;
    private TypeDefinitionHandle currentType;
    private TypeDefinitionHandle enumeratorType;
    private MethodDefinitionHandle enumeratorCtor;
    private bool isCompiledWithMono;
    private bool isCompiledWithVisualBasic;
    private bool isCompiledWithLegacyVisualBasic;
    private MethodDefinitionHandle disposeMethod;
    private IField stateField;
    private IField currentField;
    private IField disposingField;
    private Dictionary`2<IField, ILVariable> fieldToParameterMap;
    private Dictionary`2<IMethod, LongSet> finallyMethodToStateRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IMethod, ValueTuple`2<Nullable`1<int>, ILFunction>> decompiledFinallyMethods;
    private List`1<StLoc> returnStores;
    private ILVariable skipFinallyBodies;
    private ILVariable doFinallyBodies;
    private HashSet`1<ILVariable> cachedStateVars;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private bool MatchEnumeratorCreationPattern(ILFunction function);
    internal static Block SingleBlock(ILInstruction body);
    private bool MatchEnumeratorCreationNewObj(ILInstruction inst);
    internal static bool MatchEnumeratorCreationNewObj(ILInstruction inst, MetadataReader metadata, TypeDefinitionHandle currentType, MethodDefinitionHandle& enumeratorCtor, TypeDefinitionHandle& enumeratorType);
    private bool MatchMonoEnumeratorCreationNewObj(ILInstruction inst);
    public static bool IsCompilerGeneratorEnumerator(TypeDefinitionHandle type, MetadataReader metadata);
    private void AnalyzeCtor();
    internal static ILFunction CreateILAst(MethodDefinitionHandle method, ILTransformContext context);
    private void AnalyzeCurrentProperty();
    private void ResolveIEnumerableIEnumeratorFieldMapping();
    internal static void ResolveIEnumerableIEnumeratorFieldMapping(MethodDefinitionHandle getEnumeratorMethod, ILTransformContext context, Dictionary`2<IField, ILVariable> fieldToParameterMap);
    private void ConstructExceptionTable();
    [ConditionalAttribute("DEBUG")]
private void PrintFinallyMethodStateRanges(BlockContainer bc);
    private BlockContainer AnalyzeMoveNext(ILFunction function);
    private void PropagateCopiesOfFields(BlockContainer body);
    private BlockContainer ConvertBody(BlockContainer oldBody, StateRangeAnalysis rangeAnalysis);
    internal static void TranslateFieldsToLocalAccess(ILFunction function, ILInstruction inst, Dictionary`2<IField, ILVariable> fieldToVariableMap, bool isCompiledWithMono);
    private void DecompileFinallyBlocks();
    private void ReconstructTryFinallyBlocks(ILFunction iteratorFunction);
    private bool IsStateAssignment(ILInstruction inst);
    private Nullable`1<int> GetNewState(Block block);
    private void CleanSkipFinallyBodies(ILFunction function);
    private void CleanDoFinallyBodies(ILFunction function);
    private void CleanFinallyStateChecks(ILFunction function);
    private bool IsMethod(MethodDefinitionHandle method, string name);
    [CompilerGeneratedAttribute]
private bool <AnalyzeCurrentProperty>b__28_0(MethodDefinitionHandle m);
    [CompilerGeneratedAttribute]
private bool <ResolveIEnumerableIEnumeratorFieldMapping>b__29_0(MethodDefinitionHandle m);
    [CompilerGeneratedAttribute]
private bool <ConstructExceptionTable>b__31_0(MethodDefinitionHandle m);
    [CompilerGeneratedAttribute]
private bool <AnalyzeMoveNext>b__33_0(MethodDefinitionHandle m);
    [CompilerGeneratedAttribute]
private void <ConvertBody>g__ConvertBranchAfterYieldReturn|35_0(Block newBlock, Block oldBlock, int pos, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
private Block <ConvertBody>g__SplitBlock|35_1(Block newBlock, ILInstruction oldInst, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
private ILInstruction <ConvertBody>g__MakeGoTo|35_2(int v, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
private void <ConvertBody>g__UpdateBranchTargets|35_3(ILInstruction inst, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
private bool <CleanSkipFinallyBodies>g__IsCallToMonoFinallyMethod|41_0(Call call, IMethod& finallyMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Conv : UnaryInstruction {
    public ConversionKind Kind;
    public bool CheckForOverflow;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    public StackType InputType;
    public Sign InputSign;
    public PrimitiveType TargetType;
    public bool IsLifted { get; }
    public StackType ResultType { get; }
    public StackType UnderlyingResultType { get; }
    public Conv(ILInstruction argument, PrimitiveType targetType, bool checkForOverflow, Sign inputSign);
    public Conv(ILInstruction argument, StackType inputType, Sign inputSign, PrimitiveType targetType, bool checkForOverflow, bool isLifted);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    internal virtual void CheckInvariant(ILPhase phase);
    private static ConversionKind GetConversionKind(PrimitiveType targetType, StackType inputType, Sign inputSign);
    public virtual StackType get_ResultType();
    public sealed virtual StackType get_UnderlyingResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    protected virtual InstructionFlags ComputeFlags();
    public virtual ILInstruction UnwrapConv(ConversionKind kind);
}
public enum ICSharpCode.Decompiler.IL.ConversionKind : Enum {
    public byte value__;
    public static ConversionKind Invalid;
    public static ConversionKind Nop;
    public static ConversionKind IntToFloat;
    public static ConversionKind FloatToInt;
    public static ConversionKind FloatPrecisionChange;
    public static ConversionKind SignExtend;
    public static ConversionKind ZeroExtend;
    public static ConversionKind Truncate;
    public static ConversionKind StopGCTracking;
    public static ConversionKind StartGCTracking;
    public static ConversionKind ObjectInterior;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Cpblk : ILInstruction {
    public static SlotInfo DestAddressSlot;
    private ILInstruction destAddress;
    public static SlotInfo SourceAddressSlot;
    private ILInstruction sourceAddress;
    public static SlotInfo SizeSlot;
    private ILInstruction size;
    [CompilerGeneratedAttribute]
private bool <IsVolatile>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnalignedPrefix>k__BackingField;
    public ILInstruction DestAddress { get; public set; }
    public ILInstruction SourceAddress { get; public set; }
    public ILInstruction Size { get; public set; }
    public bool IsVolatile { get; public set; }
    public byte UnalignedPrefix { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Cpblk(ILInstruction destAddress, ILInstruction sourceAddress, ILInstruction size);
    private static Cpblk();
    public ILInstruction get_DestAddress();
    public void set_DestAddress(ILInstruction value);
    public ILInstruction get_SourceAddress();
    public void set_SourceAddress(ILInstruction value);
    public ILInstruction get_Size();
    public void set_Size(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVolatile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsVolatile(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual byte get_UnalignedPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UnalignedPrefix(byte value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.CSharpArgumentInfo : ValueType {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfoFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <CompileTimeType>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    public CSharpArgumentInfoFlags Flags { get; public set; }
    public IType CompileTimeType { get; public set; }
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CSharpArgumentInfoFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(CSharpArgumentInfoFlags value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IType get_CompileTimeType();
    [CompilerGeneratedAttribute]
public void set_CompileTimeType(IType value);
    public bool HasFlag(CSharpArgumentInfoFlags flag);
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.IL.CSharpArgumentInfoFlags : Enum {
    public int value__;
    public static CSharpArgumentInfoFlags None;
    public static CSharpArgumentInfoFlags UseCompileTimeType;
    public static CSharpArgumentInfoFlags Constant;
    public static CSharpArgumentInfoFlags NamedArgument;
    public static CSharpArgumentInfoFlags IsRef;
    public static CSharpArgumentInfoFlags IsOut;
    public static CSharpArgumentInfoFlags IsStaticType;
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.IL.CSharpBinderFlags : Enum {
    public int value__;
    public static CSharpBinderFlags None;
    public static CSharpBinderFlags CheckedContext;
    public static CSharpBinderFlags InvokeSimpleName;
    public static CSharpBinderFlags InvokeSpecialName;
    public static CSharpBinderFlags BinaryOperationLogical;
    public static CSharpBinderFlags ConvertExplicit;
    public static CSharpBinderFlags ConvertArrayIndex;
    public static CSharpBinderFlags ResultIndexed;
    public static CSharpBinderFlags ValueFromCompoundAssignment;
    public static CSharpBinderFlags ResultDiscarded;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DebugBreak : SimpleInstruction {
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
public class ICSharpCode.Decompiler.IL.DeconstructInstruction : ILInstruction {
    public static SlotInfo InitSlot;
    public static SlotInfo PatternSlot;
    public static SlotInfo ConversionsSlot;
    public static SlotInfo AssignmentsSlot;
    public InstructionCollection`1<StLoc> Init;
    private MatchInstruction pattern;
    private Block conversions;
    private Block assignments;
    public MatchInstruction Pattern { get; public set; }
    public Block Conversions { get; public set; }
    public Block Assignments { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public StackType ResultType { get; }
    private static DeconstructInstruction();
    public MatchInstruction get_Pattern();
    public void set_Pattern(MatchInstruction value);
    public Block get_Conversions();
    public void set_Conversions(Block value);
    public Block get_Assignments();
    public void set_Assignments(Block value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    protected internal virtual void InstructionCollectionUpdateComplete();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    internal static bool IsConversionStLoc(ILInstruction inst, ILVariable& variable, ILVariable& inputVariable);
    internal static bool IsAssignment(ILInstruction inst, ICompilation typeSystem, IType& expectedType, ILInstruction& value);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    [NullableContextAttribute("1")]
public virtual void AcceptVisitor(ILVisitor visitor);
    [NullableContextAttribute("1")]
public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    [NullableContextAttribute("1")]
public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
internal static void <CheckInvariant>g__ValidatePattern|30_0(MatchInstruction inst, <>c__DisplayClass30_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DeconstructResultInstruction : UnaryInstruction {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private StackType <ResultType>k__BackingField;
    public int Index { get; }
    public StackType ResultType { get; }
    public DeconstructResultInstruction(int index, StackType resultType, ILInstruction argument);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    [NullableContextAttribute("2")]
private MatchInstruction FindMatch();
    private void AdditionalInvariants();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DefaultValue : SimpleInstruction {
    public bool ILStackWasEmpty;
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public DefaultValue(IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicBinaryOperatorInstruction : DynamicInstruction {
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <LeftArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <RightArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    public static SlotInfo LeftSlot;
    private ILInstruction left;
    public static SlotInfo RightSlot;
    private ILInstruction right;
    public CSharpArgumentInfo LeftArgumentInfo { get; }
    public CSharpArgumentInfo RightArgumentInfo { get; }
    public ExpressionType Operation { get; }
    public StackType ResultType { get; }
    public ILInstruction Left { get; public set; }
    public ILInstruction Right { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicBinaryOperatorInstruction(CSharpBinderFlags binderFlags, ExpressionType operation, IType context, CSharpArgumentInfo leftArgumentInfo, ILInstruction left, CSharpArgumentInfo rightArgumentInfo, ILInstruction right);
    private static DynamicBinaryOperatorInstruction();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_LeftArgumentInfo();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_RightArgumentInfo();
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    public ILInstruction get_Left();
    public void set_Left(ILInstruction value);
    public ILInstruction get_Right();
    public void set_Right(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicCompoundAssign : CompoundAssignmentInstruction {
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <TargetArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <ValueArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpBinderFlags <BinderFlags>k__BackingField;
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public ExpressionType Operation { get; }
    public CSharpArgumentInfo TargetArgumentInfo { get; }
    public CSharpArgumentInfo ValueArgumentInfo { get; }
    public CSharpBinderFlags BinderFlags { get; }
    public DynamicCompoundAssign(ExpressionType op, CSharpBinderFlags binderFlags, ILInstruction target, CSharpArgumentInfo targetArgumentInfo, ILInstruction value, CSharpArgumentInfo valueArgumentInfo, CompoundTargetKind targetKind);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_TargetArgumentInfo();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_ValueArgumentInfo();
    [CompilerGeneratedAttribute]
public CSharpBinderFlags get_BinderFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    internal static bool IsExpressionTypeSupported(ExpressionType type);
    private static CompoundEvalMode CompoundEvalModeFromOperation(ExpressionType op);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicConvertInstruction : DynamicInstruction {
    private IType type;
    public static SlotInfo ArgumentSlot;
    private ILInstruction argument;
    public StackType ResultType { get; }
    public bool IsChecked { get; }
    public bool IsExplicit { get; }
    public IType Type { get; public set; }
    public ILInstruction Argument { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicConvertInstruction(CSharpBinderFlags binderFlags, IType type, IType context, ILInstruction argument);
    private static DynamicConvertInstruction();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    protected internal virtual bool PerformMatch(ListMatch& listMatch, Match& match);
    public virtual StackType get_ResultType();
    public bool get_IsChecked();
    public bool get_IsExplicit();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    public IType get_Type();
    public void set_Type(IType value);
    public ILInstruction get_Argument();
    public void set_Argument(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicGetIndexInstruction : DynamicInstruction {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpArgumentInfo> <ArgumentInfo>k__BackingField;
    public static SlotInfo ArgumentsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Arguments>k__BackingField;
    public IReadOnlyList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public StackType ResultType { get; }
    public InstructionCollection`1<ILInstruction> Arguments { get; private set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicGetIndexInstruction(CSharpBinderFlags binderFlags, IType context, CSharpArgumentInfo[] argumentInfo, ILInstruction[] arguments);
    private static DynamicGetIndexInstruction();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicGetMemberInstruction : DynamicInstruction {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <TargetArgumentInfo>k__BackingField;
    public static SlotInfo TargetSlot;
    private ILInstruction target;
    [NullableAttribute("2")]
public string Name { get; }
    public CSharpArgumentInfo TargetArgumentInfo { get; }
    public StackType ResultType { get; }
    public ILInstruction Target { get; public set; }
    public InstructionFlags DirectFlags { get; }
    [NullableContextAttribute("2")]
public DynamicGetMemberInstruction(CSharpBinderFlags binderFlags, string name, IType context, CSharpArgumentInfo targetArgumentInfo, ILInstruction target);
    private static DynamicGetMemberInstruction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_TargetArgumentInfo();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    public ILInstruction get_Target();
    public void set_Target(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.DynamicInstruction : ILInstruction {
    [CompilerGeneratedAttribute]
private CSharpBinderFlags <BinderFlags>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IType <CallingContext>k__BackingField;
    public CSharpBinderFlags BinderFlags { get; }
    [NullableAttribute("2")]
public IType CallingContext { get; }
    public InstructionFlags DirectFlags { get; }
    [NullableContextAttribute("2")]
protected DynamicInstruction(OpCode opCode, CSharpBinderFlags binderFlags, IType context);
    protected DynamicInstruction(OpCode opCode);
    [CompilerGeneratedAttribute]
public CSharpBinderFlags get_BinderFlags();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IType get_CallingContext();
    protected void WriteBinderFlags(ITextOutput output, ILAstWritingOptions options);
    internal static void WriteBinderFlags(CSharpBinderFlags flags, ITextOutput output, ILAstWritingOptions options);
    public abstract virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    internal static void WriteArgumentList(ITextOutput output, ILAstWritingOptions options, ValueTuple`2[] arguments);
    internal static void WriteArgumentList(ITextOutput output, ILAstWritingOptions options, IEnumerable`1<ValueTuple`2<ILInstruction, CSharpArgumentInfo>> arguments);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicInvokeConstructorInstruction : DynamicInstruction {
    [NullableAttribute("2")]
private IType resultType;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpArgumentInfo> <ArgumentInfo>k__BackingField;
    public static SlotInfo ArgumentsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Arguments>k__BackingField;
    public IReadOnlyList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public StackType ResultType { get; }
    public InstructionCollection`1<ILInstruction> Arguments { get; private set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicInvokeConstructorInstruction(CSharpBinderFlags binderFlags, IType type, IType context, CSharpArgumentInfo[] argumentInfo, ILInstruction[] arguments);
    private static DynamicInvokeConstructorInstruction();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicInvokeInstruction : DynamicInstruction {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpArgumentInfo> <ArgumentInfo>k__BackingField;
    public static SlotInfo ArgumentsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Arguments>k__BackingField;
    public IReadOnlyList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public StackType ResultType { get; }
    public InstructionCollection`1<ILInstruction> Arguments { get; private set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicInvokeInstruction(CSharpBinderFlags binderFlags, IType context, CSharpArgumentInfo[] argumentInfo, ILInstruction[] arguments);
    private static DynamicInvokeInstruction();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicInvokeMemberInstruction : DynamicInstruction {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IType> <TypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpArgumentInfo> <ArgumentInfo>k__BackingField;
    public static SlotInfo ArgumentsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Arguments>k__BackingField;
    public string Name { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public IReadOnlyList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public StackType ResultType { get; }
    public InstructionCollection`1<ILInstruction> Arguments { get; private set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicInvokeMemberInstruction(CSharpBinderFlags binderFlags, string name, IType[] typeArguments, IType context, CSharpArgumentInfo[] argumentInfo, ILInstruction[] arguments);
    private static DynamicInvokeMemberInstruction();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IType> get_TypeArguments();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicIsEventInstruction : DynamicInstruction {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static SlotInfo ArgumentSlot;
    private ILInstruction argument;
    [NullableAttribute("2")]
public string Name { get; }
    public StackType ResultType { get; }
    public ILInstruction Argument { get; public set; }
    public InstructionFlags DirectFlags { get; }
    [NullableContextAttribute("2")]
public DynamicIsEventInstruction(CSharpBinderFlags binderFlags, string name, IType context, ILInstruction argument);
    private static DynamicIsEventInstruction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    public ILInstruction get_Argument();
    public void set_Argument(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicLogicOperatorInstruction : DynamicInstruction {
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <LeftArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <RightArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    public static SlotInfo LeftSlot;
    private ILInstruction left;
    public static SlotInfo RightSlot;
    private ILInstruction right;
    public CSharpArgumentInfo LeftArgumentInfo { get; }
    public CSharpArgumentInfo RightArgumentInfo { get; }
    public ExpressionType Operation { get; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public ILInstruction Left { get; public set; }
    public ILInstruction Right { get; public set; }
    public DynamicLogicOperatorInstruction(CSharpBinderFlags binderFlags, ExpressionType operation, IType context, CSharpArgumentInfo leftArgumentInfo, ILInstruction left, CSharpArgumentInfo rightArgumentInfo, ILInstruction right);
    private static DynamicLogicOperatorInstruction();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_LeftArgumentInfo();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_RightArgumentInfo();
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    public ILInstruction get_Left();
    public void set_Left(ILInstruction value);
    public ILInstruction get_Right();
    public void set_Right(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicSetIndexInstruction : DynamicInstruction {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CSharpArgumentInfo> <ArgumentInfo>k__BackingField;
    public static SlotInfo ArgumentsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Arguments>k__BackingField;
    public IReadOnlyList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public StackType ResultType { get; }
    public InstructionCollection`1<ILInstruction> Arguments { get; private set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicSetIndexInstruction(CSharpBinderFlags binderFlags, IType context, CSharpArgumentInfo[] argumentInfo, ILInstruction[] arguments);
    private static DynamicSetIndexInstruction();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicSetMemberInstruction : DynamicInstruction {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <TargetArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <ValueArgumentInfo>k__BackingField;
    public static SlotInfo TargetSlot;
    private ILInstruction target;
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    [NullableAttribute("2")]
public string Name { get; }
    public CSharpArgumentInfo TargetArgumentInfo { get; }
    public CSharpArgumentInfo ValueArgumentInfo { get; }
    public StackType ResultType { get; }
    public ILInstruction Target { get; public set; }
    public ILInstruction Value { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicSetMemberInstruction(CSharpBinderFlags binderFlags, string name, IType context, CSharpArgumentInfo targetArgumentInfo, ILInstruction target, CSharpArgumentInfo valueArgumentInfo, ILInstruction value);
    private static DynamicSetMemberInstruction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_TargetArgumentInfo();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_ValueArgumentInfo();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    public ILInstruction get_Target();
    public void set_Target(ILInstruction value);
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.DynamicUnaryOperatorInstruction : DynamicInstruction {
    [CompilerGeneratedAttribute]
private CSharpArgumentInfo <OperandArgumentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionType <Operation>k__BackingField;
    public static SlotInfo OperandSlot;
    private ILInstruction operand;
    public CSharpArgumentInfo OperandArgumentInfo { get; }
    public ExpressionType Operation { get; }
    public StackType ResultType { get; }
    public ILInstruction Operand { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public DynamicUnaryOperatorInstruction(CSharpBinderFlags binderFlags, ExpressionType operation, IType context, CSharpArgumentInfo operandArgumentInfo, ILInstruction operand);
    private static DynamicUnaryOperatorInstruction();
    [CompilerGeneratedAttribute]
public CSharpArgumentInfo get_OperandArgumentInfo();
    [CompilerGeneratedAttribute]
public ExpressionType get_Operation();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    public virtual CSharpArgumentInfo GetArgumentInfoOfChild(int index);
    public ILInstruction get_Operand();
    public void set_Operand(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ExpressionTreeCast : UnaryInstruction {
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    private IType type;
    public bool IsChecked { get; public set; }
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public ExpressionTreeCast(IType type, ILInstruction argument, bool isChecked);
    [CompilerGeneratedAttribute]
public bool get_IsChecked();
    [CompilerGeneratedAttribute]
public void set_IsChecked(bool value);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.GetPinnableReference : ILInstruction {
    public static SlotInfo ArgumentSlot;
    private ILInstruction argument;
    [NullableAttribute("2")]
private IMethod method;
    public ILInstruction Argument { get; public set; }
    public StackType ResultType { get; }
    [NullableAttribute("2")]
public IMethod Method { get; }
    public InstructionFlags DirectFlags { get; }
    public GetPinnableReference(ILInstruction argument, IMethod method);
    private static GetPinnableReference();
    public ILInstruction get_Argument();
    public void set_Argument(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    [NullableContextAttribute("2")]
public sealed virtual IMethod get_Method();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
internal interface ICSharpCode.Decompiler.IL.IAddressInstruction {
    public int IndexInAddressInstructionList { get; public set; }
    public abstract virtual int get_IndexInAddressInstructionList();
    public abstract virtual void set_IndexInAddressInstructionList(int value);
}
[NullableContextAttribute("1")]
internal interface ICSharpCode.Decompiler.IL.IBranchOrLeaveInstruction {
    public BlockContainer TargetContainer { get; }
    public abstract virtual BlockContainer get_TargetContainer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.IfInstruction : ILInstruction {
    public static SlotInfo ConditionSlot;
    private ILInstruction condition;
    public static SlotInfo TrueInstSlot;
    private ILInstruction trueInst;
    public static SlotInfo FalseInstSlot;
    private ILInstruction falseInst;
    public ILInstruction Condition { get; public set; }
    public ILInstruction TrueInst { get; public set; }
    public ILInstruction FalseInst { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public IfInstruction(ILInstruction condition, ILInstruction trueInst, ILInstruction falseInst);
    private static IfInstruction();
    public ILInstruction get_Condition();
    public void set_Condition(ILInstruction value);
    public ILInstruction get_TrueInst();
    public void set_TrueInst(ILInstruction value);
    public ILInstruction get_FalseInst();
    public void set_FalseInst(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public static IfInstruction LogicAnd(ILInstruction lhs, ILInstruction rhs);
    public static IfInstruction LogicOr(ILInstruction lhs, ILInstruction rhs);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    public virtual InstructionFlags get_DirectFlags();
    protected virtual InstructionFlags ComputeFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    internal static bool IsInConditionSlot(ILInstruction inst);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.IL.IInstructionWithFieldOperand {
    public IField Field { get; }
    public abstract virtual IField get_Field();
}
[NullableContextAttribute("2")]
public interface ICSharpCode.Decompiler.IL.IInstructionWithMethodOperand {
    public IMethod Method { get; }
    public abstract virtual IMethod get_Method();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.IL.IInstructionWithTypeOperand {
    public IType Type { get; }
    public abstract virtual IType get_Type();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand {
    public ILVariable Variable { get; public set; }
    public int IndexInVariableInstructionMapping { get; public set; }
    public abstract virtual ILVariable get_Variable();
    public abstract virtual void set_Variable(ILVariable value);
    public abstract virtual int get_IndexInVariableInstructionMapping();
    public abstract virtual void set_IndexInVariableInstructionMapping(int value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ILAstWritingOptions : object {
    private bool useLogicOperationSugar;
    private bool useFieldSugar;
    private bool showILRanges;
    private bool showChildIndexInBlock;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public bool UseLogicOperationSugar { get; public set; }
    public bool UseFieldSugar { get; public set; }
    public bool ShowILRanges { get; public set; }
    public bool ShowChildIndexInBlock { get; public set; }
    public bool get_UseLogicOperationSugar();
    public void set_UseLogicOperationSugar(bool value);
    public bool get_UseFieldSugar();
    public void set_UseFieldSugar(bool value);
    public bool get_ShowILRanges();
    public void set_ShowILRanges(bool value);
    public bool get_ShowChildIndexInBlock();
    public void set_ShowChildIndexInBlock(bool value);
    protected virtual void OnPropertyChanged(string propertyName);
    [NullableContextAttribute("1")]
protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ILFunction : ILInstruction {
    public static SlotInfo BodySlot;
    private ILInstruction body;
    public static SlotInfo LocalFunctionsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILFunction> <LocalFunctions>k__BackingField;
    [NullableAttribute("2")]
public IMethod Method;
    public GenericContext GenericContext;
    [NullableAttribute("2")]
public string Name;
    public int CodeSize;
    public ILVariableCollection Variables;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BlockContainer <DeclarationScope>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ILVariable> <CapturedVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Warnings>k__BackingField;
    public bool IsIterator;
    public bool StateMachineCompiledWithMono;
    public bool StateMachineCompiledWithLegacyVisualBasic;
    [NullableAttribute("2")]
public IType AsyncReturnType;
    [NullableAttribute("2")]
public IMethod MoveNextMethod;
    [NullableAttribute("2")]
internal LocalFunctionMethod ReducedMethod;
    public AsyncDebugInfo AsyncDebugInfo;
    private int ctorCallStart;
    [NullableAttribute("2")]
public IType DelegateType;
    private ILFunctionKind kind;
    public IType ReturnType;
    public IReadOnlyList`1<IParameter> Parameters;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private List`1<int> <SequencePointCandidates>k__BackingField;
    private int helperVariableCount;
    public ILInstruction Body { get; public set; }
    public InstructionCollection`1<ILFunction> LocalFunctions { get; private set; }
    public StackType ResultType { get; }
    [NullableAttribute("2")]
public BlockContainer DeclarationScope { get; internal set; }
    public HashSet`1<ILVariable> CapturedVariables { get; }
    public List`1<string> Warnings { get; }
    public bool IsAsync { get; }
    internal int ChainedConstructorCallILOffset { get; }
    public ILFunctionKind Kind { get; internal set; }
    [NullableAttribute("2")]
public List`1<int> SequencePointCandidates { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public ILFunction(IMethod method, int codeSize, GenericContext genericContext, ILInstruction body, ILFunctionKind kind);
    internal ILFunction(IType returnType, IReadOnlyList`1<IParameter> parameters, GenericContext genericContext, ILInstruction body, ILFunctionKind kind);
    private static ILFunction();
    public ILInstruction get_Body();
    public void set_Body(ILInstruction value);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILFunction> get_LocalFunctions();
    [CompilerGeneratedAttribute]
private void set_LocalFunctions(InstructionCollection`1<ILFunction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BlockContainer get_DeclarationScope();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_DeclarationScope(BlockContainer value);
    [CompilerGeneratedAttribute]
public HashSet`1<ILVariable> get_CapturedVariables();
    [CompilerGeneratedAttribute]
public List`1<string> get_Warnings();
    public bool get_IsAsync();
    internal int get_ChainedConstructorCallILOffset();
    public ILFunctionKind get_Kind();
    internal void set_Kind(ILFunctionKind value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public List`1<int> get_SequencePointCandidates();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_SequencePointCandidates(List`1<int> value);
    internal virtual void CheckInvariant(ILPhase phase);
    private void CloneVariables();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    private LongSet FindUnusedILRanges();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    internal virtual bool CanInlineIntoSlot(int childIndex, ILInstruction expressionBeingMoved);
    public void RunTransforms(IEnumerable`1<IILTransform> transforms, ILTransformContext context);
    public ILVariable RegisterVariable(VariableKind kind, IType type, string name);
    internal void RecombineVariables(ILVariable variable1, ILVariable variable2);
    [CompilerGeneratedAttribute]
internal static void <FindUnusedILRanges>g__MarkUsedILRanges|64_0(ILInstruction inst, <>c__DisplayClass64_0& );
}
public enum ICSharpCode.Decompiler.IL.ILFunctionKind : Enum {
    public int value__;
    public static ILFunctionKind TopLevelFunction;
    public static ILFunctionKind Delegate;
    public static ILFunctionKind ExpressionTree;
    public static ILFunctionKind LocalFunction;
}
public interface ICSharpCode.Decompiler.IL.ILiftableInstruction {
    public bool IsLifted { get; }
    public StackType UnderlyingResultType { get; }
    public abstract virtual bool get_IsLifted();
    public abstract virtual StackType get_UnderlyingResultType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.ILInstruction : object {
    public OpCode OpCode;
    private static InstructionFlags invalidFlags;
    private InstructionFlags flags;
    private Interval ILRange;
    private byte refCount;
    private ILInstruction parent;
    [CompilerGeneratedAttribute]
private int <ChildIndex>k__BackingField;
    public StackType ResultType { get; }
    public InstructionFlags Flags { get; }
    public InstructionFlags DirectFlags { get; }
    public int StartILOffset { get; }
    public int EndILOffset { get; }
    public bool ILRangeIsEmpty { get; }
    [NullableAttribute("1")]
public IEnumerable`1<Interval> ILRanges { get; }
    public ChildrenCollection Children { get; }
    [NullableAttribute("1")]
public IEnumerable`1<ILInstruction> Descendants { get; }
    [NullableAttribute("1")]
public IEnumerable`1<ILInstruction> Ancestors { get; }
    protected internal bool IsConnected { get; }
    public ILInstruction Parent { get; }
    public int ChildIndex { get; internal set; }
    public SlotInfo SlotInfo { get; }
    protected ILInstruction(OpCode opCode);
    public bool MatchInvalidBranch();
    public bool MatchInvalidExpression();
    public bool MatchNop();
    public bool MatchPinnedRegion(ILVariable& variable, ILInstruction& init, ILInstruction& body);
    public bool MatchArglist();
    public bool MatchTryCatchHandler(ILInstruction& filter, ILInstruction& body, ILVariable& variable);
    public bool MatchLockInstruction(ILInstruction& onExpression, ILInstruction& body);
    public bool MatchUsingInstruction(ILVariable& variable, ILInstruction& resourceExpression, ILInstruction& body);
    public bool MatchDebugBreak();
    public bool MatchCkfinite(ILInstruction& argument);
    public bool MatchLdLoc(ILVariable& variable);
    public bool MatchLdLoca(ILVariable& variable);
    public bool MatchStLoc(ILVariable& variable, ILInstruction& value);
    public bool MatchAddressOf(ILInstruction& value, IType& type);
    public bool MatchThreeValuedBoolAnd(ILInstruction& left, ILInstruction& right);
    public bool MatchThreeValuedBoolOr(ILInstruction& left, ILInstruction& right);
    public bool MatchNullableRewrap(ILInstruction& argument);
    public bool MatchLdStr(String& value);
    public bool MatchLdStrUtf8(String& value);
    public bool MatchLdcI4(Int32& value);
    public bool MatchLdcI8(Int64& value);
    public bool MatchLdcF4(Single& value);
    public bool MatchLdcF8(Double& value);
    public bool MatchLdcDecimal(Decimal& value);
    public bool MatchLdNull();
    public bool MatchLdFtn(IMethod& method);
    public bool MatchLdVirtFtn(ILInstruction& argument, IMethod& method);
    public bool MatchLdVirtDelegate(ILInstruction& argument, IType& type, IMethod& method);
    public bool MatchLdTypeToken(IType& type);
    public bool MatchLdMemberToken(IMember& member);
    public bool MatchLocAlloc(ILInstruction& argument);
    public bool MatchLocAllocSpan(ILInstruction& argument, IType& type);
    public bool MatchCpblk(ILInstruction& destAddress, ILInstruction& sourceAddress, ILInstruction& size);
    public bool MatchInitblk(ILInstruction& address, ILInstruction& value, ILInstruction& size);
    public bool MatchLdFlda(ILInstruction& target, IField& field);
    public bool MatchLdsFlda(IField& field);
    public bool MatchCastClass(ILInstruction& argument, IType& type);
    public bool MatchIsInst(ILInstruction& argument, IType& type);
    public bool MatchLdObj(ILInstruction& target, IType& type);
    public bool MatchStObj(ILInstruction& target, ILInstruction& value, IType& type);
    public bool MatchBox(ILInstruction& argument, IType& type);
    public bool MatchUnbox(ILInstruction& argument, IType& type);
    public bool MatchUnboxAny(ILInstruction& argument, IType& type);
    public bool MatchNewArr(IType& type);
    public bool MatchDefaultValue(IType& type);
    public bool MatchThrow(ILInstruction& argument);
    public bool MatchRethrow();
    public bool MatchSizeOf(IType& type);
    public bool MatchLdElema(IType& type, ILInstruction& array);
    public bool MatchGetPinnableReference(ILInstruction& argument, IMethod& method);
    public bool MatchUserDefinedLogicOperator(IMethod& method, ILInstruction& left, ILInstruction& right);
    public bool MatchMatchInstruction(ILVariable& variable, IMethod& method, ILInstruction& testedOperand);
    public bool MatchMakeRefAny(ILInstruction& argument, IType& type);
    public bool MatchRefAnyType(ILInstruction& argument);
    public bool MatchRefAnyValue(ILInstruction& argument, IType& type);
    public bool MatchYieldReturn(ILInstruction& value);
    public bool MatchAwait(ILInstruction& value);
    protected void ValidateChild(ILInstruction inst);
    internal static void DebugAssert(bool b);
    [NullableContextAttribute("1")]
internal static void DebugAssert(bool b, string msg);
    [ConditionalAttribute("DEBUG")]
internal virtual void CheckInvariant(ILPhase phase);
    [NullableContextAttribute("1")]
public bool IsDescendantOf(ILInstruction possibleAncestor);
    [NullableContextAttribute("1")]
public ILInstruction GetCommonParent(ILInstruction other);
    [NullableContextAttribute("1")]
public bool IsBefore(ILInstruction other);
    private int CountAncestors();
    public abstract virtual StackType get_ResultType();
    internal static StackType CommonResultType(StackType a, StackType b);
    [ConditionalAttribute("DEBUG")]
private protected void MakeDirty();
    public InstructionFlags get_Flags();
    public bool HasFlag(InstructionFlags flags);
    public bool HasDirectFlag(InstructionFlags flags);
    protected void InvalidateFlags();
    protected abstract virtual InstructionFlags ComputeFlags();
    public abstract virtual InstructionFlags get_DirectFlags();
    public void AddILRange(Interval newRange);
    protected static Interval CombineILRange(Interval oldRange, Interval newRange);
    [NullableContextAttribute("1")]
public void AddILRange(ILInstruction sourceInstruction);
    [NullableContextAttribute("1")]
public void SetILRange(ILInstruction sourceInstruction);
    public void SetILRange(Interval range);
    public int get_StartILOffset();
    public int get_EndILOffset();
    public bool get_ILRangeIsEmpty();
    [NullableContextAttribute("1")]
public IEnumerable`1<Interval> get_ILRanges();
    [NullableContextAttribute("1")]
public void WriteILRange(ITextOutput output, ILAstWritingOptions options);
    [NullableContextAttribute("1")]
public abstract virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public abstract virtual void AcceptVisitor(ILVisitor visitor);
    [NullableContextAttribute("1")]
public abstract virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    [NullableContextAttribute("1")]
public abstract virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    public ChildrenCollection get_Children();
    protected abstract virtual int GetChildCount();
    [NullableContextAttribute("1")]
protected abstract virtual ILInstruction GetChild(int index);
    [NullableContextAttribute("1")]
protected abstract virtual void SetChild(int index, ILInstruction value);
    [NullableContextAttribute("1")]
protected abstract virtual SlotInfo GetChildSlot(int index);
    [ConditionalAttribute("DEBUG")]
internal void AssertNoEnumerators();
    [NullableContextAttribute("1")]
public void ReplaceWith(ILInstruction replacement);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("ICSharpCode.Decompiler.IL.ILInstruction/<get_Descendants>d__112")]
public IEnumerable`1<ILInstruction> get_Descendants();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("ICSharpCode.Decompiler.IL.ILInstruction/<get_Ancestors>d__114")]
public IEnumerable`1<ILInstruction> get_Ancestors();
    internal void AddRef();
    internal void ReleaseRef();
    protected internal bool get_IsConnected();
    protected virtual void Connected();
    protected virtual void Disconnected();
    public ILInstruction get_Parent();
    [CompilerGeneratedAttribute]
public int get_ChildIndex();
    [CompilerGeneratedAttribute]
internal void set_ChildIndex(int value);
    public SlotInfo get_SlotInfo();
    [NullableContextAttribute("1")]
protected internal void SetChildInstruction(T& childPointer, T newValue, int index);
    [NullableContextAttribute("1")]
protected internal void InstructionCollectionAdded(ILInstruction newChild);
    [NullableContextAttribute("1")]
protected internal void InstructionCollectionRemoved(ILInstruction oldChild);
    protected internal virtual void InstructionCollectionUpdateComplete();
    [NullableContextAttribute("1")]
public abstract virtual ILInstruction Clone();
    [NullableContextAttribute("1")]
protected ILInstruction ShallowClone();
    [NullableContextAttribute("1")]
public Match Match(ILInstruction node);
    protected internal abstract virtual bool PerformMatch(ILInstruction other, Match& match);
    protected internal virtual bool PerformMatch(ListMatch& listMatch, Match& match);
    [NullableContextAttribute("1")]
public ILVariable Extract(ILTransformContext context);
    [NullableContextAttribute("1")]
internal virtual bool PrepareExtract(int childIndex, ExtractionContext ctx);
    [NullableContextAttribute("1")]
internal virtual bool CanInlineIntoSlot(int childIndex, ILInstruction expressionBeingMoved);
    public bool MatchLdcI4(int val);
    public bool MatchLdcF4(float value);
    public bool MatchLdcF8(double value);
    public bool MatchLdcI(Int64& val);
    public bool MatchLdcI(long val);
    public bool MatchLdLoc(ILVariable variable);
    public bool MatchLdLoca(ILVariable variable);
    public bool MatchLdLocRef(ILVariable variable);
    public bool MatchLdLocRef(ILVariable& variable);
    public bool MatchLdThis();
    public bool MatchStLoc(ILVariable& variable);
    public bool MatchStLoc(ILVariable variable, ILInstruction& value);
    public bool MatchLdLen(StackType type, ILInstruction& array);
    public bool MatchReturn(ILInstruction& value);
    public bool MatchBranch(Block& targetBlock);
    public bool MatchBranch(Block targetBlock);
    public bool MatchLeave(BlockContainer& targetContainer, ILInstruction& value);
    public bool MatchLeave(BlockContainer targetContainer, ILInstruction& value);
    public bool MatchLeave(BlockContainer& targetContainer);
    public bool MatchLeave(BlockContainer targetContainer);
    public bool MatchIfInstruction(ILInstruction& condition, ILInstruction& trueInst, ILInstruction& falseInst);
    public bool MatchIfInstructionPositiveCondition(ILInstruction& condition, ILInstruction& trueInst, ILInstruction& falseInst);
    public bool MatchIfInstruction(ILInstruction& condition, ILInstruction& trueInst);
    public bool MatchLogicAnd(ILInstruction& lhs, ILInstruction& rhs);
    public bool MatchLogicOr(ILInstruction& lhs, ILInstruction& rhs);
    public bool MatchLogicNot(ILInstruction& arg);
    public bool MatchTryCatchHandler(ILVariable& variable);
    public bool MatchCompEquals(ILInstruction& left, ILInstruction& right);
    public bool MatchCompEqualsNull(ILInstruction& arg);
    public bool MatchCompNotEqualsNull(ILInstruction& arg);
    public bool MatchCompNotEquals(ILInstruction& left, ILInstruction& right);
    public bool MatchLdFld(ILInstruction& target, IField& field);
    public bool MatchLdsFld(IField& field);
    public bool MatchLdsFld(IField field);
    public bool MatchStsFld(IField& field, ILInstruction& value);
    public bool MatchStFld(ILInstruction& target, IField& field, ILInstruction& value);
    public bool MatchBinaryNumericInstruction(BinaryNumericOperator operator);
    public bool MatchBinaryNumericInstruction(BinaryNumericOperator operator, ILInstruction& left, ILInstruction& right);
    public bool MatchBinaryNumericInstruction(BinaryNumericOperator& operator, ILInstruction& left, ILInstruction& right);
    public bool MatchDefaultOrNullOrZero();
    [NullableContextAttribute("1")]
public virtual ILInstruction UnwrapConv(ConversionKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class ICSharpCode.Decompiler.IL.ILInstructionExtensions : object {
    [ExtensionAttribute]
public static T WithILRange(T target, ILInstruction sourceInstruction);
    [ExtensionAttribute]
public static T WithILRange(T target, Interval range);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ILInstruction GetNextSibling(ILInstruction instruction);
}
internal interface ICSharpCode.Decompiler.IL.ILoadInstruction {
    public int IndexInLoadInstructionList { get; public set; }
    public abstract virtual int get_IndexInLoadInstructionList();
    public abstract virtual void set_IndexInLoadInstructionList(int value);
}
internal enum ICSharpCode.Decompiler.IL.ILPhase : Enum {
    public int value__;
    public static ILPhase InILReader;
    public static ILPhase Normal;
    public static ILPhase InAsyncAwait;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ILReader : object {
    private ICompilation compilation;
    private MetadataModule module;
    private MetadataReader metadata;
    [CompilerGeneratedAttribute]
private bool <UseDebugSymbols>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDebugInfoProvider <DebugInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Warnings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<int> <SequencePointCandidates>k__BackingField;
    private GenericContext genericContext;
    private IMethod method;
    private MethodBodyBlock body;
    private StackType methodReturnStackType;
    private BlobReader reader;
    private ImmutableStack`1<ILVariable> currentStack;
    [NullableAttribute("2")]
private ImportedBlock currentBlock;
    private List`1<ILInstruction> expressionStack;
    private ILVariable[] parameterVariables;
    private ILVariable[] localVariables;
    private BitSet isBranchTarget;
    private BlockContainer mainContainer;
    private int currentInstructionStart;
    private Dictionary`2<int, ImportedBlock> blocksByOffset;
    private Queue`1<ImportedBlock> importQueue;
    private Dictionary`2<ExceptionRegion, ILVariable> variableByExceptionHandler;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<ILVariable> stackVariables;
    [NullableAttribute("2")]
private IType constrainedPrefix;
    public bool UseDebugSymbols { get; public set; }
    [NullableAttribute("2")]
public IDebugInfoProvider DebugInfo { get; public set; }
    public List`1<string> Warnings { get; }
    public List`1<int> SequencePointCandidates { get; }
    public ILReader(MetadataModule module);
    [CompilerGeneratedAttribute]
public bool get_UseDebugSymbols();
    [CompilerGeneratedAttribute]
public void set_UseDebugSymbols(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IDebugInfoProvider get_DebugInfo();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DebugInfo(IDebugInfoProvider value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Warnings();
    [CompilerGeneratedAttribute]
public List`1<int> get_SequencePointCandidates();
    private void Init(MethodDefinitionHandle methodDefinitionHandle, MethodBodyBlock body, GenericContext genericContext);
    private EntityHandle ReadAndDecodeMetadataToken();
    private IType ReadAndDecodeTypeReference();
    private IMethod ReadAndDecodeMethodReference();
    private IField ReadAndDecodeFieldReference();
    private ILVariable[] InitLocalVariables();
    private void InitParameterVariables();
    private ILVariable CreateILVariable(int index, IType type);
    private ILVariable CreateILVariable(int index, IType parameterType, string name);
    private void Warn(string message);
    private UnionFind`1<ILVariable> CheckOutgoingEdges();
    private void InsertStackAdjustment(Block block, ILVariable varA, ILVariable varB);
    private static bool IsValidTypeStackTypeMerge(StackType stackType1, StackType stackType2);
    private ImportedBlock StoreStackForOffset(int offset, ImmutableStack`1<ILVariable> stack);
    private void ReadInstructions(CancellationToken cancellationToken);
    private void ReadBlock(ImportedBlock block, CancellationToken cancellationToken);
    private bool CurrentStackIsEmpty();
    private void PrepareBranchTargetsAndStacksForExceptionHandlers();
    private static bool IsSequencePointInstruction(ILInstruction instruction);
    public void WriteTypedIL(MethodDefinitionHandle method, MethodBodyBlock body, ITextOutput output, GenericContext genericContext, CancellationToken cancellationToken);
    public ILFunction ReadIL(MethodDefinitionHandle method, MethodBodyBlock body, GenericContext genericContext, ILFunctionKind kind, CancellationToken cancellationToken);
    private DecodedInstruction Neg();
    private DecodedInstruction DecodeInstruction();
    private StackType PeekStackType();
    private DecodedInstruction Push(ILInstruction inst);
    private ILInstruction Peek();
    private ILInstruction Pop();
    private ILInstruction Pop(StackType expectedType);
    internal static ILInstruction Cast(ILInstruction inst, StackType expectedType, List`1<string> warnings, int ilOffset);
    private ILInstruction PopPointer();
    private ILInstruction PopStObjTarget();
    private ILInstruction PopFieldTarget(IField field);
    private ILInstruction PopLdFldTarget(IField field);
    private ILInstruction Return();
    private ILInstruction DecodeLdstr();
    private ILInstruction Ldarg(int v);
    private ILInstruction Ldarga(int v);
    private ILInstruction Starg(int v);
    private ILInstruction Ldloc(int v);
    private ILInstruction Ldloca(int v);
    private ILInstruction Stloc(int v);
    private DecodedInstruction LdElem(IType type);
    private ILInstruction StElem(IType type);
    private ILInstruction InitObj(ILInstruction target, IType type);
    private DecodedInstruction DecodeConstrainedCall();
    private DecodedInstruction DecodeTailCall();
    private DecodedInstruction DecodeUnaligned();
    private DecodedInstruction DecodeVolatile();
    private DecodedInstruction DecodeReadonly();
    private DecodedInstruction DecodeCall(OpCode opCode);
    private DecodedInstruction DecodeCallIndirect();
    private ILInstruction Comparison(ComparisonKind kind, bool un);
    private bool IsInvalidBranch(int target);
    private ILInstruction DecodeComparisonBranch(ILOpCode opCode, ComparisonKind kind, bool un);
    private ILInstruction DecodeConditionalBranch(ILOpCode opCode, bool negate);
    private ILInstruction DecodeUnconditionalBranch(ILOpCode opCode, bool isLeave);
    private void MarkBranchTarget(int targetILOffset, bool isFallThrough);
    private void FlushExpressionStack();
    private ILInstruction DecodeSwitch();
    private DecodedInstruction BinaryNumeric(BinaryNumericOperator operator, bool checkForOverflow, Sign sign);
    private ILInstruction DecodeJmp();
    private ILInstruction LdToken(EntityHandle token);
    [CompilerGeneratedAttribute]
internal static void <Cast>g__Warn|66_0(string message, <>c__DisplayClass66_0& );
    [CompilerGeneratedAttribute]
private ILInstruction[] <DecodeCall>g__PrepareArguments|88_0(bool firstArgumentIsStObjTarget, <>c__DisplayClass88_0& );
    [CompilerGeneratedAttribute]
internal static void <Comparison>g__MakeExplicitConversion|90_0(StackType sourceType, StackType targetType, PrimitiveType conversionType, <>c__DisplayClass90_0& );
    [CompilerGeneratedAttribute]
internal static void <BinaryNumeric>g__MakeExplicitConversion|98_0(StackType sourceType, StackType targetType, PrimitiveType conversionType, <>c__DisplayClass98_0& );
}
[ExtensionAttribute]
internal static class ICSharpCode.Decompiler.IL.ILTypeExtensions : object {
    [ExtensionAttribute]
public static StackType GetStackType(PrimitiveType primitiveType);
    [ExtensionAttribute]
public static Sign GetSign(PrimitiveType primitiveType);
    [ExtensionAttribute]
public static bool HasOppositeSign(PrimitiveType primitiveType);
    [ExtensionAttribute]
public static int GetSize(PrimitiveType type);
    [ExtensionAttribute]
public static bool IsSmallIntegerType(PrimitiveType type);
    [ExtensionAttribute]
public static bool IsIntegerType(PrimitiveType primitiveType);
    [ExtensionAttribute]
public static bool IsFloatType(PrimitiveType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IType InferType(ILInstruction inst, ICompilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Name} : {Type}")]
public class ICSharpCode.Decompiler.IL.ILVariable : object {
    private VariableKind kind;
    public StackType StackType;
    private IType type;
    [CompilerGeneratedAttribute]
private bool <IsRefReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasGeneratedName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILFunction <Function>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BlockContainer <CaptureScope>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInFunction>k__BackingField;
    private List`1<LdLoc> loadInstructions;
    private List`1<IStoreInstruction> storeInstructions;
    private List`1<LdLoca> addressInstructions;
    private bool initialValueIsInitialized;
    private bool usesInitialValue;
    [NullableAttribute("2")]
public IField StateMachineField;
    internal bool RemoveIfRedundant;
    private bool hasNullCheck;
    public VariableKind Kind { get; internal set; }
    public IType Type { get; internal set; }
    public bool IsRefReadOnly { get; internal set; }
    public Nullable`1<int> Index { get; private set; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    public bool HasGeneratedName { get; public set; }
    [NullableAttribute("2")]
public ILFunction Function { get; internal set; }
    [NullableAttribute("2")]
public BlockContainer CaptureScope { get; internal set; }
    public int IndexInFunction { get; internal set; }
    public int LoadCount { get; }
    public IReadOnlyList`1<LdLoc> LoadInstructions { get; }
    public int StoreCount { get; }
    public IReadOnlyList`1<IStoreInstruction> StoreInstructions { get; }
    public int AddressCount { get; }
    public IReadOnlyList`1<LdLoca> AddressInstructions { get; }
    public bool InitialValueIsInitialized { get; public set; }
    public bool UsesInitialValue { get; public set; }
    [ObsoleteAttribute("Use 'UsesInitialValue' instead.")]
public bool HasInitialValue { get; public set; }
    public bool IsSingleDefinition { get; }
    public bool IsDead { get; }
    public bool HasNullCheck { get; public set; }
    public ILVariable(VariableKind kind, IType type, Nullable`1<int> index);
    public ILVariable(VariableKind kind, IType type, StackType stackType, Nullable`1<int> index);
    public VariableKind get_Kind();
    internal void set_Kind(VariableKind value);
    public IType get_Type();
    internal void set_Type(IType value);
    [CompilerGeneratedAttribute]
public bool get_IsRefReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsRefReadOnly(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(Nullable`1<int> value);
    [ConditionalAttribute("DEBUG")]
internal void CheckInvariant();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_HasGeneratedName();
    [CompilerGeneratedAttribute]
public void set_HasGeneratedName(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ILFunction get_Function();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Function(ILFunction value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BlockContainer get_CaptureScope();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_CaptureScope(BlockContainer value);
    [CompilerGeneratedAttribute]
public int get_IndexInFunction();
    [CompilerGeneratedAttribute]
internal void set_IndexInFunction(int value);
    public int get_LoadCount();
    public IReadOnlyList`1<LdLoc> get_LoadInstructions();
    public int get_StoreCount();
    public IReadOnlyList`1<IStoreInstruction> get_StoreInstructions();
    public int get_AddressCount();
    public IReadOnlyList`1<LdLoca> get_AddressInstructions();
    internal void AddLoadInstruction(LdLoc inst);
    internal void AddStoreInstruction(IStoreInstruction inst);
    internal void AddAddressInstruction(LdLoca inst);
    internal void RemoveLoadInstruction(LdLoc inst);
    internal void RemoveStoreInstruction(IStoreInstruction inst);
    internal void RemoveAddressInstruction(LdLoca inst);
    private int AddInstruction(List`1<T> list, T inst);
    private void RemoveInstruction(List`1<T> list, int index, T inst);
    public bool get_InitialValueIsInitialized();
    public void set_InitialValueIsInitialized(bool value);
    public bool get_UsesInitialValue();
    public void set_UsesInitialValue(bool value);
    public bool get_HasInitialValue();
    public void set_HasInitialValue(bool value);
    public bool get_IsSingleDefinition();
    public bool get_IsDead();
    public bool get_HasNullCheck();
    public void set_HasNullCheck(bool value);
    [NullableContextAttribute("2")]
public virtual string ToString();
    internal void WriteDefinitionTo(ITextOutput output);
    internal void WriteTo(ITextOutput output);
    internal bool IsUsedWithin(ILInstruction inst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class ICSharpCode.Decompiler.IL.ILVariableCollection : object {
    private ILFunction scope;
    private List`1<ILVariable> list;
    public ILVariable Item { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<ICSharpCode.Decompiler.IL.ILVariable>.IsReadOnly { get; }
    internal ILVariableCollection(ILFunction scope);
    public sealed virtual ILVariable get_Item(int index);
    public bool Add(ILVariable item);
    private sealed virtual override void System.Collections.Generic.ICollection<ICSharpCode.Decompiler.IL.ILVariable>.Add(ILVariable item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ILVariable item);
    public sealed virtual bool Remove(ILVariable item);
    private void RemoveAt(int index);
    public void RemoveDead();
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(ILVariable[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<ICSharpCode.Decompiler.IL.ILVariable>.get_IsReadOnly();
    public Enumerator<ILVariable> GetEnumerator();
    private sealed virtual override IEnumerator`1<ILVariable> System.Collections.Generic.IEnumerable<ICSharpCode.Decompiler.IL.ILVariable>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal static bool <RemoveDead>g__ShouldRemoveVariable|11_0(ILVariable v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ILVariableEqualityComparer : object {
    public static ILVariableEqualityComparer Instance;
    private static ILVariableEqualityComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ILVariable x, ILVariable y);
    public sealed virtual int GetHashCode(ILVariable obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.ILVisitor : object {
    protected abstract virtual void Default(ILInstruction inst);
    protected internal virtual void VisitInvalidBranch(InvalidBranch inst);
    protected internal virtual void VisitInvalidExpression(InvalidExpression inst);
    protected internal virtual void VisitNop(Nop inst);
    protected internal virtual void VisitILFunction(ILFunction function);
    protected internal virtual void VisitBlockContainer(BlockContainer container);
    protected internal virtual void VisitBlock(Block block);
    protected internal virtual void VisitPinnedRegion(PinnedRegion inst);
    protected internal virtual void VisitBinaryNumericInstruction(BinaryNumericInstruction inst);
    protected internal virtual void VisitNumericCompoundAssign(NumericCompoundAssign inst);
    protected internal virtual void VisitUserDefinedCompoundAssign(UserDefinedCompoundAssign inst);
    protected internal virtual void VisitDynamicCompoundAssign(DynamicCompoundAssign inst);
    protected internal virtual void VisitBitNot(BitNot inst);
    protected internal virtual void VisitArglist(Arglist inst);
    protected internal virtual void VisitBranch(Branch inst);
    protected internal virtual void VisitLeave(Leave inst);
    protected internal virtual void VisitIfInstruction(IfInstruction inst);
    protected internal virtual void VisitNullCoalescingInstruction(NullCoalescingInstruction inst);
    protected internal virtual void VisitSwitchInstruction(SwitchInstruction inst);
    protected internal virtual void VisitSwitchSection(SwitchSection inst);
    protected internal virtual void VisitTryCatch(TryCatch inst);
    protected internal virtual void VisitTryCatchHandler(TryCatchHandler inst);
    protected internal virtual void VisitTryFinally(TryFinally inst);
    protected internal virtual void VisitTryFault(TryFault inst);
    protected internal virtual void VisitLockInstruction(LockInstruction inst);
    protected internal virtual void VisitUsingInstruction(UsingInstruction inst);
    protected internal virtual void VisitDebugBreak(DebugBreak inst);
    protected internal virtual void VisitComp(Comp inst);
    protected internal virtual void VisitCall(Call inst);
    protected internal virtual void VisitCallVirt(CallVirt inst);
    protected internal virtual void VisitCallIndirect(CallIndirect inst);
    protected internal virtual void VisitCkfinite(Ckfinite inst);
    protected internal virtual void VisitConv(Conv inst);
    protected internal virtual void VisitLdLoc(LdLoc inst);
    protected internal virtual void VisitLdLoca(LdLoca inst);
    protected internal virtual void VisitStLoc(StLoc inst);
    protected internal virtual void VisitAddressOf(AddressOf inst);
    protected internal virtual void VisitThreeValuedBoolAnd(ThreeValuedBoolAnd inst);
    protected internal virtual void VisitThreeValuedBoolOr(ThreeValuedBoolOr inst);
    protected internal virtual void VisitNullableUnwrap(NullableUnwrap inst);
    protected internal virtual void VisitNullableRewrap(NullableRewrap inst);
    protected internal virtual void VisitLdStr(LdStr inst);
    protected internal virtual void VisitLdStrUtf8(LdStrUtf8 inst);
    protected internal virtual void VisitLdcI4(LdcI4 inst);
    protected internal virtual void VisitLdcI8(LdcI8 inst);
    protected internal virtual void VisitLdcF4(LdcF4 inst);
    protected internal virtual void VisitLdcF8(LdcF8 inst);
    protected internal virtual void VisitLdcDecimal(LdcDecimal inst);
    protected internal virtual void VisitLdNull(LdNull inst);
    protected internal virtual void VisitLdFtn(LdFtn inst);
    protected internal virtual void VisitLdVirtFtn(LdVirtFtn inst);
    protected internal virtual void VisitLdVirtDelegate(LdVirtDelegate inst);
    protected internal virtual void VisitLdTypeToken(LdTypeToken inst);
    protected internal virtual void VisitLdMemberToken(LdMemberToken inst);
    protected internal virtual void VisitLocAlloc(LocAlloc inst);
    protected internal virtual void VisitLocAllocSpan(LocAllocSpan inst);
    protected internal virtual void VisitCpblk(Cpblk inst);
    protected internal virtual void VisitInitblk(Initblk inst);
    protected internal virtual void VisitLdFlda(LdFlda inst);
    protected internal virtual void VisitLdsFlda(LdsFlda inst);
    protected internal virtual void VisitCastClass(CastClass inst);
    protected internal virtual void VisitIsInst(IsInst inst);
    protected internal virtual void VisitLdObj(LdObj inst);
    protected internal virtual void VisitStObj(StObj inst);
    protected internal virtual void VisitBox(Box inst);
    protected internal virtual void VisitUnbox(Unbox inst);
    protected internal virtual void VisitUnboxAny(UnboxAny inst);
    protected internal virtual void VisitNewObj(NewObj inst);
    protected internal virtual void VisitNewArr(NewArr inst);
    protected internal virtual void VisitDefaultValue(DefaultValue inst);
    protected internal virtual void VisitThrow(Throw inst);
    protected internal virtual void VisitRethrow(Rethrow inst);
    protected internal virtual void VisitSizeOf(SizeOf inst);
    protected internal virtual void VisitLdLen(LdLen inst);
    protected internal virtual void VisitLdElema(LdElema inst);
    protected internal virtual void VisitGetPinnableReference(GetPinnableReference inst);
    protected internal virtual void VisitStringToInt(StringToInt inst);
    protected internal virtual void VisitExpressionTreeCast(ExpressionTreeCast inst);
    protected internal virtual void VisitUserDefinedLogicOperator(UserDefinedLogicOperator inst);
    protected internal virtual void VisitDynamicLogicOperatorInstruction(DynamicLogicOperatorInstruction inst);
    protected internal virtual void VisitDynamicBinaryOperatorInstruction(DynamicBinaryOperatorInstruction inst);
    protected internal virtual void VisitDynamicUnaryOperatorInstruction(DynamicUnaryOperatorInstruction inst);
    protected internal virtual void VisitDynamicConvertInstruction(DynamicConvertInstruction inst);
    protected internal virtual void VisitDynamicGetMemberInstruction(DynamicGetMemberInstruction inst);
    protected internal virtual void VisitDynamicSetMemberInstruction(DynamicSetMemberInstruction inst);
    protected internal virtual void VisitDynamicGetIndexInstruction(DynamicGetIndexInstruction inst);
    protected internal virtual void VisitDynamicSetIndexInstruction(DynamicSetIndexInstruction inst);
    protected internal virtual void VisitDynamicInvokeMemberInstruction(DynamicInvokeMemberInstruction inst);
    protected internal virtual void VisitDynamicInvokeConstructorInstruction(DynamicInvokeConstructorInstruction inst);
    protected internal virtual void VisitDynamicInvokeInstruction(DynamicInvokeInstruction inst);
    protected internal virtual void VisitDynamicIsEventInstruction(DynamicIsEventInstruction inst);
    protected internal virtual void VisitMatchInstruction(MatchInstruction inst);
    protected internal virtual void VisitMakeRefAny(MakeRefAny inst);
    protected internal virtual void VisitRefAnyType(RefAnyType inst);
    protected internal virtual void VisitRefAnyValue(RefAnyValue inst);
    protected internal virtual void VisitYieldReturn(YieldReturn inst);
    protected internal virtual void VisitAwait(Await inst);
    protected internal virtual void VisitDeconstructInstruction(DeconstructInstruction inst);
    protected internal virtual void VisitDeconstructResultInstruction(DeconstructResultInstruction inst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.ILVisitor`1 : object {
    protected abstract virtual T Default(ILInstruction inst);
    protected internal virtual T VisitInvalidBranch(InvalidBranch inst);
    protected internal virtual T VisitInvalidExpression(InvalidExpression inst);
    protected internal virtual T VisitNop(Nop inst);
    protected internal virtual T VisitILFunction(ILFunction function);
    protected internal virtual T VisitBlockContainer(BlockContainer container);
    protected internal virtual T VisitBlock(Block block);
    protected internal virtual T VisitPinnedRegion(PinnedRegion inst);
    protected internal virtual T VisitBinaryNumericInstruction(BinaryNumericInstruction inst);
    protected internal virtual T VisitNumericCompoundAssign(NumericCompoundAssign inst);
    protected internal virtual T VisitUserDefinedCompoundAssign(UserDefinedCompoundAssign inst);
    protected internal virtual T VisitDynamicCompoundAssign(DynamicCompoundAssign inst);
    protected internal virtual T VisitBitNot(BitNot inst);
    protected internal virtual T VisitArglist(Arglist inst);
    protected internal virtual T VisitBranch(Branch inst);
    protected internal virtual T VisitLeave(Leave inst);
    protected internal virtual T VisitIfInstruction(IfInstruction inst);
    protected internal virtual T VisitNullCoalescingInstruction(NullCoalescingInstruction inst);
    protected internal virtual T VisitSwitchInstruction(SwitchInstruction inst);
    protected internal virtual T VisitSwitchSection(SwitchSection inst);
    protected internal virtual T VisitTryCatch(TryCatch inst);
    protected internal virtual T VisitTryCatchHandler(TryCatchHandler inst);
    protected internal virtual T VisitTryFinally(TryFinally inst);
    protected internal virtual T VisitTryFault(TryFault inst);
    protected internal virtual T VisitLockInstruction(LockInstruction inst);
    protected internal virtual T VisitUsingInstruction(UsingInstruction inst);
    protected internal virtual T VisitDebugBreak(DebugBreak inst);
    protected internal virtual T VisitComp(Comp inst);
    protected internal virtual T VisitCall(Call inst);
    protected internal virtual T VisitCallVirt(CallVirt inst);
    protected internal virtual T VisitCallIndirect(CallIndirect inst);
    protected internal virtual T VisitCkfinite(Ckfinite inst);
    protected internal virtual T VisitConv(Conv inst);
    protected internal virtual T VisitLdLoc(LdLoc inst);
    protected internal virtual T VisitLdLoca(LdLoca inst);
    protected internal virtual T VisitStLoc(StLoc inst);
    protected internal virtual T VisitAddressOf(AddressOf inst);
    protected internal virtual T VisitThreeValuedBoolAnd(ThreeValuedBoolAnd inst);
    protected internal virtual T VisitThreeValuedBoolOr(ThreeValuedBoolOr inst);
    protected internal virtual T VisitNullableUnwrap(NullableUnwrap inst);
    protected internal virtual T VisitNullableRewrap(NullableRewrap inst);
    protected internal virtual T VisitLdStr(LdStr inst);
    protected internal virtual T VisitLdStrUtf8(LdStrUtf8 inst);
    protected internal virtual T VisitLdcI4(LdcI4 inst);
    protected internal virtual T VisitLdcI8(LdcI8 inst);
    protected internal virtual T VisitLdcF4(LdcF4 inst);
    protected internal virtual T VisitLdcF8(LdcF8 inst);
    protected internal virtual T VisitLdcDecimal(LdcDecimal inst);
    protected internal virtual T VisitLdNull(LdNull inst);
    protected internal virtual T VisitLdFtn(LdFtn inst);
    protected internal virtual T VisitLdVirtFtn(LdVirtFtn inst);
    protected internal virtual T VisitLdVirtDelegate(LdVirtDelegate inst);
    protected internal virtual T VisitLdTypeToken(LdTypeToken inst);
    protected internal virtual T VisitLdMemberToken(LdMemberToken inst);
    protected internal virtual T VisitLocAlloc(LocAlloc inst);
    protected internal virtual T VisitLocAllocSpan(LocAllocSpan inst);
    protected internal virtual T VisitCpblk(Cpblk inst);
    protected internal virtual T VisitInitblk(Initblk inst);
    protected internal virtual T VisitLdFlda(LdFlda inst);
    protected internal virtual T VisitLdsFlda(LdsFlda inst);
    protected internal virtual T VisitCastClass(CastClass inst);
    protected internal virtual T VisitIsInst(IsInst inst);
    protected internal virtual T VisitLdObj(LdObj inst);
    protected internal virtual T VisitStObj(StObj inst);
    protected internal virtual T VisitBox(Box inst);
    protected internal virtual T VisitUnbox(Unbox inst);
    protected internal virtual T VisitUnboxAny(UnboxAny inst);
    protected internal virtual T VisitNewObj(NewObj inst);
    protected internal virtual T VisitNewArr(NewArr inst);
    protected internal virtual T VisitDefaultValue(DefaultValue inst);
    protected internal virtual T VisitThrow(Throw inst);
    protected internal virtual T VisitRethrow(Rethrow inst);
    protected internal virtual T VisitSizeOf(SizeOf inst);
    protected internal virtual T VisitLdLen(LdLen inst);
    protected internal virtual T VisitLdElema(LdElema inst);
    protected internal virtual T VisitGetPinnableReference(GetPinnableReference inst);
    protected internal virtual T VisitStringToInt(StringToInt inst);
    protected internal virtual T VisitExpressionTreeCast(ExpressionTreeCast inst);
    protected internal virtual T VisitUserDefinedLogicOperator(UserDefinedLogicOperator inst);
    protected internal virtual T VisitDynamicLogicOperatorInstruction(DynamicLogicOperatorInstruction inst);
    protected internal virtual T VisitDynamicBinaryOperatorInstruction(DynamicBinaryOperatorInstruction inst);
    protected internal virtual T VisitDynamicUnaryOperatorInstruction(DynamicUnaryOperatorInstruction inst);
    protected internal virtual T VisitDynamicConvertInstruction(DynamicConvertInstruction inst);
    protected internal virtual T VisitDynamicGetMemberInstruction(DynamicGetMemberInstruction inst);
    protected internal virtual T VisitDynamicSetMemberInstruction(DynamicSetMemberInstruction inst);
    protected internal virtual T VisitDynamicGetIndexInstruction(DynamicGetIndexInstruction inst);
    protected internal virtual T VisitDynamicSetIndexInstruction(DynamicSetIndexInstruction inst);
    protected internal virtual T VisitDynamicInvokeMemberInstruction(DynamicInvokeMemberInstruction inst);
    protected internal virtual T VisitDynamicInvokeConstructorInstruction(DynamicInvokeConstructorInstruction inst);
    protected internal virtual T VisitDynamicInvokeInstruction(DynamicInvokeInstruction inst);
    protected internal virtual T VisitDynamicIsEventInstruction(DynamicIsEventInstruction inst);
    protected internal virtual T VisitMatchInstruction(MatchInstruction inst);
    protected internal virtual T VisitMakeRefAny(MakeRefAny inst);
    protected internal virtual T VisitRefAnyType(RefAnyType inst);
    protected internal virtual T VisitRefAnyValue(RefAnyValue inst);
    protected internal virtual T VisitYieldReturn(YieldReturn inst);
    protected internal virtual T VisitAwait(Await inst);
    protected internal virtual T VisitDeconstructInstruction(DeconstructInstruction inst);
    protected internal virtual T VisitDeconstructResultInstruction(DeconstructResultInstruction inst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.ILVisitor`2 : object {
    protected abstract virtual T Default(ILInstruction inst, C context);
    protected internal virtual T VisitInvalidBranch(InvalidBranch inst, C context);
    protected internal virtual T VisitInvalidExpression(InvalidExpression inst, C context);
    protected internal virtual T VisitNop(Nop inst, C context);
    protected internal virtual T VisitILFunction(ILFunction function, C context);
    protected internal virtual T VisitBlockContainer(BlockContainer container, C context);
    protected internal virtual T VisitBlock(Block block, C context);
    protected internal virtual T VisitPinnedRegion(PinnedRegion inst, C context);
    protected internal virtual T VisitBinaryNumericInstruction(BinaryNumericInstruction inst, C context);
    protected internal virtual T VisitNumericCompoundAssign(NumericCompoundAssign inst, C context);
    protected internal virtual T VisitUserDefinedCompoundAssign(UserDefinedCompoundAssign inst, C context);
    protected internal virtual T VisitDynamicCompoundAssign(DynamicCompoundAssign inst, C context);
    protected internal virtual T VisitBitNot(BitNot inst, C context);
    protected internal virtual T VisitArglist(Arglist inst, C context);
    protected internal virtual T VisitBranch(Branch inst, C context);
    protected internal virtual T VisitLeave(Leave inst, C context);
    protected internal virtual T VisitIfInstruction(IfInstruction inst, C context);
    protected internal virtual T VisitNullCoalescingInstruction(NullCoalescingInstruction inst, C context);
    protected internal virtual T VisitSwitchInstruction(SwitchInstruction inst, C context);
    protected internal virtual T VisitSwitchSection(SwitchSection inst, C context);
    protected internal virtual T VisitTryCatch(TryCatch inst, C context);
    protected internal virtual T VisitTryCatchHandler(TryCatchHandler inst, C context);
    protected internal virtual T VisitTryFinally(TryFinally inst, C context);
    protected internal virtual T VisitTryFault(TryFault inst, C context);
    protected internal virtual T VisitLockInstruction(LockInstruction inst, C context);
    protected internal virtual T VisitUsingInstruction(UsingInstruction inst, C context);
    protected internal virtual T VisitDebugBreak(DebugBreak inst, C context);
    protected internal virtual T VisitComp(Comp inst, C context);
    protected internal virtual T VisitCall(Call inst, C context);
    protected internal virtual T VisitCallVirt(CallVirt inst, C context);
    protected internal virtual T VisitCallIndirect(CallIndirect inst, C context);
    protected internal virtual T VisitCkfinite(Ckfinite inst, C context);
    protected internal virtual T VisitConv(Conv inst, C context);
    protected internal virtual T VisitLdLoc(LdLoc inst, C context);
    protected internal virtual T VisitLdLoca(LdLoca inst, C context);
    protected internal virtual T VisitStLoc(StLoc inst, C context);
    protected internal virtual T VisitAddressOf(AddressOf inst, C context);
    protected internal virtual T VisitThreeValuedBoolAnd(ThreeValuedBoolAnd inst, C context);
    protected internal virtual T VisitThreeValuedBoolOr(ThreeValuedBoolOr inst, C context);
    protected internal virtual T VisitNullableUnwrap(NullableUnwrap inst, C context);
    protected internal virtual T VisitNullableRewrap(NullableRewrap inst, C context);
    protected internal virtual T VisitLdStr(LdStr inst, C context);
    protected internal virtual T VisitLdStrUtf8(LdStrUtf8 inst, C context);
    protected internal virtual T VisitLdcI4(LdcI4 inst, C context);
    protected internal virtual T VisitLdcI8(LdcI8 inst, C context);
    protected internal virtual T VisitLdcF4(LdcF4 inst, C context);
    protected internal virtual T VisitLdcF8(LdcF8 inst, C context);
    protected internal virtual T VisitLdcDecimal(LdcDecimal inst, C context);
    protected internal virtual T VisitLdNull(LdNull inst, C context);
    protected internal virtual T VisitLdFtn(LdFtn inst, C context);
    protected internal virtual T VisitLdVirtFtn(LdVirtFtn inst, C context);
    protected internal virtual T VisitLdVirtDelegate(LdVirtDelegate inst, C context);
    protected internal virtual T VisitLdTypeToken(LdTypeToken inst, C context);
    protected internal virtual T VisitLdMemberToken(LdMemberToken inst, C context);
    protected internal virtual T VisitLocAlloc(LocAlloc inst, C context);
    protected internal virtual T VisitLocAllocSpan(LocAllocSpan inst, C context);
    protected internal virtual T VisitCpblk(Cpblk inst, C context);
    protected internal virtual T VisitInitblk(Initblk inst, C context);
    protected internal virtual T VisitLdFlda(LdFlda inst, C context);
    protected internal virtual T VisitLdsFlda(LdsFlda inst, C context);
    protected internal virtual T VisitCastClass(CastClass inst, C context);
    protected internal virtual T VisitIsInst(IsInst inst, C context);
    protected internal virtual T VisitLdObj(LdObj inst, C context);
    protected internal virtual T VisitStObj(StObj inst, C context);
    protected internal virtual T VisitBox(Box inst, C context);
    protected internal virtual T VisitUnbox(Unbox inst, C context);
    protected internal virtual T VisitUnboxAny(UnboxAny inst, C context);
    protected internal virtual T VisitNewObj(NewObj inst, C context);
    protected internal virtual T VisitNewArr(NewArr inst, C context);
    protected internal virtual T VisitDefaultValue(DefaultValue inst, C context);
    protected internal virtual T VisitThrow(Throw inst, C context);
    protected internal virtual T VisitRethrow(Rethrow inst, C context);
    protected internal virtual T VisitSizeOf(SizeOf inst, C context);
    protected internal virtual T VisitLdLen(LdLen inst, C context);
    protected internal virtual T VisitLdElema(LdElema inst, C context);
    protected internal virtual T VisitGetPinnableReference(GetPinnableReference inst, C context);
    protected internal virtual T VisitStringToInt(StringToInt inst, C context);
    protected internal virtual T VisitExpressionTreeCast(ExpressionTreeCast inst, C context);
    protected internal virtual T VisitUserDefinedLogicOperator(UserDefinedLogicOperator inst, C context);
    protected internal virtual T VisitDynamicLogicOperatorInstruction(DynamicLogicOperatorInstruction inst, C context);
    protected internal virtual T VisitDynamicBinaryOperatorInstruction(DynamicBinaryOperatorInstruction inst, C context);
    protected internal virtual T VisitDynamicUnaryOperatorInstruction(DynamicUnaryOperatorInstruction inst, C context);
    protected internal virtual T VisitDynamicConvertInstruction(DynamicConvertInstruction inst, C context);
    protected internal virtual T VisitDynamicGetMemberInstruction(DynamicGetMemberInstruction inst, C context);
    protected internal virtual T VisitDynamicSetMemberInstruction(DynamicSetMemberInstruction inst, C context);
    protected internal virtual T VisitDynamicGetIndexInstruction(DynamicGetIndexInstruction inst, C context);
    protected internal virtual T VisitDynamicSetIndexInstruction(DynamicSetIndexInstruction inst, C context);
    protected internal virtual T VisitDynamicInvokeMemberInstruction(DynamicInvokeMemberInstruction inst, C context);
    protected internal virtual T VisitDynamicInvokeConstructorInstruction(DynamicInvokeConstructorInstruction inst, C context);
    protected internal virtual T VisitDynamicInvokeInstruction(DynamicInvokeInstruction inst, C context);
    protected internal virtual T VisitDynamicIsEventInstruction(DynamicIsEventInstruction inst, C context);
    protected internal virtual T VisitMatchInstruction(MatchInstruction inst, C context);
    protected internal virtual T VisitMakeRefAny(MakeRefAny inst, C context);
    protected internal virtual T VisitRefAnyType(RefAnyType inst, C context);
    protected internal virtual T VisitRefAnyValue(RefAnyValue inst, C context);
    protected internal virtual T VisitYieldReturn(YieldReturn inst, C context);
    protected internal virtual T VisitAwait(Await inst, C context);
    protected internal virtual T VisitDeconstructInstruction(DeconstructInstruction inst, C context);
    protected internal virtual T VisitDeconstructResultInstruction(DeconstructResultInstruction inst, C context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Initblk : ILInstruction {
    public static SlotInfo AddressSlot;
    private ILInstruction address;
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    public static SlotInfo SizeSlot;
    private ILInstruction size;
    [CompilerGeneratedAttribute]
private bool <IsVolatile>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnalignedPrefix>k__BackingField;
    public ILInstruction Address { get; public set; }
    public ILInstruction Value { get; public set; }
    public ILInstruction Size { get; public set; }
    public bool IsVolatile { get; public set; }
    public byte UnalignedPrefix { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Initblk(ILInstruction address, ILInstruction value, ILInstruction size);
    private static Initblk();
    public ILInstruction get_Address();
    public void set_Address(ILInstruction value);
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    public ILInstruction get_Size();
    public void set_Size(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVolatile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsVolatile(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual byte get_UnalignedPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UnalignedPrefix(byte value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class ICSharpCode.Decompiler.IL.InstructionCollection`1 : object {
    private ILInstruction parentInstruction;
    private int firstChildIndex;
    private List`1<T> list;
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public InstructionCollection`1(ILInstruction parentInstruction, int firstChildIndex);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
public sealed virtual int IndexOf(T item);
    [NullableContextAttribute("2")]
public sealed virtual bool Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public sealed virtual void Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public void ReplaceList(IEnumerable`1<T> newList);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public void SwapRemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual bool Remove(T item);
    public void RemoveRange(int index, int count);
    public int RemoveAll(Predicate`1<T> predicate);
    public void MoveElementToIndex(int oldIndex, int newIndex);
    public void MoveElementToIndex(T item, int newIndex);
    public void MoveElementToEnd(int index);
    public void MoveElementToEnd(T item);
    public T First();
    [NullableContextAttribute("2")]
public T FirstOrDefault();
    public T Last();
    [NullableContextAttribute("2")]
public T LastOrDefault();
    [NullableContextAttribute("2")]
public T SecondToLastOrDefault();
    [NullableContextAttribute("2")]
public T ElementAtOrDefault(int index);
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.IL.InstructionFlags : Enum {
    public int value__;
    public static InstructionFlags None;
    public static InstructionFlags MayReadLocals;
    public static InstructionFlags MayWriteLocals;
    public static InstructionFlags SideEffect;
    public static InstructionFlags MayThrow;
    public static InstructionFlags MayBranch;
    public static InstructionFlags MayUnwrapNull;
    public static InstructionFlags EndPointUnreachable;
    public static InstructionFlags ControlFlow;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.IL.InstructionOutputExtensions : object {
    private static String[] originalOpCodeNames;
    private static InstructionOutputExtensions();
    [ExtensionAttribute]
public static void Write(ITextOutput output, OpCode opCode);
    [ExtensionAttribute]
public static void Write(ITextOutput output, StackType stackType);
    [ExtensionAttribute]
public static void Write(ITextOutput output, PrimitiveType primitiveType);
    [ExtensionAttribute]
public static void WriteTo(IType type, ITextOutput output);
    [ExtensionAttribute]
public static void WriteTo(IMember member, ITextOutput output);
    [ExtensionAttribute]
public static void WriteTo(Interval interval, ITextOutput output, ILAstWritingOptions options);
    [ExtensionAttribute]
public static void WriteTo(EntityHandle entity, PEFile module, ITextOutput output, MetadataGenericContext genericContext, ILNameSyntax syntax);
    private static void WriteTypeParameterList(ITextOutput output, ILNameSyntax syntax, ImmutableArray`1<Action`1<ILNameSyntax>> substitution);
    internal static void WriteParameterList(ITextOutput output, MethodSignature`1<Action`1<ILNameSyntax>> methodSignature);
    [ExtensionAttribute]
internal static void WriteTo(SignatureHeader& header, ITextOutput output);
    private static void WriteParent(ITextOutput output, PEFile module, MetadataReader metadata, EntityHandle parentHandle, MetadataGenericContext genericContext, ILNameSyntax syntax);
}
public class ICSharpCode.Decompiler.IL.IntroduceDynamicTypeOnLocals : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
}
internal class ICSharpCode.Decompiler.IL.IntroduceNativeIntTypeOnLocals : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static bool IsUsedAsNativeInt(LdLoc load);
    private static bool IsNativeIntStore(IStoreInstruction store, ICompilation compilation);
}
public class ICSharpCode.Decompiler.IL.IntroduceRefReadOnlyModifierOnLocals : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private bool IsUsedAsRefReadonly(ILVariable variable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.InvalidBranch : SimpleInstruction {
    [NullableAttribute("2")]
public string Message;
    public StackType ExpectedResultType;
    public InstructionFlags DirectFlags { get; }
    public StackType ResultType { get; }
    [NullableContextAttribute("2")]
public InvalidBranch(string message);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.InvalidExpression : SimpleInstruction {
    public string Severity;
    [NullableAttribute("2")]
public string Message;
    public StackType ExpectedResultType;
    public InstructionFlags DirectFlags { get; }
    public StackType ResultType { get; }
    [NullableContextAttribute("2")]
public InvalidExpression(string message);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.IsInst : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public IsInst(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
public interface ICSharpCode.Decompiler.IL.IStoreInstruction {
    public int IndexInStoreInstructionList { get; public set; }
    public abstract virtual int get_IndexInStoreInstructionList();
    public abstract virtual void set_IndexInStoreInstructionList(int value);
}
internal interface ICSharpCode.Decompiler.IL.ISupportsUnalignedPrefix {
    public byte UnalignedPrefix { get; public set; }
    public abstract virtual byte get_UnalignedPrefix();
    public abstract virtual void set_UnalignedPrefix(byte value);
}
internal interface ICSharpCode.Decompiler.IL.ISupportsVolatilePrefix {
    public bool IsVolatile { get; public set; }
    public abstract virtual bool get_IsVolatile();
    public abstract virtual void set_IsVolatile(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdcDecimal : SimpleInstruction {
    public decimal Value;
    public StackType ResultType { get; }
    public LdcDecimal(decimal value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdcF4 : SimpleInstruction {
    public float Value;
    public StackType ResultType { get; }
    public LdcF4(float value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdcF8 : SimpleInstruction {
    public double Value;
    public StackType ResultType { get; }
    public LdcF8(double value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdcI4 : SimpleInstruction {
    public int Value;
    public StackType ResultType { get; }
    public LdcI4(int value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdcI8 : SimpleInstruction {
    public long Value;
    public StackType ResultType { get; }
    public LdcI8(long value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdElema : ILInstruction {
    private IType type;
    public static SlotInfo ArraySlot;
    private ILInstruction array;
    public static SlotInfo IndicesSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Indices>k__BackingField;
    public bool WithSystemIndex;
    public bool DelayExceptions;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public IType Type { get; public set; }
    public ILInstruction Array { get; public set; }
    public InstructionCollection`1<ILInstruction> Indices { get; private set; }
    public StackType ResultType { get; }
    public bool IsReadOnly { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public LdElema(IType type, ILInstruction array, ILInstruction[] indices);
    private static LdElema();
    public IType get_Type();
    public void set_Type(IType value);
    public ILInstruction get_Array();
    public void set_Array(ILInstruction value);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Indices();
    [CompilerGeneratedAttribute]
private void set_Indices(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdFlda : ILInstruction {
    public static SlotInfo TargetSlot;
    private ILInstruction target;
    public bool DelayExceptions;
    private IField field;
    public ILInstruction Target { get; public set; }
    public IField Field { get; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LdFlda(ILInstruction target, IField field);
    private static LdFlda();
    internal virtual void CheckInvariant(ILPhase phase);
    public ILInstruction get_Target();
    public void set_Target(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public sealed virtual IField get_Field();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdFtn : SimpleInstruction {
    private IMethod method;
    public IMethod Method { get; }
    public StackType ResultType { get; }
    public LdFtn(IMethod method);
    public sealed virtual IMethod get_Method();
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdLen : ILInstruction {
    public static SlotInfo ArraySlot;
    private ILInstruction array;
    private StackType resultType;
    public ILInstruction Array { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public StackType ResultType { get; }
    public LdLen(StackType type, ILInstruction array);
    private static LdLen();
    public ILInstruction get_Array();
    public void set_Array(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdLoc : SimpleInstruction {
    private ILVariable variable;
    [CompilerGeneratedAttribute]
private int <IndexInLoadInstructionList>k__BackingField;
    public ILVariable Variable { get; public set; }
    public int IndexInLoadInstructionList { get; public set; }
    private int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.IndexInVariableInstructionMapping { get; private set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LdLoc(ILVariable variable);
    public sealed virtual ILVariable get_Variable();
    public sealed virtual void set_Variable(ILVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexInLoadInstructionList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexInLoadInstructionList(int value);
    private sealed virtual override int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.get_IndexInVariableInstructionMapping();
    private sealed virtual override void ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.set_IndexInVariableInstructionMapping(int value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdLoca : SimpleInstruction {
    private ILVariable variable;
    [CompilerGeneratedAttribute]
private int <IndexInAddressInstructionList>k__BackingField;
    public StackType ResultType { get; }
    public ILVariable Variable { get; public set; }
    public int IndexInAddressInstructionList { get; public set; }
    private int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.IndexInVariableInstructionMapping { get; private set; }
    public LdLoca(ILVariable variable);
    public virtual StackType get_ResultType();
    public sealed virtual ILVariable get_Variable();
    public sealed virtual void set_Variable(ILVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexInAddressInstructionList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexInAddressInstructionList(int value);
    private sealed virtual override int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.get_IndexInVariableInstructionMapping();
    private sealed virtual override void ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.set_IndexInVariableInstructionMapping(int value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdMemberToken : SimpleInstruction {
    private IMember member;
    public IMember Member { get; }
    public StackType ResultType { get; }
    public LdMemberToken(IMember member);
    public IMember get_Member();
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdNull : SimpleInstruction {
    public StackType ResultType { get; }
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdObj : ILInstruction {
    public static SlotInfo TargetSlot;
    private ILInstruction target;
    private IType type;
    [CompilerGeneratedAttribute]
private bool <IsVolatile>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnalignedPrefix>k__BackingField;
    public ILInstruction Target { get; public set; }
    public IType Type { get; public set; }
    public bool IsVolatile { get; public set; }
    public byte UnalignedPrefix { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LdObj(ILInstruction target, IType type);
    private static LdObj();
    public ILInstruction get_Target();
    public void set_Target(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public IType get_Type();
    public void set_Type(IType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVolatile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsVolatile(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual byte get_UnalignedPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UnalignedPrefix(byte value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    private void OriginalWriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdsFlda : SimpleInstruction {
    private IField field;
    public StackType ResultType { get; }
    public IField Field { get; }
    public LdsFlda(IField field);
    public virtual StackType get_ResultType();
    public sealed virtual IField get_Field();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdStr : SimpleInstruction {
    public string Value;
    public StackType ResultType { get; }
    public LdStr(string value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdStrUtf8 : SimpleInstruction {
    public string Value;
    public StackType ResultType { get; }
    public LdStrUtf8(string value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdTypeToken : SimpleInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public LdTypeToken(IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdVirtDelegate : UnaryInstruction {
    private IType type;
    private IMethod method;
    public IType Type { get; public set; }
    public IMethod Method { get; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LdVirtDelegate(ILInstruction argument, IType type, IMethod method);
    public IType get_Type();
    public void set_Type(IType value);
    public sealed virtual IMethod get_Method();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LdVirtFtn : UnaryInstruction {
    private IMethod method;
    public IMethod Method { get; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LdVirtFtn(ILInstruction argument, IMethod method);
    public sealed virtual IMethod get_Method();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Leave : ILInstruction {
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    [NullableAttribute("2")]
private BlockContainer targetContainer;
    public ILInstruction Value { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public BlockContainer TargetContainer { get; public set; }
    public string TargetLabel { get; }
    public bool IsLeavingFunction { get; }
    public bool TriggersFinallyBlock { get; }
    [NullableContextAttribute("2")]
public Leave(BlockContainer targetContainer, ILInstruction value);
    private static Leave();
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public sealed virtual BlockContainer get_TargetContainer();
    public void set_TargetContainer(BlockContainer value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    public string get_TargetLabel();
    public bool get_IsLeavingFunction();
    public bool get_TriggersFinallyBlock();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LocAlloc : UnaryInstruction {
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LocAlloc(ILInstruction argument);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LocAllocSpan : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LocAllocSpan(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.LockInstruction : ILInstruction {
    public static SlotInfo OnExpressionSlot;
    private ILInstruction onExpression;
    public static SlotInfo BodySlot;
    private ILInstruction body;
    public ILInstruction OnExpression { get; public set; }
    public ILInstruction Body { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public LockInstruction(ILInstruction onExpression, ILInstruction body);
    private static LockInstruction();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public ILInstruction get_OnExpression();
    public void set_OnExpression(ILInstruction value);
    public ILInstruction get_Body();
    public void set_Body(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.MakeRefAny : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public MakeRefAny(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.MatchInstruction : ILInstruction {
    private ILVariable variable;
    [CompilerGeneratedAttribute]
private int <IndexInStoreInstructionList>k__BackingField;
    [NullableAttribute("2")]
private IMethod method;
    public bool IsDeconstructCall;
    public bool IsDeconstructTuple;
    public bool CheckType;
    public bool CheckNotNull;
    public static SlotInfo TestedOperandSlot;
    private ILInstruction testedOperand;
    public static SlotInfo SubPatternsSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <SubPatterns>k__BackingField;
    public bool IsVar { get; }
    public bool HasDesignator { get; }
    public int NumPositionalPatterns { get; }
    public ILVariable Variable { get; public set; }
    public int IndexInStoreInstructionList { get; public set; }
    private int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.IndexInVariableInstructionMapping { get; private set; }
    [NullableAttribute("2")]
public IMethod Method { get; }
    public ILInstruction TestedOperand { get; public set; }
    public InstructionCollection`1<ILInstruction> SubPatterns { get; private set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public MatchInstruction(ILVariable variable, ILInstruction testedOperand);
    public MatchInstruction(ILVariable variable, IMethod method, ILInstruction testedOperand, ILInstruction[] subPatterns);
    private static MatchInstruction();
    public bool get_IsVar();
    public bool get_HasDesignator();
    public int get_NumPositionalPatterns();
    [NullableContextAttribute("2")]
public static bool IsPatternMatch(ILInstruction inst, ILInstruction& testedOperand);
    private static bool IsConstant(ILInstruction inst);
    internal IType GetDeconstructResultType(int index);
    private void AdditionalInvariants();
    [NullableContextAttribute("2")]
internal static bool IsDeconstructMethod(IMethod method);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public sealed virtual ILVariable get_Variable();
    public sealed virtual void set_Variable(ILVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexInStoreInstructionList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexInStoreInstructionList(int value);
    private sealed virtual override int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.get_IndexInVariableInstructionMapping();
    private sealed virtual override void ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.set_IndexInVariableInstructionMapping(int value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    [NullableContextAttribute("2")]
public sealed virtual IMethod get_Method();
    public ILInstruction get_TestedOperand();
    public void set_TestedOperand(ILInstruction value);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_SubPatterns();
    [CompilerGeneratedAttribute]
private void set_SubPatterns(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.NewArr : ILInstruction {
    private IType type;
    public static SlotInfo IndicesSlot;
    [CompilerGeneratedAttribute]
private InstructionCollection`1<ILInstruction> <Indices>k__BackingField;
    public IType Type { get; public set; }
    public InstructionCollection`1<ILInstruction> Indices { get; private set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public NewArr(IType type, ILInstruction[] indices);
    private static NewArr();
    public IType get_Type();
    public void set_Type(IType value);
    [CompilerGeneratedAttribute]
public InstructionCollection`1<ILInstruction> get_Indices();
    [CompilerGeneratedAttribute]
private void set_Indices(InstructionCollection`1<ILInstruction> value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.NewObj : CallInstruction {
    public StackType ResultType { get; }
    public NewObj(IMethod method);
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Nop : SimpleInstruction {
    [NullableAttribute("2")]
public string Comment;
    public NopKind Kind;
    public StackType ResultType { get; }
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
public enum ICSharpCode.Decompiler.IL.NopKind : Enum {
    public int value__;
    public static NopKind Normal;
    public static NopKind Pop;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.NullableRewrap : UnaryInstruction {
    public InstructionFlags DirectFlags { get; }
    public StackType ResultType { get; }
    public NullableRewrap(ILInstruction argument);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual InstructionFlags get_DirectFlags();
    protected virtual InstructionFlags ComputeFlags();
    public virtual StackType get_ResultType();
    internal virtual bool PrepareExtract(int childIndex, ExtractionContext ctx);
    internal virtual bool CanInlineIntoSlot(int childIndex, ILInstruction expressionBeingMoved);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.NullableUnwrap : UnaryInstruction {
    public bool RefInput;
    [CompilerGeneratedAttribute]
private StackType <ResultType>k__BackingField;
    public bool RefOutput { get; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public NullableUnwrap(StackType unwrappedType, ILInstruction argument, bool refInput);
    public bool get_RefOutput();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    [CompilerGeneratedAttribute]
public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.NullCoalescingInstruction : ILInstruction {
    public NullCoalescingKind Kind;
    public StackType UnderlyingResultType;
    public static SlotInfo ValueInstSlot;
    private ILInstruction valueInst;
    public static SlotInfo FallbackInstSlot;
    private ILInstruction fallbackInst;
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public ILInstruction ValueInst { get; public set; }
    public ILInstruction FallbackInst { get; public set; }
    public NullCoalescingInstruction(NullCoalescingKind kind, ILInstruction valueInst, ILInstruction fallbackInst);
    private static NullCoalescingInstruction();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    public virtual InstructionFlags get_DirectFlags();
    protected virtual InstructionFlags ComputeFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public ILInstruction get_ValueInst();
    public void set_ValueInst(ILInstruction value);
    public ILInstruction get_FallbackInst();
    public void set_FallbackInst(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
public enum ICSharpCode.Decompiler.IL.NullCoalescingKind : Enum {
    public int value__;
    public static NullCoalescingKind Ref;
    public static NullCoalescingKind Nullable;
    public static NullCoalescingKind NullableWithValueFallback;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.NumericCompoundAssign : CompoundAssignmentInstruction {
    private IType type;
    public bool CheckForOverflow;
    public Sign Sign;
    public StackType LeftInputType;
    public StackType RightInputType;
    [CompilerGeneratedAttribute]
private StackType <UnderlyingResultType>k__BackingField;
    public BinaryNumericOperator Operator;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public StackType UnderlyingResultType { get; }
    public bool IsLifted { get; }
    public InstructionFlags DirectFlags { get; }
    public NumericCompoundAssign(BinaryNumericInstruction binary, ILInstruction target, CompoundTargetKind targetKind, ILInstruction value, IType type, CompoundEvalMode evalMode);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public sealed virtual StackType get_UnderlyingResultType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    internal static bool IsBinaryCompatibleWithType(BinaryNumericInstruction binary, IType type, DecompilerSettings settings);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
public enum ICSharpCode.Decompiler.IL.OpCode : Enum {
    public byte value__;
    public static OpCode InvalidBranch;
    public static OpCode InvalidExpression;
    public static OpCode Nop;
    public static OpCode ILFunction;
    public static OpCode BlockContainer;
    public static OpCode Block;
    public static OpCode PinnedRegion;
    public static OpCode BinaryNumericInstruction;
    public static OpCode NumericCompoundAssign;
    public static OpCode UserDefinedCompoundAssign;
    public static OpCode DynamicCompoundAssign;
    public static OpCode BitNot;
    public static OpCode Arglist;
    public static OpCode Branch;
    public static OpCode Leave;
    public static OpCode IfInstruction;
    public static OpCode NullCoalescingInstruction;
    public static OpCode SwitchInstruction;
    public static OpCode SwitchSection;
    public static OpCode TryCatch;
    public static OpCode TryCatchHandler;
    public static OpCode TryFinally;
    public static OpCode TryFault;
    public static OpCode LockInstruction;
    public static OpCode UsingInstruction;
    public static OpCode DebugBreak;
    public static OpCode Comp;
    public static OpCode Call;
    public static OpCode CallVirt;
    public static OpCode CallIndirect;
    public static OpCode Ckfinite;
    public static OpCode Conv;
    public static OpCode LdLoc;
    public static OpCode LdLoca;
    public static OpCode StLoc;
    public static OpCode AddressOf;
    public static OpCode ThreeValuedBoolAnd;
    public static OpCode ThreeValuedBoolOr;
    public static OpCode NullableUnwrap;
    public static OpCode NullableRewrap;
    public static OpCode LdStr;
    public static OpCode LdStrUtf8;
    public static OpCode LdcI4;
    public static OpCode LdcI8;
    public static OpCode LdcF4;
    public static OpCode LdcF8;
    public static OpCode LdcDecimal;
    public static OpCode LdNull;
    public static OpCode LdFtn;
    public static OpCode LdVirtFtn;
    public static OpCode LdVirtDelegate;
    public static OpCode LdTypeToken;
    public static OpCode LdMemberToken;
    public static OpCode LocAlloc;
    public static OpCode LocAllocSpan;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode LdFlda;
    public static OpCode LdsFlda;
    public static OpCode CastClass;
    public static OpCode IsInst;
    public static OpCode LdObj;
    public static OpCode StObj;
    public static OpCode Box;
    public static OpCode Unbox;
    public static OpCode UnboxAny;
    public static OpCode NewObj;
    public static OpCode NewArr;
    public static OpCode DefaultValue;
    public static OpCode Throw;
    public static OpCode Rethrow;
    public static OpCode SizeOf;
    public static OpCode LdLen;
    public static OpCode LdElema;
    public static OpCode GetPinnableReference;
    public static OpCode StringToInt;
    public static OpCode ExpressionTreeCast;
    public static OpCode UserDefinedLogicOperator;
    public static OpCode DynamicLogicOperatorInstruction;
    public static OpCode DynamicBinaryOperatorInstruction;
    public static OpCode DynamicUnaryOperatorInstruction;
    public static OpCode DynamicConvertInstruction;
    public static OpCode DynamicGetMemberInstruction;
    public static OpCode DynamicSetMemberInstruction;
    public static OpCode DynamicGetIndexInstruction;
    public static OpCode DynamicSetIndexInstruction;
    public static OpCode DynamicInvokeMemberInstruction;
    public static OpCode DynamicInvokeConstructorInstruction;
    public static OpCode DynamicInvokeInstruction;
    public static OpCode DynamicIsEventInstruction;
    public static OpCode MatchInstruction;
    public static OpCode MakeRefAny;
    public static OpCode RefAnyType;
    public static OpCode RefAnyValue;
    public static OpCode YieldReturn;
    public static OpCode Await;
    public static OpCode DeconstructInstruction;
    public static OpCode DeconstructResultInstruction;
    public static OpCode AnyNode;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Patterns.AnyNode : PatternInstruction {
    [NullableAttribute("2")]
private CaptureGroup group;
    [NullableContextAttribute("2")]
public AnyNode(CaptureGroup group);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
public class ICSharpCode.Decompiler.IL.Patterns.CaptureGroup : object {
}
public class ICSharpCode.Decompiler.IL.Patterns.ListMatch : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<ILInstruction> SyntaxList;
    internal int SyntaxIndex;
    [NullableAttribute("2")]
private List`1<SavePoint> backtrackingStack;
    [NullableAttribute("2")]
private Stack`1<int> restoreStack;
    private ListMatch(IReadOnlyList`1<ILInstruction> syntaxList);
    [NullableContextAttribute("1")]
internal static bool DoMatch(IReadOnlyList`1<ILInstruction> patterns, IReadOnlyList`1<ILInstruction> syntaxList, Match& match);
    [NullableContextAttribute("1")]
internal static bool PerformMatchSequence(IReadOnlyList`1<ILInstruction> patterns, ListMatch& listMatch, Match& match);
    private void AddSavePoint(SavePoint savepoint);
    internal void AddSavePoint(Match& match, int data);
    internal int GetSavePointStartMarker();
    internal void PushToSavePoints(int startMarker, int data);
    internal Nullable`1<int> PopFromSavePoint();
    internal bool RestoreSavePoint(Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Patterns.Match : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static List`1<KeyValuePair`2<CaptureGroup, ILInstruction>> emptyResults;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<CaptureGroup, ILInstruction>> results;
    public bool Success { get; internal set; }
    private static Match();
    public bool get_Success();
    internal void set_Success(bool value);
    public static bool op_True(Match m);
    public static bool op_False(Match m);
    internal void Add(CaptureGroup g, ILInstruction n);
    internal int CheckPoint();
    internal void RestoreCheckPoint(int checkPoint);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.IL.Patterns.Match/<Get>d__10")]
public IEnumerable`1<ILInstruction> Get(CaptureGroup captureGroup);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.Patterns.PatternInstruction : ILInstruction {
    public InstructionFlags DirectFlags { get; }
    public StackType ResultType { get; }
    protected PatternInstruction(OpCode opCode);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual StackType get_ResultType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.PinnedRegion : ILInstruction {
    private ILVariable variable;
    [CompilerGeneratedAttribute]
private int <IndexInStoreInstructionList>k__BackingField;
    public static SlotInfo InitSlot;
    private ILInstruction init;
    public static SlotInfo BodySlot;
    private ILInstruction body;
    public StackType ResultType { get; }
    public ILVariable Variable { get; public set; }
    public int IndexInStoreInstructionList { get; public set; }
    private int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.IndexInVariableInstructionMapping { get; private set; }
    public ILInstruction Init { get; public set; }
    public ILInstruction Body { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public PinnedRegion(ILVariable variable, ILInstruction init, ILInstruction body);
    private static PinnedRegion();
    public virtual StackType get_ResultType();
    public sealed virtual ILVariable get_Variable();
    public sealed virtual void set_Variable(ILVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexInStoreInstructionList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexInStoreInstructionList(int value);
    private sealed virtual override int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.get_IndexInVariableInstructionMapping();
    private sealed virtual override void ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.set_IndexInVariableInstructionMapping(int value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    public ILInstruction get_Init();
    public void set_Init(ILInstruction value);
    public ILInstruction get_Body();
    public void set_Body(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
internal class ICSharpCode.Decompiler.IL.PointerArithmeticOffset : ValueType {
    public static ILInstruction Detect(ILInstruction byteOffsetInst, IType pointerElementType, bool checkForOverflow, bool unwrapZeroExtension);
    public static Nullable`1<int> ComputeSizeOf(IType type);
    internal static bool IsFixedVariable(ILInstruction inst);
}
public enum ICSharpCode.Decompiler.IL.PrimitiveType : Enum {
    public byte value__;
    public static PrimitiveType None;
    public static PrimitiveType I1;
    public static PrimitiveType I2;
    public static PrimitiveType I4;
    public static PrimitiveType I8;
    public static PrimitiveType R4;
    public static PrimitiveType R8;
    public static PrimitiveType U1;
    public static PrimitiveType U2;
    public static PrimitiveType U4;
    public static PrimitiveType U8;
    public static PrimitiveType I;
    public static PrimitiveType U;
    public static PrimitiveType Ref;
    public static PrimitiveType R;
    public static PrimitiveType Unknown;
}
public class ICSharpCode.Decompiler.IL.ReduceNestingTransform : object {
    private ILTransformContext context;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private void Visit(BlockContainer container, Block continueTarget);
    private void Visit(Block block, Block continueTarget, ILInstruction nextInstruction);
    private void VisitContainers(ILInstruction inst, Block continueTarget);
    private void ImproveILOrdering(Block block, IfInstruction ifInst, Block continueTarget);
    private bool ReduceNesting(Block block, IfInstruction ifInst, ILInstruction exitInst);
    private bool ReduceSwitchNesting(Block parentBlock, BlockContainer switchContainer, ILInstruction exitInst);
    private bool CanDuplicateExit(ILInstruction exit, Block continueTarget, ILInstruction& keywordExit);
    private void EnsureEndPointUnreachable(ILInstruction inst, ILInstruction fallthroughExit);
    private void RemoveRedundantExit(Block block, ILInstruction implicitExit);
    private IfInstruction GetElseIfParent(IfInstruction ifInst);
    private void UpdateStats(ILInstruction inst, Int32& maxStatements, Int32& maxDepth);
    private void ComputeStats(ILInstruction inst, Int32& numStatements, Int32& maxDepth, int currentDepth, bool isStatement);
    private bool ShouldReduceNesting(ILInstruction inst, int maxStatements, int maxDepth);
    private void ExtractElseBlock(IfInstruction ifInst);
    private void EliminateRedundantTryFinally(TryFinally tryFinally, ILTransformContext context);
    [CompilerGeneratedAttribute]
internal static ILInstruction <Visit>g__NextInsn|3_0(<>c__DisplayClass3_0& , <>c__DisplayClass3_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.RefAnyType : UnaryInstruction {
    public StackType ResultType { get; }
    public RefAnyType(ILInstruction argument);
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.RefAnyValue : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public RefAnyValue(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Rethrow : SimpleInstruction {
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class ICSharpCode.Decompiler.IL.SemanticHelper : object {
    internal static InstructionFlags CombineBranches(InstructionFlags trueFlags, InstructionFlags falseFlags);
    internal static bool IsPure(InstructionFlags inst);
    internal static bool MayReorder(ILInstruction inst1, ILInstruction inst2);
    private static bool Inst2MightWriteToVariableReadByInst1(ILInstruction inst1, ILInstruction inst2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.SimpleInstruction : ILInstruction {
    public InstructionFlags DirectFlags { get; }
    protected SimpleInstruction(OpCode opCode);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.SizeOf : SimpleInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public SizeOf(IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.SlotInfo : object {
    public static SlotInfo None;
    public string Name;
    public bool CanInlineInto;
    public bool IsCollection;
    public SlotInfo(string name, bool canInlineInto, bool isCollection);
    private static SlotInfo();
    public virtual string ToString();
}
public enum ICSharpCode.Decompiler.IL.StackType : Enum {
    public byte value__;
    public static StackType Unknown;
    public static StackType I4;
    public static StackType I;
    public static StackType I8;
    public static StackType F4;
    public static StackType F8;
    public static StackType O;
    public static StackType Ref;
    public static StackType Void;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.StLoc : ILInstruction {
    internal bool IsStackAdjustment;
    internal bool ILStackWasEmpty;
    private ILVariable variable;
    [CompilerGeneratedAttribute]
private int <IndexInStoreInstructionList>k__BackingField;
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    public ILVariable Variable { get; public set; }
    public int IndexInStoreInstructionList { get; public set; }
    private int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.IndexInVariableInstructionMapping { get; private set; }
    public ILInstruction Value { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public StLoc(ILVariable variable, ILInstruction value);
    private static StLoc();
    internal virtual void CheckInvariant(ILPhase phase);
    public sealed virtual ILVariable get_Variable();
    public sealed virtual void set_Variable(ILVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexInStoreInstructionList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexInStoreInstructionList(int value);
    private sealed virtual override int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.get_IndexInVariableInstructionMapping();
    private sealed virtual override void ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.set_IndexInVariableInstructionMapping(int value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.StObj : ILInstruction {
    public static SlotInfo TargetSlot;
    private ILInstruction target;
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    private IType type;
    [CompilerGeneratedAttribute]
private bool <IsVolatile>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <UnalignedPrefix>k__BackingField;
    public ILInstruction Target { get; public set; }
    public ILInstruction Value { get; public set; }
    public IType Type { get; public set; }
    public bool IsVolatile { get; public set; }
    public byte UnalignedPrefix { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public StObj(ILInstruction target, ILInstruction value, IType type);
    private static StObj();
    public bool CanInlineIntoTargetSlot(ILInstruction inst);
    private void CheckTargetSlot();
    public ILInstruction get_Target();
    public void set_Target(ILInstruction value);
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public IType get_Type();
    public void set_Type(IType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVolatile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsVolatile(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual byte get_UnalignedPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UnalignedPrefix(byte value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    private void OriginalWriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.StringToInt : ILInstruction {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<string, int>> <Map>k__BackingField;
    public static SlotInfo ArgumentSlot;
    private ILInstruction argument;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, int>> Map { get; }
    public ILInstruction Argument { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public StringToInt(ILInstruction argument, List`1<ValueTuple`2<string, int>> map);
    public StringToInt(ILInstruction argument, String[] map);
    private static StringToInt();
    [CompilerGeneratedAttribute]
public List`1<ValueTuple`2<string, int>> get_Map();
    private static List`1<ValueTuple`2<string, int>> ArrayToDictionary(String[] map);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public ILInstruction get_Argument();
    public void set_Argument(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.SwitchInstruction : ILInstruction {
    public static SlotInfo ValueSlot;
    public static SlotInfo SectionSlot;
    public bool IsLifted;
    [NullableAttribute("2")]
public IType Type;
    private ILInstruction value;
    public InstructionCollection`1<SwitchSection> Sections;
    private StackType resultType;
    public ILInstruction Value { get; public set; }
    public InstructionFlags DirectFlags { get; }
    public StackType ResultType { get; }
    public SwitchInstruction(ILInstruction value);
    private static SwitchInstruction();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    protected virtual int GetChildCount();
    protected virtual ILInstruction GetChild(int index);
    protected virtual void SetChild(int index, ILInstruction value);
    protected virtual SlotInfo GetChildSlot(int index);
    public virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    public void SetResultType(StackType resultType);
    internal virtual void CheckInvariant(ILPhase phase);
    public SwitchSection GetDefaultSection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.SwitchSection : ILInstruction {
    public static SlotInfo BodySlot;
    private ILInstruction body;
    [CompilerGeneratedAttribute]
private bool <HasNullLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private LongSet <Labels>k__BackingField;
    public ILInstruction Body { get; public set; }
    public StackType ResultType { get; }
    public bool HasNullLabel { get; public set; }
    public LongSet Labels { get; public set; }
    public InstructionFlags DirectFlags { get; }
    private static SwitchSection();
    public ILInstruction get_Body();
    public void set_Body(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    [CompilerGeneratedAttribute]
public bool get_HasNullLabel();
    [CompilerGeneratedAttribute]
public void set_HasNullLabel(bool value);
    [CompilerGeneratedAttribute]
public LongSet get_Labels();
    [CompilerGeneratedAttribute]
public void set_Labels(LongSet value);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ThreeValuedBoolAnd : BinaryInstruction {
    private bool ICSharpCode.Decompiler.IL.ILiftableInstruction.IsLifted { get; }
    private StackType ICSharpCode.Decompiler.IL.ILiftableInstruction.UnderlyingResultType { get; }
    public StackType ResultType { get; }
    public ThreeValuedBoolAnd(ILInstruction left, ILInstruction right);
    private sealed virtual override bool ICSharpCode.Decompiler.IL.ILiftableInstruction.get_IsLifted();
    private sealed virtual override StackType ICSharpCode.Decompiler.IL.ILiftableInstruction.get_UnderlyingResultType();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.ThreeValuedBoolOr : BinaryInstruction {
    private bool ICSharpCode.Decompiler.IL.ILiftableInstruction.IsLifted { get; }
    private StackType ICSharpCode.Decompiler.IL.ILiftableInstruction.UnderlyingResultType { get; }
    public StackType ResultType { get; }
    public ThreeValuedBoolOr(ILInstruction left, ILInstruction right);
    private sealed virtual override bool ICSharpCode.Decompiler.IL.ILiftableInstruction.get_IsLifted();
    private sealed virtual override StackType ICSharpCode.Decompiler.IL.ILiftableInstruction.get_UnderlyingResultType();
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Throw : UnaryInstruction {
    internal StackType resultType;
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Throw(ILInstruction argument);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Transforms.AccessPathElement : ValueType {
    public OpCode OpCode;
    public IMember Member;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ILInstruction[] Indices;
    public AccessPathElement(OpCode opCode, IMember member, ILInstruction[] indices);
    public virtual string ToString();
    public static ValueTuple`4<AccessPathKind, List`1<AccessPathElement>, List`1<ILInstruction>, ILVariable> GetAccessPath(ILInstruction instruction, IType rootType, DecompilerSettings settings, CSharpTypeResolveContext resolveContext, Dictionary`2<ILVariable, ValueTuple`2<int, ILInstruction>> possibleIndexVariables);
    private static bool CanBeUsedInInitializer(IProperty property, CSharpTypeResolveContext resolveContext, AccessPathKind kind);
    private static bool IsAccessorAccessible(IMethod setter, CSharpTypeResolveContext resolveContext);
    private static bool IsMethodApplicable(IMethod method, IReadOnlyList`1<ILInstruction> arguments, IType rootType, CSharpTypeResolveContext resolveContext, DecompilerSettings settings);
    private static IType GetReturnTypeFromInstruction(ILInstruction instruction);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AccessPathElement other);
    public static bool op_Equality(AccessPathElement lhs, AccessPathElement rhs);
    public static bool op_Inequality(AccessPathElement lhs, AccessPathElement rhs);
    [CompilerGeneratedAttribute]
internal static bool <IsMethodApplicable>g__CanInferTypeArgumentsFromParameters|8_1(IMethod method, <>c__DisplayClass8_0& );
}
public enum ICSharpCode.Decompiler.IL.Transforms.AccessPathKind : Enum {
    public int value__;
    public static AccessPathKind Invalid;
    public static AccessPathKind Setter;
    public static AccessPathKind Adder;
}
public class ICSharpCode.Decompiler.IL.Transforms.AssignVariableNames : object {
    private static Dictionary`2<string, string> typeNameToVariableNameDict;
    private ILTransformContext context;
    private List`1<string> currentLowerCaseTypeOrMemberNames;
    private Dictionary`2<string, int> reservedVariableNames;
    private Dictionary`2<MethodDefinitionHandle, string> localFunctionMapping;
    private HashSet`1<ILVariable> loopCounters;
    private static char maxLoopVariableName;
    private int numDisplayClassLocals;
    private static AssignVariableNames();
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.IL.Transforms.AssignVariableNames/<CollectAllLowerCaseMemberNames>d__9")]
private static IEnumerable`1<string> CollectAllLowerCaseMemberNames(ITypeDefinition type);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.IL.Transforms.AssignVariableNames/<CollectAllLowerCaseTypeNames>d__10")]
private static IEnumerable`1<string> CollectAllLowerCaseTypeNames(ITypeDefinition type);
    private static bool IsLowerCase(string name);
    private bool IsSetOrEventAccessor(IMethod method);
    private void PerformAssignment(ILFunction function);
    internal static bool IsSupportedInstruction(object arg);
    private bool ConflictWithLocal(ILVariable v);
    internal static bool IsValidName(string varName);
    public string GetAlternativeName(string oldVariableName);
    private HashSet`1<ILVariable> CollectLoopCounters(ILFunction function);
    private string GenerateNameForVariable(ILVariable variable);
    private static string GetNameFromInstruction(ILInstruction inst);
    private static string GetNameForArgument(ILInstruction parent, int i);
    private static bool ExcludeMethodFromCandidates(IMethod m);
    private static string GetNameByType(IType type);
    private static void AddExistingName(Dictionary`2<string, int> reservedVariableNames, string name);
    private static string SplitName(string name, Int32& number);
    private static string CleanUpVariableName(string name);
    internal static IType GuessType(IType variableType, ILInstruction inst, ILTransformContext context);
    private static Dictionary`2<string, int> CollectReservedVariableNames(ILFunction function, ILVariable existingVariable, bool mustResolveConflicts);
    internal static string GenerateForeachVariableName(ILFunction function, ILInstruction valueContext, ILVariable existingVariable, bool mustResolveConflicts);
    internal static string GenerateVariableName(ILFunction function, IType type, ILInstruction valueContext, ILVariable existingVariable, bool mustResolveConflicts);
    private static bool IsPlural(string baseName, String& proposedName);
    [CompilerGeneratedAttribute]
private void <PerformAssignment>g__AssignName|13_1(<>c__DisplayClass13_0& );
}
public class ICSharpCode.Decompiler.IL.Transforms.BlockILTransform : object {
    [CompilerGeneratedAttribute]
private IList`1<IBlockTransform> <PreOrderTransforms>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IBlockTransform> <PostOrderTransforms>k__BackingField;
    private bool running;
    public IList`1<IBlockTransform> PreOrderTransforms { get; }
    public IList`1<IBlockTransform> PostOrderTransforms { get; }
    [CompilerGeneratedAttribute]
public IList`1<IBlockTransform> get_PreOrderTransforms();
    [CompilerGeneratedAttribute]
public IList`1<IBlockTransform> get_PostOrderTransforms();
    public virtual string ToString();
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private void VisitBlock(ControlFlowNode cfgNode, BlockTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.BlockTransformContext : ILTransformContext {
    [CompilerGeneratedAttribute]
private Block <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowNode <ControlFlowNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    public Block Block { get; public set; }
    public ControlFlowNode ControlFlowNode { get; public set; }
    public ControlFlowGraph ControlFlowGraph { get; public set; }
    public BlockTransformContext(ILTransformContext context);
    [CompilerGeneratedAttribute]
public Block get_Block();
    [CompilerGeneratedAttribute]
public void set_Block(Block value);
    [CompilerGeneratedAttribute]
public ControlFlowNode get_ControlFlowNode();
    [CompilerGeneratedAttribute]
public void set_ControlFlowNode(ControlFlowNode value);
    [CompilerGeneratedAttribute]
public ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public void set_ControlFlowGraph(ControlFlowGraph value);
}
public class ICSharpCode.Decompiler.IL.Transforms.CachedDelegateInitialization : object {
    private BlockTransformContext context;
    public sealed virtual void Run(Block block, BlockTransformContext context);
    private bool CachedDelegateInitializationWithField(IfInstruction inst);
    private bool CachedDelegateInitializationWithLocal(IfInstruction inst);
    private bool CachedDelegateInitializationRoslynInStaticWithLocal(IfInstruction inst);
    private bool CachedDelegateInitializationRoslynWithLocal(IfInstruction inst);
    private bool CachedDelegateInitializationVB(IfInstruction inst);
    private bool CachedDelegateInitializationVBWithReturn(IfInstruction inst);
    private bool CachedDelegateInitializationVBWithClosure(IfInstruction inst);
}
internal class ICSharpCode.Decompiler.IL.Transforms.CombineExitsTransform : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static Leave CombineExits(Block block);
}
public class ICSharpCode.Decompiler.IL.Transforms.CopyPropagation : object {
    public static void Propagate(StLoc store, ILTransformContext context);
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static void RunOnBlock(Block block, ILTransformContext context, HashSet`1<ILVariable> splitVariables);
    private static bool CanPerformCopyPropagation(ILVariable target, ILInstruction value, HashSet`1<ILVariable> splitVariables);
    private static void DoPropagate(ILVariable v, ILInstruction copiedExpr, Block block, Int32& i, ILTransformContext context);
}
internal class ICSharpCode.Decompiler.IL.Transforms.DeconstructionTransform : object {
    private StatementTransformContext context;
    private Dictionary`2<ILVariable, int> deconstructionResultsLookup;
    private ILVariable[] deconstructionResults;
    private ILVariable tupleVariable;
    private TupleType tupleType;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(Block block, int pos, StatementTransformContext context);
    private void Reset();
    private int FindIndex(ILInstruction inst, Action`1& delayedActions);
    private bool InlineDeconstructionInitializer(Block block, int pos);
    private bool TransformDeconstruction(Block block, int pos);
    private bool MatchDeconstruction(ILInstruction inst, IMethod& deconstructMethod, ILInstruction& testedOperand);
    private bool MatchConversions(Block block, Int32& pos, Dictionary`2& conversions, List`1& conversionStLocs, Action`1& delayedActions);
    private bool MatchConversion(ILInstruction inst, ILInstruction& inputInstruction, ILVariable& outputVariable, ConversionInfo& info);
    private bool MatchAssignments(Block block, Int32& pos, Dictionary`2<ILVariable, ConversionInfo> conversions, List`1<StLoc> conversionStLocs, Action`1& delayedActions);
    private bool MatchAssignment(ILInstruction inst, IType& targetType, ILInstruction& valueInst, Action`1& addAssignment);
    private bool IsCompatibleImplicitConversion(IType targetType, ConversionInfo conversionInfo);
}
public class ICSharpCode.Decompiler.IL.Transforms.DelegateConstruction : object {
    private ILTransformContext context;
    private ITypeResolveContext decompilationContext;
    private Stack`1<MethodDefinitionHandle> activeMethods;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
    internal static bool MatchDelegateConstruction(ILInstruction inst, IMethod& targetMethod, ILInstruction& target, IType& delegateType, bool allowTransformed);
    private static bool IsAnonymousMethod(ITypeDefinition decompiledTypeDefinition, IMethod method);
    private static bool ContainsAnonymousType(IMethod method);
    private static Nullable`1<GenericContext> GenericContextFromTypeArguments(TypeParameterSubstitution subst);
    private ILFunction TransformDelegateConstruction(ILInstruction value, IMethod targetMethod, ILInstruction target, IType delegateType);
    private static bool ValidateDelegateTarget(ILInstruction inst);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.IL.Transforms.DelegateConstruction/<GetTransforms>d__10")]
private IEnumerable`1<IILTransform> GetTransforms();
}
public class ICSharpCode.Decompiler.IL.Transforms.DetectCatchWhenConditionBlocks : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static void PropagateExceptionVariable(ILTransformContext context, TryCatchHandler handler);
    private bool MatchCatchWhenEntryPoint(ILVariable exceptionVar, BlockContainer container, Block entryPoint, IType& exceptionType, ILInstruction& exceptionSlot, Block& whenConditionBlock);
    private bool MatchFalseBlock(BlockContainer container, Block falseBlock, ILVariable& returnVar, Block& exitBlock);
    private bool MatchExitBlock(BlockContainer container, Block exitBlock, ILVariable returnVar);
    [CompilerGeneratedAttribute]
internal static void <PropagateExceptionVariable>g__PropagateExceptionInstance|1_0(StLoc store, <>c__DisplayClass1_0& );
}
public class ICSharpCode.Decompiler.IL.Transforms.DynamicCallSiteTransform : object {
    private ILTransformContext context;
    private static string CallSiteTypeName;
    private static string CSharpBinderTypeName;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private ILInstruction MakeDynamicInstruction(CallSiteInfo callsite, CallVirt targetInvokeCall, List`1<ILInstruction> deadArguments);
    private bool ScanCallSiteInitBlock(Block callSiteInitBlock, IField callSiteCacheField, IType callSiteDelegateType, CallSiteInfo& callSiteInfo, Block& blockAfterInit);
    private bool ExtractArgumentInfo(ILInstruction value, CallSiteInfo& callSiteInfo, int instructionOffset, ILVariable variable);
    private bool MatchCallSiteCacheNullCheck(ILInstruction condition, IField& callSiteCacheField, IType& callSiteDelegate, Boolean& invertBranches);
}
public class ICSharpCode.Decompiler.IL.Transforms.DynamicIsEventAssignmentTransform : object {
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
    private static bool MatchIsEventAssignmentIfInstruction(ILInstruction ifInst, DynamicIsEventInstruction isEvent, ILVariable flagVar, ILVariable getMemberVar, DynamicSetMemberInstruction& setMemberInst, ILInstruction& getMemberVarUse, ILInstruction& isEventConditionUse);
    private static bool MatchLhsCacheIfInstruction(ILInstruction ifInst, ILVariable flagVar, StLoc& cacheStore);
    private static bool MatchFlagEqualsZero(ILInstruction condition, ILVariable flagVar);
}
public class ICSharpCode.Decompiler.IL.Transforms.EarlyExpressionTransforms : ILVisitor {
    private ILTransformContext context;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    protected virtual void Default(ILInstruction inst);
    protected internal virtual void VisitComp(Comp inst);
    internal static void FixComparisonKindLdNull(Comp inst, ILTransformContext context);
    protected internal virtual void VisitStObj(StObj inst);
    internal static bool StObjToStLoc(StObj inst, ILTransformContext context);
    protected internal virtual void VisitLdObj(LdObj inst);
    internal static bool LdObjToLdLoc(LdObj inst, ILTransformContext context);
    internal static void AddressOfLdLocToLdLoca(LdObj inst, ILTransformContext context);
}
internal enum ICSharpCode.Decompiler.IL.Transforms.ExpressionClassification : Enum {
    public int value__;
    public static ExpressionClassification RValue;
    public static ExpressionClassification MutableLValue;
    public static ExpressionClassification ReadonlyLValue;
}
public class ICSharpCode.Decompiler.IL.Transforms.ExpressionTransforms : ILVisitor {
    internal StatementTransformContext context;
    public static void RunOnSingleStatement(ILInstruction statement, ILTransformContext context);
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
    protected virtual void Default(ILInstruction inst);
    protected internal virtual void VisitBlockContainer(BlockContainer container);
    protected internal virtual void VisitBlock(Block block);
    protected internal virtual void VisitComp(Comp inst);
    protected internal virtual void VisitConv(Conv inst);
    protected internal virtual void VisitBox(Box inst);
    protected internal virtual void VisitLdElema(LdElema inst);
    protected internal virtual void VisitNewArr(NewArr inst);
    private void CleanUpArrayIndices(InstructionCollection`1<ILInstruction> indices);
    private void VisitLogicNot(Comp inst, ILInstruction arg);
    protected internal virtual void VisitCall(Call inst);
    protected internal virtual void VisitCallVirt(CallVirt inst);
    protected internal virtual void VisitNewObj(NewObj inst);
    private bool TransformDelegateCtorLdVirtFtnToLdVirtDelegate(NewObj inst, LdVirtDelegate& ldVirtDelegate);
    private bool TransformSpanTCtorContainingStackAlloc(NewObj newObj, ILInstruction& locallocSpan);
    private bool MatchesElementCount(ILInstruction sizeInBytesInstr, IType elementType, ILInstruction elementCountInstr2);
    private bool TransformDecimalCtorToConstant(NewObj inst, LdcDecimal& result);
    private bool TransformDecimalFieldToConstant(LdObj inst, LdcDecimal& result);
    protected internal virtual void VisitLdObj(LdObj inst);
    protected internal virtual void VisitStObj(StObj inst);
    protected internal virtual void VisitStLoc(StLoc inst);
    protected internal virtual void VisitIfInstruction(IfInstruction inst);
    private IfInstruction HandleConditionalOperator(IfInstruction inst);
    private void HandleSwitchExpression(BlockContainer container, SwitchInstruction switchInst);
    private bool TransformDynamicAddAssignOrRemoveAssign(IfInstruction inst);
    protected internal virtual void VisitDynamicSetMemberInstruction(DynamicSetMemberInstruction inst);
    internal static void TransformDynamicSetMemberInstruction(DynamicSetMemberInstruction inst, StatementTransformContext context);
    protected internal virtual void VisitDynamicSetIndexInstruction(DynamicSetIndexInstruction inst);
    protected internal virtual void VisitBinaryNumericInstruction(BinaryNumericInstruction inst);
    protected internal virtual void VisitTryCatchHandler(TryCatchHandler inst);
    private void TransformCatchVariable(TryCatchHandler handler, Block entryPoint, bool isCatchBlock);
    private void TransformCatchWhen(TryCatchHandler handler, Block entryPoint);
    [CompilerGeneratedAttribute]
internal static bool <VisitBinaryNumericInstruction>g__MatchExpectedShiftSize|31_0(ILInstruction rhs, <>c__DisplayClass31_0& );
}
internal class ICSharpCode.Decompiler.IL.Transforms.ExtractionContext : object {
    private ILFunction Function;
    private ILTransformContext context;
    internal InstructionFlags FlagsBeingMoved;
    private List`1<Func`1<ILInstruction>> MoveActions;
    private ExtractionContext(ILFunction function, ILTransformContext context);
    internal void RegisterMove(ILInstruction predecessor);
    internal void RegisterMoveIfNecessary(ILInstruction predecessor);
    public bool CanReorderWithInstructionsBeingMoved(ILInstruction predecessor);
    public static ILVariable Extract(ILInstruction instToExtract, ILTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.FixLoneIsInst : object {
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.FixRemainingIncrements : object {
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.HighLevelLoopTransform : object {
    private ILTransformContext context;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private bool MatchWhileLoop(BlockContainer loop, IfInstruction& condition, Block& loopBody);
    private bool MightBeHeaderOfForEach(BlockContainer loop, List`1<ILInstruction> conditions);
    private void SplitConditions(ILInstruction expression, List`1<ILInstruction> conditions);
    private bool MatchDoWhileLoop(BlockContainer loop);
    private static ValueTuple`5<List`1<IfInstruction>, ILInstruction, bool, bool, bool> AnalyzeDoWhileConditions(BlockContainer loop);
    private static List`1<IfInstruction> CollectConditions(BlockContainer loop, Block block, bool swap);
    private static bool UsesVariableCapturedInLoop(BlockContainer loop, ILInstruction condition);
    private static bool MatchDoWhileConditionBlock(BlockContainer loop, Block block, Boolean& swapBranches, Boolean& unwrapCondtionBlock, Block& conditionBlock);
    internal static bool MatchDoWhileConditionBlock(Block block, Block& target1, Block& target2);
    internal static Block GetIncrementBlock(BlockContainer loop, Block whileLoopBody);
    internal static bool MatchIncrementBlock(Block block, Block& loopHead);
    private bool MatchForLoop(BlockContainer loop, IfInstruction whileCondition, Block whileLoopBody);
    private bool IsAssignment(ILInstruction inst);
    public static bool MatchIncrement(ILInstruction inst, ILVariable& variable);
    private static bool IsSimpleStatement(ILInstruction inst);
    [CompilerGeneratedAttribute]
internal static bool <MightBeHeaderOfForEach>g__IsGetCurrentCall|3_0(ILInstruction inst);
}
public interface ICSharpCode.Decompiler.IL.Transforms.IBlockTransform {
    public abstract virtual void Run(Block block, BlockTransformContext context);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.IL.Transforms.IILTransform {
    public abstract virtual void Run(ILFunction function, ILTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.ILInlining : object {
    internal InliningOptions options;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    public sealed virtual void Run(Block block, BlockTransformContext context);
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
    internal static InliningOptions OptionsForBlock(Block block, int pos, ILTransformContext context);
    private static bool PreferExpressionsOverStatements(ILFunction function);
    public static bool InlineAllInBlock(ILFunction function, Block block, InliningOptions options, ILTransformContext context);
    internal static bool IsInConstructorInitializer(ILFunction function, ILInstruction inst);
    internal static bool IsCatchWhenBlock(Block block);
    public static int InlineInto(Block block, int pos, InliningOptions options, ILTransformContext context);
    public static bool InlineIfPossible(Block block, int pos, ILTransformContext context);
    public static bool InlineOneIfPossible(Block block, int pos, InliningOptions options, ILTransformContext context);
    public static bool InlineOne(StLoc stloc, InliningOptions options, ILTransformContext context);
    private static bool DoInline(ILVariable v, ILInstruction inlinedExpression, ILInstruction next, InliningOptions options, ILTransformContext context);
    private static bool IsGeneratedValueTypeTemporary(LdLoca loadInst, ILVariable v, ILInstruction inlinedExpression, InliningOptions options);
    internal static bool MethodRequiresCopyForReadonlyLValue(IMethod method, IType constrainedTo);
    internal static bool IsUsedAsThisPointerInCall(LdLoca ldloca);
    private static bool IsUsedAsThisPointerInCall(LdLoca ldloca, IMethod& method, IType& constrainedType);
    private static bool IsUsedAsThisPointerInFieldRead(LdLoca ldloca);
    internal static ExpressionClassification ClassifyExpression(ILInstruction inst);
    internal static bool IsReadonlyReference(ILInstruction addr);
    private static bool NonAggressiveInlineInto(ILInstruction next, FindResult findResult, ILInstruction inlinedExpression, ILVariable v);
    public static bool CanInlineInto(ILInstruction expr, ILVariable v, ILInstruction expressionBeingMoved);
    internal static FindResult FindLoadInNext(ILInstruction expr, ILVariable v, ILInstruction expressionBeingMoved, InliningOptions options);
    private static FindResult NoContinue(FindResult findResult);
    private static bool IsSafeForInlineOver(ILInstruction expr, ILInstruction expressionBeingMoved);
    internal static CallInstruction FindFirstInlinedCall(ILInstruction inst);
    public static bool CanMoveInto(ILInstruction expressionBeingMoved, ILInstruction stmt, ILInstruction targetLoad);
    internal static bool CanUninline(ILInstruction arg, ILInstruction stmt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.IL.Transforms.ILInstructionMatchComparer : object {
    public static ILInstructionMatchComparer Instance;
    private static ILInstructionMatchComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ILInstruction x, ILInstruction y);
    public sealed virtual int GetHashCode(ILInstruction obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Transforms.ILTransformContext : object {
    [CompilerGeneratedAttribute]
private ILFunction <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecompilerTypeSystem <TypeSystem>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDebugInfoProvider <DebugInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DecompilerSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Stepper <Stepper>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DecompileRun <DecompileRun>k__BackingField;
    public ILFunction Function { get; }
    public IDecompilerTypeSystem TypeSystem { get; }
    [NullableAttribute("2")]
public IDebugInfoProvider DebugInfo { get; }
    public DecompilerSettings Settings { get; }
    public CancellationToken CancellationToken { get; public set; }
    public Stepper Stepper { get; public set; }
    public PEFile PEFile { get; }
    [NullableAttribute("2")]
internal DecompileRun DecompileRun { get; internal set; }
    [NullableAttribute("2")]
internal ResolvedUsingScope UsingScope { get; }
    public ILTransformContext(ILFunction function, IDecompilerTypeSystem typeSystem, IDebugInfoProvider debugInfo, DecompilerSettings settings);
    public ILTransformContext(ILTransformContext context, ILFunction function);
    [CompilerGeneratedAttribute]
public ILFunction get_Function();
    [CompilerGeneratedAttribute]
public IDecompilerTypeSystem get_TypeSystem();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IDebugInfoProvider get_DebugInfo();
    [CompilerGeneratedAttribute]
public DecompilerSettings get_Settings();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public Stepper get_Stepper();
    [CompilerGeneratedAttribute]
public void set_Stepper(Stepper value);
    public PEFile get_PEFile();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal DecompileRun get_DecompileRun();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_DecompileRun(DecompileRun value);
    [NullableContextAttribute("2")]
internal ResolvedUsingScope get_UsingScope();
    internal ILReader CreateILReader();
    [ConditionalAttribute("STEP")]
internal void Step(string description, ILInstruction near);
    [ConditionalAttribute("STEP")]
internal void StepStartGroup(string description, ILInstruction near);
    [ConditionalAttribute("STEP")]
internal void StepEndGroup(bool keepIfEmpty);
}
internal class ICSharpCode.Decompiler.IL.Transforms.IndexRangeTransform : object {
    public static bool HandleLdElema(LdElema ldelema, ILTransformContext context);
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(Block block, int pos, StatementTransformContext context);
    private bool MatchIndexImplicitConv(ILInstruction inst, ILInstruction& offsetInst);
    private static bool IsSlicingMethod(IMethod method);
    private bool CheckContainerLengthVariableUseCount(ILVariable containerLengthVar, IndexKind startIndexKind, IndexKind endIndexKind);
    private static bool MatchIndexFromRange(IndexKind indexKind, ILInstruction indexLoad, ILVariable rangeVar, string accessorName);
    private static ILInstruction MakeIndex(IndexKind indexKind, ILInstruction indexLoad, IndexMethods specialMethods);
    private bool CSharpWillGenerateIndexer(IType declaringType, bool slicing);
    private static bool MatchContainerLengthStore(ILInstruction inst, ILVariable& lengthVar, ILVariable& containerVar);
    private static bool MatchContainerLength(ILInstruction init, ILVariable lengthVar, ILVariable& containerVar);
    private static bool MatchContainerVar(ILInstruction inst, ILVariable& containerVar);
    private static IndexKind MatchGetOffset(ILInstruction inst, ILInstruction& indexLoad, ILVariable containerLengthVar, ILVariable& containerVar);
    private static bool MatchSliceLength(ILInstruction inst, IndexKind& endIndexKind, ILInstruction& endIndexLoad, ILVariable containerLengthVar, ILVariable& containerVar, ILVariable startOffsetVar);
    [CompilerGeneratedAttribute]
private void <ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run>g__TransformIndexing|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
private void <ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run>g__TransformSlicing|2_1(bool sliceLengthWasMisdetectedAsStartOffset, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
private ILInstruction <ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run>g__MakeRange|2_2(IndexKind startIndexKind, ILInstruction startIndexLoad, IndexKind endIndexKind, ILInstruction endIndexLoad, IndexMethods specialMethods, <>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
private void <ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run>g__ExtendSlicing|2_3(<>c__DisplayClass2_0& );
}
internal class ICSharpCode.Decompiler.IL.Transforms.InlineReturnTransform : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static bool CanModifyInstructions(ILVariable returnVar, Block leaveBlock, List`1& instructionsToModify);
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.IL.Transforms.InliningOptions : Enum {
    public int value__;
    public static InliningOptions None;
    public static InliningOptions Aggressive;
    public static InliningOptions IntroduceNamedArguments;
    public static InliningOptions FindDeconstruction;
    public static InliningOptions AllowChangingOrderOfEvaluationForExceptions;
    public static InliningOptions AllowInliningOfLdloca;
}
public class ICSharpCode.Decompiler.IL.Transforms.InterpolatedStringTransform : object {
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(Block block, int pos, StatementTransformContext context);
    private bool IsKnownCall(Block block, int pos, ILVariable v);
    private bool FindToStringAndClear(Block block, int pos, int interpolationStart, int interpolationEnd, ILVariable v, ILInstruction& insertionPoint);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.IL.Transforms.IStatementTransform {
    public abstract virtual void Run(Block block, int pos, StatementTransformContext context);
}
internal class ICSharpCode.Decompiler.IL.Transforms.LdLocaDupInitObjTransform : object {
    [NullableContextAttribute("1")]
private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
    [NullableContextAttribute("1")]
private bool TryTransform(Block block, int i, ILTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.LocalFunctionDecompiler : object {
    private ILTransformContext context;
    private ITypeResolveContext resolveContext;
    private static Regex functionNameRegex;
    private static LocalFunctionDecompiler();
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private void ReplaceReferencesToDisplayClassThis(ValueCollection<MethodDefinitionHandle, LocalFunctionInfo> localFunctions);
    private void DetermineCaptureAndDeclarationScopes(ValueCollection<MethodDefinitionHandle, LocalFunctionInfo> localFunctions);
    private void TransformUseSites(ValueCollection<MethodDefinitionHandle, LocalFunctionInfo> localFunctions);
    private void PropagateClosureParameterArguments(Dictionary`2<MethodDefinitionHandle, LocalFunctionInfo> localFunctions);
    private ILInstruction FindCompatibleArgument(LocalFunctionInfo info, IList`1<ILInstruction> arguments, bool ignoreStructure);
    private ILVariable ResolveAncestorScopeReference(ILInstruction inst);
    private ILFunction GetDeclaringFunction(ILFunction localFunction);
    private bool TryValidateSkipCount(LocalFunctionInfo info, Int32& skipCount);
    private void FindUseSites(ILFunction function, ILTransformContext context, Dictionary`2<MethodDefinitionHandle, LocalFunctionInfo> localFunctions);
    private ILFunction ReadLocalFunctionDefinition(ILFunction rootFunction, IMethod targetMethod, int skipCount);
    private int GetSkipCount(ILFunction rootFunction, IMethod targetMethod);
    private static Nullable`1<GenericContext> GenericContextFromTypeArguments(IMethod targetMethod, int skipCount);
    private static T FindCommonAncestorInstruction(ILInstruction a, ILInstruction b);
    internal static bool IsClosureParameter(IParameter parameter, ITypeResolveContext context);
    internal static ILInstruction GetStatement(ILInstruction inst);
    private LocalFunctionMethod ReduceToLocalFunction(IMethod method, int typeParametersToRemove);
    private static void TransformToLocalFunctionReference(ILFunction function, CallInstruction useSite);
    private void TransformToLocalFunctionInvocation(LocalFunctionMethod reducedMethod, CallInstruction useSite);
    private void DetermineCaptureAndDeclarationScope(LocalFunctionInfo info, ILInstruction useSite);
    private bool DetermineCaptureAndDeclarationScope(LocalFunctionInfo info, int parameterIndex, ILInstruction arg);
    private bool IsInNestedLocalFunction(BlockContainer declarationScope, ILFunction function);
    internal static bool IsLocalFunctionReference(NewObj inst, ILTransformContext context);
    public static bool IsLocalFunctionMethod(IMethod method, ILTransformContext context);
    public static bool IsLocalFunctionMethod(PEFile module, MethodDefinitionHandle methodHandle, ILTransformContext context);
    public static bool LocalFunctionNeedsAccessibilityChange(PEFile module, MethodDefinitionHandle methodHandle);
    public static bool IsLocalFunctionDisplayClass(PEFile module, TypeDefinitionHandle typeHandle, ILTransformContext context);
    internal static bool ParseLocalFunctionName(string name, String& callerName, String& functionName);
    [CompilerGeneratedAttribute]
private void <PropagateClosureParameterArguments>g__AddAsArgument|7_0(int index, ILInstruction argument, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
private void <FindUseSites>g__HandleUseSite|12_0(IMethod targetMethod, ILInstruction inst, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private bool <ReduceToLocalFunction>g__CanBeStaticLocalFunction|19_0(<>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static ILInstruction <DetermineCaptureAndDeclarationScope>g__GetClosureInitializer|23_0(ILVariable variable);
}
public class ICSharpCode.Decompiler.IL.Transforms.LockTransform : object {
    private BlockTransformContext context;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IBlockTransform.Run(Block block, BlockTransformContext context);
    private bool TransformLockMCS(Block block, int i);
    private bool TransformLockV2(Block block, int i);
    private bool TransformLockV4(Block block, int i);
    private bool TransformLockV4YieldReturn(Block block, int i);
    private bool TransformLockRoslyn(Block block, int i);
    private bool MatchExitBlock(Block entryPoint, ILVariable flag, ILVariable obj);
    private bool MatchExitBlock(Block exitBlock, ILVariable obj);
    private bool MatchLockEntryPoint(Block entryPoint, ILVariable flag, ILVariable obj);
    private bool MatchLockEntryPoint(Block entryPoint, ILVariable flag, StLoc& obj);
    private bool MatchLockEntryPoint(Block entryPoint, ILVariable flag, ILVariable& exitVairable, StLoc& obj);
    private bool MatchCall(Call call, string methodName, ILVariable flag, StLoc& obj);
    private bool MatchCall(Call call, string methodName, ILVariable[] variables);
}
public class ICSharpCode.Decompiler.IL.Transforms.NamedArgumentTransform : object {
    internal static FindResult CanIntroduceNamedArgument(CallInstruction call, ILInstruction child, ILVariable v, ILInstruction expressionBeingMoved);
    internal static FindResult CanExtendNamedArgument(Block block, ILVariable v, ILInstruction expressionBeingMoved);
    internal static void IntroduceNamedArgument(ILInstruction arg, ILTransformContext context);
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.NullableLiftingStatementTransform : object {
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
}
internal class ICSharpCode.Decompiler.IL.Transforms.NullableLiftingTransform : ValueType {
    private ILTransformContext context;
    private List`1<ILVariable> nullableVars;
    public NullableLiftingTransform(ILTransformContext context);
    public bool Run(IfInstruction ifInst);
    public bool Run(BinaryNumericInstruction bni);
    public bool RunStatements(Block block, int pos);
    private bool AnalyzeCondition(ILInstruction condition);
    private bool AnalyzeNegatedCondition(ILInstruction condition);
    private ILInstruction Lift(ILInstruction ifInst, ILInstruction condition, ILInstruction trueInst, ILInstruction falseInst);
    private bool IsGenericNewPattern(ILInstruction compLeft, ILInstruction compRight, ILInstruction trueInst, ILInstruction falseInst);
    private bool MatchThreeValuedLogicConditionPattern(ILInstruction condition, ILVariable& nullable1, ILVariable& nullable2);
    private static bool MatchCompOrDecimal(ILInstruction inst, CompOrDecimal& result);
    private ILInstruction LiftCSharpEqualityComparison(CompOrDecimal valueComp, ComparisonKind newComparisonKind, ILInstruction hasValueTest);
    private ILInstruction LiftCSharpComparison(CompOrDecimal comp, ComparisonKind newComparisonKind);
    private ILInstruction LiftCSharpUserEqualityComparison(CompOrDecimal hasValueComp, ComparisonKind newComparisonKind, ILInstruction nestedIfInst);
    private ILInstruction LiftCSharpUserComparison(ILInstruction trueInst, ILInstruction falseInst);
    private ILInstruction LiftNormal(ILInstruction trueInst, ILInstruction falseInst);
    private ValueTuple`2<ILInstruction, BitSet> DoLift(ILInstruction inst);
    private ValueTuple`3<ILInstruction, ILInstruction, BitSet> DoLiftBinary(ILInstruction lhs, ILInstruction rhs, IType leftExpectedType, IType rightExpectedType);
    private ILInstruction NewNullable(ILInstruction inst, IType underlyingType);
    internal static bool MatchHasValueCall(ILInstruction inst, ILInstruction& arg);
    internal static bool MatchHasValueCall(ILInstruction inst, ILVariable& v);
    internal static bool MatchHasValueCall(ILInstruction inst, ILVariable v);
    internal static bool MatchNegatedHasValueCall(ILInstruction inst, ILVariable v);
    internal static bool MatchNullableCtor(ILInstruction inst, IType& underlyingType, ILInstruction& arg);
    internal static bool MatchGetValueOrDefault(ILInstruction inst, ILInstruction& arg);
    internal static bool MatchGetValueOrDefault(ILInstruction inst, ILVariable& v);
    internal static bool MatchGetValueOrDefault(ILInstruction inst, ILVariable v);
    private static bool MatchNull(ILInstruction inst, IType& underlyingType);
    private static bool MatchNull(ILInstruction inst, IType underlyingType);
}
public class ICSharpCode.Decompiler.IL.Transforms.NullCoalescingTransform : object {
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
    private bool TransformRefTypes(Block block, int pos, StatementTransformContext context);
    private bool TransformThrowExpressionValueTypes(Block block, int pos, StatementTransformContext context);
}
public class ICSharpCode.Decompiler.IL.Transforms.NullPropagationStatementTransform : object {
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
}
[IsReadOnlyAttribute]
internal class ICSharpCode.Decompiler.IL.Transforms.NullPropagationTransform : ValueType {
    private ILTransformContext context;
    public NullPropagationTransform(ILTransformContext context);
    internal static bool IsProtectedIfInst(IfInstruction ifInst);
    internal ILInstruction Run(ILInstruction condition, ILInstruction trueInst, ILInstruction falseInst);
    private ILInstruction TryNullPropagation(ILVariable testedVar, ILInstruction nonNullInst, ILInstruction nullInst, Mode mode);
    internal void RunStatements(Block block, int pos);
    private void TryNullPropForVoidCall(ILVariable testedVar, Mode mode, Block body, IfInstruction ifInst);
    private bool IsValidAccessChain(ILVariable testedVar, Mode mode, ILInstruction inst, ILInstruction& finalLoad);
    private static bool IsGetter(IMethod method);
    private void IntroduceUnwrap(ILVariable testedVar, ILInstruction varLoad, Mode mode);
    private bool TransformNullPropagationOnUnconstrainedGenericExpression(Block block, int pos, ILVariable& target, ILInstruction& nonNullInst, ILInstruction& nullInst, Block& endBlock);
    private bool MatchStLocResultTemporary(Block block, int pos, IType type, ILVariable target, ILVariable defaultTemporary, ILInstruction fallbackBlock, ILInstruction& nonNullInst, ILInstruction& nullInst, Block& endBlock);
    private bool MatchLeaveResult(Block block, int pos, IType type, ILVariable target, ILVariable defaultTemporary, ILInstruction fallbackBlock, ILInstruction& nonNullInst, ILInstruction& nullInst);
    private bool IsFallbackBlock(Block block, IType type, ILVariable target, ILVariable defaultTemporary, ILVariable resultTemporary, ILInstruction endBlockOrLeaveContainer, ILInstruction& nullInst);
    [CompilerGeneratedAttribute]
internal static bool <IsValidAccessChain>g__ArgumentsAfterFirstMayUnwrapNull|8_0(InstructionCollection`1<ILInstruction> arguments);
    [CompilerGeneratedAttribute]
internal static bool <IsValidAccessChain>g__IsValidEndOfChain|8_1(<>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsValidAccessChain>g__CanTransformToExtensionMethodCall|8_2(CallInstruction call, ILTransformContext context);
}
internal class ICSharpCode.Decompiler.IL.Transforms.ParameterNullCheckTransform : object {
    [NullableContextAttribute("1")]
private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
    [NullableContextAttribute("1")]
private bool MatchThrowIfNullCall(ILInstruction instruction, ILVariable& parameterVariable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.IL.Transforms.PatternMatchingTransform : object {
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
    private bool PatternMatchRefTypes(Block block, BlockContainer container, ILTransformContext context, ControlFlowGraph& cfg);
    private bool CheckAllUsesDominatedBy(ILVariable v, BlockContainer container, ILInstruction trueInst, ILInstruction storeToV, ILInstruction loadInNullCheck, ILTransformContext context, ControlFlowGraph& cfg);
    private bool PatternMatchValueTypes(Block block, BlockContainer container, ILTransformContext context, ControlFlowGraph& cfg);
    [NullableContextAttribute("2")]
private bool MatchIsInstBlock(Block block, IType& type, LdLoc& testedOperand, Block& unboxBlock, Block& falseBlock);
    [NullableContextAttribute("2")]
private bool MatchUnboxBlock(Block unboxBlock, IType type, ILVariable& testedOperand, ILVariable& v, ILInstruction& storeToV);
}
internal class ICSharpCode.Decompiler.IL.Transforms.ProxyCallReplacer : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private void Run(CallInstruction inst, ILTransformContext context);
    private static bool IsDefinedInCurrentOrOuterClass(IMethod method, ITypeDefinition declaringTypeDefinition);
}
public class ICSharpCode.Decompiler.IL.Transforms.RemoveDeadVariableInit : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    internal static void ResetUsesInitialValueFlag(ILFunction function, ILTransformContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.IL.Transforms.RemoveInfeasiblePathTransform : object {
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
    private bool DoTransform(Block block, ILTransformContext context);
    [NullableContextAttribute("2")]
private bool MatchBlock1(Block block, ILVariable& variable, Int32& constantValue, Branch& branch);
    private bool MatchBlock2(Block block, ILVariable s, int constantValue, ILInstruction& exitInst);
}
public class ICSharpCode.Decompiler.IL.Transforms.SplitVariables : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private static bool IsCandidateVariable(ILVariable v);
    private static AddressUse DetermineAddressUse(ILInstruction addressLoadingInstruction, ILVariable targetVar);
    private static AddressUse HandleCall(ILInstruction addressLoadingInstruction, ILVariable targetVar, CallInstruction call);
    private static LdLoca GetAddressLoadForRefLocalUse(LdLoc ldloc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Transforms.StatementTransform : object {
    private IStatementTransform[] children;
    public StatementTransform(IStatementTransform[] children);
    public sealed virtual void Run(Block block, BlockTransformContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Transforms.StatementTransformContext : ILTransformContext {
    [CompilerGeneratedAttribute]
private BlockTransformContext <BlockContext>k__BackingField;
    internal bool rerunCurrentPosition;
    internal Nullable`1<int> rerunPosition;
    public BlockTransformContext BlockContext { get; }
    public Block Block { get; }
    public StatementTransformContext(BlockTransformContext blockContext);
    [CompilerGeneratedAttribute]
public BlockTransformContext get_BlockContext();
    public Block get_Block();
    public void RequestRerun(int pos);
    public void RequestRerun();
}
public class ICSharpCode.Decompiler.IL.Transforms.StepLimitReachedException : Exception {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Transforms.Stepper : object {
    [CompilerGeneratedAttribute]
private int <StepLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDebug>k__BackingField;
    private Stack`1<Node> groups;
    private IList`1<Node> steps;
    private int step;
    public static bool SteppingAvailable { get; }
    public IList`1<Node> Steps { get; }
    public int StepLimit { get; public set; }
    public bool IsDebug { get; public set; }
    public static bool get_SteppingAvailable();
    public IList`1<Node> get_Steps();
    [CompilerGeneratedAttribute]
public int get_StepLimit();
    [CompilerGeneratedAttribute]
public void set_StepLimit(int value);
    [CompilerGeneratedAttribute]
public bool get_IsDebug();
    [CompilerGeneratedAttribute]
public void set_IsDebug(bool value);
    public void Step(string description, ILInstruction near);
    private Node StepInternal(string description, ILInstruction near);
    public void StartGroup(string description, ILInstruction near);
    public void EndGroup(bool keepIfEmpty);
}
public class ICSharpCode.Decompiler.IL.Transforms.SwitchOnNullableTransform : object {
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private bool MatchSwitchOnNullable(InstructionCollection`1<ILInstruction> instructions, int i, SwitchInstruction& newSwitch);
    private static SwitchInstruction BuildLiftedSwitch(Block nullCaseBlock, SwitchInstruction switchInst, ILInstruction switchValue);
    private bool MatchRoslynSwitchOnNullable(InstructionCollection`1<ILInstruction> instructions, int i, SwitchInstruction& newSwitch);
}
public class ICSharpCode.Decompiler.IL.Transforms.SwitchOnStringTransform : object {
    private ILTransformContext context;
    private SwitchAnalysis analysis;
    public sealed virtual void Run(ILFunction function, ILTransformContext context);
    private Dictionary`2<IField, ValueTuple`6<List`1<ValueTuple`2<string, int>>, IfInstruction, Block, Block, Block, bool>> ScanHashtableInitializerBlocks(Block entryPoint);
    private bool SimplifyCascadingIfStatements(InstructionCollection`1<ILInstruction> instructions, Int32& i);
    private bool ValidateUsesOfSwitchValueVariable(ILVariable switchValueVar, HashSet`1<Block> caseBlocks);
    private bool SimplifyCSharp1CascadingIfStatements(InstructionCollection`1<ILInstruction> instructions, Int32& i);
    private bool IsIsInternedCall(Call call, ILInstruction& argument);
    private ILInstruction MatchCaseBlock(Block currentBlock, ILVariable switchVariable, String& value, Boolean& emptyStringEqualsNull, ILInstruction& caseBlockOrLeave);
    private bool MatchLegacySwitchOnStringWithDict(InstructionCollection`1<ILInstruction> instructions, Int32& i);
    private bool FixCasesWithoutValue(List`1<SwitchSection> sections, List`1<ValueTuple`2<string, int>> stringValues);
    private bool AddNullSection(List`1<SwitchSection> sections, List`1<ValueTuple`2<string, int>> stringValues, Block nullValueCaseBlock);
    private bool MatchDictionaryFieldLoad(ILInstruction inst, Func`2<IType, bool> typeMatcher, IField& dictField, IType& dictionaryType);
    private bool ExtractStringValuesFromInitBlock(Block block, List`1& values, Block& blockAfterInit, IType dictionaryType, IField dictionaryField, bool isHashtablePattern);
    private bool MatchAddCall(IType dictionaryType, ILInstruction inst, ILVariable dictVar, Int32& index, String& value);
    private bool IsStringToIntDictionary(IType dictionaryType);
    private bool IsNonGenericHashtable(IType dictionaryType);
    private bool MatchLegacySwitchOnStringWithHashtable(Block block, Dictionary`2<IField, ValueTuple`6<List`1<ValueTuple`2<string, int>>, IfInstruction, Block, Block, Block, bool>> hashtableInitializers, Int32& i);
    private bool FindHashtableInitBlock(Block entryPoint, List`1& stringValues, IField& dictField, Block& blockAfterThisInitBlock, ILInstruction& thisSwitchInitJumpInst, ILInstruction& nextSwitchInitJumpInst);
    private bool MatchRoslynSwitchOnString(InstructionCollection`1<ILInstruction> instructions, Int32& i);
    private bool MatchRoslynSwitchOnStringUsingLengthAndChar(InstructionCollection`1<ILInstruction> instructions, Int32& i);
    private bool IsNullCheckInDefaultBlock(Block& exitOrDefaultBlock, ILVariable switchVar, Block& nullValueCaseBlock);
    private bool MatchRoslynCaseBlockHead(Block target, ILVariable switchValueVar, ILInstruction& bodyOrLeave, Block& defaultOrExitBlock, String& stringValue, Boolean& emptyStringEqualsNull);
    private bool MatchRoslynEmptyStringCaseBlockHead(Block target, ILVariable switchValueVar, ILInstruction& bodyOrLeave, Block& defaultOrExitBlock);
    private bool MatchStringLengthCall(ILInstruction inst, ILVariable switchValueVar);
    internal static bool MatchComputeStringHashCall(ILInstruction inst, ILVariable targetVar, LdLoc& switchValue);
    private bool MatchStringEqualityComparison(ILInstruction condition, ILVariable variable, String& stringValue, Boolean& isVBCompareString);
    private bool MatchStringEqualityComparison(ILInstruction condition, ILVariable& variable, String& stringValue, Boolean& isVBCompareString);
    [CompilerGeneratedAttribute]
internal static bool <SimplifyCascadingIfStatements>g__AddSwitchSection|4_0(string value, ILInstruction inst, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static SwitchInstruction <MatchRoslynSwitchOnString>g__ReplaceWithSwitchInstruction|19_1(int offset, <>c__DisplayClass19_0& );
    [CompilerGeneratedAttribute]
internal static bool <MatchRoslynSwitchOnStringUsingLengthAndChar>g__MatchGetChars|20_1(ILInstruction instruction, ILVariable switchValueVar, Int32& index);
    [CompilerGeneratedAttribute]
private bool <MatchRoslynSwitchOnStringUsingLengthAndChar>g__MatchSwitchOnCharBlock|20_2(Block block, int length, ILVariable switchValueVar, List`1& results, <>c__DisplayClass20_0& );
    [CompilerGeneratedAttribute]
private bool <MatchRoslynSwitchOnStringUsingLengthAndChar>g__MatchSwitchOnLengthBlock|20_3(ILVariable switchValueVar, Block switchOnLengthBlock, List`1& blocks, <>c__DisplayClass20_0& );
}
public class ICSharpCode.Decompiler.IL.Transforms.TransformArrayInitializers : object {
    private StatementTransformContext context;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(Block block, int pos, StatementTransformContext context);
    private bool DoTransform(ILFunction function, Block body, int pos);
    internal static bool TransformSpanTArrayInitialization(NewObj inst, StatementTransformContext context, ILInstruction& replacement);
    private static bool DecodeUTF8String(BlobReader blob, int size, String& text);
    private static bool MatchSpanTCtorWithPointerAndSize(NewObj newObj, StatementTransformContext context, IType& elementType, FieldDefinition& field, Int32& size);
    private bool DoTransformMultiDim(ILFunction function, Block body, int pos);
    private bool DoTransformStackAllocInitializer(Block body, int pos);
    private bool HandleCpblkInitializer(Block block, int pos, ILVariable v, long length, BlobReader& blob, IType& elementType);
    private bool HandleSequentialLocAllocInitializer(Block block, int pos, ILVariable store, ILInstruction locAllocInstruction, IType& elementType, StObj[]& values, Int32& instructionsToRemove);
    private ILInstruction RewrapStore(ILVariable target, StObj storeInstruction, IType type);
    private ILInstruction StElemPtr(ILVariable target, int offset, LdcI4 value, IType type);
    internal static bool HandleSimpleArrayInitializer(ILFunction function, Block block, int pos, ILVariable store, Int32[] arrayLength, ValueTuple`2[]& values, Int32& instructionsToRemove);
    private bool HandleJaggedArrayInitializer(Block block, int pos, ILVariable store, IType elementType, int length, ILVariable& finalStore, ILInstruction[]& values, Int32& instructionsToRemove);
    private bool MatchJaggedArrayStore(Block block, int pos, ILVariable store, int index, ILInstruction& initializer, IType& type);
    private static Block BlockFromInitializer(ILVariable v, IType elementType, Int32[] arrayLength, ILInstruction[] values);
    private static bool MatchNewArr(ILInstruction instruction, IType& arrayType, Int32[]& length);
    private bool MatchInitializeArrayCall(ILInstruction instruction, ILInstruction& array, FieldDefinition& field);
    private bool HandleRuntimeHelpersInitializeArray(Block body, int pos, ILVariable array, IType arrayType, Int32[] arrayLength, ILInstruction[]& values, Int32& foundPos);
    private bool DoTransformInlineRuntimeHelpersInitializeArray(Block body, int pos);
    private static bool DecodeArrayInitializer(IType type, BlobReader initialValue, Int32[] arrayLength, List`1<ILInstruction> output);
    private static bool DecodeArrayInitializer(BlobReader initialValue, Int32[] arrayLength, List`1<ILInstruction> output, TypeCode elementType, ValueDecoder decoder);
    private static ILInstruction StElem(ILInstruction array, ILInstruction[] indices, ILInstruction value, IType type);
    internal static ILInstruction GetNullExpression(IType elementType);
    private static int ElementSizeOf(TypeCode elementType);
}
public class ICSharpCode.Decompiler.IL.Transforms.TransformAssignment : object {
    private StatementTransformContext context;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(Block block, int pos, StatementTransformContext context);
    private bool TransformInlineAssignmentStObjOrCall(Block block, int pos);
    private static IType SwapSign(IType type, ICompilation compilation);
    private static ILInstruction UnwrapSmallIntegerConv(ILInstruction inst, Conv& conv);
    private static bool ValidateCompoundAssign(BinaryNumericInstruction binary, Conv conv, IType targetType, DecompilerSettings settings);
    private static bool MatchingGetterAndSetterCalls(CallInstruction getterCall, CallInstruction setterCall, Action`1& finalizeMatch);
    internal static bool HandleCompoundAssign(ILInstruction compoundStore, StatementTransformContext context);
    private bool TransformInlineAssignmentLocal(Block block, int pos);
    internal static bool IsImplicitTruncation(ILInstruction value, IType type, ICompilation compilation, bool allowNullableValue);
    internal static ImplicitTruncationResult CheckImplicitTruncation(ILInstruction value, IType type, ICompilation compilation, bool allowNullableValue);
    private static ImplicitTruncationResult CommonImplicitTruncation(ImplicitTruncationResult left, ImplicitTruncationResult right);
    private static bool IsCompoundStore(ILInstruction inst, IType& storeType, ILInstruction& value, ICompilation compilation);
    private static bool IsMatchingCompoundLoad(ILInstruction load, ILInstruction store, ILInstruction& target, CompoundTargetKind& targetKind, Action`1& finalizeMatch, ILVariable forbiddenVariable, ILInstruction previousInstruction);
    private bool TransformPostIncDecOperatorWithInlineStore(Block block, int pos);
    private bool TransformPostIncDecOperator(Block block, int i);
    private static bool IsSameMember(IMember a, IMember b);
    [CompilerGeneratedAttribute]
internal static ExpressionType <HandleCompoundAssign>g__ToCompound|7_0(ExpressionType from);
    [CompilerGeneratedAttribute]
internal static bool <IsMatchingCompoundLoad>g__IsDuplicatedAddressComputation|14_0(ILInstruction storeTarget, ILInstruction loadTarget, <>c__DisplayClass14_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Transforms.TransformCollectionAndObjectInitializers : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ILVariable, ValueTuple`2<int, ILInstruction>> possibleIndexVariables;
    private List`1<AccessPathElement> currentPath;
    private bool isCollection;
    private Stack`1<HashSet`1<AccessPathElement>> pathStack;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(Block block, int pos, StatementTransformContext context);
    internal static bool IsRecordCloneMethodCall(CallInstruction ci);
    private bool IsMethodCallOnVariable(ILInstruction inst, ILVariable variable);
    private bool IsPartOfInitializer(InstructionCollection`1<ILInstruction> instructions, int pos, ILVariable target, IType rootType, BlockKind& blockKind, StatementTransformContext context);
    private bool IsValidObjectInitializerTarget(List`1<AccessPathElement> path);
}
public class ICSharpCode.Decompiler.IL.Transforms.TransformDisplayClassUsage : ILVisitor {
    private ILTransformContext context;
    private ITypeResolveContext decompilationContext;
    private Dictionary`2<ILVariable, DisplayClass> displayClasses;
    private Dictionary`2<ILVariable, ILVariable> displayClassCopyMap;
    private Stack`1<ILFunction> currentFunctions;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IILTransform.Run(ILFunction function, ILTransformContext context);
    private void ClearState();
    private void AnalyzeFunction(ILFunction function);
    private bool ValidateDisplayClassUses(ILVariable v, DisplayClass displayClass);
    private DisplayClass AnalyzeVariable(ILVariable v);
    private DisplayClass DetectDisplayClass(ILVariable v);
    private void HandleInitBlock(Block initBlock, int startIndex, DisplayClass result, ILVariable targetVariable);
    private Block FindDisplayStructInitBlock(ILVariable v);
    private DisplayClass DetectDisplayClassInitializer(ILVariable v);
    private bool ValidateDisplayClassDefinition(ITypeDefinition definition);
    internal static bool ValidateConstructor(ILTransformContext context, IMethod method);
    private static ILOpCode DecodeOpCodeSkipNop(BlobReader& reader);
    private VariableToDeclare AddVariable(DisplayClass result, StObj statement, IField field);
    private ILVariable ResolveVariableToPropagate(ILInstruction value, IType expectedType);
    private void Transform(ILFunction function);
    internal static bool IsClosure(ILTransformContext context, ILVariable variable, ITypeDefinition& closureType, ILInstruction& initializer);
    private static bool IsClosureInit(ILTransformContext context, StLoc inst, ITypeDefinition& closureType);
    private bool IsMonoNestedCaptureScope(ITypeDefinition closureType);
    private DisplayClass HandleMonoStateMachine(ILFunction function, ILVariable thisVariable);
    internal static bool IsPotentialClosure(ILTransformContext context, NewObj inst);
    internal static bool IsPotentialClosure(ILTransformContext context, ITypeDefinition potentialDisplayClass);
    internal static bool IsPotentialClosure(ITypeDefinition decompiledTypeDefinition, ITypeDefinition potentialDisplayClass, bool allowTypeImplementingInterfaces);
    protected internal virtual void VisitILFunction(ILFunction function);
    protected virtual void Default(ILInstruction inst);
    protected internal virtual void VisitStLoc(StLoc inst);
    protected internal virtual void VisitStObj(StObj inst);
    protected internal virtual void VisitLdObj(LdObj inst);
    private bool IsDisplayClassLoad(ILInstruction target, ILVariable& variable);
    private bool IsDisplayClassFieldAccess(ILInstruction inst, ILVariable& displayClassVar, DisplayClass& displayClass, IField& field);
    protected internal virtual void VisitLdFlda(LdFlda inst);
    [CompilerGeneratedAttribute]
private void <AnalyzeFunction>g__VisitFunction|8_0(ILFunction f);
    [CompilerGeneratedAttribute]
private void <AnalyzeFunction>g__VisitChildren|8_1(ILInstruction inst);
    [CompilerGeneratedAttribute]
private void <AnalyzeFunction>g__Visit|8_2(ILInstruction inst);
    [CompilerGeneratedAttribute]
private bool <ValidateDisplayClassUses>g__ValidateUse|9_0(DisplayClass container, ILInstruction use, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static ILInstruction <FindDisplayStructInitBlock>g__Visit|13_0(ILInstruction inst, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static ILInstruction <FindDisplayStructInitBlock>g__VisitChildren|13_1(ILInstruction inst, <>c__DisplayClass13_0& );
}
public class ICSharpCode.Decompiler.IL.Transforms.TransformExpressionTrees : object {
    private StatementTransformContext context;
    private Dictionary`2<ILVariable, ValueTuple`2<IType, string>> parameters;
    private Dictionary`2<ILVariable, ILVariable> parameterMapping;
    private List`1<ILInstruction> instructionsToRemove;
    private Stack`1<ILFunction> lambdaStack;
    private CSharpConversions conversions;
    private CSharpResolver resolver;
    private static bool MightBeExpressionTree(ILInstruction inst, ILInstruction stmt);
    private static bool IsEmptyParameterList(ILInstruction inst);
    private bool MatchParameterVariableAssignment(ILInstruction expr, ILVariable& parameterReferenceVar, IType& type, String& name);
    public sealed virtual void Run(Block block, int pos, StatementTransformContext context);
    private bool TryConvertExpressionTree(ILInstruction instruction, ILInstruction statement);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertLambda(CallInstruction instruction);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertQuote(CallInstruction invocation);
    private void SetExpressionTreeFlag(ILFunction lambda, CallInstruction call);
    private bool ReadParameters(ILInstruction initializer, IList`1<IParameter> parameters, IList`1<ILVariable> parameterVariables, ITypeResolveContext resolveContext);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertInstruction(ILInstruction instruction, IType typeHint);
    private bool IsExpressionTree(IType delegateType);
    private IType UnwrapExpressionTree(IType delegateType);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertArrayIndex(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertArrayLength(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertBinaryNumericOperator(CallInstruction invocation, BinaryNumericOperator op, Nullable`1<bool> isChecked);
    private ValueTuple`2<Func`2<ILVariable, ILInstruction>, IType> ConvertBind(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertCall(CallInstruction invocation);
    private ILInstruction PrepareCallTarget(IType expectedType, ILInstruction target, IType targetType);
    private ILInstruction UnpackConstant(ILInstruction inst);
    private Func`1[] ConvertCallArguments(IList`1<ILInstruction> arguments, IMethod method);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertCast(CallInstruction invocation, bool isChecked);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertCoalesce(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertComparison(CallInstruction invocation, ComparisonKind kind);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertCondition(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertConstant(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertElementInit(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertField(CallInstruction invocation, IType typeHint);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertInvoke(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertListInit(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertLogicOperator(CallInstruction invocation, bool and);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertMemberInit(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertNewArrayBounds(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertNewArrayInit(CallInstruction invocation);
    private bool MatchNew(CallInstruction invocation, IMethod& ctor);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertNewObject(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertNotOperator(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertProperty(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertTypeAs(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertTypeIs(CallInstruction invocation);
    private ValueTuple`2<Func`1<ILInstruction>, IType> ConvertUnaryNumericOperator(CallInstruction invocation, BinaryNumericOperator op, Nullable`1<bool> isChecked);
    private ILInstruction ConvertValue(ILInstruction value, ILInstruction context);
    private bool IsClosureReference(ILVariable variable);
    private bool IsExpressionTreeParameter(ILVariable variable);
    private bool MatchConstantCall(ILInstruction inst, ILInstruction& value, IType& type);
    internal static bool MatchGetTypeFromHandle(ILInstruction inst, IType& type);
    private bool MatchGetMethodFromHandle(ILInstruction inst, IMember& member);
    private bool MatchGetConstructorFromHandle(ILInstruction inst, IMember& member);
    private bool MatchGetFieldFromHandle(ILInstruction inst, IMember& member);
    private static bool MatchFromHandleParameterList(CallInstruction call, IMember& member);
    private bool MatchArgumentList(ILInstruction inst, IList`1& arguments);
    [CompilerGeneratedAttribute]
internal static ILInstruction <ConvertNewObject>g__BuildNewObj|41_0(IMethod method, Func`1[] args);
}
public class ICSharpCode.Decompiler.IL.Transforms.UserDefinedLogicTransform : object {
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IStatementTransform.Run(Block block, int pos, StatementTransformContext context);
    private bool RoslynOptimized(Block block, int pos, StatementTransformContext context);
    private bool LegacyPattern(Block block, int pos, StatementTransformContext context);
    private static bool MatchCondition(ILInstruction condition, ILVariable& v, String& name);
    private static bool MatchBitwiseCall(Call call, ILVariable v, string conditionMethodName);
    public static ILInstruction Transform(ILInstruction condition, ILInstruction trueInst, ILInstruction falseInst);
    public static ILInstruction TransformDynamic(ILInstruction condition, ILInstruction trueInst, ILInstruction falseInst);
}
public class ICSharpCode.Decompiler.IL.Transforms.UsingTransform : object {
    private BlockTransformContext context;
    private sealed virtual override void ICSharpCode.Decompiler.IL.Transforms.IBlockTransform.Run(Block block, BlockTransformContext context);
    private bool TransformUsing(Block block, int i);
    private bool TransformUsingVB(Block block, int i);
    private bool CheckResourceType(IType type);
    private bool ImplementsForeachPattern(IType type);
    private bool MatchDisposeBlock(BlockContainer container, ILVariable objVar, bool usingNull, String& disposeMethodFullName, KnownTypeCode disposeTypeCode);
    private bool MatchDisposeCheck(ILVariable objVar, ILInstruction checkInst, bool isReference, bool usingNull, Int32& numObjVarLoadsInCheck, string disposeMethodFullName, KnownTypeCode disposeTypeCode);
    private bool MatchNullCheckOrTypeCheck(ILInstruction condition, ILVariable& objVar, KnownTypeCode disposeType, Boolean& isInlinedIsInst);
    private bool TransformAsyncUsing(Block block, int i);
    private bool CheckAsyncResourceType(IType type, String& disposeMethodFullName);
    private bool UnwrapAwait(ILInstruction& awaitInstruction);
    [CompilerGeneratedAttribute]
private bool <CheckResourceType>b__4_3(IMethod m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.TryCatch : TryInstruction {
    public static SlotInfo HandlerSlot;
    public InstructionCollection`1<TryCatchHandler> Handlers;
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public TryCatch(ILInstruction tryBlock);
    private static TryCatch();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public virtual ILInstruction Clone();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    protected virtual int GetChildCount();
    protected virtual ILInstruction GetChild(int index);
    protected virtual void SetChild(int index, ILInstruction value);
    protected virtual SlotInfo GetChildSlot(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.TryCatchHandler : ILInstruction {
    public static SlotInfo FilterSlot;
    private ILInstruction filter;
    public static SlotInfo BodySlot;
    private ILInstruction body;
    private ILVariable variable;
    [CompilerGeneratedAttribute]
private int <IndexInStoreInstructionList>k__BackingField;
    [CompilerGeneratedAttribute]
private Interval <ExceptionSpecifierILRange>k__BackingField;
    public ILInstruction Filter { get; public set; }
    public ILInstruction Body { get; public set; }
    public ILVariable Variable { get; public set; }
    public int IndexInStoreInstructionList { get; public set; }
    private int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.IndexInVariableInstructionMapping { get; private set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Interval ExceptionSpecifierILRange { get; private set; }
    public TryCatchHandler(ILInstruction filter, ILInstruction body, ILVariable variable);
    private static TryCatchHandler();
    public ILInstruction get_Filter();
    public void set_Filter(ILInstruction value);
    public ILInstruction get_Body();
    public void set_Body(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public sealed virtual ILVariable get_Variable();
    public sealed virtual void set_Variable(ILVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexInStoreInstructionList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexInStoreInstructionList(int value);
    private sealed virtual override int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.get_IndexInVariableInstructionMapping();
    private sealed virtual override void ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.set_IndexInVariableInstructionMapping(int value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    [CompilerGeneratedAttribute]
public Interval get_ExceptionSpecifierILRange();
    [CompilerGeneratedAttribute]
private void set_ExceptionSpecifierILRange(Interval value);
    public void AddExceptionSpecifierILRange(Interval newRange);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.TryFault : TryInstruction {
    public static SlotInfo FaultBlockSlot;
    private ILInstruction faultBlock;
    public ILInstruction FaultBlock { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public TryFault(ILInstruction tryBlock, ILInstruction faultBlock);
    private static TryFault();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public ILInstruction get_FaultBlock();
    public void set_FaultBlock(ILInstruction value);
    public virtual ILInstruction Clone();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    protected virtual int GetChildCount();
    protected virtual ILInstruction GetChild(int index);
    protected virtual void SetChild(int index, ILInstruction value);
    protected virtual SlotInfo GetChildSlot(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.TryFinally : TryInstruction {
    public static SlotInfo FinallyBlockSlot;
    private ILInstruction finallyBlock;
    public ILInstruction FinallyBlock { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public TryFinally(ILInstruction tryBlock, ILInstruction finallyBlock);
    private static TryFinally();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public ILInstruction get_FinallyBlock();
    public void set_FinallyBlock(ILInstruction value);
    public virtual ILInstruction Clone();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    protected virtual int GetChildCount();
    protected virtual ILInstruction GetChild(int index);
    protected virtual void SetChild(int index, ILInstruction value);
    protected virtual SlotInfo GetChildSlot(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.TryInstruction : ILInstruction {
    public static SlotInfo TryBlockSlot;
    private ILInstruction tryBlock;
    public ILInstruction TryBlock { get; public set; }
    protected TryInstruction(OpCode opCode, ILInstruction tryBlock);
    private static TryInstruction();
    public ILInstruction get_TryBlock();
    public void set_TryBlock(ILInstruction value);
}
internal class ICSharpCode.Decompiler.IL.TupleTransform : object {
    public static bool MatchTupleFieldAccess(LdFlda inst, IType& tupleType, ILInstruction& target, Int32& position);
    public static bool MatchTupleConstruction(NewObj newobj, ILInstruction[]& arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.IL.UnaryInstruction : ILInstruction {
    public static SlotInfo ArgumentSlot;
    private ILInstruction argument;
    public ILInstruction Argument { get; public set; }
    public InstructionFlags DirectFlags { get; }
    protected UnaryInstruction(OpCode opCode, ILInstruction argument);
    private static UnaryInstruction();
    public ILInstruction get_Argument();
    public void set_Argument(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.Unbox : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public Unbox(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.UnboxAny : UnaryInstruction {
    private IType type;
    public IType Type { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public UnboxAny(ILInstruction argument, IType type);
    public IType get_Type();
    public void set_Type(IType value);
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.UserDefinedCompoundAssign : CompoundAssignmentInstruction {
    public IMethod Method;
    public InstructionFlags DirectFlags { get; }
    public bool IsLifted { get; }
    public StackType ResultType { get; }
    public UserDefinedCompoundAssign(IMethod method, CompoundEvalMode evalMode, ILInstruction target, CompoundTargetKind targetKind, ILInstruction value);
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    public bool get_IsLifted();
    public static bool IsIncrementOrDecrement(IMethod method, DecompilerSettings settings);
    public static bool IsStringConcat(IMethod method);
    public virtual StackType get_ResultType();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.UserDefinedLogicOperator : ILInstruction {
    private IMethod method;
    public static SlotInfo LeftSlot;
    private ILInstruction left;
    public static SlotInfo RightSlot;
    private ILInstruction right;
    public InstructionFlags DirectFlags { get; }
    public IMethod Method { get; }
    public StackType ResultType { get; }
    public ILInstruction Left { get; public set; }
    public ILInstruction Right { get; public set; }
    public UserDefinedLogicOperator(IMethod method, ILInstruction left, ILInstruction right);
    private static UserDefinedLogicOperator();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public sealed virtual IMethod get_Method();
    public virtual StackType get_ResultType();
    public ILInstruction get_Left();
    public void set_Left(ILInstruction value);
    public ILInstruction get_Right();
    public void set_Right(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.UsingInstruction : ILInstruction {
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRefStruct>k__BackingField;
    private ILVariable variable;
    [CompilerGeneratedAttribute]
private int <IndexInStoreInstructionList>k__BackingField;
    public static SlotInfo ResourceExpressionSlot;
    private ILInstruction resourceExpression;
    public static SlotInfo BodySlot;
    private ILInstruction body;
    public bool IsAsync { get; public set; }
    public bool IsRefStruct { get; public set; }
    public ILVariable Variable { get; public set; }
    public int IndexInStoreInstructionList { get; public set; }
    private int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.IndexInVariableInstructionMapping { get; private set; }
    public ILInstruction ResourceExpression { get; public set; }
    public ILInstruction Body { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public UsingInstruction(ILVariable variable, ILInstruction resourceExpression, ILInstruction body);
    private static UsingInstruction();
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
    [CompilerGeneratedAttribute]
public void set_IsAsync(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRefStruct();
    [CompilerGeneratedAttribute]
public void set_IsRefStruct(bool value);
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public sealed virtual ILVariable get_Variable();
    public sealed virtual void set_Variable(ILVariable value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IndexInStoreInstructionList();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndexInStoreInstructionList(int value);
    private sealed virtual override int ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.get_IndexInVariableInstructionMapping();
    private sealed virtual override void ICSharpCode.Decompiler.IL.IInstructionWithVariableOperand.set_IndexInVariableInstructionMapping(int value);
    protected virtual void Connected();
    protected virtual void Disconnected();
    public ILInstruction get_ResourceExpression();
    public void set_ResourceExpression(ILInstruction value);
    public ILInstruction get_Body();
    public void set_Body(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
    internal virtual void CheckInvariant(ILPhase phase);
}
public enum ICSharpCode.Decompiler.IL.VariableKind : Enum {
    public int value__;
    public static VariableKind Local;
    public static VariableKind PinnedLocal;
    public static VariableKind PinnedRegionLocal;
    public static VariableKind UsingLocal;
    public static VariableKind ForeachLocal;
    public static VariableKind InitializerTarget;
    public static VariableKind Parameter;
    public static VariableKind ExceptionStackSlot;
    public static VariableKind ExceptionLocal;
    public static VariableKind StackSlot;
    public static VariableKind NamedArgument;
    public static VariableKind DisplayClassLocal;
    public static VariableKind PatternLocal;
    public static VariableKind DeconstructionInitTemporary;
}
[ExtensionAttribute]
internal static class ICSharpCode.Decompiler.IL.VariableKindExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsThis(ILVariable v);
    [ExtensionAttribute]
public static bool IsLocal(VariableKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.IL.YieldReturn : ILInstruction {
    public static SlotInfo ValueSlot;
    private ILInstruction value;
    public ILInstruction Value { get; public set; }
    public StackType ResultType { get; }
    public InstructionFlags DirectFlags { get; }
    public YieldReturn(ILInstruction value);
    private static YieldReturn();
    public ILInstruction get_Value();
    public void set_Value(ILInstruction value);
    protected sealed virtual int GetChildCount();
    protected sealed virtual ILInstruction GetChild(int index);
    protected sealed virtual void SetChild(int index, ILInstruction value);
    protected sealed virtual SlotInfo GetChildSlot(int index);
    public sealed virtual ILInstruction Clone();
    public virtual StackType get_ResultType();
    protected virtual InstructionFlags ComputeFlags();
    public virtual InstructionFlags get_DirectFlags();
    public virtual void WriteTo(ITextOutput output, ILAstWritingOptions options);
    public virtual void AcceptVisitor(ILVisitor visitor);
    public virtual T AcceptVisitor(ILVisitor`1<T> visitor);
    public virtual T AcceptVisitor(ILVisitor`2<C, T> visitor, C context);
    [NullableContextAttribute("2")]
protected internal virtual bool PerformMatch(ILInstruction other, Match& match);
}
[EventSourceAttribute]
public class ICSharpCode.Decompiler.Instrumentation.DecompilerEventSource : EventSource {
    public static DecompilerEventSource Log;
    private static DecompilerEventSource();
    [EventAttribute("1")]
public void DoDecompileEvent(string eventName, long elapsedMilliseconds);
    [EventAttribute("2")]
public void DoDecompileProperty(string propertyName, long elapsedMilliseconds);
    [EventAttribute("3")]
public void DoDecompileField(string fieldName, long elapsedMilliseconds);
    [EventAttribute("4")]
public void DoDecompileTypeDefinition(string typeDefName, long elapsedMilliseconds);
    [EventAttribute("5")]
public void DoDecompileMethod(string methodName, long elapsedMilliseconds);
}
public interface ICSharpCode.Decompiler.ITextOutput {
    public string IndentationString { get; public set; }
    public abstract virtual string get_IndentationString();
    public abstract virtual void set_IndentationString(string value);
    public abstract virtual void Indent();
    public abstract virtual void Unindent();
    public abstract virtual void Write(char ch);
    public abstract virtual void Write(string text);
    public abstract virtual void WriteLine();
    public abstract virtual void WriteReference(OpCodeInfo opCode, bool omitSuffix);
    public abstract virtual void WriteReference(PEFile module, Handle handle, string text, string protocol, bool isDefinition);
    public abstract virtual void WriteReference(IType type, string text, bool isDefinition);
    public abstract virtual void WriteReference(IMember member, string text, bool isDefinition);
    public abstract virtual void WriteLocalReference(string text, object reference, bool isDefinition);
    public abstract virtual void MarkFoldStart(string collapsedText, bool defaultCollapsed, bool isDefinition);
    public abstract virtual void MarkFoldEnd();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Metadata.AssemblyNameReference : object {
    private string fullName;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PublicKeyToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWindowsRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetargetable>k__BackingField;
    [NullableAttribute("1")]
public string Name { get; private set; }
    [NullableAttribute("1")]
public string FullName { get; }
    public Version Version { get; private set; }
    public string Culture { get; private set; }
    public Byte[] PublicKeyToken { get; private set; }
    public bool IsWindowsRuntime { get; private set; }
    public bool IsRetargetable { get; private set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Name(string value);
    [NullableContextAttribute("1")]
public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Culture();
    [CompilerGeneratedAttribute]
private void set_Culture(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_PublicKeyToken();
    [CompilerGeneratedAttribute]
private void set_PublicKeyToken(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWindowsRuntime();
    [CompilerGeneratedAttribute]
private void set_IsWindowsRuntime(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRetargetable();
    [CompilerGeneratedAttribute]
private void set_IsRetargetable(bool value);
    [NullableContextAttribute("1")]
public static AssemblyNameReference Parse(string fullName);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Metadata.AssemblyReference : object {
    private static SHA1 sha1;
    private AssemblyReference entry;
    [CompilerGeneratedAttribute]
private MetadataReader <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyReferenceHandle <Handle>k__BackingField;
    [NullableAttribute("2")]
private string name;
    [NullableAttribute("2")]
private string fullName;
    public MetadataReader Metadata { get; }
    public AssemblyReferenceHandle Handle { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsRetargetable { get; }
    public string Name { get; }
    public string FullName { get; }
    [NullableAttribute("2")]
public Version Version { get; }
    public string Culture { get; }
    [NullableAttribute("2")]
private Byte[] ICSharpCode.Decompiler.Metadata.IAssemblyReference.PublicKeyToken { get; }
    public AssemblyReference(MetadataReader metadata, AssemblyReferenceHandle handle);
    public AssemblyReference(PEFile module, AssemblyReferenceHandle handle);
    private static AssemblyReference();
    [CompilerGeneratedAttribute]
public MetadataReader get_Metadata();
    [CompilerGeneratedAttribute]
public AssemblyReferenceHandle get_Handle();
    public sealed virtual bool get_IsWindowsRuntime();
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual string get_Name();
    public sealed virtual string get_FullName();
    [NullableContextAttribute("2")]
public sealed virtual Version get_Version();
    public sealed virtual string get_Culture();
    [NullableContextAttribute("2")]
private sealed virtual override Byte[] ICSharpCode.Decompiler.Metadata.IAssemblyReference.get_PublicKeyToken();
    [NullableContextAttribute("2")]
public Byte[] GetPublicKeyToken();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Metadata.AssemblyReferenceClassifier : object {
    public virtual bool IsGacAssembly(IAssemblyReference reference);
    public virtual bool IsSharedAssembly(IAssemblyReference reference, String& runtimePack);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Metadata.ByteArrayResource : Resource {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private Byte[] data;
    public string Name { get; }
    public ByteArrayResource(string name, Byte[] data);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual Stream TryOpenStream();
    public virtual Nullable`1<long> TryGetLength();
}
public class ICSharpCode.Decompiler.Metadata.CodeMappingInfo : object {
    [CompilerGeneratedAttribute]
private PEFile <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDefinitionHandle <TypeDefinition>k__BackingField;
    private Dictionary`2<MethodDefinitionHandle, List`1<MethodDefinitionHandle>> parts;
    private Dictionary`2<MethodDefinitionHandle, MethodDefinitionHandle> parents;
    public PEFile Module { get; }
    public TypeDefinitionHandle TypeDefinition { get; }
    public CodeMappingInfo(PEFile module, TypeDefinitionHandle type);
    [CompilerGeneratedAttribute]
public PEFile get_Module();
    [CompilerGeneratedAttribute]
public TypeDefinitionHandle get_TypeDefinition();
    public IEnumerable`1<MethodDefinitionHandle> GetMethodParts(MethodDefinitionHandle method);
    public MethodDefinitionHandle GetParentMethod(MethodDefinitionHandle method);
    public void AddMapping(MethodDefinitionHandle parent, MethodDefinitionHandle part);
}
[IsReadOnlyAttribute]
internal class ICSharpCode.Decompiler.Metadata.CustomAttributeDecoder`1 : ValueType {
    private ICustomAttributeTypeProvider`1<TType> _provider;
    private MetadataReader _reader;
    private bool _provideBoxingTypeInfo;
    public CustomAttributeDecoder`1(ICustomAttributeTypeProvider`1<TType> provider, MetadataReader reader, bool provideBoxingTypeInfo);
    public ImmutableArray`1<CustomAttributeNamedArgument`1<TType>> DecodeNamedArguments(BlobReader& valueReader, int count);
    private ArgumentTypeInfo<TType> DecodeNamedArgumentType(BlobReader& valueReader, bool isElementType);
    private CustomAttributeTypedArgument`1<TType> DecodeArgument(BlobReader& valueReader, ArgumentTypeInfo<TType> info);
    private Nullable`1<ImmutableArray`1<CustomAttributeTypedArgument`1<TType>>> DecodeArrayArgument(BlobReader& blobReader, ArgumentTypeInfo<TType> info);
}
internal enum ICSharpCode.Decompiler.Metadata.DecompilerRuntime : Enum {
    public int value__;
    public static DecompilerRuntime NETFramework;
    public static DecompilerRuntime NETCoreApp;
    public static DecompilerRuntime Mono;
}
public class ICSharpCode.Decompiler.Metadata.DotNetCorePathFinder : object {
    private static String[] LookupPaths;
    private static String[] RuntimePacks;
    private DotNetCorePackageInfo[] packages;
    private List`1<string> searchPaths;
    private List`1<string> packageBasePaths;
    private Version targetFrameworkVersion;
    private string dotnetBasePath;
    private string preferredRuntimePack;
    public DotNetCorePathFinder(TargetFrameworkIdentifier targetFramework, Version targetFrameworkVersion, string preferredRuntimePack);
    public DotNetCorePathFinder(string parentAssemblyFileName, string targetFrameworkIdString, string preferredRuntimePack, TargetFrameworkIdentifier targetFramework, Version targetFrameworkVersion, ReferenceLoadInfo loadInfo);
    private static DotNetCorePathFinder();
    public void AddSearchDirectory(string path);
    public void RemoveSearchDirectory(string path);
    public string TryResolveDotNetCore(IAssemblyReference name);
    internal string GetReferenceAssemblyPath(string targetFramework);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.DotNetCorePathFinder/<LoadPackageInfos>d__15")]
private static IEnumerable`1<DotNetCorePackageInfo> LoadPackageInfos(string depsJsonFileName, string targetFramework);
    public string TryResolveDotNetCoreShared(IAssemblyReference name, String& runtimePack);
    private static string GetClosestVersionFolder(string basePath, Version version);
    internal static ValueTuple`2<Version, string> ConvertToVersion(string name);
    public static string FindDotNetExeDirectory();
    private static string GetRealPath(string path, Encoding encoding);
    private static Byte* GetRealPath(Byte* path, Byte* resolvedPath);
    private static void Free(Void* ptr);
    [CompilerGeneratedAttribute]
internal static string <ConvertToVersion>g__RemoveTrailingVersionInfo|18_0(<>c__DisplayClass18_0& );
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Metadata.DotNetCorePathFinderExtensions : object {
    private static string PathPattern;
    private static string RefPathPattern;
    private static DotNetCorePathFinderExtensions();
    [ExtensionAttribute]
public static string DetectTargetFrameworkId(PEFile assembly);
    [ExtensionAttribute]
public static string DetectTargetFrameworkId(MetadataReader metadata, string assemblyPath);
    [ExtensionAttribute]
public static bool IsReferenceAssembly(PEFile assembly);
    [ExtensionAttribute]
public static bool IsReferenceAssembly(PEReader assembly, string assemblyPath);
    [ExtensionAttribute]
public static string DetectRuntimePack(PEFile assembly);
}
public class ICSharpCode.Decompiler.Metadata.EnumUnderlyingTypeResolveException : Exception {
    public EnumUnderlyingTypeResolveException(string message);
    public EnumUnderlyingTypeResolveException(string message, Exception inner);
    protected EnumUnderlyingTypeResolveException(SerializationInfo info, StreamingContext context);
}
public class ICSharpCode.Decompiler.Metadata.FindTypeDecoder : object {
    [NullableAttribute("1")]
private PEFile declaringModule;
    [NullableAttribute("2")]
private MetadataModule currentModule;
    private TypeDefinitionHandle handle;
    [NullableAttribute("2")]
private string typeName;
    [NullableAttribute("2")]
private string namespaceName;
    private PrimitiveTypeCode primitiveType;
    [NullableContextAttribute("1")]
internal FindTypeDecoder(TypeDefinitionHandle handle, PEFile declaringModule);
    [NullableContextAttribute("1")]
public FindTypeDecoder(MetadataModule currentModule, ITypeDefinition type);
    public sealed virtual bool GetArrayType(bool elementType, ArrayShape shape);
    public sealed virtual bool GetByReferenceType(bool elementType);
    public sealed virtual bool GetFunctionPointerType(MethodSignature`1<bool> signature);
    public static bool AnyInMethodSignature(MethodSignature`1<bool> signature);
    public sealed virtual bool GetGenericInstantiation(bool genericType, ImmutableArray`1<bool> typeArguments);
    public sealed virtual bool GetGenericMethodParameter(Unit genericContext, int index);
    public sealed virtual bool GetGenericTypeParameter(Unit genericContext, int index);
    public sealed virtual bool GetModifiedType(bool modifier, bool unmodifiedType, bool isRequired);
    public sealed virtual bool GetPinnedType(bool elementType);
    public sealed virtual bool GetPointerType(bool elementType);
    public sealed virtual bool GetPrimitiveType(PrimitiveTypeCode typeCode);
    public sealed virtual bool GetSZArrayType(bool elementType);
    [NullableContextAttribute("1")]
public sealed virtual bool GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    [NullableContextAttribute("1")]
public sealed virtual bool GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    [NullableContextAttribute("1")]
public sealed virtual bool GetTypeFromSpecification(MetadataReader reader, Unit genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    [NullableContextAttribute("1")]
public bool GetTypeFromEntity(MetadataReader reader, EntityHandle handle, Unit genericContext, byte rawTypeKind);
}
public class ICSharpCode.Decompiler.Metadata.FullTypeNameSignatureDecoder : object {
    [NullableAttribute("1")]
private MetadataReader metadata;
    [NullableContextAttribute("1")]
public FullTypeNameSignatureDecoder(MetadataReader metadata);
    public sealed virtual FullTypeName GetArrayType(FullTypeName elementType, ArrayShape shape);
    public sealed virtual FullTypeName GetByReferenceType(FullTypeName elementType);
    public sealed virtual FullTypeName GetFunctionPointerType(MethodSignature`1<FullTypeName> signature);
    public sealed virtual FullTypeName GetGenericInstantiation(FullTypeName genericType, ImmutableArray`1<FullTypeName> typeArguments);
    public sealed virtual FullTypeName GetGenericMethodParameter(Unit genericContext, int index);
    public sealed virtual FullTypeName GetGenericTypeParameter(Unit genericContext, int index);
    public sealed virtual FullTypeName GetModifiedType(FullTypeName modifier, FullTypeName unmodifiedType, bool isRequired);
    public sealed virtual FullTypeName GetPinnedType(FullTypeName elementType);
    public sealed virtual FullTypeName GetPointerType(FullTypeName elementType);
    public sealed virtual FullTypeName GetPrimitiveType(PrimitiveTypeCode typeCode);
    public sealed virtual FullTypeName GetSystemType();
    public sealed virtual FullTypeName GetSZArrayType(FullTypeName elementType);
    [NullableContextAttribute("1")]
public sealed virtual FullTypeName GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    [NullableContextAttribute("1")]
public sealed virtual FullTypeName GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    [NullableContextAttribute("1")]
public sealed virtual FullTypeName GetTypeFromSerializedName(string name);
    [NullableContextAttribute("1")]
public sealed virtual FullTypeName GetTypeFromSpecification(MetadataReader reader, Unit genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    public sealed virtual PrimitiveTypeCode GetUnderlyingEnumType(FullTypeName type);
    public sealed virtual bool IsSystemType(FullTypeName type);
}
[NullableContextAttribute("2")]
public interface ICSharpCode.Decompiler.Metadata.IAssemblyReference {
    [NullableAttribute("1")]
public string Name { get; }
    [NullableAttribute("1")]
public string FullName { get; }
    public Version Version { get; }
    public string Culture { get; }
    public Byte[] PublicKeyToken { get; }
    public bool IsWindowsRuntime { get; }
    public bool IsRetargetable { get; }
    [NullableContextAttribute("1")]
public abstract virtual string get_Name();
    [NullableContextAttribute("1")]
public abstract virtual string get_FullName();
    public abstract virtual Version get_Version();
    public abstract virtual string get_Culture();
    public abstract virtual Byte[] get_PublicKeyToken();
    public abstract virtual bool get_IsWindowsRuntime();
    public abstract virtual bool get_IsRetargetable();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.Metadata.IAssemblyResolver {
    public abstract virtual PEFile Resolve(IAssemblyReference reference);
    public abstract virtual PEFile ResolveModule(PEFile mainModule, string moduleName);
    public abstract virtual Task`1<PEFile> ResolveAsync(IAssemblyReference reference);
    public abstract virtual Task`1<PEFile> ResolveModuleAsync(PEFile mainModule, string moduleName);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Metadata.ILOpCodeExtensions : object {
    public static HashSet`1<string> ILKeywords;
    private static Byte[] operandTypes;
    private static String[] operandNames;
    private static ILOpCodeExtensions();
    [ExtensionAttribute]
public static OperandType GetOperandType(ILOpCode opCode);
    [ExtensionAttribute]
public static string GetDisplayName(ILOpCode opCode);
    [ExtensionAttribute]
public static bool IsDefined(ILOpCode opCode);
    private static HashSet`1<string> BuildKeywordList(String[] keywords);
}
public enum ICSharpCode.Decompiler.Metadata.MessageKind : Enum {
    public int value__;
    public static MessageKind Error;
    public static MessageKind Warning;
    public static MessageKind Info;
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Metadata.MetadataExtensions : object {
    internal static TypeProvider minimalCorlibTypeProvider;
    public static ICustomAttributeTypeProvider`1<IType> MinimalAttributeTypeProvider { get; }
    public static ISignatureTypeProvider`2<IType, GenericContext> MinimalSignatureTypeProvider { get; }
    private static MetadataExtensions();
    [ExtensionAttribute]
private static HashAlgorithm GetHashAlgorithm(MetadataReader reader);
    private static string CalculatePublicKeyToken(BlobHandle blob, MetadataReader reader);
    [ExtensionAttribute]
public static string GetPublicKeyToken(MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullAssemblyName(MetadataReader reader);
    [ExtensionAttribute]
public static bool TryGetFullAssemblyName(MetadataReader reader, String& assemblyName);
    [ExtensionAttribute]
public static string GetFullAssemblyName(AssemblyReference reference, MetadataReader reader);
    [ExtensionAttribute]
public static bool TryGetFullAssemblyName(AssemblyReference reference, MetadataReader reader, String& assemblyName);
    [ExtensionAttribute]
public static string ToHexString(IEnumerable`1<byte> bytes, int estimatedLength);
    [ExtensionAttribute]
public static void AppendHexString(StringBuilder builder, BlobReader reader);
    [ExtensionAttribute]
public static string ToHexString(BlobReader reader);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.MetadataExtensions/<GetTopLevelTypeDefinitions>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> GetTopLevelTypeDefinitions(MetadataReader reader);
    [ExtensionAttribute]
public static string ToILNameString(FullTypeName typeName, bool omitGenerics);
    [ExtensionAttribute]
[ObsoleteAttribute("Use MetadataModule.GetDeclaringModule() instead")]
public static IModuleReference GetDeclaringModule(TypeReferenceHandle handle, MetadataReader reader);
    public static ICustomAttributeTypeProvider`1<IType> get_MinimalAttributeTypeProvider();
    public static ISignatureTypeProvider`2<IType, GenericContext> get_MinimalSignatureTypeProvider();
    [ExtensionAttribute]
public static PrimitiveTypeCode ToPrimitiveTypeCode(KnownTypeCode typeCode);
    [ExtensionAttribute]
public static KnownTypeCode ToKnownTypeCode(PrimitiveTypeCode typeCode);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.MetadataExtensions/<GetModuleReferences>d__20")]
[ExtensionAttribute]
public static IEnumerable`1<ModuleReferenceHandle> GetModuleReferences(MetadataReader metadata);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.MetadataExtensions/<GetTypeSpecifications>d__21")]
[ExtensionAttribute]
public static IEnumerable`1<TypeSpecificationHandle> GetTypeSpecifications(MetadataReader metadata);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.MetadataExtensions/<GetMethodSpecifications>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<MethodSpecificationHandle> GetMethodSpecifications(MetadataReader metadata);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.MetadataExtensions/<GetMethodSemantics>d__23")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`4<Handle, MethodSemanticsAttributes, MethodDefinitionHandle, EntityHandle>> GetMethodSemantics(MetadataReader metadata);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.MetadataExtensions/<GetFieldLayouts>d__24")]
[ExtensionAttribute]
public static IEnumerable`1<EntityHandle> GetFieldLayouts(MetadataReader metadata);
    [ExtensionAttribute]
public static ValueTuple`2<int, FieldDefinitionHandle> GetFieldLayout(MetadataReader metadata, EntityHandle fieldLayoutHandle);
    [CompilerGeneratedAttribute]
internal static ValueTuple`4<Handle, MethodSemanticsAttributes, MethodDefinitionHandle, EntityHandle> <GetMethodSemantics>g__Read|23_0(int row, <>c__DisplayClass23_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ICSharpCode.Decompiler.Metadata.MetadataGenericContext : ValueType {
    [NullableAttribute("2")]
private MetadataReader metadata;
    private TypeDefinitionHandle declaringType;
    private MethodDefinitionHandle method;
    public MetadataGenericContext(MethodDefinitionHandle method, PEFile module);
    public MetadataGenericContext(MethodDefinitionHandle method, MetadataReader metadata);
    public MetadataGenericContext(TypeDefinitionHandle declaringType, PEFile module);
    public MetadataGenericContext(TypeDefinitionHandle declaringType, MetadataReader metadata);
    public string GetGenericTypeParameterName(int index);
    public string GetGenericMethodTypeParameterName(int index);
    public GenericParameterHandle GetGenericTypeParameterHandleOrNull(int index);
    public GenericParameterHandle GetGenericMethodTypeParameterHandleOrNull(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.Metadata.MetadataResource : Resource {
    [CompilerGeneratedAttribute]
private PEFile <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private ManifestResourceHandle <Handle>k__BackingField;
    public PEFile Module { get; }
    public ManifestResourceHandle Handle { get; }
    public bool IsNil { get; }
    public string Name { get; }
    public ManifestResourceAttributes Attributes { get; }
    public ResourceType ResourceType { get; }
    public MetadataResource(PEFile module, ManifestResourceHandle handle);
    [CompilerGeneratedAttribute]
public PEFile get_Module();
    [CompilerGeneratedAttribute]
public ManifestResourceHandle get_Handle();
    public bool get_IsNil();
    public bool Equals(MetadataResource other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string get_Name();
    public virtual ManifestResourceAttributes get_Attributes();
    public bool HasFlag(ManifestResourceAttributes flag);
    public virtual ResourceType get_ResourceType();
    private ResourceType GetResourceType();
    [NullableContextAttribute("0")]
private bool TryReadResource(Byte*& ptr, Int64& length);
    [NullableContextAttribute("2")]
public virtual Stream TryOpenStream();
    public virtual Nullable`1<long> TryGetLength();
}
public static class ICSharpCode.Decompiler.Metadata.MetadataTokenHelpers : object {
    public static Nullable`1<EntityHandle> TryAsEntityHandle(int metadataToken);
    public static EntityHandle EntityHandleOrNil(int metadataToken);
}
internal class ICSharpCode.Decompiler.Metadata.MethodSemanticsLookup : object {
    private static MethodSemanticsAttributes csharpAccessors;
    private List`1<Entry> entries;
    public MethodSemanticsLookup(MetadataReader metadata, MethodSemanticsAttributes filter);
    public ValueTuple`2<EntityHandle, MethodSemanticsAttributes> GetSemantics(MethodDefinitionHandle method);
    [CompilerGeneratedAttribute]
private void <.ctor>g__AddEntry|3_0(MethodSemanticsAttributes semantics, MethodDefinitionHandle method, EntityHandle association, <>c__DisplayClass3_0& );
}
public enum ICSharpCode.Decompiler.Metadata.OperandType : Enum {
    public int value__;
    public static OperandType BrTarget;
    public static OperandType Field;
    public static OperandType I;
    public static OperandType I8;
    public static OperandType Method;
    public static OperandType None;
    public static OperandType R;
    public static OperandType Sig;
    public static OperandType String;
    public static OperandType Switch;
    public static OperandType Tok;
    public static OperandType Type;
    public static OperandType Variable;
    public static OperandType ShortBrTarget;
    public static OperandType ShortI;
    public static OperandType ShortR;
    public static OperandType ShortVariable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{FileName}")]
public class ICSharpCode.Decompiler.Metadata.PEFile : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private PEReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReader <Metadata>k__BackingField;
    [NullableAttribute("2")]
private string name;
    [NullableAttribute("2")]
private string fullName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AssemblyReference> assemblyReferences;
    [NullableAttribute("2")]
private Dictionary`2<TopLevelTypeName, TypeDefinitionHandle> typeLookup;
    [NullableAttribute("2")]
private Dictionary`2<FullTypeName, ExportedTypeHandle> typeForwarderLookup;
    [NullableAttribute("2")]
private MethodSemanticsLookup methodSemanticsLookup;
    public string FileName { get; }
    public PEReader Reader { get; }
    public MetadataReader Metadata { get; }
    public bool IsAssembly { get; }
    public string Name { get; }
    public string FullName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<AssemblyReference> AssemblyReferences { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Resource> Resources { get; }
    internal MethodSemanticsLookup MethodSemanticsLookup { get; }
    public PEFile(string fileName, PEStreamOptions streamOptions, MetadataReaderOptions metadataOptions);
    public PEFile(string fileName, Stream stream, PEStreamOptions streamOptions, MetadataReaderOptions metadataOptions);
    public PEFile(string fileName, PEReader reader, MetadataReaderOptions metadataOptions);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public PEReader get_Reader();
    [CompilerGeneratedAttribute]
public MetadataReader get_Metadata();
    public bool get_IsAssembly();
    public string get_Name();
    public string get_FullName();
    public TargetRuntime GetRuntime();
    public ImmutableArray`1<AssemblyReference> get_AssemblyReferences();
    public ImmutableArray`1<Resource> get_Resources();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.PEFile/<GetResources>d__26")]
private IEnumerable`1<Resource> GetResources();
    public sealed virtual void Dispose();
    public TypeDefinitionHandle GetTypeDefinition(TopLevelTypeName typeName);
    public ExportedTypeHandle GetTypeForwarder(FullTypeName typeName);
    internal MethodSemanticsLookup get_MethodSemanticsLookup();
    public IModuleReference WithOptions(TypeSystemOptions options);
    private sealed virtual override IModule ICSharpCode.Decompiler.TypeSystem.IModuleReference.Resolve(ITypeResolveContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private AssemblyReference <get_AssemblyReferences>b__23_0(AssemblyReferenceHandle r);
}
public class ICSharpCode.Decompiler.Metadata.PEFileNotSupportedException : Exception {
    public PEFileNotSupportedException(string message);
    public PEFileNotSupportedException(string message, Exception inner);
    protected PEFileNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class ICSharpCode.Decompiler.Metadata.ReferenceLoadInfo : object {
    private Dictionary`2<string, UnresolvedAssemblyNameReference> loadedAssemblyReferences;
    public IReadOnlyList`1<UnresolvedAssemblyNameReference> Entries { get; }
    public bool HasErrors { get; }
    public void AddMessage(string fullName, MessageKind kind, string message);
    public void AddMessageOnce(string fullName, MessageKind kind, string message);
    public bool TryGetInfo(string fullName, UnresolvedAssemblyNameReference& info);
    public IReadOnlyList`1<UnresolvedAssemblyNameReference> get_Entries();
    public bool get_HasErrors();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Metadata.ResolutionException : Exception {
    [CompilerGeneratedAttribute]
private IAssemblyReference <Reference>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MainModuleFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedFullPath>k__BackingField;
    public IAssemblyReference Reference { get; }
    public string ModuleName { get; }
    public string MainModuleFullPath { get; }
    public string ResolvedFullPath { get; }
    public ResolutionException(IAssemblyReference reference, string resolvedPath, Exception innerException);
    [NullableContextAttribute("1")]
public ResolutionException(string mainModule, string moduleName, string resolvedPath, Exception innerException);
    [CompilerGeneratedAttribute]
public IAssemblyReference get_Reference();
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
public string get_MainModuleFullPath();
    [CompilerGeneratedAttribute]
public string get_ResolvedFullPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.Metadata.Resource : object {
    public ResourceType ResourceType { get; }
    public ManifestResourceAttributes Attributes { get; }
    public string Name { get; }
    public virtual ResourceType get_ResourceType();
    public virtual ManifestResourceAttributes get_Attributes();
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual Stream TryOpenStream();
    public abstract virtual Nullable`1<long> TryGetLength();
}
internal class ICSharpCode.Decompiler.Metadata.ResourceMemoryStream : UnmanagedMemoryStream {
    [NullableAttribute("1")]
private PEReader peReader;
    public ResourceMemoryStream(PEReader peReader, Byte* data, long length);
}
public enum ICSharpCode.Decompiler.Metadata.ResourceType : Enum {
    public int value__;
    public static ResourceType Linked;
    public static ResourceType Embedded;
    public static ResourceType AssemblyLinked;
}
public static class ICSharpCode.Decompiler.Metadata.SignatureBlobComparer : object {
    public static bool EqualsMethodSignature(BlobReader a, BlobReader b, MetadataReader contextForA, MetadataReader contextForB);
    private static bool EqualsMethodSignature(BlobReader& a, BlobReader& b, MetadataReader contextForA, MetadataReader contextForB);
    public static bool EqualsTypeSignature(BlobReader a, BlobReader b, MetadataReader contextForA, MetadataReader contextForB);
    private static bool EqualsTypeSignature(BlobReader& a, BlobReader& b, MetadataReader contextForA, MetadataReader contextForB);
    private static bool IsSameCompressedInteger(BlobReader& a, BlobReader& b, Int32& value);
    private static bool IsSameCompressedSignedInteger(BlobReader& a, BlobReader& b, Int32& value);
    private static bool TypesAreEqual(BlobReader& a, BlobReader& b, MetadataReader contextForA, MetadataReader contextForB, int typeCode);
    private static bool TypeHandleEquals(BlobReader& a, BlobReader& b, MetadataReader contextForA, MetadataReader contextForB);
}
public enum ICSharpCode.Decompiler.Metadata.TargetFrameworkIdentifier : Enum {
    public int value__;
    public static TargetFrameworkIdentifier NETFramework;
    public static TargetFrameworkIdentifier NETCoreApp;
    public static TargetFrameworkIdentifier NETStandard;
    public static TargetFrameworkIdentifier Silverlight;
    public static TargetFrameworkIdentifier NET;
}
public enum ICSharpCode.Decompiler.Metadata.TargetRuntime : Enum {
    public int value__;
    public static TargetRuntime Unknown;
    public static TargetRuntime Net_1_0;
    public static TargetRuntime Net_1_1;
    public static TargetRuntime Net_2_0;
    public static TargetRuntime Net_4_0;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Metadata.UniversalAssemblyResolver : AssemblyReferenceClassifier {
    private Lazy`1<DotNetCorePathFinder> dotNetCorePathFinder;
    private bool throwOnError;
    private PEStreamOptions streamOptions;
    private MetadataReaderOptions metadataOptions;
    [NullableAttribute("2")]
private string mainAssemblyFileName;
    [NullableAttribute("2")]
private string baseDirectory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> directories;
    private static List`1<string> gac_paths;
    private static DecompilerRuntime decompilerRuntime;
    private string targetFramework;
    private string runtimePack;
    private TargetFrameworkIdentifier targetFrameworkIdentifier;
    private Version targetFrameworkVersion;
    internal static Version ZeroVersion;
    private static UniversalAssemblyResolver();
    [NullableContextAttribute("2")]
public UniversalAssemblyResolver(string mainAssemblyFileName, bool throwOnError, string targetFramework, string runtimePack, PEStreamOptions streamOptions, MetadataReaderOptions metadataOptions);
    [NullableContextAttribute("2")]
public void AddSearchDirectory(string directory);
    [NullableContextAttribute("2")]
public void RemoveSearchDirectory(string directory);
    public String[] GetSearchDirectories();
    internal static ValueTuple`2<TargetFrameworkIdentifier, Version> ParseTargetFramework(string targetFramework);
    public sealed virtual PEFile Resolve(IAssemblyReference name);
    public sealed virtual PEFile ResolveModule(PEFile mainModule, string moduleName);
    [NullableContextAttribute("2")]
private PEFile CreatePEFileFromFileName(string fileName, Func`2<Exception, Exception> makeException);
    public sealed virtual Task`1<PEFile> ResolveAsync(IAssemblyReference name);
    public sealed virtual Task`1<PEFile> ResolveModuleAsync(PEFile mainModule, string moduleName);
    public virtual bool IsSharedAssembly(IAssemblyReference reference, String& runtimePack);
    public string FindAssemblyFile(IAssemblyReference name);
    private DotNetCorePathFinder InitDotNetCorePathFinder();
    private string FindWindowsMetadataFile(IAssemblyReference name);
    private string FindWindowsMetadataInSystemDirectory(IAssemblyReference name);
    [NullableContextAttribute("2")]
private string ResolveSilverlight(IAssemblyReference name, Version version);
    private string FindClosestVersionDirectory(string basePath, Version version);
    private string ResolveInternal(IAssemblyReference name);
    private string SearchDirectory(IAssemblyReference name, IEnumerable`1<string> directories);
    private static bool IsSpecialVersionOrRetargetable(IAssemblyReference reference);
    private string SearchDirectory(IAssemblyReference name, string directory);
    [NullableContextAttribute("2")]
private static bool IsZeroOrAllOnes(Version version);
    private string GetCorlib(IAssemblyReference reference);
    [NullableContextAttribute("2")]
private string GetMscorlibBasePath(Version version, string publicKeyToken);
    private string GetMonoMscorlibBasePath(Version version);
    public static List`1<string> GetGacPaths();
    private static List`1<string> GetDefaultMonoGacPaths();
    private static string GetCurrentMonoGac();
    public static string GetAssemblyInGac(IAssemblyReference reference);
    private static string GetAssemblyInMonoGac(IAssemblyReference reference);
    private static string GetAssemblyInNetGac(IAssemblyReference reference);
    private static string GetAssemblyFile(IAssemblyReference reference, string prefix, string gac);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Metadata.UniversalAssemblyResolver/<EnumerateGac>d__47")]
public static IEnumerable`1<AssemblyNameReference> EnumerateGac();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private string <GetMscorlibBasePath>g__GetSubFolderForVersion|38_0(<>c__DisplayClass38_0& );
}
public class ICSharpCode.Decompiler.Metadata.UnresolvedAssemblyNameReference : object {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ValueTuple`2<MessageKind, string>> <Messages>k__BackingField;
    public string FullName { get; }
    public bool HasErrors { get; }
    public List`1<ValueTuple`2<MessageKind, string>> Messages { get; }
    public UnresolvedAssemblyNameReference(string fullName);
    [CompilerGeneratedAttribute]
public string get_FullName();
    public bool get_HasErrors();
    [CompilerGeneratedAttribute]
public List`1<ValueTuple`2<MessageKind, string>> get_Messages();
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.NRExtensions : object {
    [ExtensionAttribute]
public static bool IsCompilerGenerated(IEntity entity);
    [ExtensionAttribute]
public static bool IsCompilerGeneratedOrIsInCompilerGeneratedClass(IEntity entity);
    [ExtensionAttribute]
public static bool HasGeneratedName(IMember member);
    [ExtensionAttribute]
public static bool HasGeneratedName(IType type);
    [ExtensionAttribute]
public static bool IsAnonymousType(IType type);
    [ExtensionAttribute]
public static bool ContainsAnonymousType(IType type);
    [ExtensionAttribute]
internal static string GetDocumentation(IEntity entity);
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.Output.ConversionFlags : Enum {
    public int value__;
    public static ConversionFlags None;
    public static ConversionFlags ShowParameterList;
    public static ConversionFlags ShowParameterNames;
    public static ConversionFlags ShowAccessibility;
    public static ConversionFlags ShowDefinitionKeyword;
    public static ConversionFlags ShowDeclaringType;
    public static ConversionFlags ShowModifiers;
    public static ConversionFlags ShowReturnType;
    public static ConversionFlags UseFullyQualifiedTypeNames;
    public static ConversionFlags ShowTypeParameterList;
    public static ConversionFlags ShowBody;
    public static ConversionFlags UseFullyQualifiedEntityNames;
    public static ConversionFlags PlaceReturnTypeAfterParameterList;
    public static ConversionFlags ShowTypeParameterVarianceModifier;
    public static ConversionFlags ShowParameterModifiers;
    public static ConversionFlags ShowParameterDefaultValues;
    public static ConversionFlags UseNullableSpecifierForValueTypes;
    public static ConversionFlags SupportInitAccessors;
    public static ConversionFlags SupportRecordClasses;
    public static ConversionFlags SupportRecordStructs;
    public static ConversionFlags SupportUnsignedRightShift;
    public static ConversionFlags SupportOperatorChecked;
    public static ConversionFlags StandardConversionFlags;
    public static ConversionFlags All;
}
public interface ICSharpCode.Decompiler.Output.IAmbience {
    public ConversionFlags ConversionFlags { get; public set; }
    public abstract virtual ConversionFlags get_ConversionFlags();
    public abstract virtual void set_ConversionFlags(ConversionFlags value);
    public abstract virtual string ConvertSymbol(ISymbol symbol);
    public abstract virtual string ConvertType(IType type);
    public abstract virtual string ConvertConstantValue(object constantValue);
    public abstract virtual string WrapComment(string comment);
}
public class ICSharpCode.Decompiler.PartialTypeInfo : object {
    private HashSet`1<EntityHandle> declaredMembers;
    [CompilerGeneratedAttribute]
private TypeDefinitionHandle <DeclaringTypeDefinitionHandle>k__BackingField;
    public TypeDefinitionHandle DeclaringTypeDefinitionHandle { get; }
    public string DebugOutput { get; }
    public PartialTypeInfo(ITypeDefinition declaringTypeDefinition);
    public PartialTypeInfo(TypeDefinitionHandle declaringTypeDefinitionHandle);
    [CompilerGeneratedAttribute]
public TypeDefinitionHandle get_DeclaringTypeDefinitionHandle();
    public void AddDeclaredMember(IMember member);
    public void AddDeclaredMember(EntityHandle handle);
    public bool IsDeclaredMember(IMember member);
    public bool IsDeclaredMember(EntityHandle handle);
    public void AddDeclaredMembers(PartialTypeInfo info);
    public string get_DebugOutput();
}
public class ICSharpCode.Decompiler.PlainTextOutput : object {
    private TextWriter writer;
    private int indent;
    private bool needsIndent;
    private int line;
    private int column;
    [CompilerGeneratedAttribute]
private string <IndentationString>k__BackingField;
    public string IndentationString { get; public set; }
    public TextLocation Location { get; }
    public PlainTextOutput(TextWriter writer);
    [CompilerGeneratedAttribute]
public sealed virtual string get_IndentationString();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IndentationString(string value);
    public TextLocation get_Location();
    public virtual string ToString();
    public sealed virtual void Indent();
    public sealed virtual void Unindent();
    private void WriteIndent();
    public sealed virtual void Write(char ch);
    public sealed virtual void Write(string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteReference(OpCodeInfo opCode, bool omitSuffix);
    public sealed virtual void WriteReference(PEFile module, Handle handle, string text, string protocol, bool isDefinition);
    public sealed virtual void WriteReference(IType type, string text, bool isDefinition);
    public sealed virtual void WriteReference(IMember member, string text, bool isDefinition);
    public sealed virtual void WriteLocalReference(string text, object reference, bool isDefinition);
    private sealed virtual override void ICSharpCode.Decompiler.ITextOutput.MarkFoldStart(string collapsedText, bool defaultCollapsed, bool isDefinition);
    private sealed virtual override void ICSharpCode.Decompiler.ITextOutput.MarkFoldEnd();
}
public class ICSharpCode.Decompiler.Semantics.AmbiguousMemberResolveResult : MemberResolveResult {
    public bool IsError { get; }
    public AmbiguousMemberResolveResult(ResolveResult targetResult, IMember member);
    public virtual bool get_IsError();
}
public class ICSharpCode.Decompiler.Semantics.AmbiguousTypeResolveResult : TypeResolveResult {
    public bool IsError { get; }
    public AmbiguousTypeResolveResult(IType type);
    public virtual bool get_IsError();
}
public class ICSharpCode.Decompiler.Semantics.ArrayAccessResolveResult : ResolveResult {
    public ResolveResult Array;
    public IList`1<ResolveResult> Indexes;
    public ArrayAccessResolveResult(IType elementType, ResolveResult array, IList`1<ResolveResult> indexes);
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.Semantics.ArrayCreateResolveResult : ResolveResult {
    public IReadOnlyList`1<ResolveResult> SizeArguments;
    public IReadOnlyList`1<ResolveResult> InitializerElements;
    public ArrayCreateResolveResult(IType arrayType, IReadOnlyList`1<ResolveResult> sizeArguments, IReadOnlyList`1<ResolveResult> initializerElements);
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.Semantics.ByReferenceResolveResult : ResolveResult {
    [CompilerGeneratedAttribute]
private ReferenceKind <ReferenceKind>k__BackingField;
    public ResolveResult ElementResult;
    public ReferenceKind ReferenceKind { get; }
    public bool IsOut { get; }
    public bool IsRef { get; }
    public bool IsIn { get; }
    public IType ElementType { get; }
    public ByReferenceResolveResult(ResolveResult elementResult, ReferenceKind kind);
    internal ByReferenceResolveResult(IType elementType, ReferenceKind kind);
    [CompilerGeneratedAttribute]
public ReferenceKind get_ReferenceKind();
    public bool get_IsOut();
    public bool get_IsRef();
    public bool get_IsIn();
    public IType get_ElementType();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.Semantics.ConstantResolveResult : ResolveResult {
    private object constantValue;
    public bool IsCompileTimeConstant { get; }
    public object ConstantValue { get; }
    public ConstantResolveResult(IType type, object constantValue);
    public virtual bool get_IsCompileTimeConstant();
    public virtual object get_ConstantValue();
    public virtual string ToString();
}
public abstract class ICSharpCode.Decompiler.Semantics.Conversion : object {
    public static Conversion None;
    public static Conversion IdentityConversion;
    public static Conversion ImplicitNumericConversion;
    public static Conversion ExplicitNumericConversion;
    public static Conversion ImplicitLiftedNumericConversion;
    public static Conversion ExplicitLiftedNumericConversion;
    public static Conversion NullLiteralConversion;
    public static Conversion ImplicitConstantExpressionConversion;
    public static Conversion ImplicitReferenceConversion;
    public static Conversion ExplicitReferenceConversion;
    public static Conversion ImplicitDynamicConversion;
    public static Conversion ExplicitDynamicConversion;
    public static Conversion ImplicitNullableConversion;
    public static Conversion ExplicitNullableConversion;
    public static Conversion ImplicitPointerConversion;
    public static Conversion ExplicitPointerConversion;
    public static Conversion BoxingConversion;
    public static Conversion UnboxingConversion;
    public static Conversion TryCast;
    public static Conversion ImplicitInterpolatedStringConversion;
    public static Conversion ThrowExpressionConversion;
    public bool IsValid { get; }
    public bool IsImplicit { get; }
    public bool IsExplicit { get; }
    public bool IsTryCast { get; }
    public bool IsThrowExpressionConversion { get; }
    public bool IsIdentityConversion { get; }
    public bool IsNullLiteralConversion { get; }
    public bool IsConstantExpressionConversion { get; }
    public bool IsNumericConversion { get; }
    public bool IsLifted { get; }
    public bool IsDynamicConversion { get; }
    public bool IsReferenceConversion { get; }
    public bool IsEnumerationConversion { get; }
    public bool IsNullableConversion { get; }
    public bool IsUserDefined { get; }
    public Conversion ConversionBeforeUserDefinedOperator { get; }
    public Conversion ConversionAfterUserDefinedOperator { get; }
    public bool IsBoxingConversion { get; }
    public bool IsUnboxingConversion { get; }
    public bool IsPointerConversion { get; }
    public bool IsMethodGroupConversion { get; }
    public bool IsVirtualMethodLookup { get; }
    public bool DelegateCapturesFirstArgument { get; }
    public bool IsAnonymousFunctionConversion { get; }
    public IMethod Method { get; }
    public bool IsTupleConversion { get; }
    public bool IsInterpolatedStringConversion { get; }
    public ImmutableArray`1<Conversion> ElementConversions { get; }
    private static Conversion();
    public static Conversion EnumerationConversion(bool isImplicit, bool isLifted);
    public static Conversion UserDefinedConversion(IMethod operatorMethod, bool isImplicit, Conversion conversionBeforeUserDefinedOperator, Conversion conversionAfterUserDefinedOperator, bool isLifted, bool isAmbiguous);
    public static Conversion MethodGroupConversion(IMethod chosenMethod, bool isVirtualMethodLookup, bool delegateCapturesFirstArgument);
    public static Conversion InvalidMethodGroupConversion(IMethod chosenMethod, bool isVirtualMethodLookup, bool delegateCapturesFirstArgument);
    public static Conversion TupleConversion(ImmutableArray`1<Conversion> conversions);
    public virtual bool get_IsValid();
    public virtual bool get_IsImplicit();
    public virtual bool get_IsExplicit();
    public virtual bool get_IsTryCast();
    public virtual bool get_IsThrowExpressionConversion();
    public virtual bool get_IsIdentityConversion();
    public virtual bool get_IsNullLiteralConversion();
    public virtual bool get_IsConstantExpressionConversion();
    public virtual bool get_IsNumericConversion();
    public virtual bool get_IsLifted();
    public virtual bool get_IsDynamicConversion();
    public virtual bool get_IsReferenceConversion();
    public virtual bool get_IsEnumerationConversion();
    public virtual bool get_IsNullableConversion();
    public virtual bool get_IsUserDefined();
    public virtual Conversion get_ConversionBeforeUserDefinedOperator();
    public virtual Conversion get_ConversionAfterUserDefinedOperator();
    public virtual bool get_IsBoxingConversion();
    public virtual bool get_IsUnboxingConversion();
    public virtual bool get_IsPointerConversion();
    public virtual bool get_IsMethodGroupConversion();
    public virtual bool get_IsVirtualMethodLookup();
    public virtual bool get_DelegateCapturesFirstArgument();
    public virtual bool get_IsAnonymousFunctionConversion();
    public virtual IMethod get_Method();
    public virtual bool get_IsTupleConversion();
    public virtual bool get_IsInterpolatedStringConversion();
    public virtual ImmutableArray`1<Conversion> get_ElementConversions();
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Equals(Conversion other);
}
public class ICSharpCode.Decompiler.Semantics.ConversionResolveResult : ResolveResult {
    public ResolveResult Input;
    public Conversion Conversion;
    public bool CheckForOverflow;
    public bool IsError { get; }
    public ConversionResolveResult(IType targetType, ResolveResult input, Conversion conversion);
    public ConversionResolveResult(IType targetType, ResolveResult input, Conversion conversion, bool checkForOverflow);
    public virtual bool get_IsError();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.Semantics.ErrorResolveResult : ResolveResult {
    public static ErrorResolveResult UnknownError;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private TextLocation <Location>k__BackingField;
    public bool IsError { get; }
    public string Message { get; private set; }
    public TextLocation Location { get; private set; }
    public ErrorResolveResult(IType type);
    public ErrorResolveResult(IType type, string message, TextLocation location);
    private static ErrorResolveResult();
    public virtual bool get_IsError();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public TextLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(TextLocation value);
}
public class ICSharpCode.Decompiler.Semantics.ForEachResolveResult : ResolveResult {
    public ResolveResult GetEnumeratorCall;
    public IType CollectionType;
    public IType EnumeratorType;
    public IType ElementType;
    public IProperty CurrentProperty;
    public IMethod MoveNextMethod;
    public ForEachResolveResult(ResolveResult getEnumeratorCall, IType collectionType, IType enumeratorType, IType elementType, IProperty currentProperty, IMethod moveNextMethod, IType voidType);
}
public class ICSharpCode.Decompiler.Semantics.InitializedObjectResolveResult : ResolveResult {
    public InitializedObjectResolveResult(IType type);
}
public class ICSharpCode.Decompiler.Semantics.InterpolatedStringResolveResult : ResolveResult {
    public string FormatString;
    public ResolveResult[] Arguments;
    public InterpolatedStringResolveResult(IType stringType, string formatString, ResolveResult[] arguments);
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.Semantics.InvocationResolveResult : MemberResolveResult {
    public IList`1<ResolveResult> Arguments;
    public IList`1<ResolveResult> InitializerStatements;
    public IParameterizedMember Member { get; }
    public InvocationResolveResult(ResolveResult targetResult, IParameterizedMember member, IList`1<ResolveResult> arguments, IList`1<ResolveResult> initializerStatements, IType returnTypeOverride);
    public IParameterizedMember get_Member();
    public virtual IList`1<ResolveResult> GetArgumentsForCall();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.Semantics.LocalResolveResult : ResolveResult {
    private IVariable variable;
    public IVariable Variable { get; }
    public bool IsParameter { get; }
    public bool IsCompileTimeConstant { get; }
    public object ConstantValue { get; }
    public LocalResolveResult(IVariable variable);
    private static IType UnpackTypeIfByRefParameter(IVariable variable);
    public IVariable get_Variable();
    public bool get_IsParameter();
    public virtual bool get_IsCompileTimeConstant();
    public virtual object get_ConstantValue();
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.Semantics.MemberResolveResult : ResolveResult {
    private IMember member;
    private bool isConstant;
    private object constantValue;
    private ResolveResult targetResult;
    private bool isVirtualCall;
    public ResolveResult TargetResult { get; }
    public IMember Member { get; }
    public bool IsVirtualCall { get; }
    public bool IsCompileTimeConstant { get; }
    public object ConstantValue { get; }
    public MemberResolveResult(ResolveResult targetResult, IMember member, IType returnTypeOverride);
    public MemberResolveResult(ResolveResult targetResult, IMember member, bool isVirtualCall, IType returnTypeOverride);
    public MemberResolveResult(ResolveResult targetResult, IMember member, IType returnType, bool isConstant, object constantValue);
    public MemberResolveResult(ResolveResult targetResult, IMember member, IType returnType, bool isConstant, object constantValue, bool isVirtualCall);
    private static IType ComputeType(IMember member);
    public ResolveResult get_TargetResult();
    public IMember get_Member();
    public bool get_IsVirtualCall();
    public virtual bool get_IsCompileTimeConstant();
    public virtual object get_ConstantValue();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.Semantics.NamedArgumentResolveResult : ResolveResult {
    public IParameterizedMember Member;
    public IParameter Parameter;
    public string ParameterName;
    public ResolveResult Argument;
    public NamedArgumentResolveResult(IParameter parameter, ResolveResult argument, IParameterizedMember member);
    public NamedArgumentResolveResult(string parameterName, ResolveResult argument);
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
public class ICSharpCode.Decompiler.Semantics.NamespaceResolveResult : ResolveResult {
    private INamespace ns;
    public INamespace Namespace { get; }
    public string NamespaceName { get; }
    public NamespaceResolveResult(INamespace ns);
    public INamespace get_Namespace();
    public string get_NamespaceName();
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.Semantics.OperatorResolveResult : ResolveResult {
    private ExpressionType operatorType;
    private IMethod userDefinedOperatorMethod;
    private IList`1<ResolveResult> operands;
    private bool isLiftedOperator;
    public ExpressionType OperatorType { get; }
    public IList`1<ResolveResult> Operands { get; }
    public IMethod UserDefinedOperatorMethod { get; }
    public bool IsLiftedOperator { get; }
    public OperatorResolveResult(IType resultType, ExpressionType operatorType, ResolveResult[] operands);
    public OperatorResolveResult(IType resultType, ExpressionType operatorType, IMethod userDefinedOperatorMethod, bool isLiftedOperator, IList`1<ResolveResult> operands);
    public ExpressionType get_OperatorType();
    public IList`1<ResolveResult> get_Operands();
    public IMethod get_UserDefinedOperatorMethod();
    public bool get_IsLiftedOperator();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
}
internal class ICSharpCode.Decompiler.Semantics.OutVarResolveResult : ResolveResult {
    public IType OriginalVariableType;
    public OutVarResolveResult(IType originalVariableType);
}
public class ICSharpCode.Decompiler.Semantics.ResolveResult : object {
    private IType type;
    public IType Type { get; }
    public bool IsCompileTimeConstant { get; }
    public object ConstantValue { get; }
    public bool IsError { get; }
    public ResolveResult(IType type);
    public IType get_Type();
    public virtual bool get_IsCompileTimeConstant();
    public virtual object get_ConstantValue();
    public virtual bool get_IsError();
    public virtual string ToString();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
    public virtual ResolveResult ShallowClone();
}
public class ICSharpCode.Decompiler.Semantics.SizeOfResolveResult : ResolveResult {
    private IType referencedType;
    private Nullable`1<int> constantValue;
    public IType ReferencedType { get; }
    public bool IsCompileTimeConstant { get; }
    public object ConstantValue { get; }
    public bool IsError { get; }
    public SizeOfResolveResult(IType int32, IType referencedType, Nullable`1<int> constantValue);
    public IType get_ReferencedType();
    public virtual bool get_IsCompileTimeConstant();
    public virtual object get_ConstantValue();
    public virtual bool get_IsError();
}
public class ICSharpCode.Decompiler.Semantics.ThisResolveResult : ResolveResult {
    private bool causesNonVirtualInvocation;
    public bool CausesNonVirtualInvocation { get; }
    public ThisResolveResult(IType type, bool causesNonVirtualInvocation);
    public bool get_CausesNonVirtualInvocation();
}
internal class ICSharpCode.Decompiler.Semantics.ThrowResolveResult : ResolveResult {
}
public class ICSharpCode.Decompiler.Semantics.TupleResolveResult : ResolveResult {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ResolveResult> <Elements>k__BackingField;
    public ImmutableArray`1<ResolveResult> Elements { get; }
    public TupleResolveResult(ICompilation compilation, ImmutableArray`1<ResolveResult> elements, ImmutableArray`1<string> elementNames, IModule valueTupleAssembly);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ResolveResult> get_Elements();
    public virtual IEnumerable`1<ResolveResult> GetChildResults();
    private static IType GetTupleType(ICompilation compilation, ImmutableArray`1<ResolveResult> elements, ImmutableArray`1<string> elementNames, IModule valueTupleAssembly);
}
public class ICSharpCode.Decompiler.Semantics.TypeIsResolveResult : ResolveResult {
    public ResolveResult Input;
    public IType TargetType;
    public TypeIsResolveResult(ResolveResult input, IType targetType, IType booleanType);
}
public class ICSharpCode.Decompiler.Semantics.TypeOfResolveResult : ResolveResult {
    private IType referencedType;
    public IType ReferencedType { get; }
    public TypeOfResolveResult(IType systemType, IType referencedType);
    public IType get_ReferencedType();
}
public class ICSharpCode.Decompiler.Semantics.TypeResolveResult : ResolveResult {
    public bool IsError { get; }
    public TypeResolveResult(IType type);
    public virtual bool get_IsError();
}
public class ICSharpCode.Decompiler.Semantics.UnknownIdentifierResolveResult : ResolveResult {
    private string identifier;
    private int typeArgumentCount;
    public string Identifier { get; }
    public int TypeArgumentCount { get; }
    public bool IsError { get; }
    public UnknownIdentifierResolveResult(string identifier, int typeArgumentCount);
    public string get_Identifier();
    public int get_TypeArgumentCount();
    public virtual bool get_IsError();
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.Semantics.UnknownMemberResolveResult : ResolveResult {
    private IType targetType;
    private string memberName;
    private ReadOnlyCollection`1<IType> typeArguments;
    public IType TargetType { get; }
    public string MemberName { get; }
    public ReadOnlyCollection`1<IType> TypeArguments { get; }
    public bool IsError { get; }
    public UnknownMemberResolveResult(IType targetType, string memberName, IEnumerable`1<IType> typeArguments);
    public IType get_TargetType();
    public string get_MemberName();
    public ReadOnlyCollection`1<IType> get_TypeArguments();
    public virtual bool get_IsError();
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.Semantics.UnknownMethodResolveResult : UnknownMemberResolveResult {
    private ReadOnlyCollection`1<IParameter> parameters;
    public ReadOnlyCollection`1<IParameter> Parameters { get; }
    public UnknownMethodResolveResult(IType targetType, string methodName, IEnumerable`1<IType> typeArguments, IEnumerable`1<IParameter> parameters);
    public ReadOnlyCollection`1<IParameter> get_Parameters();
}
public static class ICSharpCode.Decompiler.SingleFileBundle : object {
    public static bool IsBundle(MemoryMappedViewAccessor view, Int64& bundleHeaderOffset);
    public static bool IsBundle(Byte* data, long size, Int64& bundleHeaderOffset);
    private static UnmanagedMemoryStream AsStream(MemoryMappedViewAccessor view);
    public static Header ReadManifest(MemoryMappedViewAccessor view, long bundleHeaderOffset);
    public static Header ReadManifest(Stream stream);
    private static Entry ReadEntry(BinaryReader reader, UInt32 bundleMajorVersion);
}
public class ICSharpCode.Decompiler.Solution.ProjectId : object {
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TypeGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public Guid Guid { get; }
    public Guid TypeGuid { get; }
    public string PlatformName { get; }
    public ProjectId(string projectPlatform, Guid projectGuid, Guid typeGuid);
    [CompilerGeneratedAttribute]
public Guid get_Guid();
    [CompilerGeneratedAttribute]
public Guid get_TypeGuid();
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
public class ICSharpCode.Decompiler.Solution.ProjectItem : ProjectId {
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string ProjectName { get; }
    public string FilePath { get; }
    public ProjectItem(string projectFile, string projectPlatform, Guid projectGuid, Guid typeGuid);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public string get_FilePath();
}
public static class ICSharpCode.Decompiler.Solution.ProjectTypeGuids : object {
    public static Guid SolutionFolder;
    public static Guid CSharpWindows;
    public static Guid CSharpCore;
    public static Guid Silverlight;
    public static Guid PortableLibrary;
    private static ProjectTypeGuids();
}
public static class ICSharpCode.Decompiler.Solution.SolutionCreator : object {
    private static XNamespace ProjectFileNamespace;
    private static SolutionCreator();
    public static void WriteSolutionFile(string targetFile, IEnumerable`1<ProjectItem> projects);
    private static void WriteSolutionFile(TextWriter writer, IEnumerable`1<ProjectItem> projects, string solutionFilePath);
    private static void WriteHeader(TextWriter writer);
    private static void WriteProjects(TextWriter writer, IEnumerable`1<ProjectItem> projects, string solutionFilePath);
    private static IEnumerable`1<string> WriteSolutionConfigurations(TextWriter writer, IEnumerable`1<ProjectItem> projects);
    private static void WriteProjectConfigurations(TextWriter writer, IEnumerable`1<ProjectItem> projects, IEnumerable`1<string> solutionPlatforms);
    private static void FixProjectReferences(IEnumerable`1<ProjectItem> projects);
    private static void FixProjectReferences(string projectFilePath, XElement itemGroup, IDictionary`2<string, ProjectItem> projects);
    private static string GetRelativePath(string fromFilePath, string toFilePath);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.SRMExtensions : object {
    [ExtensionAttribute]
public static bool HasFlag(TypeDefinition typeDefinition, TypeAttributes attribute);
    [ExtensionAttribute]
public static bool HasFlag(MethodDefinition methodDefinition, MethodAttributes attribute);
    [ExtensionAttribute]
public static bool HasFlag(FieldDefinition fieldDefinition, FieldAttributes attribute);
    [ExtensionAttribute]
public static bool HasFlag(PropertyDefinition propertyDefinition, PropertyAttributes attribute);
    [ExtensionAttribute]
public static bool HasFlag(EventDefinition eventDefinition, EventAttributes attribute);
    [ExtensionAttribute]
public static bool IsTypeKind(HandleKind kind);
    [ExtensionAttribute]
public static bool IsMemberKind(HandleKind kind);
    [ExtensionAttribute]
public static bool IsEntityHandle(Handle handle);
    [ExtensionAttribute]
public static bool IsValueType(TypeDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsValueType(TypeDefinition typeDefinition, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsEnum(TypeDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsEnum(TypeDefinition typeDefinition, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsEnum(TypeDefinitionHandle handle, MetadataReader reader, PrimitiveTypeCode& underlyingType);
    [ExtensionAttribute]
public static bool IsEnum(TypeDefinition typeDefinition, MetadataReader reader, PrimitiveTypeCode& underlyingType);
    [ExtensionAttribute]
public static bool IsDelegate(TypeDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsDelegate(TypeDefinition typeDefinition, MetadataReader reader);
    [ExtensionAttribute]
public static bool HasBody(MethodDefinition methodDefinition);
    [ExtensionAttribute]
public static int GetCodeSize(MethodBodyBlock body);
    [ExtensionAttribute]
public static MethodDefinitionHandle GetAny(PropertyAccessors accessors);
    [ExtensionAttribute]
public static MethodDefinitionHandle GetAny(EventAccessors accessors);
    [ExtensionAttribute]
public static EntityHandle GetGenericType(TypeSpecification& ts, MetadataReader metadata);
    [ExtensionAttribute]
public static EntityHandle GetDeclaringType(EntityHandle entity, MetadataReader metadata);
    [ExtensionAttribute]
public static TypeReferenceHandle GetDeclaringType(TypeReference& tr);
    [ExtensionAttribute]
public static FullTypeName GetFullTypeName(EntityHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsKnownType(EntityHandle handle, MetadataReader reader, KnownTypeCode knownType);
    [ExtensionAttribute]
internal static bool IsKnownType(EntityHandle handle, MetadataReader reader, KnownAttribute knownType);
    private static bool IsKnownType(EntityHandle handle, MetadataReader reader, TopLevelTypeName knownType);
    private static bool SignatureIsKnownType(MetadataReader reader, TopLevelTypeName knownType, BlobReader& blob);
    [ExtensionAttribute]
public static FullTypeName GetFullTypeName(TypeSpecificationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static FullTypeName GetFullTypeName(TypeReferenceHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static FullTypeName GetFullTypeName(TypeDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static FullTypeName GetFullTypeName(TypeDefinition td, MetadataReader reader);
    [ExtensionAttribute]
public static FullTypeName GetFullTypeName(ExportedType type, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsAnonymousType(TypeDefinition type, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsGeneratedName(StringHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool HasGeneratedName(MethodDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool HasGeneratedName(TypeDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool HasGeneratedName(TypeDefinition type, MetadataReader metadata);
    [ExtensionAttribute]
public static bool HasGeneratedName(FieldDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(MethodDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGeneratedOrIsInCompilerGeneratedClass(MethodDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGeneratedOrIsInCompilerGeneratedClass(TypeDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(MethodDefinition method, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(FieldDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(FieldDefinition field, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(TypeDefinitionHandle handle, MetadataReader metadata);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(TypeDefinition type, MetadataReader metadata);
    [ExtensionAttribute]
public static EntityHandle GetAttributeType(CustomAttribute attribute, MetadataReader reader);
    [ExtensionAttribute]
public static bool HasKnownAttribute(CustomAttributeHandleCollection customAttributes, MetadataReader metadata, KnownAttribute type);
    [ExtensionAttribute]
internal static bool IsKnownAttribute(CustomAttribute attr, MetadataReader metadata, KnownAttribute attrType);
    [ExtensionAttribute]
public static Nullable`1<Nullability> GetNullableContext(CustomAttributeHandleCollection customAttributes, MetadataReader metadata);
    [ExtensionAttribute]
public static BlobReader GetInitialValue(FieldDefinition field, PEReader pefile, ICompilation typeSystem);
    [ExtensionAttribute]
public static EntityHandle GetBaseTypeOrNil(TypeDefinition definition);
    [ExtensionAttribute]
public static string ToILSyntax(SignatureCallingConvention callConv);
    [ExtensionAttribute]
public static ImmutableArray`1<MethodImplementationHandle> GetMethodImplementations(MethodDefinitionHandle handle, MetadataReader reader);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.TextOutputExtensions : object {
    [ExtensionAttribute]
public static void Write(ITextOutput output, string format, Object[] args);
    [ExtensionAttribute]
public static void WriteLine(ITextOutput output, string text);
    [ExtensionAttribute]
public static void WriteLine(ITextOutput output, string format, Object[] args);
}
internal class ICSharpCode.Decompiler.TextOutputWithRollback : object {
    private List`1<Action`1<ITextOutput>> actions;
    private ITextOutput target;
    private string ICSharpCode.Decompiler.ITextOutput.IndentationString { get; private set; }
    public TextOutputWithRollback(ITextOutput target);
    private sealed virtual override string ICSharpCode.Decompiler.ITextOutput.get_IndentationString();
    private sealed virtual override void ICSharpCode.Decompiler.ITextOutput.set_IndentationString(string value);
    public void Commit();
    public sealed virtual void Indent();
    public sealed virtual void MarkFoldEnd();
    public sealed virtual void MarkFoldStart(string collapsedText, bool defaultCollapsed, bool isDefinition);
    public sealed virtual void Unindent();
    public sealed virtual void Write(char ch);
    public sealed virtual void Write(string text);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLocalReference(string text, object reference, bool isDefinition);
    public sealed virtual void WriteReference(OpCodeInfo opCode, bool omitSuffix);
    public sealed virtual void WriteReference(PEFile module, Handle handle, string text, string protocol, bool isDefinition);
    public sealed virtual void WriteReference(IType type, string text, bool isDefinition);
    public sealed virtual void WriteReference(IMember member, string text, bool isDefinition);
}
public class ICSharpCode.Decompiler.TextOutputWriter : TextWriter {
    private ITextOutput output;
    public Encoding Encoding { get; }
    public TextOutputWriter(ITextOutput output);
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void Write(string value);
    public virtual void WriteLine();
}
public class ICSharpCode.Decompiler.TextTokenWriter : TokenWriter {
    private ITextOutput output;
    private DecompilerSettings settings;
    private IDecompilerTypeSystem typeSystem;
    private Stack`1<AstNode> nodeStack;
    private int braceLevelWithinType;
    private bool inDocumentationComment;
    private bool firstUsingDeclaration;
    private bool lastUsingDeclaration;
    public TextTokenWriter(ITextOutput output, DecompilerSettings settings, IDecompilerTypeSystem typeSystem);
    public virtual void WriteIdentifier(Identifier identifier);
    private ISymbol GetCurrentMemberReference();
    private ISymbol FilterMember(ISymbol symbol);
    private object GetCurrentLocalReference();
    private object GetCurrentLocalDefinition(Identifier id);
    private ISymbol GetCurrentDefinition();
    public virtual void WriteKeyword(Role role, string keyword);
    public virtual void WriteToken(Role role, string token);
    public virtual void Space();
    public virtual void Indent();
    public virtual void Unindent();
    public virtual void NewLine();
    public virtual void WriteComment(CommentType commentType, string content);
    public virtual void WritePreProcessorDirective(PreProcessorDirectiveType type, string argument);
    public virtual void WritePrimitiveValue(object value, LiteralFormat format);
    public virtual void WriteInterpolatedText(string text);
    public virtual void WritePrimitiveType(string type);
    public virtual void StartNode(AstNode node);
    private bool IsUsingDeclaration(AstNode node);
    public virtual void EndNode(AstNode node);
    public static bool IsDefinition(AstNode& node);
}
public enum ICSharpCode.Decompiler.TypeSystem.Accessibility : Enum {
    public byte value__;
    public static Accessibility None;
    public static Accessibility Private;
    public static Accessibility ProtectedAndInternal;
    public static Accessibility Protected;
    public static Accessibility Internal;
    public static Accessibility ProtectedOrInternal;
    public static Accessibility Public;
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.TypeSystem.AccessibilityExtensions : object {
    [ExtensionAttribute]
public static bool LessThanOrEqual(Accessibility a, Accessibility b);
    [ExtensionAttribute]
public static Accessibility Intersect(Accessibility a, Accessibility b);
    [ExtensionAttribute]
public static Accessibility Union(Accessibility a, Accessibility b);
    [ExtensionAttribute]
public static Accessibility EffectiveAccessibility(IEntity entity);
}
internal class ICSharpCode.Decompiler.TypeSystem.ApplyAttributeTypeVisitor : TypeVisitor {
    private ICompilation compilation;
    private bool hasDynamicAttribute;
    private Boolean[] dynamicAttributeData;
    private bool hasNativeIntegersAttribute;
    private Boolean[] nativeIntegersAttributeData;
    private TypeSystemOptions options;
    private String[] tupleElementNames;
    private Nullability defaultNullability;
    private Nullability[] nullableAttributeData;
    private int dynamicTypeIndex;
    private int tupleTypeIndex;
    private int nullabilityTypeIndex;
    private int nativeIntTypeIndex;
    private ApplyAttributeTypeVisitor(ICompilation compilation, bool hasDynamicAttribute, Boolean[] dynamicAttributeData, bool hasNativeIntegersAttribute, Boolean[] nativeIntegersAttributeData, TypeSystemOptions options, String[] tupleElementNames, Nullability defaultNullability, Nullability[] nullableAttributeData);
    public static IType ApplyAttributesToType(IType inputType, ICompilation compilation, Nullable`1<CustomAttributeHandleCollection> attributes, MetadataReader metadata, TypeSystemOptions options, Nullability nullableContext, bool typeChildrenOnly);
    public virtual IType VisitModOpt(ModifiedType type);
    public virtual IType VisitModReq(ModifiedType type);
    public virtual IType VisitPointerType(PointerType type);
    private Nullability GetNullability();
    private void ExpectDummyNullabilityForGenericValueType();
    public virtual IType VisitArrayType(ArrayType type);
    public virtual IType VisitByReferenceType(ByReferenceType type);
    public virtual IType VisitParameterizedType(ParameterizedType type);
    public virtual IType VisitFunctionPointerType(FunctionPointerType type);
    public virtual IType VisitTypeDefinition(ITypeDefinition type);
    public virtual IType VisitOtherType(IType type);
    public virtual IType VisitTypeParameter(ITypeParameter type);
}
public class ICSharpCode.Decompiler.TypeSystem.ArrayType : TypeWithElementType {
    private int dimensions;
    private ICompilation compilation;
    private Nullability nullability;
    public TypeKind Kind { get; }
    public ICompilation Compilation { get; }
    public int Dimensions { get; }
    public Nullability Nullability { get; }
    public string NameSuffix { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    public ArrayType(ICompilation compilation, IType elementType, int dimensions, Nullability nullability);
    public virtual TypeKind get_Kind();
    public sealed virtual ICompilation get_Compilation();
    public int get_Dimensions();
    public virtual Nullability get_Nullability();
    public virtual IType ChangeNullability(Nullability nullability);
    public virtual string get_NameSuffix();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual string ToString();
    public virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual IType VisitChildren(TypeVisitor visitor);
}
public class ICSharpCode.Decompiler.TypeSystem.ArrayTypeReference : object {
    private ITypeReference elementType;
    private int dimensions;
    public ITypeReference ElementType { get; }
    public int Dimensions { get; }
    public ArrayTypeReference(ITypeReference elementType, int dimensions);
    public ITypeReference get_ElementType();
    public int get_Dimensions();
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public class ICSharpCode.Decompiler.TypeSystem.AssemblyQualifiedTypeName : ValueType {
    public string AssemblyName;
    public FullTypeName TypeName;
    public AssemblyQualifiedTypeName(FullTypeName typeName, string assemblyName);
    public AssemblyQualifiedTypeName(ITypeDefinition typeDefinition);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyQualifiedTypeName other);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyQualifiedTypeName lhs, AssemblyQualifiedTypeName rhs);
    public static bool op_Inequality(AssemblyQualifiedTypeName lhs, AssemblyQualifiedTypeName rhs);
}
public class ICSharpCode.Decompiler.TypeSystem.ByReferenceType : TypeWithElementType {
    public TypeKind Kind { get; }
    public string NameSuffix { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public bool IsByRefLike { get; }
    public ByReferenceType(IType elementType);
    public virtual TypeKind get_Kind();
    public virtual string get_NameSuffix();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual bool get_IsByRefLike();
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual IType VisitChildren(TypeVisitor visitor);
}
public class ICSharpCode.Decompiler.TypeSystem.ByReferenceTypeReference : object {
    private ITypeReference elementType;
    public ITypeReference ElementType { get; }
    public ByReferenceTypeReference(ITypeReference elementType);
    public ITypeReference get_ElementType();
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public static class ICSharpCode.Decompiler.TypeSystem.ComHelper : object {
    public static bool IsComImport(ITypeDefinition typeDefinition);
    public static IType GetCoClass(ITypeDefinition typeDefinition);
}
public class ICSharpCode.Decompiler.TypeSystem.DecompilerTypeSystem : SimpleCompilation {
    private MetadataModule mainModule;
    private static String[] implicitReferences;
    public MetadataModule MainModule { get; }
    public DecompilerTypeSystem(PEFile mainModule, IAssemblyResolver assemblyResolver);
    public DecompilerTypeSystem(PEFile mainModule, IAssemblyResolver assemblyResolver, DecompilerSettings settings);
    public DecompilerTypeSystem(PEFile mainModule, IAssemblyResolver assemblyResolver, TypeSystemOptions typeSystemOptions);
    private static DecompilerTypeSystem();
    public static TypeSystemOptions GetOptions(DecompilerSettings settings);
    public static Task`1<DecompilerTypeSystem> CreateAsync(PEFile mainModule, IAssemblyResolver assemblyResolver);
    public static Task`1<DecompilerTypeSystem> CreateAsync(PEFile mainModule, IAssemblyResolver assemblyResolver, DecompilerSettings settings);
    [AsyncStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.DecompilerTypeSystem/<CreateAsync>d__3")]
public static Task`1<DecompilerTypeSystem> CreateAsync(PEFile mainModule, IAssemblyResolver assemblyResolver, TypeSystemOptions typeSystemOptions);
    [AsyncStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.DecompilerTypeSystem/<InitializeAsync>d__10")]
private Task InitializeAsync(PEFile mainModule, IAssemblyResolver assemblyResolver, TypeSystemOptions typeSystemOptions);
    public sealed virtual MetadataModule get_MainModule();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IModule <>n__0();
}
[IsReadOnlyAttribute]
public class ICSharpCode.Decompiler.TypeSystem.FullTypeName : ValueType {
    private TopLevelTypeName topLevelType;
    private NestedTypeName[] nestedTypes;
    public TopLevelTypeName TopLevelTypeName { get; }
    public bool IsNested { get; }
    public int NestingLevel { get; }
    public string Name { get; }
    public string ReflectionName { get; }
    public int TypeParameterCount { get; }
    private FullTypeName(TopLevelTypeName topLevelTypeName, NestedTypeName[] nestedTypes);
    public FullTypeName(TopLevelTypeName topLevelTypeName);
    public FullTypeName(string reflectionName);
    public TopLevelTypeName get_TopLevelTypeName();
    public bool get_IsNested();
    public int get_NestingLevel();
    public string get_Name();
    public string get_ReflectionName();
    public int get_TypeParameterCount();
    public string GetNestedTypeName(int nestingLevel);
    public int GetNestedTypeAdditionalTypeParameterCount(int nestingLevel);
    public FullTypeName GetDeclaringType();
    public FullTypeName NestedType(string name, int additionalTypeParameterCount);
    public static FullTypeName op_Implicit(TopLevelTypeName topLevelTypeName);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FullTypeName other);
    public virtual int GetHashCode();
    public static bool op_Equality(FullTypeName left, FullTypeName right);
    public static bool op_Inequality(FullTypeName left, FullTypeName right);
}
public class ICSharpCode.Decompiler.TypeSystem.FullTypeNameComparer : object {
    public static FullTypeNameComparer Ordinal;
    public static FullTypeNameComparer OrdinalIgnoreCase;
    public StringComparer NameComparer;
    public FullTypeNameComparer(StringComparer nameComparer);
    private static FullTypeNameComparer();
    public sealed virtual bool Equals(FullTypeName x, FullTypeName y);
    public sealed virtual int GetHashCode(FullTypeName obj);
}
public class ICSharpCode.Decompiler.TypeSystem.FunctionPointerType : AbstractType {
    private MetadataModule module;
    public SignatureCallingConvention CallingConvention;
    public ImmutableArray`1<IType> CustomCallingConventions;
    public IType ReturnType;
    public bool ReturnIsRefReadOnly;
    public ImmutableArray`1<IType> ParameterTypes;
    public ImmutableArray`1<ReferenceKind> ParameterReferenceKinds;
    public string Name { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public TypeKind Kind { get; }
    public FunctionPointerType(MetadataModule module, SignatureCallingConvention callingConvention, ImmutableArray`1<IType> customCallingConventions, IType returnType, bool returnIsRefReadOnly, ImmutableArray`1<IType> parameterTypes, ImmutableArray`1<ReferenceKind> parameterReferenceKinds);
    public static FunctionPointerType FromSignature(MethodSignature`1<IType> signature, MetadataModule module);
    public virtual string get_Name();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual TypeKind get_Kind();
    public virtual ITypeDefinition GetDefinition();
    public virtual ITypeDefinitionOrUnknown GetDefinitionOrUnknown();
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual IType VisitChildren(TypeVisitor visitor);
    public virtual bool Equals(IType other);
    public virtual int GetHashCode();
    internal IType WithSignature(IType returnType, ImmutableArray`1<IType> parameterTypes);
}
[IsReadOnlyAttribute]
public class ICSharpCode.Decompiler.TypeSystem.GenericContext : ValueType {
    public IReadOnlyList`1<ITypeParameter> ClassTypeParameters;
    public IReadOnlyList`1<ITypeParameter> MethodTypeParameters;
    public GenericContext(IReadOnlyList`1<ITypeParameter> classTypeParameters);
    public GenericContext(IReadOnlyList`1<ITypeParameter> classTypeParameters, IReadOnlyList`1<ITypeParameter> methodTypeParameters);
    internal GenericContext(ITypeResolveContext context);
    internal GenericContext(IEntity context);
    public ITypeParameter GetClassTypeParameter(int index);
    public ITypeParameter GetMethodTypeParameter(int index);
    internal TypeParameterSubstitution ToSubstitution();
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.TypeSystem.GetMemberOptions : Enum {
    public int value__;
    public static GetMemberOptions None;
    public static GetMemberOptions ReturnMemberDefinitions;
    public static GetMemberOptions IgnoreInheritedMembers;
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IAttribute {
    public IType AttributeType { get; }
    [NullableAttribute("2")]
public IMethod Constructor { get; }
    public bool HasDecodeErrors { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> FixedArguments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> NamedArguments { get; }
    public abstract virtual IType get_AttributeType();
    [NullableContextAttribute("2")]
public abstract virtual IMethod get_Constructor();
    public abstract virtual bool get_HasDecodeErrors();
    public abstract virtual ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> get_FixedArguments();
    public abstract virtual ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> get_NamedArguments();
}
public interface ICSharpCode.Decompiler.TypeSystem.ICodeContext {
    [NullableAttribute("1")]
public IEnumerable`1<IVariable> LocalVariables { get; }
    public bool IsWithinLambdaExpression { get; }
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<IVariable> get_LocalVariables();
    public abstract virtual bool get_IsWithinLambdaExpression();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.ICompilation {
    public IModule MainModule { get; }
    public IReadOnlyList`1<IModule> Modules { get; }
    public IReadOnlyList`1<IModule> ReferencedModules { get; }
    public INamespace RootNamespace { get; }
    public StringComparer NameComparer { get; }
    public CacheManager CacheManager { get; }
    public abstract virtual IModule get_MainModule();
    public abstract virtual IReadOnlyList`1<IModule> get_Modules();
    public abstract virtual IReadOnlyList`1<IModule> get_ReferencedModules();
    public abstract virtual INamespace get_RootNamespace();
    [NullableContextAttribute("2")]
public abstract virtual INamespace GetNamespaceForExternAlias(string alias);
    public abstract virtual IType FindType(KnownTypeCode typeCode);
    public abstract virtual StringComparer get_NameComparer();
    public abstract virtual CacheManager get_CacheManager();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.ICompilationProvider {
    public ICompilation Compilation { get; }
    public abstract virtual ICompilation get_Compilation();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IDecompilerTypeSystem {
    public MetadataModule MainModule { get; }
    public abstract virtual MetadataModule get_MainModule();
}
[NullableContextAttribute("2")]
public interface ICSharpCode.Decompiler.TypeSystem.IEntity {
    public EntityHandle MetadataToken { get; }
    [NullableAttribute("1")]
public string Name { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; }
    public IModule ParentModule { get; }
    public Accessibility Accessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public abstract virtual EntityHandle get_MetadataToken();
    [NullableContextAttribute("1")]
public abstract virtual string get_Name();
    public abstract virtual ITypeDefinition get_DeclaringTypeDefinition();
    public abstract virtual IType get_DeclaringType();
    public abstract virtual IModule get_ParentModule();
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<IAttribute> GetAttributes();
    public abstract virtual bool HasAttribute(KnownAttribute attribute);
    public abstract virtual IAttribute GetAttribute(KnownAttribute attribute);
    public abstract virtual Accessibility get_Accessibility();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
}
[NullableContextAttribute("2")]
public interface ICSharpCode.Decompiler.TypeSystem.IEvent {
    [MemberNotNullWhenAttribute("True", "AddAccessor")]
public bool CanAdd { get; }
    [MemberNotNullWhenAttribute("True", "RemoveAccessor")]
public bool CanRemove { get; }
    [MemberNotNullWhenAttribute("True", "InvokeAccessor")]
public bool CanInvoke { get; }
    public IMethod AddAccessor { get; }
    public IMethod RemoveAccessor { get; }
    public IMethod InvokeAccessor { get; }
    [MemberNotNullWhenAttribute("True", "AddAccessor")]
public abstract virtual bool get_CanAdd();
    [MemberNotNullWhenAttribute("True", "RemoveAccessor")]
public abstract virtual bool get_CanRemove();
    [MemberNotNullWhenAttribute("True", "InvokeAccessor")]
public abstract virtual bool get_CanInvoke();
    public abstract virtual IMethod get_AddAccessor();
    public abstract virtual IMethod get_RemoveAccessor();
    public abstract virtual IMethod get_InvokeAccessor();
}
public interface ICSharpCode.Decompiler.TypeSystem.IField {
    [NullableAttribute("1")]
public string Name { get; }
    public bool IsReadOnly { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    public bool IsVolatile { get; }
    [NullableContextAttribute("1")]
public abstract virtual string get_Name();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_ReturnTypeIsRefReadOnly();
    public abstract virtual bool get_IsVolatile();
}
public interface ICSharpCode.Decompiler.TypeSystem.IFreezable {
    public bool IsFrozen { get; }
    public abstract virtual bool get_IsFrozen();
    public abstract virtual void Freeze();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IMember {
    public IMember MemberDefinition { get; }
    public IType ReturnType { get; }
    public IType DeclaringType { get; }
    public IEnumerable`1<IMember> ExplicitlyImplementedInterfaceMembers { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsOverridable { get; }
    public TypeParameterSubstitution Substitution { get; }
    public abstract virtual IMember get_MemberDefinition();
    public abstract virtual IType get_ReturnType();
    public abstract virtual IType get_DeclaringType();
    public abstract virtual IEnumerable`1<IMember> get_ExplicitlyImplementedInterfaceMembers();
    public abstract virtual bool get_IsExplicitInterfaceImplementation();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsOverride();
    public abstract virtual bool get_IsOverridable();
    public abstract virtual TypeParameterSubstitution get_Substitution();
    public abstract virtual IMember Specialize(TypeParameterSubstitution substitution);
    public abstract virtual bool Equals(IMember obj, TypeVisitor typeNormalization);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IMemberReference {
    public ITypeReference DeclaringTypeReference { get; }
    public abstract virtual ITypeReference get_DeclaringTypeReference();
    public abstract virtual IMember Resolve(ITypeResolveContext context);
}
public interface ICSharpCode.Decompiler.TypeSystem.IMethod {
    public bool ReturnTypeIsRefReadOnly { get; }
    public bool IsInitOnly { get; }
    public bool ThisIsRefReadOnly { get; }
    [NullableAttribute("1")]
public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    [NullableAttribute("1")]
public IReadOnlyList`1<IType> TypeArguments { get; }
    public bool IsExtensionMethod { get; }
    public bool IsLocalFunction { get; }
    public bool IsConstructor { get; }
    public bool IsDestructor { get; }
    public bool IsOperator { get; }
    public bool HasBody { get; }
    [MemberNotNullWhenAttribute("True", "AccessorOwner")]
public bool IsAccessor { get; }
    [NullableAttribute("2")]
public IMember AccessorOwner { get; }
    public MethodSemanticsAttributes AccessorKind { get; }
    [NullableAttribute("2")]
public IMethod ReducedFrom { get; }
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<IAttribute> GetReturnTypeAttributes();
    public abstract virtual bool get_ReturnTypeIsRefReadOnly();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_ThisIsRefReadOnly();
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyList`1<IType> get_TypeArguments();
    public abstract virtual bool get_IsExtensionMethod();
    public abstract virtual bool get_IsLocalFunction();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsDestructor();
    public abstract virtual bool get_IsOperator();
    public abstract virtual bool get_HasBody();
    [MemberNotNullWhenAttribute("True", "AccessorOwner")]
public abstract virtual bool get_IsAccessor();
    [NullableContextAttribute("2")]
public abstract virtual IMember get_AccessorOwner();
    public abstract virtual MethodSemanticsAttributes get_AccessorKind();
    [NullableContextAttribute("2")]
public abstract virtual IMethod get_ReducedFrom();
    [NullableContextAttribute("1")]
public abstract virtual IMethod Specialize(TypeParameterSubstitution substitution);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IModule {
    [NullableAttribute("2")]
public PEFile PEFile { get; }
    public bool IsMainModule { get; }
    public string AssemblyName { get; }
    public Version AssemblyVersion { get; }
    public string FullAssemblyName { get; }
    public INamespace RootNamespace { get; }
    public IEnumerable`1<ITypeDefinition> TopLevelTypeDefinitions { get; }
    public IEnumerable`1<ITypeDefinition> TypeDefinitions { get; }
    [NullableContextAttribute("2")]
public abstract virtual PEFile get_PEFile();
    public abstract virtual bool get_IsMainModule();
    public abstract virtual string get_AssemblyName();
    public abstract virtual Version get_AssemblyVersion();
    public abstract virtual string get_FullAssemblyName();
    public abstract virtual IEnumerable`1<IAttribute> GetAssemblyAttributes();
    public abstract virtual IEnumerable`1<IAttribute> GetModuleAttributes();
    public abstract virtual bool InternalsVisibleTo(IModule module);
    public abstract virtual INamespace get_RootNamespace();
    [NullableContextAttribute("2")]
public abstract virtual ITypeDefinition GetTypeDefinition(TopLevelTypeName topLevelTypeName);
    public abstract virtual IEnumerable`1<ITypeDefinition> get_TopLevelTypeDefinitions();
    public abstract virtual IEnumerable`1<ITypeDefinition> get_TypeDefinitions();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IModuleReference {
    public abstract virtual IModule Resolve(ITypeResolveContext context);
}
public abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.AbstractFreezable : object {
    private bool isFrozen;
    public bool IsFrozen { get; }
    public sealed virtual bool get_IsFrozen();
    public sealed virtual void Freeze();
    protected virtual void FreezeInternal();
}
public abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.AbstractType : object {
    public string FullName { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string ReflectionName { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public bool IsByRefLike { get; }
    public Nullability Nullability { get; }
    public TypeKind Kind { get; }
    public int TypeParameterCount { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public IType DeclaringType { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    public virtual string get_FullName();
    public abstract virtual string get_Name();
    public virtual string get_Namespace();
    public virtual string get_ReflectionName();
    public abstract virtual Nullable`1<bool> get_IsReferenceType();
    public virtual bool get_IsByRefLike();
    public virtual Nullability get_Nullability();
    public virtual IType ChangeNullability(Nullability nullability);
    public abstract virtual TypeKind get_Kind();
    public virtual int get_TypeParameterCount();
    public virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public virtual IReadOnlyList`1<IType> get_TypeArguments();
    public virtual IType get_DeclaringType();
    public virtual ITypeDefinition GetDefinition();
    public virtual ITypeDefinitionOrUnknown GetDefinitionOrUnknown();
    public virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public virtual IEnumerable`1<IType> GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IType> GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMember> GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual TypeParameterSubstitution GetSubstitution();
    public TypeParameterSubstitution GetSubstitution(IReadOnlyList`1<IType> methodTypeArguments);
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual string ToString();
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual IType VisitChildren(TypeVisitor visitor);
}
public abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.AbstractTypeParameter : object {
    private ICompilation compilation;
    private SymbolKind ownerType;
    private IEntity owner;
    private int index;
    private string name;
    private VarianceModifier variance;
    private IType modreq(System.Runtime.CompilerServices.IsVolatile) effectiveBaseClass;
    private IReadOnlyCollection`1<IType> effectiveInterfaceSet;
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    public SymbolKind OwnerType { get; }
    public IEntity Owner { get; }
    public int Index { get; }
    public VarianceModifier Variance { get; }
    public ICompilation Compilation { get; }
    public IType EffectiveBaseClass { get; }
    public IReadOnlyCollection`1<IType> EffectiveInterfaceSet { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasUnmanagedConstraint { get; }
    public Nullability NullabilityConstraint { get; }
    public TypeKind Kind { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IType.IsByRefLike { get; }
    private Nullability ICSharpCode.Decompiler.TypeSystem.IType.Nullability { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.IType.DeclaringType { get; }
    private int ICSharpCode.Decompiler.TypeSystem.IType.TypeParameterCount { get; }
    private IReadOnlyList`1<ITypeParameter> ICSharpCode.Decompiler.TypeSystem.IType.TypeParameters { get; }
    private IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.TypeArguments { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    public IReadOnlyList`1<TypeConstraint> TypeConstraints { get; }
    public string Name { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.Namespace { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.FullName { get; }
    public string ReflectionName { get; }
    protected AbstractTypeParameter(IEntity owner, int index, string name, VarianceModifier variance);
    protected AbstractTypeParameter(ICompilation compilation, SymbolKind ownerType, int index, string name, VarianceModifier variance);
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    public sealed virtual SymbolKind get_OwnerType();
    public sealed virtual IEntity get_Owner();
    public sealed virtual int get_Index();
    public abstract virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual VarianceModifier get_Variance();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual IType get_EffectiveBaseClass();
    private IType CalculateEffectiveBaseClass();
    public sealed virtual IReadOnlyCollection`1<IType> get_EffectiveInterfaceSet();
    private IReadOnlyCollection`1<IType> CalculateEffectiveInterfaceSet();
    public abstract virtual bool get_HasDefaultConstructorConstraint();
    public abstract virtual bool get_HasReferenceTypeConstraint();
    public abstract virtual bool get_HasValueTypeConstraint();
    public abstract virtual bool get_HasUnmanagedConstraint();
    public abstract virtual Nullability get_NullabilityConstraint();
    public sealed virtual TypeKind get_Kind();
    public sealed virtual Nullable`1<bool> get_IsReferenceType();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IType.get_IsByRefLike();
    private sealed virtual override Nullability ICSharpCode.Decompiler.TypeSystem.IType.get_Nullability();
    public sealed virtual IType ChangeNullability(Nullability nullability);
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IType.get_DeclaringType();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.IType.get_TypeParameterCount();
    private sealed virtual override IReadOnlyList`1<ITypeParameter> ICSharpCode.Decompiler.TypeSystem.IType.get_TypeParameters();
    private sealed virtual override IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.get_TypeArguments();
    public sealed virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public abstract virtual IReadOnlyList`1<TypeConstraint> get_TypeConstraints();
    public sealed virtual string get_Name();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_Namespace();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_FullName();
    public sealed virtual string get_ReflectionName();
    private sealed virtual override ITypeDefinition ICSharpCode.Decompiler.TypeSystem.IType.GetDefinition();
    private sealed virtual override ITypeDefinitionOrUnknown ICSharpCode.Decompiler.TypeSystem.IType.GetDefinitionOrUnknown();
    public sealed virtual IType AcceptVisitor(TypeVisitor visitor);
    public sealed virtual IType VisitChildren(TypeVisitor visitor);
    private sealed virtual override IEnumerable`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMember> GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IType.GetSubstitution();
    private static Predicate`1<T> FilterNonStatic(Predicate`1<T> filter);
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual string ToString();
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.AttributeBuilder : ValueType {
    private ICompilation compilation;
    private IType attributeType;
    private Builder<CustomAttributeTypedArgument`1<IType>> fixedArgs;
    private Builder<CustomAttributeNamedArgument`1<IType>> namedArgs;
    public AttributeBuilder(MetadataModule module, KnownAttribute attributeType);
    public AttributeBuilder(MetadataModule module, IType attributeType);
    public void AddFixedArg(CustomAttributeTypedArgument`1<IType> arg);
    public void AddFixedArg(KnownTypeCode type, object value);
    public void AddFixedArg(TopLevelTypeName type, object value);
    public void AddFixedArg(IType type, object value);
    public void AddNamedArg(string name, KnownTypeCode type, object value);
    public void AddNamedArg(string name, TopLevelTypeName type, object value);
    public void AddNamedArg(string name, IType type, object value);
    public IAttribute Build();
}
[IsReadOnlyAttribute]
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.AttributeListBuilder : ValueType {
    private MetadataModule module;
    private List`1<IAttribute> attributes;
    private static string InteropServices;
    public AttributeListBuilder(MetadataModule module);
    public AttributeListBuilder(MetadataModule module, int capacity);
    public void Add(IAttribute attr);
    public void Add(KnownAttribute type);
    public void Add(KnownAttribute type, KnownTypeCode argType, object argValue);
    public void Add(KnownAttribute type, TopLevelTypeName argType, object argValue);
    public void Add(KnownAttribute type, ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> fixedArguments);
    internal void AddMarshalInfo(BlobHandle marshalInfo);
    private IAttribute ConvertMarshalInfo(BlobReader marshalInfo);
    public void Add(CustomAttributeHandleCollection attributes, SymbolKind target);
    private bool IgnoreAttribute(IType attributeType, SymbolKind target);
    internal bool IgnoreAttribute(TopLevelTypeName attributeType, SymbolKind target);
    internal bool HasAttribute(MetadataReader metadata, CustomAttributeHandleCollection customAttributes, KnownAttribute attribute, SymbolKind symbolKind);
    internal IAttribute GetAttribute(MetadataReader metadata, CustomAttributeHandleCollection customAttributes, KnownAttribute attribute, SymbolKind symbolKind);
    private static bool IsMethodLike(SymbolKind kind);
    public void AddSecurityAttributes(DeclarativeSecurityAttributeHandleCollection securityDeclarations);
    public void AddSecurityAttributes(DeclarativeSecurityAttribute secDecl);
    private IAttribute ReadXmlSecurityAttribute(BlobReader& reader, CustomAttributeTypedArgument`1<IType> securityAction);
    private IAttribute ReadBinarySecurityAttribute(BlobReader& reader, CustomAttributeTypedArgument`1<IType> securityAction);
    public IAttribute[] Build();
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.BaseTypeCollector : List`1<IType> {
    private Stack`1<IType> activeTypes;
    internal bool SkipImplementedInterfaces;
    public void CollectBaseTypes(IType type);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.CustomAttribute : object {
    private MetadataModule module;
    private CustomAttributeHandle handle;
    [CompilerGeneratedAttribute]
private IMethod <Constructor>k__BackingField;
    private CustomAttributeValue`1<IType> value;
    private bool valueDecoded;
    private bool hasDecodeErrors;
    public IMethod Constructor { get; }
    public IType AttributeType { get; }
    public ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> FixedArguments { get; }
    public ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> NamedArguments { get; }
    public bool HasDecodeErrors { get; }
    internal CustomAttribute(MetadataModule module, IMethod attrCtor, CustomAttributeHandle handle);
    [CompilerGeneratedAttribute]
public sealed virtual IMethod get_Constructor();
    public sealed virtual IType get_AttributeType();
    public sealed virtual ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> get_FixedArguments();
    public sealed virtual ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> get_NamedArguments();
    public sealed virtual bool get_HasDecodeErrors();
    private void DecodeValue();
    internal static IMember MemberForNamedArgument(IType attributeType, CustomAttributeNamedArgument`1<IType> namedArgument);
}
internal static class ICSharpCode.Decompiler.TypeSystem.Implementation.DecimalConstantHelper : object {
    public static bool AllowsDecimalConstants(MetadataModule module);
    public static bool IsDecimalConstant(MetadataModule module, CustomAttributeHandleCollection attributeHandles);
    public static object GetDecimalConstantValue(MetadataModule module, CustomAttributeHandleCollection attributeHandles);
    private static Nullable`1<decimal> TryDecodeDecimalConstantAttribute(MetadataModule module, CustomAttribute attribute);
}
public abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.DecoratedType : object {
    protected IType baseType;
    private TypeKind ICSharpCode.Decompiler.TypeSystem.IType.Kind { get; }
    private Nullable`1<bool> ICSharpCode.Decompiler.TypeSystem.IType.IsReferenceType { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IType.IsByRefLike { get; }
    private Nullability ICSharpCode.Decompiler.TypeSystem.IType.Nullability { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.IType.DeclaringType { get; }
    private int ICSharpCode.Decompiler.TypeSystem.IType.TypeParameterCount { get; }
    private IReadOnlyList`1<ITypeParameter> ICSharpCode.Decompiler.TypeSystem.IType.TypeParameters { get; }
    private IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.TypeArguments { get; }
    private IEnumerable`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.DirectBaseTypes { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.FullName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.Name { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.ReflectionName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.Namespace { get; }
    protected DecoratedType(IType baseType);
    private sealed virtual override TypeKind ICSharpCode.Decompiler.TypeSystem.IType.get_Kind();
    private sealed virtual override Nullable`1<bool> ICSharpCode.Decompiler.TypeSystem.IType.get_IsReferenceType();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IType.get_IsByRefLike();
    private sealed virtual override Nullability ICSharpCode.Decompiler.TypeSystem.IType.get_Nullability();
    public abstract virtual IType ChangeNullability(Nullability nullability);
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IType.get_DeclaringType();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.IType.get_TypeParameterCount();
    private sealed virtual override IReadOnlyList`1<ITypeParameter> ICSharpCode.Decompiler.TypeSystem.IType.get_TypeParameters();
    private sealed virtual override IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.get_TypeArguments();
    private sealed virtual override IEnumerable`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.get_DirectBaseTypes();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_FullName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_Name();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_ReflectionName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_Namespace();
    public abstract virtual IType AcceptVisitor(TypeVisitor visitor);
    public abstract virtual bool Equals(IType other);
    private sealed virtual override IEnumerable`1<IMethod> ICSharpCode.Decompiler.TypeSystem.IType.GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IMethod> ICSharpCode.Decompiler.TypeSystem.IType.GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    private sealed virtual override ITypeDefinition ICSharpCode.Decompiler.TypeSystem.IType.GetDefinition();
    private sealed virtual override ITypeDefinitionOrUnknown ICSharpCode.Decompiler.TypeSystem.IType.GetDefinitionOrUnknown();
    private sealed virtual override IEnumerable`1<IEvent> ICSharpCode.Decompiler.TypeSystem.IType.GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IField> ICSharpCode.Decompiler.TypeSystem.IType.GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IType.GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IMethod> ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IMethod> ICSharpCode.Decompiler.TypeSystem.IType.GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    private sealed virtual override IEnumerable`1<IProperty> ICSharpCode.Decompiler.TypeSystem.IType.GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IType.GetSubstitution();
    public abstract virtual IType VisitChildren(TypeVisitor visitor);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultAssemblyReference : object {
    public static IModuleReference CurrentAssembly;
    private string shortName;
    public DefaultAssemblyReference(string assemblyName);
    private static DefaultAssemblyReference();
    public sealed virtual IModule Resolve(ITypeResolveContext context);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultAttribute : object {
    private IType attributeType;
    private IMethod modreq(System.Runtime.CompilerServices.IsVolatile) constructor;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> <FixedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> <NamedArguments>k__BackingField;
    public ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> FixedArguments { get; }
    public ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> NamedArguments { get; }
    public IType AttributeType { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IAttribute.HasDecodeErrors { get; }
    public IMethod Constructor { get; }
    public DefaultAttribute(IType attributeType, ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> fixedArguments, ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> namedArguments);
    public DefaultAttribute(IMethod constructor, ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> fixedArguments, ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> namedArguments);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<CustomAttributeTypedArgument`1<IType>> get_FixedArguments();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<CustomAttributeNamedArgument`1<IType>> get_NamedArguments();
    public sealed virtual IType get_AttributeType();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IAttribute.get_HasDecodeErrors();
    public sealed virtual IMethod get_Constructor();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <get_Constructor>b__15_0(IMethod m);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultParameter : object {
    private IType type;
    private string name;
    private IReadOnlyList`1<IAttribute> attributes;
    private ReferenceKind referenceKind;
    private bool isParams;
    private bool isOptional;
    private object defaultValue;
    private IParameterizedMember owner;
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    public IParameterizedMember Owner { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsRef { get; }
    public bool IsOut { get; }
    public bool IsIn { get; }
    public bool IsParams { get; }
    public bool IsOptional { get; }
    public string Name { get; }
    public IType Type { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IVariable.IsConst { get; }
    public bool HasConstantValueInSignature { get; }
    public LifetimeAnnotation Lifetime { get; }
    public DefaultParameter(IType type, string name);
    public DefaultParameter(IType type, string name, IParameterizedMember owner, IReadOnlyList`1<IAttribute> attributes, ReferenceKind referenceKind, bool isParams, bool isOptional, object defaultValue);
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    public sealed virtual IParameterizedMember get_Owner();
    public sealed virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual bool get_IsRef();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsOptional();
    public sealed virtual string get_Name();
    public sealed virtual IType get_Type();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IVariable.get_IsConst();
    public sealed virtual bool get_HasConstantValueInSignature();
    public sealed virtual LifetimeAnnotation get_Lifetime();
    public sealed virtual object GetConstantValue(bool throwOnInvalidMetadata);
    public virtual string ToString();
    public static string ToString(IParameter parameter);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultTypeParameter : AbstractTypeParameter {
    private bool hasValueTypeConstraint;
    private bool hasReferenceTypeConstraint;
    private bool hasDefaultConstructorConstraint;
    private Nullability nullabilityConstraint;
    private IReadOnlyList`1<IAttribute> attributes;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TypeConstraint> <TypeConstraints>k__BackingField;
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool HasUnmanagedConstraint { get; }
    public Nullability NullabilityConstraint { get; }
    public IReadOnlyList`1<TypeConstraint> TypeConstraints { get; }
    public DefaultTypeParameter(IEntity owner, int index, string name, VarianceModifier variance, IReadOnlyList`1<IAttribute> attributes, bool hasValueTypeConstraint, bool hasReferenceTypeConstraint, bool hasDefaultConstructorConstraint, IReadOnlyList`1<IType> constraints, Nullability nullabilityConstraint);
    public DefaultTypeParameter(ICompilation compilation, SymbolKind ownerType, int index, string name, VarianceModifier variance, IReadOnlyList`1<IAttribute> attributes, bool hasValueTypeConstraint, bool hasReferenceTypeConstraint, bool hasDefaultConstructorConstraint, IReadOnlyList`1<IType> constraints, Nullability nullabilityConstraint);
    public virtual IEnumerable`1<IAttribute> GetAttributes();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasDefaultConstructorConstraint();
    public virtual bool get_HasUnmanagedConstraint();
    public virtual Nullability get_NullabilityConstraint();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<TypeConstraint> get_TypeConstraints();
    private IReadOnlyList`1<TypeConstraint> MakeConstraints(IReadOnlyList`1<IType> constraints);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.DefaultVariable : object {
    private string name;
    private IType type;
    private object constantValue;
    private bool isConst;
    public string Name { get; }
    public IType Type { get; }
    public bool IsConst { get; }
    public SymbolKind SymbolKind { get; }
    public DefaultVariable(IType type, string name);
    public DefaultVariable(IType type, string name, bool isConst, object constantValue);
    public sealed virtual string get_Name();
    public sealed virtual IType get_Type();
    public sealed virtual bool get_IsConst();
    public sealed virtual object GetConstantValue(bool throwOnInvalidMetadata);
    public sealed virtual SymbolKind get_SymbolKind();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.DummyTypeParameter : AbstractType {
    private static ITypeParameter[] methodTypeParameters;
    private static ITypeParameter[] classTypeParameters;
    private static IReadOnlyList`1[] classTypeParameterLists;
    private SymbolKind ownerType;
    private int index;
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    public string Name { get; }
    public string ReflectionName { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public TypeKind Kind { get; }
    public int Index { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ITypeParameter.OwnerType { get; }
    private VarianceModifier ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Variance { get; }
    private IEntity ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Owner { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.ITypeParameter.EffectiveBaseClass { get; }
    private IReadOnlyCollection`1<IType> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.EffectiveInterfaceSet { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasDefaultConstructorConstraint { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasReferenceTypeConstraint { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasValueTypeConstraint { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasUnmanagedConstraint { get; }
    private Nullability ICSharpCode.Decompiler.TypeSystem.ITypeParameter.NullabilityConstraint { get; }
    private IReadOnlyList`1<TypeConstraint> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.TypeConstraints { get; }
    private DummyTypeParameter(SymbolKind ownerType, int index);
    private static DummyTypeParameter();
    public static ITypeParameter GetMethodTypeParameter(int index);
    public static ITypeParameter GetClassTypeParameter(int index);
    private static ITypeParameter GetTypeParameter(ITypeParameter[]& typeParameters, SymbolKind symbolKind, int index);
    internal static IReadOnlyList`1<ITypeParameter> GetClassTypeParameterList(int length);
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    public virtual string get_Name();
    public virtual string get_ReflectionName();
    public virtual string ToString();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual TypeKind get_Kind();
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public sealed virtual int get_Index();
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.GetAttributes();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_OwnerType();
    private sealed virtual override VarianceModifier ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_Variance();
    private sealed virtual override IEntity ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_Owner();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_EffectiveBaseClass();
    private sealed virtual override IReadOnlyCollection`1<IType> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_EffectiveInterfaceSet();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasDefaultConstructorConstraint();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasReferenceTypeConstraint();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasValueTypeConstraint();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasUnmanagedConstraint();
    private sealed virtual override Nullability ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_NullabilityConstraint();
    private sealed virtual override IReadOnlyList`1<TypeConstraint> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_TypeConstraints();
    public virtual IType ChangeNullability(Nullability nullability);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.FakeEvent : FakeMember {
    [CompilerGeneratedAttribute]
private IMethod <AddAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethod <RemoveAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethod <InvokeAccessor>k__BackingField;
    public SymbolKind SymbolKind { get; }
    public bool CanAdd { get; }
    public bool CanRemove { get; }
    public bool CanInvoke { get; }
    public IMethod AddAccessor { get; public set; }
    public IMethod RemoveAccessor { get; public set; }
    public IMethod InvokeAccessor { get; public set; }
    public FakeEvent(ICompilation compilation);
    public virtual SymbolKind get_SymbolKind();
    public virtual IMember Specialize(TypeParameterSubstitution substitution);
    public sealed virtual bool get_CanAdd();
    public sealed virtual bool get_CanRemove();
    public sealed virtual bool get_CanInvoke();
    [CompilerGeneratedAttribute]
public sealed virtual IMethod get_AddAccessor();
    [CompilerGeneratedAttribute]
public void set_AddAccessor(IMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual IMethod get_RemoveAccessor();
    [CompilerGeneratedAttribute]
public void set_RemoveAccessor(IMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual IMethod get_InvokeAccessor();
    [CompilerGeneratedAttribute]
public void set_InvokeAccessor(IMethod value);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.FakeField : FakeMember {
    private bool ICSharpCode.Decompiler.TypeSystem.IField.IsReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IField.ReturnTypeIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IField.IsVolatile { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IVariable.IsConst { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.IVariable.Type { get; }
    public SymbolKind SymbolKind { get; }
    public FakeField(ICompilation compilation);
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IField.get_IsReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IField.get_ReturnTypeIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IField.get_IsVolatile();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IVariable.get_IsConst();
    private sealed virtual override object ICSharpCode.Decompiler.TypeSystem.IVariable.GetConstantValue(bool throwOnInvalidMetadata);
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IVariable.get_Type();
    public virtual SymbolKind get_SymbolKind();
    public virtual IMember Specialize(TypeParameterSubstitution substitution);
}
internal abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.FakeMember : object {
    private ICompilation compilation;
    [CompilerGeneratedAttribute]
private IType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Accessibility <Accessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    private IMember ICSharpCode.Decompiler.TypeSystem.IMember.MemberDefinition { get; }
    public IType ReturnType { get; public set; }
    private IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.ExplicitlyImplementedInterfaceMembers { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsExplicitInterfaceImplementation { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsVirtual { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsOverride { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsOverridable { get; }
    private TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.Substitution { get; }
    private EntityHandle ICSharpCode.Decompiler.TypeSystem.IEntity.MetadataToken { get; }
    public string Name { get; public set; }
    private ITypeDefinition ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; public set; }
    private IModule ICSharpCode.Decompiler.TypeSystem.IEntity.ParentModule { get; }
    public Accessibility Accessibility { get; public set; }
    public bool IsStatic { get; public set; }
    private bool ICSharpCode.Decompiler.TypeSystem.IEntity.IsAbstract { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IEntity.IsSealed { get; }
    public SymbolKind SymbolKind { get; }
    private ICompilation ICSharpCode.Decompiler.TypeSystem.ICompilationProvider.Compilation { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.FullName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.ReflectionName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.Namespace { get; }
    protected FakeMember(ICompilation compilation);
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.get_MemberDefinition();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ReturnType();
    [CompilerGeneratedAttribute]
public void set_ReturnType(IType value);
    private sealed virtual override IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.get_ExplicitlyImplementedInterfaceMembers();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsExplicitInterfaceImplementation();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsVirtual();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsOverride();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsOverridable();
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.get_Substitution();
    private sealed virtual override EntityHandle ICSharpCode.Decompiler.TypeSystem.IEntity.get_MetadataToken();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    private sealed virtual override ITypeDefinition ICSharpCode.Decompiler.TypeSystem.IEntity.get_DeclaringTypeDefinition();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(IType value);
    private sealed virtual override IModule ICSharpCode.Decompiler.TypeSystem.IEntity.get_ParentModule();
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.HasAttribute(KnownAttribute attribute);
    private sealed virtual override IAttribute ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttribute(KnownAttribute attribute);
    [CompilerGeneratedAttribute]
public sealed virtual Accessibility get_Accessibility();
    [CompilerGeneratedAttribute]
public void set_Accessibility(Accessibility value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStatic();
    [CompilerGeneratedAttribute]
public void set_IsStatic(bool value);
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.get_IsAbstract();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.get_IsSealed();
    public abstract virtual SymbolKind get_SymbolKind();
    private sealed virtual override ICompilation ICSharpCode.Decompiler.TypeSystem.ICompilationProvider.get_Compilation();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_FullName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_ReflectionName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_Namespace();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.Equals(IMember obj, TypeVisitor typeNormalization);
    public abstract virtual IMember Specialize(TypeParameterSubstitution substitution);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.FakeMethod : FakeMember {
    private SymbolKind symbolKind;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITypeParameter> <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IMember <AccessorOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSemanticsAttributes <AccessorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IParameter> <Parameters>k__BackingField;
    public SymbolKind SymbolKind { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ReturnTypeIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ThisIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsInitOnly { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; public set; }
    private IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IMethod.TypeArguments { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsExtensionMethod { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsLocalFunction { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsConstructor { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsDestructor { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsOperator { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.HasBody { get; }
    public bool IsAccessor { get; }
    public IMember AccessorOwner { get; public set; }
    public MethodSemanticsAttributes AccessorKind { get; public set; }
    private IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.ReducedFrom { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; public set; }
    public FakeMethod(ICompilation compilation, SymbolKind symbolKind);
    public virtual SymbolKind get_SymbolKind();
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IMethod.GetReturnTypeAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ReturnTypeIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ThisIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsInitOnly();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    [CompilerGeneratedAttribute]
public void set_TypeParameters(IReadOnlyList`1<ITypeParameter> value);
    private sealed virtual override IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IMethod.get_TypeArguments();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsExtensionMethod();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsLocalFunction();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsConstructor();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsDestructor();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsOperator();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_HasBody();
    public sealed virtual bool get_IsAccessor();
    [CompilerGeneratedAttribute]
public sealed virtual IMember get_AccessorOwner();
    [CompilerGeneratedAttribute]
public void set_AccessorOwner(IMember value);
    [CompilerGeneratedAttribute]
public sealed virtual MethodSemanticsAttributes get_AccessorKind();
    [CompilerGeneratedAttribute]
public void set_AccessorKind(MethodSemanticsAttributes value);
    private sealed virtual override IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.get_ReducedFrom();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IReadOnlyList`1<IParameter> value);
    public virtual IMember Specialize(TypeParameterSubstitution substitution);
    private sealed virtual override IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.Specialize(TypeParameterSubstitution substitution);
    internal static IMethod CreateDummyConstructor(ICompilation compilation, IType declaringType, Accessibility accessibility);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.FakeProperty : FakeMember {
    [CompilerGeneratedAttribute]
private IMethod <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethod <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IParameter> <Parameters>k__BackingField;
    public SymbolKind SymbolKind { get; }
    public bool CanGet { get; }
    public bool CanSet { get; }
    public IMethod Getter { get; public set; }
    public IMethod Setter { get; public set; }
    public bool IsIndexer { get; public set; }
    public bool ReturnTypeIsRefReadOnly { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; public set; }
    public FakeProperty(ICompilation compilation);
    public virtual SymbolKind get_SymbolKind();
    public virtual IMember Specialize(TypeParameterSubstitution substitution);
    public sealed virtual bool get_CanGet();
    public sealed virtual bool get_CanSet();
    [CompilerGeneratedAttribute]
public sealed virtual IMethod get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(IMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual IMethod get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(IMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIndexer();
    [CompilerGeneratedAttribute]
public void set_IsIndexer(bool value);
    public sealed virtual bool get_ReturnTypeIsRefReadOnly();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IReadOnlyList`1<IParameter> value);
    public virtual string ToString();
}
public static class ICSharpCode.Decompiler.TypeSystem.Implementation.FreezableHelper : object {
    public static void ThrowIfFrozen(IFreezable freezable);
    public static IList`1<T> FreezeListAndElements(IList`1<T> list);
    public static IList`1<T> FreezeList(IList`1<T> list);
    public static void Freeze(object item);
    public static T FreezeAndReturn(T item);
    public static T GetFrozenClone(T item);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.GetClassTypeReference : object {
    private IModuleReference module;
    private FullTypeName fullTypeName;
    private Nullable`1<bool> isReferenceType;
    public IModuleReference Module { get; }
    public FullTypeName FullTypeName { get; }
    public GetClassTypeReference(FullTypeName fullTypeName, IModuleReference module, Nullable`1<bool> isReferenceType);
    public GetClassTypeReference(string namespaceName, string name, int typeParameterCount, Nullable`1<bool> isReferenceType);
    public GetClassTypeReference(IModuleReference module, string namespaceName, string name, int typeParameterCount, Nullable`1<bool> isReferenceType);
    public IModuleReference get_Module();
    public FullTypeName get_FullTypeName();
    internal static IType ResolveInAllAssemblies(ICompilation compilation, FullTypeName& fullTypeName);
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
internal static class ICSharpCode.Decompiler.TypeSystem.Implementation.GetMembersHelper : object {
    private static GetMemberOptions declaredMembers;
    public static IEnumerable`1<IType> GetNestedTypes(IType type, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public static IEnumerable`1<IType> GetNestedTypes(IType type, IReadOnlyList`1<IType> nestedTypeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.Implementation.GetMembersHelper/<GetNestedTypesImpl>d__2")]
private static IEnumerable`1<IType> GetNestedTypesImpl(IType outerType, IReadOnlyList`1<IType> nestedTypeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public static IEnumerable`1<IMethod> GetMethods(IType type, Predicate`1<IMethod> filter, GetMemberOptions options);
    public static IEnumerable`1<IMethod> GetMethods(IType type, IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    private static Predicate`1<IMethod> FilterTypeParameterCount(int expectedTypeParameterCount);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.Implementation.GetMembersHelper/<GetMethodsImpl>d__7")]
private static IEnumerable`1<IMethod> GetMethodsImpl(IType baseType, IReadOnlyList`1<IType> methodTypeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public static IEnumerable`1<IMethod> GetAccessors(IType type, Predicate`1<IMethod> filter, GetMemberOptions options);
    private static IEnumerable`1<IMethod> GetAccessorsImpl(IType baseType, Predicate`1<IMethod> filter, GetMemberOptions options);
    public static IEnumerable`1<IMethod> GetConstructors(IType type, Predicate`1<IMethod> filter, GetMemberOptions options);
    private static IEnumerable`1<IMethod> GetConstructorsImpl(IType baseType, Predicate`1<IMethod> filter, GetMemberOptions options);
    private static IEnumerable`1<IMethod> GetConstructorsOrAccessorsImpl(IType baseType, IEnumerable`1<IMethod> declaredMembers, GetMemberOptions options);
    public static IEnumerable`1<IProperty> GetProperties(IType type, Predicate`1<IProperty> filter, GetMemberOptions options);
    private static IEnumerable`1<IProperty> GetPropertiesImpl(IType baseType, Predicate`1<IProperty> filter, GetMemberOptions options);
    public static IEnumerable`1<IField> GetFields(IType type, Predicate`1<IField> filter, GetMemberOptions options);
    private static IEnumerable`1<IField> GetFieldsImpl(IType baseType, Predicate`1<IField> filter, GetMemberOptions options);
    public static IEnumerable`1<IEvent> GetEvents(IType type, Predicate`1<IEvent> filter, GetMemberOptions options);
    private static IEnumerable`1<IEvent> GetEventsImpl(IType baseType, Predicate`1<IEvent> filter, GetMemberOptions options);
    public static IEnumerable`1<IMember> GetMembers(IType type, Predicate`1<IMember> filter, GetMemberOptions options);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.Implementation.GetMembersHelper/<GetMembersImpl>d__20")]
private static IEnumerable`1<IMember> GetMembersImpl(IType baseType, Predicate`1<IMember> filter, GetMemberOptions options);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.KnownTypeCache : object {
    private ICompilation compilation;
    private IType[] knownTypes;
    public KnownTypeCache(ICompilation compilation);
    public IType FindType(KnownTypeCode typeCode);
    private IType SearchType(KnownTypeCode typeCode);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.LocalFunctionMethod : object {
    private IMethod baseMethod;
    [CompilerGeneratedAttribute]
private int <NumberOfCompilerGeneratedParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfCompilerGeneratedTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStaticLocalFunction>k__BackingField;
    private List`1<ITypeParameter> typeParameters;
    private List`1<IType> typeArguments;
    private List`1<IParameter> parameters;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal int NumberOfCompilerGeneratedParameters { get; }
    internal int NumberOfCompilerGeneratedTypeParameters { get; }
    internal bool IsStaticLocalFunction { get; }
    public IMember MemberDefinition { get; }
    public IType ReturnType { get; }
    private IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.ExplicitlyImplementedInterfaceMembers { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsExplicitInterfaceImplementation { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsOverridable { get; }
    public TypeParameterSubstitution Substitution { get; }
    public bool IsExtensionMethod { get; }
    public bool IsLocalFunction { get; }
    public bool IsConstructor { get; }
    public bool IsDestructor { get; }
    public bool IsOperator { get; }
    public bool HasBody { get; }
    public bool IsAccessor { get; }
    public IMember AccessorOwner { get; }
    public MethodSemanticsAttributes AccessorKind { get; }
    public IMethod ReducedFrom { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public EntityHandle MetadataToken { get; }
    public SymbolKind SymbolKind { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; }
    public IModule ParentModule { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ReturnTypeIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ThisIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsInitOnly { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public Accessibility Accessibility { get; }
    public string FullName { get; }
    public string Name { get; public set; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    public ICompilation Compilation { get; }
    public LocalFunctionMethod(IMethod baseMethod, string name, bool isStaticLocalFunction, int numberOfCompilerGeneratedParameters, int numberOfCompilerGeneratedTypeParameters);
    public sealed virtual bool Equals(IMember obj, TypeVisitor typeNormalization);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal int get_NumberOfCompilerGeneratedParameters();
    [CompilerGeneratedAttribute]
internal int get_NumberOfCompilerGeneratedTypeParameters();
    [CompilerGeneratedAttribute]
internal bool get_IsStaticLocalFunction();
    public sealed virtual IMember get_MemberDefinition();
    public sealed virtual IType get_ReturnType();
    private sealed virtual override IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.get_ExplicitlyImplementedInterfaceMembers();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsExplicitInterfaceImplementation();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual TypeParameterSubstitution get_Substitution();
    public sealed virtual IMethod Specialize(TypeParameterSubstitution substitution);
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.Specialize(TypeParameterSubstitution substitution);
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsLocalFunction();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsDestructor();
    public sealed virtual bool get_IsOperator();
    public sealed virtual bool get_HasBody();
    public sealed virtual bool get_IsAccessor();
    public sealed virtual IMember get_AccessorOwner();
    public sealed virtual MethodSemanticsAttributes get_AccessorKind();
    public sealed virtual IMethod get_ReducedFrom();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual IReadOnlyList`1<IType> get_TypeArguments();
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    public sealed virtual EntityHandle get_MetadataToken();
    public sealed virtual SymbolKind get_SymbolKind();
    public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    public sealed virtual IType get_DeclaringType();
    public sealed virtual IModule get_ParentModule();
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.HasAttribute(KnownAttribute attribute);
    private sealed virtual override IAttribute ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttribute(KnownAttribute attribute);
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IMethod.GetReturnTypeAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ReturnTypeIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ThisIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsInitOnly();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual Accessibility get_Accessibility();
    public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual string get_ReflectionName();
    public sealed virtual string get_Namespace();
    public sealed virtual ICompilation get_Compilation();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.MergedNamespace : object {
    private string externAlias;
    private ICompilation compilation;
    private INamespace parentNamespace;
    private INamespace[] namespaces;
    private Dictionary`2<string, INamespace> childNamespaces;
    public string ExternAlias { get; }
    public string FullName { get; }
    public string Name { get; }
    public INamespace ParentNamespace { get; }
    public IEnumerable`1<ITypeDefinition> Types { get; }
    public SymbolKind SymbolKind { get; }
    public ICompilation Compilation { get; }
    public IEnumerable`1<IModule> ContributingModules { get; }
    public IEnumerable`1<INamespace> ChildNamespaces { get; }
    public MergedNamespace(ICompilation compilation, INamespace[] namespaces, string externAlias);
    public MergedNamespace(INamespace parentNamespace, INamespace[] namespaces);
    public sealed virtual string get_ExternAlias();
    public sealed virtual string get_FullName();
    public sealed virtual string get_Name();
    public sealed virtual INamespace get_ParentNamespace();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_Types();
    public sealed virtual SymbolKind get_SymbolKind();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual IEnumerable`1<IModule> get_ContributingModules();
    public sealed virtual IEnumerable`1<INamespace> get_ChildNamespaces();
    public sealed virtual INamespace GetChildNamespace(string name);
    private Dictionary`2<string, INamespace> GetChildNamespaces();
    public sealed virtual ITypeDefinition GetTypeDefinition(string name, int typeParameterCount);
    public virtual string ToString();
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataEvent : object {
    private MetadataModule module;
    private EventDefinitionHandle handle;
    private EventAccessors accessors;
    private string name;
    private IType returnType;
    public EntityHandle MetadataToken { get; }
    public string Name { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    public bool CanAdd { get; }
    public bool CanRemove { get; }
    public bool CanInvoke { get; }
    public IMethod AddAccessor { get; }
    public IMethod RemoveAccessor { get; }
    public IMethod InvokeAccessor { get; }
    private IMethod AnyAccessor { get; }
    public IType ReturnType { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public IEnumerable`1<IMember> ExplicitlyImplementedInterfaceMembers { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; }
    private IMember ICSharpCode.Decompiler.TypeSystem.IMember.MemberDefinition { get; }
    private TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.Substitution { get; }
    public Accessibility Accessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsOverridable { get; }
    public IModule ParentModule { get; }
    public ICompilation Compilation { get; }
    public string FullName { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    internal MetadataEvent(MetadataModule module, EventDefinitionHandle handle);
    public virtual string ToString();
    public sealed virtual EntityHandle get_MetadataToken();
    public sealed virtual string get_Name();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    public sealed virtual bool get_CanAdd();
    public sealed virtual bool get_CanRemove();
    public sealed virtual bool get_CanInvoke();
    public sealed virtual IMethod get_AddAccessor();
    public sealed virtual IMethod get_RemoveAccessor();
    public sealed virtual IMethod get_InvokeAccessor();
    private IMethod get_AnyAccessor();
    public sealed virtual IType get_ReturnType();
    public sealed virtual bool get_IsExplicitInterfaceImplementation();
    public sealed virtual IEnumerable`1<IMember> get_ExplicitlyImplementedInterfaceMembers();
    internal static IEnumerable`1<IMember> GetInterfaceMembersFromAccessor(IMethod method);
    public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    public sealed virtual IType get_DeclaringType();
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.get_MemberDefinition();
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.get_Substitution();
    public sealed virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual bool HasAttribute(KnownAttribute attribute);
    public sealed virtual IAttribute GetAttribute(KnownAttribute attribute);
    public sealed virtual Accessibility get_Accessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual IModule get_ParentModule();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual string get_FullName();
    public sealed virtual string get_ReflectionName();
    public sealed virtual string get_Namespace();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.Equals(IMember obj, TypeVisitor typeNormalization);
    public sealed virtual IMember Specialize(TypeParameterSubstitution substitution);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataField : object {
    private MetadataModule module;
    private FieldDefinitionHandle handle;
    private FieldAttributes attributes;
    private ITypeDefinition declaringType;
    private string name;
    private object constantValue;
    private IType type;
    private bool isVolatile;
    private byte decimalConstantState;
    public EntityHandle MetadataToken { get; }
    public string Name { get; }
    public Accessibility Accessibility { get; }
    public bool IsReadOnly { get; }
    public bool IsStatic { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    private IMember ICSharpCode.Decompiler.TypeSystem.IMember.MemberDefinition { get; }
    private TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.Substitution { get; }
    private IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.ExplicitlyImplementedInterfaceMembers { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsExplicitInterfaceImplementation { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsVirtual { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsOverride { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsOverridable { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IEntity.IsAbstract { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IEntity.IsSealed { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; }
    public IModule ParentModule { get; }
    public ICompilation Compilation { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    public string FullName { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    public bool IsVolatile { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.IMember.ReturnType { get; }
    public IType Type { get; }
    public bool IsConst { get; }
    private bool IsDecimalConstant { get; }
    internal MetadataField(MetadataModule module, FieldDefinitionHandle handle);
    public sealed virtual EntityHandle get_MetadataToken();
    public virtual string ToString();
    public sealed virtual string get_Name();
    public sealed virtual Accessibility get_Accessibility();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsStatic();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.get_MemberDefinition();
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.get_Substitution();
    private sealed virtual override IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.get_ExplicitlyImplementedInterfaceMembers();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsExplicitInterfaceImplementation();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsVirtual();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsOverride();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsOverridable();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.get_IsAbstract();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.get_IsSealed();
    public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    public sealed virtual IType get_DeclaringType();
    public sealed virtual IModule get_ParentModule();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual bool HasAttribute(KnownAttribute attribute);
    public sealed virtual IAttribute GetAttribute(KnownAttribute attribute);
    public sealed virtual bool get_ReturnTypeIsRefReadOnly();
    public sealed virtual string get_FullName();
    public sealed virtual string get_ReflectionName();
    public sealed virtual string get_Namespace();
    public sealed virtual bool get_IsVolatile();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IMember.get_ReturnType();
    public sealed virtual IType get_Type();
    private IType DecodeTypeAndVolatileFlag();
    public sealed virtual bool get_IsConst();
    private bool get_IsDecimalConstant();
    public sealed virtual object GetConstantValue(bool throwOnInvalidMetadata);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.Equals(IMember obj, TypeVisitor typeNormalization);
    public sealed virtual IMember Specialize(TypeParameterSubstitution substitution);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataMethod : object {
    private MetadataModule module;
    private MethodDefinitionHandle handle;
    private MethodAttributes attributes;
    private SymbolKind symbolKind;
    private ITypeParameter[] typeParameters;
    private EntityHandle accessorOwner;
    [CompilerGeneratedAttribute]
private MethodSemanticsAttributes <AccessorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionMethod>k__BackingField;
    private ITypeDefinition declaringType;
    private string name;
    private IParameter[] parameters;
    private IType returnType;
    private byte returnTypeIsRefReadonly;
    private byte thisIsRefReadonly;
    private bool isInitOnly;
    public MethodSemanticsAttributes AccessorKind { get; }
    public bool IsExtensionMethod { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsLocalFunction { get; }
    public EntityHandle MetadataToken { get; }
    public string Name { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    private IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IMethod.TypeArguments { get; }
    public SymbolKind SymbolKind { get; }
    public bool IsConstructor { get; }
    public bool IsDestructor { get; }
    public bool IsOperator { get; }
    public bool IsAccessor { get; }
    public bool HasBody { get; }
    public IMember AccessorOwner { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public bool IsInitOnly { get; }
    internal Nullability NullableContext { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public IEnumerable`1<IMember> ExplicitlyImplementedInterfaceMembers { get; }
    private IMember ICSharpCode.Decompiler.TypeSystem.IMember.MemberDefinition { get; }
    private IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.ReducedFrom { get; }
    private TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.Substitution { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; }
    public IModule ParentModule { get; }
    public ICompilation Compilation { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    public bool ThisIsRefReadOnly { get; }
    public Accessibility Accessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsOverridable { get; }
    public string FullName { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    internal MetadataMethod(MetadataModule module, MethodDefinitionHandle handle);
    [CompilerGeneratedAttribute]
public sealed virtual MethodSemanticsAttributes get_AccessorKind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsExtensionMethod();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsLocalFunction();
    public sealed virtual EntityHandle get_MetadataToken();
    public virtual string ToString();
    public sealed virtual string get_Name();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    private sealed virtual override IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IMethod.get_TypeArguments();
    public sealed virtual SymbolKind get_SymbolKind();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsDestructor();
    public sealed virtual bool get_IsOperator();
    public sealed virtual bool get_IsAccessor();
    public sealed virtual bool get_HasBody();
    public sealed virtual IMember get_AccessorOwner();
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual bool get_IsInitOnly();
    internal Nullability get_NullableContext();
    private void DecodeSignature();
    internal static ValueTuple`3<IType, IParameter[], ModifiedType> DecodeSignature(MetadataModule module, IParameterizedMember owner, MethodSignature`1<IType> signature, Nullable`1<ParameterHandleCollection> parameterHandles, Nullability nullableContext, TypeSystemOptions typeSystemOptions, Nullable`1<CustomAttributeHandleCollection> returnTypeAttributes);
    public sealed virtual bool get_IsExplicitInterfaceImplementation();
    public sealed virtual IEnumerable`1<IMember> get_ExplicitlyImplementedInterfaceMembers();
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.get_MemberDefinition();
    private sealed virtual override IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.get_ReducedFrom();
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.get_Substitution();
    public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    public sealed virtual IType get_DeclaringType();
    public sealed virtual IModule get_ParentModule();
    public sealed virtual ICompilation get_Compilation();
    private IType FindInteropType(string name);
    public sealed virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual bool HasAttribute(KnownAttribute attribute);
    public sealed virtual IAttribute GetAttribute(KnownAttribute attribute);
    public sealed virtual IEnumerable`1<IAttribute> GetReturnTypeAttributes();
    public sealed virtual bool get_ReturnTypeIsRefReadOnly();
    public sealed virtual bool get_ThisIsRefReadOnly();
    public sealed virtual Accessibility get_Accessibility();
    internal static Accessibility GetAccessibility(MethodAttributes attr);
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual string get_FullName();
    public sealed virtual string get_ReflectionName();
    public sealed virtual string get_Namespace();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.Equals(IMember obj, TypeVisitor typeNormalization);
    public sealed virtual IMethod Specialize(TypeParameterSubstitution substitution);
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.Specialize(TypeParameterSubstitution substitution);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataNamespace : object {
    private MetadataModule module;
    private NamespaceDefinition ns;
    [CompilerGeneratedAttribute]
private INamespace <ParentNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private INamespace[] childNamespaces;
    public INamespace ParentNamespace { get; }
    public string FullName { get; }
    public string Name { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamespace.ExternAlias { get; }
    public IEnumerable`1<INamespace> ChildNamespaces { get; }
    private IEnumerable`1<ITypeDefinition> ICSharpCode.Decompiler.TypeSystem.INamespace.Types { get; }
    private IEnumerable`1<IModule> ICSharpCode.Decompiler.TypeSystem.INamespace.ContributingModules { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    private ICompilation ICSharpCode.Decompiler.TypeSystem.ICompilationProvider.Compilation { get; }
    public MetadataNamespace(MetadataModule module, INamespace parent, string fullName, NamespaceDefinition ns);
    [CompilerGeneratedAttribute]
public sealed virtual INamespace get_ParentNamespace();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamespace.get_ExternAlias();
    public sealed virtual IEnumerable`1<INamespace> get_ChildNamespaces();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataNamespace/<ICSharpCode-Decompiler-TypeSystem-INamespace-get_Types>d__18")]
private sealed virtual override IEnumerable`1<ITypeDefinition> ICSharpCode.Decompiler.TypeSystem.INamespace.get_Types();
    private sealed virtual override IEnumerable`1<IModule> ICSharpCode.Decompiler.TypeSystem.INamespace.get_ContributingModules();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    private sealed virtual override ICompilation ICSharpCode.Decompiler.TypeSystem.ICompilationProvider.get_Compilation();
    private sealed virtual override INamespace ICSharpCode.Decompiler.TypeSystem.INamespace.GetChildNamespace(string name);
    private sealed virtual override ITypeDefinition ICSharpCode.Decompiler.TypeSystem.INamespace.GetTypeDefinition(string name, int typeParameterCount);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataParameter : object {
    private MetadataModule module;
    private ParameterHandle handle;
    private ParameterAttributes attributes;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterizedMember <Owner>k__BackingField;
    private string name;
    private byte constantValueInSignatureState;
    private byte decimalConstantState;
    private static ParameterAttributes inOut;
    public IType Type { get; }
    public IParameterizedMember Owner { get; }
    public EntityHandle MetadataToken { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsRef { get; }
    public bool IsOut { get; }
    public bool IsIn { get; }
    public bool IsOptional { get; }
    public LifetimeAnnotation Lifetime { get; }
    public bool IsParams { get; }
    public string Name { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IVariable.IsConst { get; }
    public bool HasConstantValueInSignature { get; }
    private bool IsDecimalConstant { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    internal MetadataParameter(MetadataModule module, IParameterizedMember owner, IType type, ParameterHandle handle);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IParameterizedMember get_Owner();
    public EntityHandle get_MetadataToken();
    public sealed virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual bool get_IsRef();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsOptional();
    private ReferenceKind DetectRefKind();
    public sealed virtual LifetimeAnnotation get_Lifetime();
    public sealed virtual bool get_IsParams();
    public sealed virtual string get_Name();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IVariable.get_IsConst();
    public sealed virtual object GetConstantValue(bool throwOnInvalidMetadata);
    public sealed virtual bool get_HasConstantValueInSignature();
    private bool get_IsDecimalConstant();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    public virtual string ToString();
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataProperty : object {
    private static Accessibility InvalidAccessibility;
    private MetadataModule module;
    private PropertyDefinitionHandle handle;
    private IMethod getter;
    private IMethod setter;
    private string name;
    private SymbolKind symbolKind;
    private Accessibility modreq(System.Runtime.CompilerServices.IsVolatile) cachedAccessiblity;
    private IParameter[] parameters;
    private IType returnType;
    public EntityHandle MetadataToken { get; }
    public string Name { get; }
    public bool CanGet { get; }
    public bool CanSet { get; }
    public IMethod Getter { get; }
    public IMethod Setter { get; }
    private IMethod AnyAccessor { get; }
    public bool IsIndexer { get; }
    public SymbolKind SymbolKind { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public IEnumerable`1<IMember> ExplicitlyImplementedInterfaceMembers { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; }
    private IMember ICSharpCode.Decompiler.TypeSystem.IMember.MemberDefinition { get; }
    private TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.Substitution { get; }
    public Accessibility Accessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsOverridable { get; }
    public IModule ParentModule { get; }
    public ICompilation Compilation { get; }
    public string FullName { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    internal MetadataProperty(MetadataModule module, PropertyDefinitionHandle handle);
    private bool DetermineIsIndexer(string name);
    public virtual string ToString();
    public sealed virtual EntityHandle get_MetadataToken();
    public sealed virtual string get_Name();
    public sealed virtual bool get_CanGet();
    public sealed virtual bool get_CanSet();
    public sealed virtual IMethod get_Getter();
    public sealed virtual IMethod get_Setter();
    private IMethod get_AnyAccessor();
    public sealed virtual bool get_IsIndexer();
    public sealed virtual SymbolKind get_SymbolKind();
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual bool get_ReturnTypeIsRefReadOnly();
    private void DecodeSignature();
    public sealed virtual bool get_IsExplicitInterfaceImplementation();
    public sealed virtual IEnumerable`1<IMember> get_ExplicitlyImplementedInterfaceMembers();
    internal static IEnumerable`1<IMember> GetInterfaceMembersFromAccessor(IMethod method);
    public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    public sealed virtual IType get_DeclaringType();
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.get_MemberDefinition();
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.get_Substitution();
    public sealed virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual bool HasAttribute(KnownAttribute attribute);
    public sealed virtual IAttribute GetAttribute(KnownAttribute attribute);
    public sealed virtual Accessibility get_Accessibility();
    private Accessibility ComputeAccessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual IModule get_ParentModule();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual string get_FullName();
    public sealed virtual string get_ReflectionName();
    public sealed virtual string get_Namespace();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.Equals(IMember obj, TypeVisitor typeNormalization);
    public sealed virtual IMember Specialize(TypeParameterSubstitution substitution);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataTypeDefinition : object {
    private MetadataModule module;
    private TypeDefinitionHandle handle;
    private FullTypeName fullTypeName;
    private TypeAttributes attributes;
    [CompilerGeneratedAttribute]
private TypeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsByRefLike>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeDefinition <DeclaringTypeDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITypeParameter> <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private KnownTypeCode <KnownTypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <EnumUnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExtensionMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullability <NullableContext>k__BackingField;
    private IMember[] members;
    private IField[] fields;
    private IProperty[] properties;
    private IEvent[] events;
    private IMethod[] methods;
    private List`1<IType> directBaseTypes;
    private bool defaultMemberNameInitialized;
    private string defaultMemberName;
    private ITypeDefinition[] nestedTypes;
    [CompilerGeneratedAttribute]
private string <MetadataName>k__BackingField;
    private byte isRecord;
    public TypeKind Kind { get; }
    public bool IsByRefLike { get; }
    public bool IsReadOnly { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public KnownTypeCode KnownTypeCode { get; }
    public IType EnumUnderlyingType { get; }
    public bool HasExtensionMethods { get; }
    public Nullability NullableContext { get; }
    public IReadOnlyList`1<ITypeDefinition> NestedTypes { get; }
    public IReadOnlyList`1<IMember> Members { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IType DeclaringType { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public int TypeParameterCount { get; }
    private IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.TypeArguments { get; }
    private Nullability ICSharpCode.Decompiler.TypeSystem.IType.Nullability { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    public EntityHandle MetadataToken { get; }
    public string MetadataName { get; }
    public FullTypeName FullTypeName { get; }
    public string Name { get; }
    public IModule ParentModule { get; }
    public string DefaultMemberName { get; }
    public Accessibility Accessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public SymbolKind SymbolKind { get; }
    public ICompilation Compilation { get; }
    public string FullName { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    public bool IsRecord { get; }
    internal MetadataTypeDefinition(MetadataModule module, TypeDefinitionHandle handle);
    [CompilerGeneratedAttribute]
public sealed virtual TypeKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsByRefLike();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    [CompilerGeneratedAttribute]
public sealed virtual KnownTypeCode get_KnownTypeCode();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_EnumUnderlyingType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasExtensionMethods();
    [CompilerGeneratedAttribute]
public sealed virtual Nullability get_NullableContext();
    public virtual string ToString();
    public sealed virtual IReadOnlyList`1<ITypeDefinition> get_NestedTypes();
    public sealed virtual IReadOnlyList`1<IMember> get_Members();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IType get_DeclaringType();
    public sealed virtual Nullable`1<bool> get_IsReferenceType();
    public sealed virtual int get_TypeParameterCount();
    private sealed virtual override IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IType.get_TypeArguments();
    private sealed virtual override Nullability ICSharpCode.Decompiler.TypeSystem.IType.get_Nullability();
    public sealed virtual IType ChangeNullability(Nullability nullability);
    public sealed virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public sealed virtual EntityHandle get_MetadataToken();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MetadataName();
    public sealed virtual FullTypeName get_FullTypeName();
    public sealed virtual string get_Name();
    public sealed virtual IModule get_ParentModule();
    public sealed virtual IEnumerable`1<IAttribute> GetAttributes();
    public sealed virtual bool HasAttribute(KnownAttribute attribute);
    public sealed virtual IAttribute GetAttribute(KnownAttribute attribute);
    public string get_DefaultMemberName();
    public sealed virtual Accessibility get_Accessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual SymbolKind get_SymbolKind();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual string get_FullName();
    public sealed virtual string get_ReflectionName();
    public sealed virtual string get_Namespace();
    private sealed virtual override ITypeDefinition ICSharpCode.Decompiler.TypeSystem.IType.GetDefinition();
    private sealed virtual override ITypeDefinitionOrUnknown ICSharpCode.Decompiler.TypeSystem.IType.GetDefinitionOrUnknown();
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IType.GetSubstitution();
    public sealed virtual IType AcceptVisitor(TypeVisitor visitor);
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IType.VisitChildren(TypeVisitor visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool System.IEquatable<ICSharpCode.Decompiler.TypeSystem.IType>.Equals(IType other);
    public sealed virtual IEnumerable`1<IType> GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IType> GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    private IEnumerable`1<T> GetFiltered(IEnumerable`1<T> input, Predicate`1<T> filter);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataTypeDefinition/<ApplyFilter>d__112`1")]
private IEnumerable`1<T> ApplyFilter(IEnumerable`1<T> input, Predicate`1<T> filter);
    public sealed virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMember> GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataTypeDefinition/<GetFilteredAccessors>d__121")]
private IEnumerable`1<IMethod> GetFilteredAccessors(Predicate`1<IMethod> filter);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataTypeDefinition/<GetOverrides>d__122")]
internal IEnumerable`1<IMethod> GetOverrides(MethodDefinitionHandle method);
    internal bool HasOverrides(MethodDefinitionHandle method);
    public sealed virtual bool get_IsRecord();
    private bool ComputeIsRecord();
    [CompilerGeneratedAttribute]
private SpecializedMethod <GetConstructors>b__115_1(IMethod m);
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.MetadataTypeParameter : AbstractTypeParameter {
    private MetadataModule module;
    private GenericParameterHandle handle;
    private GenericParameterAttributes attr;
    private IReadOnlyList`1<TypeConstraint> constraints;
    private byte unmanagedConstraint;
    private static byte nullabilityNotYetLoaded;
    private byte nullabilityConstraint;
    public GenericParameterHandle MetadataToken { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasUnmanagedConstraint { get; }
    public Nullability NullabilityConstraint { get; }
    public IReadOnlyList`1<TypeConstraint> TypeConstraints { get; }
    private MetadataTypeParameter(MetadataModule module, IEntity owner, int index, string name, GenericParameterHandle handle, GenericParameterAttributes attr);
    public static ITypeParameter[] Create(MetadataModule module, ITypeDefinition copyFromOuter, IEntity owner, GenericParameterHandleCollection handles);
    public static ITypeParameter[] Create(MetadataModule module, IEntity owner, GenericParameterHandleCollection handles);
    public static MetadataTypeParameter Create(MetadataModule module, IEntity owner, int index, GenericParameterHandle handle);
    private static VarianceModifier GetVariance(GenericParameterAttributes attr);
    public GenericParameterHandle get_MetadataToken();
    public virtual IEnumerable`1<IAttribute> GetAttributes();
    public virtual bool get_HasDefaultConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasUnmanagedConstraint();
    private bool LoadUnmanagedConstraint();
    public virtual Nullability get_NullabilityConstraint();
    private Nullability LoadNullabilityConstraint();
    public virtual IReadOnlyList`1<TypeConstraint> get_TypeConstraints();
    private IReadOnlyList`1<TypeConstraint> DecodeConstraints();
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.MinimalCorlib : object {
    public static IModuleReference Instance;
    [CompilerGeneratedAttribute]
private ICompilation <Compilation>k__BackingField;
    private CorlibTypeDefinition[] typeDefinitions;
    private CorlibNamespace rootNamespace;
    private Version asmVersion;
    public ICompilation Compilation { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IModule.IsMainModule { get; }
    private string ICSharpCode.Decompiler.TypeSystem.IModule.AssemblyName { get; }
    private Version ICSharpCode.Decompiler.TypeSystem.IModule.AssemblyVersion { get; }
    private string ICSharpCode.Decompiler.TypeSystem.IModule.FullAssemblyName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.ISymbol.Name { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    private PEFile ICSharpCode.Decompiler.TypeSystem.IModule.PEFile { get; }
    private INamespace ICSharpCode.Decompiler.TypeSystem.IModule.RootNamespace { get; }
    public IEnumerable`1<ITypeDefinition> TopLevelTypeDefinitions { get; }
    public IEnumerable`1<ITypeDefinition> TypeDefinitions { get; }
    private MinimalCorlib(ICompilation compilation, IEnumerable`1<KnownTypeReference> types);
    private static MinimalCorlib();
    public static IModuleReference CreateWithTypes(IEnumerable`1<KnownTypeReference> types);
    [CompilerGeneratedAttribute]
public sealed virtual ICompilation get_Compilation();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IModule.get_IsMainModule();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.IModule.get_AssemblyName();
    private sealed virtual override Version ICSharpCode.Decompiler.TypeSystem.IModule.get_AssemblyVersion();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.IModule.get_FullAssemblyName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.ISymbol.get_Name();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    private sealed virtual override PEFile ICSharpCode.Decompiler.TypeSystem.IModule.get_PEFile();
    private sealed virtual override INamespace ICSharpCode.Decompiler.TypeSystem.IModule.get_RootNamespace();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_TopLevelTypeDefinitions();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_TypeDefinitions();
    public sealed virtual ITypeDefinition GetTypeDefinition(TopLevelTypeName topLevelTypeName);
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IModule.GetAssemblyAttributes();
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IModule.GetModuleAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IModule.InternalsVisibleTo(IModule module);
    [CompilerGeneratedAttribute]
private CorlibTypeDefinition <.ctor>b__8_0(KnownTypeReference ktr);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.ModifiedType : TypeWithElementType {
    private TypeKind kind;
    private IType modifier;
    public IType Modifier { get; }
    public TypeKind Kind { get; }
    public string NameSuffix { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public bool IsByRefLike { get; }
    public Nullability Nullability { get; }
    public ModifiedType(IType modifier, IType unmodifiedType, bool isRequired);
    public IType get_Modifier();
    public virtual TypeKind get_Kind();
    public virtual string get_NameSuffix();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual bool get_IsByRefLike();
    public virtual Nullability get_Nullability();
    public virtual IType ChangeNullability(Nullability nullability);
    public virtual ITypeDefinition GetDefinition();
    public virtual ITypeDefinitionOrUnknown GetDefinitionOrUnknown();
    public virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMember> GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IType> GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IType> GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public virtual IType VisitChildren(TypeVisitor visitor);
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual bool Equals(IType other);
    public virtual int GetHashCode();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.NestedTypeReference : object {
    private ITypeReference declaringTypeRef;
    private string name;
    private int additionalTypeParameterCount;
    private Nullable`1<bool> isReferenceType;
    public ITypeReference DeclaringTypeReference { get; }
    public string Name { get; }
    public int AdditionalTypeParameterCount { get; }
    public NestedTypeReference(ITypeReference declaringTypeRef, string name, int additionalTypeParameterCount, Nullable`1<bool> isReferenceType);
    public ITypeReference get_DeclaringTypeReference();
    public string get_Name();
    public int get_AdditionalTypeParameterCount();
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.NullabilityAnnotatedType : DecoratedType {
    private Nullability nullability;
    public Nullability Nullability { get; }
    public IType TypeWithoutAnnotation { get; }
    internal NullabilityAnnotatedType(IType type, Nullability nullability);
    public sealed virtual Nullability get_Nullability();
    public IType get_TypeWithoutAnnotation();
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual bool Equals(IType other);
    public virtual IType ChangeNullability(Nullability nullability);
    public virtual IType VisitChildren(TypeVisitor visitor);
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.NullabilityAnnotatedTypeParameter : NullabilityAnnotatedType {
    private ITypeParameter baseType;
    public ITypeParameter OriginalTypeParameter { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ITypeParameter.OwnerType { get; }
    private IEntity ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Owner { get; }
    private int ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Index { get; }
    private string ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Name { get; }
    private string ICSharpCode.Decompiler.TypeSystem.ISymbol.Name { get; }
    private VarianceModifier ICSharpCode.Decompiler.TypeSystem.ITypeParameter.Variance { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.ITypeParameter.EffectiveBaseClass { get; }
    private IReadOnlyCollection`1<IType> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.EffectiveInterfaceSet { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasDefaultConstructorConstraint { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasReferenceTypeConstraint { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasValueTypeConstraint { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.HasUnmanagedConstraint { get; }
    private Nullability ICSharpCode.Decompiler.TypeSystem.ITypeParameter.NullabilityConstraint { get; }
    private IReadOnlyList`1<TypeConstraint> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.TypeConstraints { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    internal NullabilityAnnotatedTypeParameter(ITypeParameter type, Nullability nullability);
    public ITypeParameter get_OriginalTypeParameter();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_OwnerType();
    private sealed virtual override IEntity ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_Owner();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_Index();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_Name();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.ISymbol.get_Name();
    private sealed virtual override VarianceModifier ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_Variance();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_EffectiveBaseClass();
    private sealed virtual override IReadOnlyCollection`1<IType> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_EffectiveInterfaceSet();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasDefaultConstructorConstraint();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasReferenceTypeConstraint();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasValueTypeConstraint();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_HasUnmanagedConstraint();
    private sealed virtual override Nullability ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_NullabilityConstraint();
    private sealed virtual override IReadOnlyList`1<TypeConstraint> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.get_TypeConstraints();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.ITypeParameter.GetAttributes();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.PinnedType : TypeWithElementType {
    public string NameSuffix { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public bool IsByRefLike { get; }
    public TypeKind Kind { get; }
    public PinnedType(IType elementType);
    public virtual string get_NameSuffix();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual bool get_IsByRefLike();
    public virtual TypeKind get_Kind();
    public virtual IType VisitChildren(TypeVisitor visitor);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.SimpleCompilation : object {
    private CacheManager cacheManager;
    private IModule mainModule;
    private KnownTypeCache knownTypeCache;
    private IReadOnlyList`1<IModule> assemblies;
    private IReadOnlyList`1<IModule> referencedAssemblies;
    private bool initialized;
    private INamespace rootNamespace;
    public IModule MainModule { get; }
    public IReadOnlyList`1<IModule> Modules { get; }
    public IReadOnlyList`1<IModule> ReferencedModules { get; }
    public INamespace RootNamespace { get; }
    public CacheManager CacheManager { get; }
    public StringComparer NameComparer { get; }
    public SimpleCompilation(IModuleReference mainAssembly, IModuleReference[] assemblyReferences);
    public SimpleCompilation(IModuleReference mainAssembly, IEnumerable`1<IModuleReference> assemblyReferences);
    protected void Init(IModuleReference mainAssembly, IEnumerable`1<IModuleReference> assemblyReferences);
    public sealed virtual IModule get_MainModule();
    public sealed virtual IReadOnlyList`1<IModule> get_Modules();
    public sealed virtual IReadOnlyList`1<IModule> get_ReferencedModules();
    public sealed virtual INamespace get_RootNamespace();
    protected virtual INamespace CreateRootNamespace();
    public sealed virtual CacheManager get_CacheManager();
    public virtual INamespace GetNamespaceForExternAlias(string alias);
    public sealed virtual IType FindType(KnownTypeCode typeCode);
    public sealed virtual StringComparer get_NameComparer();
    public virtual string ToString();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedEvent : SpecializedMember {
    private IEvent eventDefinition;
    private IMethod addAccessor;
    private IMethod removeAccessor;
    private IMethod invokeAccessor;
    public bool CanAdd { get; }
    public bool CanRemove { get; }
    public bool CanInvoke { get; }
    public IMethod AddAccessor { get; }
    public IMethod RemoveAccessor { get; }
    public IMethod InvokeAccessor { get; }
    public SpecializedEvent(IEvent eventDefinition, TypeParameterSubstitution substitution);
    public static IEvent Create(IEvent ev, TypeParameterSubstitution substitution);
    public sealed virtual bool get_CanAdd();
    public sealed virtual bool get_CanRemove();
    public sealed virtual bool get_CanInvoke();
    public sealed virtual IMethod get_AddAccessor();
    public sealed virtual IMethod get_RemoveAccessor();
    public sealed virtual IMethod get_InvokeAccessor();
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedField : SpecializedMember {
    private IField fieldDefinition;
    public bool IsReadOnly { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    public bool IsVolatile { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.IVariable.Type { get; }
    public bool IsConst { get; }
    public SpecializedField(IField fieldDefinition, TypeParameterSubstitution substitution);
    internal static IField Create(IField fieldDefinition, TypeParameterSubstitution substitution);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_ReturnTypeIsRefReadOnly();
    public sealed virtual bool get_IsVolatile();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IVariable.get_Type();
    public sealed virtual bool get_IsConst();
    public sealed virtual object GetConstantValue(bool throwOnInvalidMetadata);
}
public abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMember : object {
    protected IMember baseMember;
    private TypeParameterSubstitution substitution;
    private IType declaringType;
    private IType returnType;
    public TypeParameterSubstitution Substitution { get; }
    public IType DeclaringType { get; internal set; }
    public IMember MemberDefinition { get; }
    public IType ReturnType { get; protected set; }
    public EntityHandle MetadataToken { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsOverridable { get; }
    public SymbolKind SymbolKind { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IEnumerable`1<IMember> ExplicitlyImplementedInterfaceMembers { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public Accessibility Accessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public string FullName { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string ReflectionName { get; }
    public ICompilation Compilation { get; }
    public IModule ParentModule { get; }
    protected SpecializedMember(IMember memberDefinition);
    protected void AddSubstitution(TypeParameterSubstitution newSubstitution);
    internal IMethod WrapAccessor(IMethod& cachingField, IMethod accessorDefinition);
    public sealed virtual TypeParameterSubstitution get_Substitution();
    public sealed virtual IType get_DeclaringType();
    internal void set_DeclaringType(IType value);
    public sealed virtual IMember get_MemberDefinition();
    public sealed virtual IType get_ReturnType();
    protected void set_ReturnType(IType value);
    public sealed virtual EntityHandle get_MetadataToken();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual SymbolKind get_SymbolKind();
    public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.HasAttribute(KnownAttribute attribute);
    private sealed virtual override IAttribute ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttribute(KnownAttribute attribute);
    public sealed virtual IEnumerable`1<IMember> get_ExplicitlyImplementedInterfaceMembers();
    public sealed virtual bool get_IsExplicitInterfaceImplementation();
    public sealed virtual Accessibility get_Accessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual string get_FullName();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string get_ReflectionName();
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual IModule get_ParentModule();
    public virtual IMember Specialize(TypeParameterSubstitution newSubstitution);
    public virtual bool Equals(IMember obj, TypeVisitor typeNormalization);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IMember <get_ExplicitlyImplementedInterfaceMembers>b__33_0(IMember m);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedMethod : SpecializedParameterizedMember {
    private IMethod methodDefinition;
    private ITypeParameter[] specializedTypeParameters;
    private bool isParameterized;
    private TypeParameterSubstitution substitutionWithoutSpecializedTypeParameters;
    private IMember accessorOwner;
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ThisIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsInitOnly { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public bool IsExtensionMethod { get; }
    public bool IsLocalFunction { get; }
    public bool IsConstructor { get; }
    public bool IsDestructor { get; }
    public bool IsOperator { get; }
    public bool HasBody { get; }
    public bool IsAccessor { get; }
    public MethodSemanticsAttributes AccessorKind { get; }
    public IMethod ReducedFrom { get; }
    public IMember AccessorOwner { get; internal set; }
    public SpecializedMethod(IMethod methodDefinition, TypeParameterSubstitution substitution);
    internal static IMethod Create(IMethod methodDefinition, TypeParameterSubstitution substitution);
    public sealed virtual IReadOnlyList`1<IType> get_TypeArguments();
    public sealed virtual IEnumerable`1<IAttribute> GetReturnTypeAttributes();
    public sealed virtual bool get_ReturnTypeIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ThisIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsInitOnly();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsLocalFunction();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsDestructor();
    public sealed virtual bool get_IsOperator();
    public sealed virtual bool get_HasBody();
    public sealed virtual bool get_IsAccessor();
    public sealed virtual MethodSemanticsAttributes get_AccessorKind();
    public sealed virtual IMethod get_ReducedFrom();
    public sealed virtual IMember get_AccessorOwner();
    internal void set_AccessorOwner(IMember value);
    public virtual bool Equals(IMember obj, TypeVisitor typeNormalization);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual IMember Specialize(TypeParameterSubstitution newSubstitution);
    private sealed virtual override IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.Specialize(TypeParameterSubstitution newSubstitution);
    public virtual string ToString();
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedParameter : object {
    private IParameter baseParameter;
    private IType newType;
    private IParameterizedMember newOwner;
    private ReferenceKind ICSharpCode.Decompiler.TypeSystem.IParameter.ReferenceKind { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IParameter.IsRef { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IParameter.IsOut { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IParameter.IsIn { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IParameter.IsParams { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IParameter.IsOptional { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IParameter.HasConstantValueInSignature { get; }
    private IParameterizedMember ICSharpCode.Decompiler.TypeSystem.IParameter.Owner { get; }
    private string ICSharpCode.Decompiler.TypeSystem.IVariable.Name { get; }
    private string ICSharpCode.Decompiler.TypeSystem.ISymbol.Name { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.IVariable.Type { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IVariable.IsConst { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    public LifetimeAnnotation Lifetime { get; }
    public SpecializedParameter(IParameter baseParameter, IType newType, IParameterizedMember newOwner);
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IParameter.GetAttributes();
    private sealed virtual override ReferenceKind ICSharpCode.Decompiler.TypeSystem.IParameter.get_ReferenceKind();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IParameter.get_IsRef();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IParameter.get_IsOut();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IParameter.get_IsIn();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IParameter.get_IsParams();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IParameter.get_IsOptional();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IParameter.get_HasConstantValueInSignature();
    private sealed virtual override IParameterizedMember ICSharpCode.Decompiler.TypeSystem.IParameter.get_Owner();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.IVariable.get_Name();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.ISymbol.get_Name();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IVariable.get_Type();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IVariable.get_IsConst();
    private sealed virtual override object ICSharpCode.Decompiler.TypeSystem.IVariable.GetConstantValue(bool throwOnInvalidMetadata);
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    public sealed virtual LifetimeAnnotation get_Lifetime();
    public virtual string ToString();
}
public abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedParameterizedMember : SpecializedMember {
    private IReadOnlyList`1<IParameter> parameters;
    public IReadOnlyList`1<IParameter> Parameters { get; protected set; }
    protected SpecializedParameterizedMember(IParameterizedMember memberDefinition);
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    protected void set_Parameters(IReadOnlyList`1<IParameter> value);
    protected IParameter[] CreateParameters(Func`2<IType, IType> substitution);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IType <get_Parameters>b__3_0(IType t);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.SpecializedProperty : SpecializedParameterizedMember {
    private IProperty propertyDefinition;
    private IMethod getter;
    private IMethod setter;
    public bool CanGet { get; }
    public bool CanSet { get; }
    public IMethod Getter { get; }
    public IMethod Setter { get; }
    public bool IsIndexer { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    public SpecializedProperty(IProperty propertyDefinition, TypeParameterSubstitution substitution);
    internal static IProperty Create(IProperty propertyDefinition, TypeParameterSubstitution substitution);
    public sealed virtual bool get_CanGet();
    public sealed virtual bool get_CanSet();
    public sealed virtual IMethod get_Getter();
    public sealed virtual IMethod get_Setter();
    public sealed virtual bool get_IsIndexer();
    public sealed virtual bool get_ReturnTypeIsRefReadOnly();
}
internal class ICSharpCode.Decompiler.TypeSystem.Implementation.SyntheticRangeIndexAccessor : object {
    private IMethod underlyingMethod;
    private IType indexOrRangeType;
    private IReadOnlyList`1<IParameter> parameters;
    private bool slicing;
    public bool IsSlicing { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ReturnTypeIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ThisIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsInitOnly { get; }
    private IReadOnlyList`1<ITypeParameter> ICSharpCode.Decompiler.TypeSystem.IMethod.TypeParameters { get; }
    private IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IMethod.TypeArguments { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsExtensionMethod { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsLocalFunction { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsConstructor { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsDestructor { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsOperator { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.HasBody { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsAccessor { get; }
    private IMember ICSharpCode.Decompiler.TypeSystem.IMethod.AccessorOwner { get; }
    private MethodSemanticsAttributes ICSharpCode.Decompiler.TypeSystem.IMethod.AccessorKind { get; }
    private IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.ReducedFrom { get; }
    private IReadOnlyList`1<IParameter> ICSharpCode.Decompiler.TypeSystem.IParameterizedMember.Parameters { get; }
    private IMember ICSharpCode.Decompiler.TypeSystem.IMember.MemberDefinition { get; }
    private IType ICSharpCode.Decompiler.TypeSystem.IMember.ReturnType { get; }
    private IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.ExplicitlyImplementedInterfaceMembers { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsExplicitInterfaceImplementation { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsVirtual { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsOverride { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMember.IsOverridable { get; }
    private TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.Substitution { get; }
    private EntityHandle ICSharpCode.Decompiler.TypeSystem.IEntity.MetadataToken { get; }
    public string Name { get; }
    public IType DeclaringType { get; }
    private ITypeDefinition ICSharpCode.Decompiler.TypeSystem.IEntity.DeclaringTypeDefinition { get; }
    private IModule ICSharpCode.Decompiler.TypeSystem.IEntity.ParentModule { get; }
    private Accessibility ICSharpCode.Decompiler.TypeSystem.IEntity.Accessibility { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IEntity.IsStatic { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IEntity.IsAbstract { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IEntity.IsSealed { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    private ICompilation ICSharpCode.Decompiler.TypeSystem.ICompilationProvider.Compilation { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.FullName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.ReflectionName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.INamedElement.Namespace { get; }
    public SyntheticRangeIndexAccessor(IMethod underlyingMethod, IType indexOrRangeType, bool slicing);
    public bool get_IsSlicing();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ReturnTypeIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ThisIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsInitOnly();
    private sealed virtual override IReadOnlyList`1<ITypeParameter> ICSharpCode.Decompiler.TypeSystem.IMethod.get_TypeParameters();
    private sealed virtual override IReadOnlyList`1<IType> ICSharpCode.Decompiler.TypeSystem.IMethod.get_TypeArguments();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsExtensionMethod();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsLocalFunction();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsConstructor();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsDestructor();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsOperator();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_HasBody();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsAccessor();
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMethod.get_AccessorOwner();
    private sealed virtual override MethodSemanticsAttributes ICSharpCode.Decompiler.TypeSystem.IMethod.get_AccessorKind();
    private sealed virtual override IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.get_ReducedFrom();
    private sealed virtual override IReadOnlyList`1<IParameter> ICSharpCode.Decompiler.TypeSystem.IParameterizedMember.get_Parameters();
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.get_MemberDefinition();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.IMember.get_ReturnType();
    private sealed virtual override IEnumerable`1<IMember> ICSharpCode.Decompiler.TypeSystem.IMember.get_ExplicitlyImplementedInterfaceMembers();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsExplicitInterfaceImplementation();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsVirtual();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsOverride();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.get_IsOverridable();
    private sealed virtual override TypeParameterSubstitution ICSharpCode.Decompiler.TypeSystem.IMember.get_Substitution();
    private sealed virtual override EntityHandle ICSharpCode.Decompiler.TypeSystem.IEntity.get_MetadataToken();
    public sealed virtual string get_Name();
    public sealed virtual IType get_DeclaringType();
    private sealed virtual override ITypeDefinition ICSharpCode.Decompiler.TypeSystem.IEntity.get_DeclaringTypeDefinition();
    private sealed virtual override IModule ICSharpCode.Decompiler.TypeSystem.IEntity.get_ParentModule();
    private sealed virtual override Accessibility ICSharpCode.Decompiler.TypeSystem.IEntity.get_Accessibility();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.get_IsStatic();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.get_IsAbstract();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.get_IsSealed();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    private sealed virtual override ICompilation ICSharpCode.Decompiler.TypeSystem.ICompilationProvider.get_Compilation();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_FullName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_ReflectionName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.INamedElement.get_Namespace();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMember.Equals(IMember obj, TypeVisitor typeNormalization);
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.HasAttribute(KnownAttribute attribute);
    private sealed virtual override IAttribute ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttribute(KnownAttribute attribute);
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IMethod.GetReturnTypeAttributes();
    private sealed virtual override IMethod ICSharpCode.Decompiler.TypeSystem.IMethod.Specialize(TypeParameterSubstitution substitution);
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.Specialize(TypeParameterSubstitution substitution);
}
internal static class ICSharpCode.Decompiler.TypeSystem.Implementation.ThreeState : object {
    public static byte Unknown;
    public static byte False;
    public static byte True;
    public static byte From(bool value);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.TypeParameterReference : object {
    private static TypeParameterReference[] classTypeParameterReferences;
    private static TypeParameterReference[] methodTypeParameterReferences;
    private SymbolKind ownerType;
    private int index;
    public int Index { get; }
    public TypeParameterReference(SymbolKind ownerType, int index);
    private static TypeParameterReference();
    public static TypeParameterReference Create(SymbolKind ownerType, int index);
    public int get_Index();
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
}
public abstract class ICSharpCode.Decompiler.TypeSystem.Implementation.TypeWithElementType : AbstractType {
    protected IType elementType;
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string ReflectionName { get; }
    public string NameSuffix { get; }
    public IType ElementType { get; }
    protected TypeWithElementType(IType elementType);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual string get_FullName();
    public virtual string get_ReflectionName();
    public virtual string ToString();
    public abstract virtual string get_NameSuffix();
    public IType get_ElementType();
    public abstract virtual IType VisitChildren(TypeVisitor visitor);
}
public class ICSharpCode.Decompiler.TypeSystem.Implementation.UnknownType : AbstractType {
    private bool namespaceKnown;
    private FullTypeName fullTypeName;
    private Nullable`1<bool> isReferenceType;
    public TypeKind Kind { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string ReflectionName { get; }
    public FullTypeName FullTypeName { get; }
    public int TypeParameterCount { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public UnknownType(string namespaceName, string name, int typeParameterCount, Nullable`1<bool> isReferenceType);
    public UnknownType(FullTypeName fullTypeName, Nullable`1<bool> isReferenceType);
    public virtual TypeKind get_Kind();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.ITypeReference.Resolve(ITypeResolveContext context);
    public virtual ITypeDefinitionOrUnknown GetDefinitionOrUnknown();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual string get_ReflectionName();
    public sealed virtual FullTypeName get_FullTypeName();
    public virtual int get_TypeParameterCount();
    public virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public virtual IReadOnlyList`1<IType> get_TypeArguments();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual IType ChangeNullability(Nullability nullability);
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.INamedElement {
    public string FullName { get; }
    public string Name { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    public abstract virtual string get_FullName();
    public abstract virtual string get_Name();
    public abstract virtual string get_ReflectionName();
    public abstract virtual string get_Namespace();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.INamespace {
    public string ExternAlias { get; }
    public string FullName { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public INamespace ParentNamespace { get; }
    public IEnumerable`1<INamespace> ChildNamespaces { get; }
    public IEnumerable`1<ITypeDefinition> Types { get; }
    public IEnumerable`1<IModule> ContributingModules { get; }
    public abstract virtual string get_ExternAlias();
    public abstract virtual string get_FullName();
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual INamespace get_ParentNamespace();
    public abstract virtual IEnumerable`1<INamespace> get_ChildNamespaces();
    public abstract virtual IEnumerable`1<ITypeDefinition> get_Types();
    public abstract virtual IEnumerable`1<IModule> get_ContributingModules();
    public abstract virtual INamespace GetChildNamespace(string name);
    public abstract virtual ITypeDefinition GetTypeDefinition(string name, int typeParameterCount);
}
public static class ICSharpCode.Decompiler.TypeSystem.InheritanceHelper : object {
    public static IMember GetBaseMember(IMember member);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.InheritanceHelper/<GetBaseMembers>d__1")]
public static IEnumerable`1<IMember> GetBaseMembers(IMember member, bool includeImplementedInterfaces);
    public static IMember GetDerivedMember(IMember baseMember, ITypeDefinition derivedType);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.InheritanceHelper/<GetAttributes>d__3")]
internal static IEnumerable`1<IAttribute> GetAttributes(ITypeDefinition typeDef);
    internal static IAttribute GetAttribute(ITypeDefinition typeDef, KnownAttribute attributeType);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.InheritanceHelper/<GetAttributes>d__5")]
internal static IEnumerable`1<IAttribute> GetAttributes(IMember member);
    internal static IAttribute GetAttribute(IMember member, KnownAttribute attributeType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.TypeSystem.InterningProvider : object {
    [NullableAttribute("1")]
public static InterningProvider Dummy;
    private static InterningProvider();
    public abstract virtual ISupportsInterning Intern(ISupportsInterning obj);
    [NullableContextAttribute("1")]
public T Intern(T obj);
    public abstract virtual string Intern(string text);
    public abstract virtual object InternValue(object obj);
    [NullableContextAttribute("1")]
public abstract virtual IList`1<T> InternList(IList`1<T> list);
}
public class ICSharpCode.Decompiler.TypeSystem.IntersectionType : AbstractType {
    private ReadOnlyCollection`1<IType> types;
    public ReadOnlyCollection`1<IType> Types { get; }
    public TypeKind Kind { get; }
    public string Name { get; }
    public string ReflectionName { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    private IntersectionType(IType[] types);
    public ReadOnlyCollection`1<IType> get_Types();
    public static IType Create(IEnumerable`1<IType> types);
    public virtual TypeKind get_Kind();
    public virtual string get_Name();
    public virtual string get_ReflectionName();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMember> GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    private static Predicate`1<T> FilterNonStatic(Predicate`1<T> filter);
}
public interface ICSharpCode.Decompiler.TypeSystem.IParameter {
    public ReferenceKind ReferenceKind { get; }
    public LifetimeAnnotation Lifetime { get; }
    public bool IsRef { get; }
    public bool IsOut { get; }
    public bool IsIn { get; }
    public bool IsParams { get; }
    public bool IsOptional { get; }
    public bool HasConstantValueInSignature { get; }
    [NullableAttribute("2")]
public IParameterizedMember Owner { get; }
    [NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<IAttribute> GetAttributes();
    public abstract virtual ReferenceKind get_ReferenceKind();
    public abstract virtual LifetimeAnnotation get_Lifetime();
    public abstract virtual bool get_IsRef();
    public abstract virtual bool get_IsOut();
    public abstract virtual bool get_IsIn();
    public abstract virtual bool get_IsParams();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_HasConstantValueInSignature();
    [NullableContextAttribute("2")]
public abstract virtual IParameterizedMember get_Owner();
}
public interface ICSharpCode.Decompiler.TypeSystem.IParameterizedMember {
    [NullableAttribute("1")]
public IReadOnlyList`1<IParameter> Parameters { get; }
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyList`1<IParameter> get_Parameters();
}
public interface ICSharpCode.Decompiler.TypeSystem.IProperty {
    [MemberNotNullWhenAttribute("True", "Getter")]
public bool CanGet { get; }
    [MemberNotNullWhenAttribute("True", "Setter")]
public bool CanSet { get; }
    [NullableAttribute("2")]
public IMethod Getter { get; }
    [NullableAttribute("2")]
public IMethod Setter { get; }
    public bool IsIndexer { get; }
    public bool ReturnTypeIsRefReadOnly { get; }
    [MemberNotNullWhenAttribute("True", "Getter")]
public abstract virtual bool get_CanGet();
    [MemberNotNullWhenAttribute("True", "Setter")]
public abstract virtual bool get_CanSet();
    [NullableContextAttribute("2")]
public abstract virtual IMethod get_Getter();
    [NullableContextAttribute("2")]
public abstract virtual IMethod get_Setter();
    public abstract virtual bool get_IsIndexer();
    public abstract virtual bool get_ReturnTypeIsRefReadOnly();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.ISupportsInterning {
    public abstract virtual int GetHashCodeForInterning();
    public abstract virtual bool EqualsForInterning(ISupportsInterning other);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.ISymbol {
    public SymbolKind SymbolKind { get; }
    public string Name { get; }
    public abstract virtual SymbolKind get_SymbolKind();
    public abstract virtual string get_Name();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IType {
    public TypeKind Kind { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public bool IsByRefLike { get; }
    public Nullability Nullability { get; }
    [NullableAttribute("2")]
public IType DeclaringType { get; }
    public int TypeParameterCount { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    public abstract virtual TypeKind get_Kind();
    public abstract virtual Nullable`1<bool> get_IsReferenceType();
    public abstract virtual bool get_IsByRefLike();
    public abstract virtual Nullability get_Nullability();
    public abstract virtual IType ChangeNullability(Nullability newNullability);
    [NullableContextAttribute("2")]
public abstract virtual ITypeDefinition GetDefinition();
    [NullableContextAttribute("2")]
public abstract virtual ITypeDefinitionOrUnknown GetDefinitionOrUnknown();
    [NullableContextAttribute("2")]
public abstract virtual IType get_DeclaringType();
    public abstract virtual int get_TypeParameterCount();
    public abstract virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public abstract virtual IReadOnlyList`1<IType> get_TypeArguments();
    public abstract virtual IType AcceptVisitor(TypeVisitor visitor);
    public abstract virtual IType VisitChildren(TypeVisitor visitor);
    public abstract virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public abstract virtual TypeParameterSubstitution GetSubstitution();
    public abstract virtual IEnumerable`1<IType> GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IType> GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IMethod> GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IMember> GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    public abstract virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.ITypeDefinition {
    public IReadOnlyList`1<ITypeDefinition> NestedTypes { get; }
    public IReadOnlyList`1<IMember> Members { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public KnownTypeCode KnownTypeCode { get; }
    [NullableAttribute("2")]
public IType EnumUnderlyingType { get; }
    public bool IsReadOnly { get; }
    public string MetadataName { get; }
    [NullableAttribute("2")]
public IType DeclaringType { get; }
    public bool HasExtensionMethods { get; }
    public Nullability NullableContext { get; }
    public bool IsRecord { get; }
    public abstract virtual IReadOnlyList`1<ITypeDefinition> get_NestedTypes();
    public abstract virtual IReadOnlyList`1<IMember> get_Members();
    public abstract virtual IEnumerable`1<IField> get_Fields();
    public abstract virtual IEnumerable`1<IMethod> get_Methods();
    public abstract virtual IEnumerable`1<IProperty> get_Properties();
    public abstract virtual IEnumerable`1<IEvent> get_Events();
    public abstract virtual KnownTypeCode get_KnownTypeCode();
    [NullableContextAttribute("2")]
public abstract virtual IType get_EnumUnderlyingType();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual string get_MetadataName();
    [NullableContextAttribute("2")]
public abstract virtual IType get_DeclaringType();
    public abstract virtual bool get_HasExtensionMethods();
    public abstract virtual Nullability get_NullableContext();
    public abstract virtual bool get_IsRecord();
}
public interface ICSharpCode.Decompiler.TypeSystem.ITypeDefinitionOrUnknown {
    public FullTypeName FullTypeName { get; }
    public abstract virtual FullTypeName get_FullTypeName();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.ITypeParameter {
    public SymbolKind OwnerType { get; }
    [NullableAttribute("2")]
public IEntity Owner { get; }
    public int Index { get; }
    public string Name { get; }
    public VarianceModifier Variance { get; }
    public IType EffectiveBaseClass { get; }
    public IReadOnlyCollection`1<IType> EffectiveInterfaceSet { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasUnmanagedConstraint { get; }
    public Nullability NullabilityConstraint { get; }
    public IReadOnlyList`1<TypeConstraint> TypeConstraints { get; }
    public abstract virtual SymbolKind get_OwnerType();
    [NullableContextAttribute("2")]
public abstract virtual IEntity get_Owner();
    public abstract virtual int get_Index();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<IAttribute> GetAttributes();
    public abstract virtual VarianceModifier get_Variance();
    public abstract virtual IType get_EffectiveBaseClass();
    public abstract virtual IReadOnlyCollection`1<IType> get_EffectiveInterfaceSet();
    public abstract virtual bool get_HasDefaultConstructorConstraint();
    public abstract virtual bool get_HasReferenceTypeConstraint();
    public abstract virtual bool get_HasValueTypeConstraint();
    public abstract virtual bool get_HasUnmanagedConstraint();
    public abstract virtual Nullability get_NullabilityConstraint();
    public abstract virtual IReadOnlyList`1<TypeConstraint> get_TypeConstraints();
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.ITypeReference {
    public abstract virtual IType Resolve(ITypeResolveContext context);
}
[NullableContextAttribute("2")]
public interface ICSharpCode.Decompiler.TypeSystem.ITypeResolveContext {
    public IModule CurrentModule { get; }
    public ITypeDefinition CurrentTypeDefinition { get; }
    public IMember CurrentMember { get; }
    public abstract virtual IModule get_CurrentModule();
    public abstract virtual ITypeDefinition get_CurrentTypeDefinition();
    public abstract virtual IMember get_CurrentMember();
    [NullableContextAttribute("1")]
public abstract virtual ITypeResolveContext WithCurrentTypeDefinition(ITypeDefinition typeDefinition);
    [NullableContextAttribute("1")]
public abstract virtual ITypeResolveContext WithCurrentMember(IMember member);
}
[NullableContextAttribute("1")]
public interface ICSharpCode.Decompiler.TypeSystem.IVariable {
    public string Name { get; }
    public IType Type { get; }
    public bool IsConst { get; }
    public abstract virtual string get_Name();
    public abstract virtual IType get_Type();
    public abstract virtual bool get_IsConst();
    [NullableContextAttribute("2")]
public abstract virtual object GetConstantValue(bool throwOnInvalidMetadata);
}
public enum ICSharpCode.Decompiler.TypeSystem.KnownAttribute : Enum {
    public int value__;
    public static KnownAttribute None;
    public static KnownAttribute CompilerGenerated;
    public static KnownAttribute CompilerFeatureRequired;
    public static KnownAttribute Extension;
    public static KnownAttribute Dynamic;
    public static KnownAttribute TupleElementNames;
    public static KnownAttribute Nullable;
    public static KnownAttribute NullableContext;
    public static KnownAttribute NullablePublicOnly;
    public static KnownAttribute Conditional;
    public static KnownAttribute Obsolete;
    public static KnownAttribute Embedded;
    public static KnownAttribute IsReadOnly;
    public static KnownAttribute SpecialName;
    public static KnownAttribute DebuggerHidden;
    public static KnownAttribute DebuggerStepThrough;
    public static KnownAttribute DebuggerBrowsable;
    public static KnownAttribute AssemblyVersion;
    public static KnownAttribute InternalsVisibleTo;
    public static KnownAttribute TypeForwardedTo;
    public static KnownAttribute ReferenceAssembly;
    public static KnownAttribute Serializable;
    public static KnownAttribute Flags;
    public static KnownAttribute ComImport;
    public static KnownAttribute CoClass;
    public static KnownAttribute StructLayout;
    public static KnownAttribute DefaultMember;
    public static KnownAttribute IsByRefLike;
    public static KnownAttribute IteratorStateMachine;
    public static KnownAttribute AsyncStateMachine;
    public static KnownAttribute AsyncMethodBuilder;
    public static KnownAttribute AsyncIteratorStateMachine;
    public static KnownAttribute FieldOffset;
    public static KnownAttribute NonSerialized;
    public static KnownAttribute DecimalConstant;
    public static KnownAttribute FixedBuffer;
    public static KnownAttribute DllImport;
    public static KnownAttribute PreserveSig;
    public static KnownAttribute MethodImpl;
    public static KnownAttribute IndexerName;
    public static KnownAttribute ParamArray;
    public static KnownAttribute In;
    public static KnownAttribute Out;
    public static KnownAttribute Optional;
    public static KnownAttribute DefaultParameterValue;
    public static KnownAttribute CallerMemberName;
    public static KnownAttribute CallerFilePath;
    public static KnownAttribute CallerLineNumber;
    public static KnownAttribute ScopedRef;
    public static KnownAttribute IsUnmanaged;
    public static KnownAttribute MarshalAs;
    public static KnownAttribute PermissionSet;
    public static KnownAttribute NativeInteger;
    public static KnownAttribute PreserveBaseOverrides;
    public static KnownAttribute RequiredAttribute;
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.TypeSystem.KnownAttributes : object {
    internal static int Count;
    private static TopLevelTypeName[] typeNames;
    private static KnownAttributes();
    [ExtensionAttribute]
public static TopLevelTypeName& modreq(System.Runtime.InteropServices.InAttribute) GetTypeName(KnownAttribute attr);
    [ExtensionAttribute]
public static IType FindType(ICompilation compilation, KnownAttribute attrType);
    [ExtensionAttribute]
public static KnownAttribute IsKnownAttributeType(ITypeDefinition attributeType);
    [ExtensionAttribute]
public static bool IsCustomAttribute(KnownAttribute knownAttribute);
}
public enum ICSharpCode.Decompiler.TypeSystem.KnownTypeCode : Enum {
    public int value__;
    public static KnownTypeCode None;
    public static KnownTypeCode Object;
    public static KnownTypeCode DBNull;
    public static KnownTypeCode Boolean;
    public static KnownTypeCode Char;
    public static KnownTypeCode SByte;
    public static KnownTypeCode Byte;
    public static KnownTypeCode Int16;
    public static KnownTypeCode UInt16;
    public static KnownTypeCode Int32;
    public static KnownTypeCode UInt32;
    public static KnownTypeCode Int64;
    public static KnownTypeCode UInt64;
    public static KnownTypeCode Single;
    public static KnownTypeCode Double;
    public static KnownTypeCode Decimal;
    public static KnownTypeCode DateTime;
    public static KnownTypeCode String;
    public static KnownTypeCode Void;
    public static KnownTypeCode Type;
    public static KnownTypeCode Array;
    public static KnownTypeCode Attribute;
    public static KnownTypeCode ValueType;
    public static KnownTypeCode Enum;
    public static KnownTypeCode Delegate;
    public static KnownTypeCode MulticastDelegate;
    public static KnownTypeCode Exception;
    public static KnownTypeCode IntPtr;
    public static KnownTypeCode UIntPtr;
    public static KnownTypeCode IEnumerable;
    public static KnownTypeCode IEnumerator;
    public static KnownTypeCode IEnumerableOfT;
    public static KnownTypeCode IEnumeratorOfT;
    public static KnownTypeCode ICollection;
    public static KnownTypeCode ICollectionOfT;
    public static KnownTypeCode IList;
    public static KnownTypeCode IListOfT;
    public static KnownTypeCode IReadOnlyCollectionOfT;
    public static KnownTypeCode IReadOnlyListOfT;
    public static KnownTypeCode Task;
    public static KnownTypeCode TaskOfT;
    public static KnownTypeCode ValueTask;
    public static KnownTypeCode ValueTaskOfT;
    public static KnownTypeCode NullableOfT;
    public static KnownTypeCode IDisposable;
    public static KnownTypeCode IAsyncDisposable;
    public static KnownTypeCode INotifyCompletion;
    public static KnownTypeCode ICriticalNotifyCompletion;
    public static KnownTypeCode TypedReference;
    public static KnownTypeCode IFormattable;
    public static KnownTypeCode FormattableString;
    public static KnownTypeCode DefaultInterpolatedStringHandler;
    public static KnownTypeCode SpanOfT;
    public static KnownTypeCode ReadOnlySpanOfT;
    public static KnownTypeCode MemoryOfT;
    public static KnownTypeCode Unsafe;
    public static KnownTypeCode IAsyncEnumerableOfT;
    public static KnownTypeCode IAsyncEnumeratorOfT;
    public static KnownTypeCode Index;
    public static KnownTypeCode Range;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.TypeSystem.KnownTypeReference : object {
    internal static int KnownTypeCodeCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static KnownTypeReference[] knownTypeReferences;
    private KnownTypeCode knownTypeCode;
    private string namespaceName;
    private string name;
    private int typeParameterCount;
    internal KnownTypeCode baseType;
    internal TypeKind typeKind;
    public static IEnumerable`1<KnownTypeReference> AllKnownTypes { get; }
    public KnownTypeCode KnownTypeCode { get; }
    public string Namespace { get; }
    public string Name { get; }
    public int TypeParameterCount { get; }
    public TopLevelTypeName TypeName { get; }
    private KnownTypeReference(KnownTypeCode knownTypeCode, TypeKind typeKind, string namespaceName, string name, int typeParameterCount, KnownTypeCode baseType);
    private static KnownTypeReference();
    [NullableContextAttribute("2")]
public static KnownTypeReference Get(KnownTypeCode typeCode);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.KnownTypeReference/<get_AllKnownTypes>d__4")]
public static IEnumerable`1<KnownTypeReference> get_AllKnownTypes();
    public KnownTypeCode get_KnownTypeCode();
    public string get_Namespace();
    public string get_Name();
    public int get_TypeParameterCount();
    public TopLevelTypeName get_TypeName();
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static string GetCSharpNameByTypeCode(KnownTypeCode knownTypeCode);
}
public class ICSharpCode.Decompiler.TypeSystem.LifetimeAnnotation : ValueType {
    [ObsoleteAttribute("Use ScopedRef property instead of directly accessing this field")]
public bool RefScoped;
    [ObsoleteAttribute("C# 11 preview: "ref scoped" no longer supported")]
public bool ValueScoped;
    public bool ScopedRef { get; public set; }
    public bool get_ScopedRef();
    public void set_ScopedRef(bool value);
}
[DebuggerDisplayAttribute("<MetadataModule: {AssemblyName}>")]
public class ICSharpCode.Decompiler.TypeSystem.MetadataModule : object {
    [CompilerGeneratedAttribute]
private ICompilation <Compilation>k__BackingField;
    internal MetadataReader metadata;
    private TypeSystemOptions options;
    internal TypeProvider TypeProvider;
    internal Nullability NullableContext;
    private MetadataNamespace rootNamespace;
    private MetadataTypeDefinition[] typeDefs;
    private MetadataField[] fieldDefs;
    private MetadataMethod[] methodDefs;
    private MetadataProperty[] propertyDefs;
    private MetadataEvent[] eventDefs;
    private IModule[] referencedAssemblies;
    [CompilerGeneratedAttribute]
private PEFile <PEFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullAssemblyName>k__BackingField;
    private String[] internalsVisibleTo;
    private static NormalizeTypeVisitor normalizeTypeVisitor;
    private IType[] knownAttributeTypes;
    private IAttribute[] knownAttributes;
    private Accessibility minAccessibilityForNRT;
    public ICompilation Compilation { get; }
    public TypeSystemOptions TypeSystemOptions { get; }
    public PEFile PEFile { get; }
    public bool IsMainModule { get; }
    public string AssemblyName { get; }
    public Version AssemblyVersion { get; }
    public string FullAssemblyName { get; }
    private string ICSharpCode.Decompiler.TypeSystem.ISymbol.Name { get; }
    private SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.SymbolKind { get; }
    public INamespace RootNamespace { get; }
    public IEnumerable`1<ITypeDefinition> TopLevelTypeDefinitions { get; }
    public IEnumerable`1<ITypeDefinition> TypeDefinitions { get; }
    internal bool IncludeInternalMembers { get; }
    internal MetadataModule(ICompilation compilation, PEFile peFile, TypeSystemOptions options);
    private static MetadataModule();
    [CompilerGeneratedAttribute]
public sealed virtual ICompilation get_Compilation();
    internal string GetString(StringHandle name);
    public TypeSystemOptions get_TypeSystemOptions();
    [CompilerGeneratedAttribute]
public sealed virtual PEFile get_PEFile();
    public sealed virtual bool get_IsMainModule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssemblyName();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullAssemblyName();
    private sealed virtual override string ICSharpCode.Decompiler.TypeSystem.ISymbol.get_Name();
    private sealed virtual override SymbolKind ICSharpCode.Decompiler.TypeSystem.ISymbol.get_SymbolKind();
    public sealed virtual INamespace get_RootNamespace();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_TopLevelTypeDefinitions();
    public sealed virtual ITypeDefinition GetTypeDefinition(TopLevelTypeName topLevelTypeName);
    public sealed virtual bool InternalsVisibleTo(IModule module);
    private String[] GetInternalsVisibleTo();
    private static string GetShortName(string fullAssemblyName);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.MetadataModule/<get_TypeDefinitions>d__46")]
public sealed virtual IEnumerable`1<ITypeDefinition> get_TypeDefinitions();
    public ITypeDefinition GetDefinition(TypeDefinitionHandle handle);
    public IField GetDefinition(FieldDefinitionHandle handle);
    public IMethod GetDefinition(MethodDefinitionHandle handle);
    public IProperty GetDefinition(PropertyDefinitionHandle handle);
    public IEvent GetDefinition(EventDefinitionHandle handle);
    private void HandleOutOfRange(EntityHandle handle);
    public IModule ResolveModule(AssemblyReferenceHandle handle);
    private IModule ResolveModuleUncached(AssemblyReferenceHandle handle);
    public IModule ResolveModule(ModuleReferenceHandle handle);
    public IModule GetDeclaringModule(TypeReferenceHandle handle);
    public IType ResolveType(EntityHandle typeRefDefSpec, GenericContext context, Nullable`1<CustomAttributeHandleCollection> typeAttributes, Nullability nullableContext);
    public IType ResolveType(EntityHandle typeRefDefSpec, GenericContext context, TypeSystemOptions customOptions, Nullable`1<CustomAttributeHandleCollection> typeAttributes, Nullability nullableContext);
    private IType ResolveDeclaringType(EntityHandle declaringTypeReference, GenericContext context);
    private IType IntroduceTupleTypes(IType ty);
    public IMethod ResolveMethod(EntityHandle methodReference, GenericContext context);
    private IMethod ResolveMethodDefinition(MethodDefinitionHandle methodDefHandle, bool expandVarArgs);
    private IMethod ResolveMethodSpecification(MethodSpecificationHandle methodSpecHandle, GenericContext context, bool expandVarArgs);
    private IMethod ResolveMethodReference(MemberReferenceHandle memberRefHandle, GenericContext context, IReadOnlyList`1<IType> methodTypeArguments, bool expandVarArgs);
    private static bool CompareTypes(IType a, IType b);
    private static bool CompareSignatures(IReadOnlyList`1<IParameter> parameters, ImmutableArray`1<IType> parameterTypes);
    private IMethod CreateFakeMethod(IType declaringType, string name, MethodSignature`1<IType> signature);
    private void GuessFakeMethodAccessor(IType declaringType, string name, MethodSignature`1<IType> signature, FakeMethod m, List`1<IParameter> parameters);
    public IEntity ResolveEntity(EntityHandle entityHandle, GenericContext context);
    private IField ResolveFieldReference(MemberReferenceHandle memberReferenceHandle, GenericContext context);
    public ValueTuple`2<SignatureHeader, FunctionPointerType> DecodeMethodSignature(StandaloneSignatureHandle handle, GenericContext genericContext);
    public ImmutableArray`1<IType> DecodeLocalSignature(StandaloneSignatureHandle handle, GenericContext genericContext);
    public sealed virtual IEnumerable`1<IAttribute> GetAssemblyAttributes();
    public sealed virtual IEnumerable`1<IAttribute> GetModuleAttributes();
    private void AddTypeForwarderAttributes(AttributeListBuilder& b);
    private IType ResolveForwardedType(ExportedType forwarder);
    internal IType GetAttributeType(KnownAttribute attr);
    internal IAttribute MakeAttribute(KnownAttribute type);
    internal bool get_IncludeInternalMembers();
    internal bool IsVisible(FieldAttributes att);
    internal bool IsVisible(MethodAttributes att);
    private static Accessibility FindMinimumAccessibilityForNRT(MetadataReader metadata, CustomAttributeHandleCollection customAttributes);
    internal bool ShouldDecodeNullableAttributes(IEntity entity);
    internal TypeSystemOptions OptionsForEntity(IEntity entity);
    [CompilerGeneratedAttribute]
private IModule <ResolveForwardedType>g__ResolveModule|77_0(ExportedType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ICSharpCode.Decompiler.TypeSystem.NormalizeTypeVisitor : TypeVisitor {
    internal static NormalizeTypeVisitor TypeErasure;
    internal static NormalizeTypeVisitor IgnoreNullabilityAndTuples;
    public bool RemoveModOpt;
    public bool RemoveModReq;
    public bool ReplaceClassTypeParametersWithDummy;
    public bool ReplaceMethodTypeParametersWithDummy;
    public bool DynamicAndObject;
    public bool IntPtrToNInt;
    public bool TupleToUnderlyingType;
    public bool RemoveNullability;
    private static NormalizeTypeVisitor();
    public bool EquivalentTypes(IType a, IType b);
    public virtual IType VisitTypeParameter(ITypeParameter type);
    public virtual IType VisitTypeDefinition(ITypeDefinition type);
    public virtual IType VisitTupleType(TupleType type);
    public virtual IType VisitNullabilityAnnotatedType(NullabilityAnnotatedType type);
    public virtual IType VisitArrayType(ArrayType type);
    public virtual IType VisitModOpt(ModifiedType type);
    public virtual IType VisitModReq(ModifiedType type);
}
public enum ICSharpCode.Decompiler.TypeSystem.Nullability : Enum {
    public byte value__;
    public static Nullability Oblivious;
    public static Nullability NotNullable;
    public static Nullability Nullable;
}
public static class ICSharpCode.Decompiler.TypeSystem.NullableType : object {
    public static bool IsNullable(IType type);
    public static bool IsNonNullableValueType(IType type);
    public static IType GetUnderlyingType(IType type);
    public static IType Create(ICompilation compilation, IType elementType);
    public static ParameterizedTypeReference Create(ITypeReference elementType);
}
public class ICSharpCode.Decompiler.TypeSystem.ParameterizedType : object {
    private IType genericType;
    private IType[] typeArguments;
    public TypeKind Kind { get; }
    public IType GenericType { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public bool IsByRefLike { get; }
    public Nullability Nullability { get; }
    public IType DeclaringType { get; }
    public int TypeParameterCount { get; }
    public string FullName { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string ReflectionName { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    public ParameterizedType(IType genericType, IEnumerable`1<IType> typeArguments);
    internal ParameterizedType(IType genericType, IType[] typeArguments);
    public sealed virtual TypeKind get_Kind();
    public IType get_GenericType();
    public sealed virtual Nullable`1<bool> get_IsReferenceType();
    public sealed virtual bool get_IsByRefLike();
    public sealed virtual Nullability get_Nullability();
    public sealed virtual IType ChangeNullability(Nullability nullability);
    public sealed virtual IType get_DeclaringType();
    public sealed virtual int get_TypeParameterCount();
    public sealed virtual string get_FullName();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string get_ReflectionName();
    public virtual string ToString();
    public sealed virtual IReadOnlyList`1<IType> get_TypeArguments();
    public IType GetTypeArgument(int index);
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual ITypeDefinition GetDefinition();
    public sealed virtual ITypeDefinitionOrUnknown GetDefinitionOrUnknown();
    public sealed virtual TypeParameterSubstitution GetSubstitution();
    public TypeParameterSubstitution GetSubstitution(IReadOnlyList`1<IType> methodTypeArguments);
    public sealed virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public sealed virtual IEnumerable`1<IType> GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IType> GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMember> GetMembers(Predicate`1<IMember> filter, GetMemberOptions options);
    public sealed virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IType other);
    public virtual int GetHashCode();
    public sealed virtual IType AcceptVisitor(TypeVisitor visitor);
    public sealed virtual IType VisitChildren(TypeVisitor visitor);
}
public class ICSharpCode.Decompiler.TypeSystem.ParameterizedTypeReference : object {
    private ITypeReference genericType;
    private ITypeReference[] typeArguments;
    public ITypeReference GenericType { get; }
    public IReadOnlyList`1<ITypeReference> TypeArguments { get; }
    public ParameterizedTypeReference(ITypeReference genericType, IEnumerable`1<ITypeReference> typeArguments);
    public ITypeReference get_GenericType();
    public IReadOnlyList`1<ITypeReference> get_TypeArguments();
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public class ICSharpCode.Decompiler.TypeSystem.ParameterListComparer : object {
    public static ParameterListComparer Instance;
    private static NormalizeTypeVisitor normalizationVisitor;
    private bool includeModifiers;
    private static ParameterListComparer();
    public static ParameterListComparer WithOptions(bool includeModifiers);
    public sealed virtual bool Equals(IReadOnlyList`1<IParameter> x, IReadOnlyList`1<IParameter> y);
    public sealed virtual int GetHashCode(IReadOnlyList`1<IParameter> obj);
}
public class ICSharpCode.Decompiler.TypeSystem.PointerType : TypeWithElementType {
    public TypeKind Kind { get; }
    public string NameSuffix { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public PointerType(IType elementType);
    public virtual TypeKind get_Kind();
    public virtual string get_NameSuffix();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual int GetHashCode();
    public virtual bool Equals(IType other);
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual IType VisitChildren(TypeVisitor visitor);
}
public class ICSharpCode.Decompiler.TypeSystem.PointerTypeReference : object {
    private ITypeReference elementType;
    public ITypeReference ElementType { get; }
    public PointerTypeReference(ITypeReference elementType);
    public ITypeReference get_ElementType();
    public sealed virtual IType Resolve(ITypeResolveContext context);
    public virtual string ToString();
    private sealed virtual override int ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.GetHashCodeForInterning();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.ISupportsInterning.EqualsForInterning(ISupportsInterning other);
}
public enum ICSharpCode.Decompiler.TypeSystem.ReferenceKind : Enum {
    public byte value__;
    public static ReferenceKind None;
    public static ReferenceKind Out;
    public static ReferenceKind Ref;
    public static ReferenceKind In;
}
public class ICSharpCode.Decompiler.TypeSystem.ReferenceResolvingException : Exception {
    public ReferenceResolvingException(string message);
    public ReferenceResolvingException(string message, Exception inner);
    protected ReferenceResolvingException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.TypeSystem.ReflectionHelper : object {
    [ExtensionAttribute]
public static IType FindType(ICompilation compilation, Type type);
    [ExtensionAttribute]
public static IType FindType(ICompilation compilation, StackType stackType, Sign sign);
    [ExtensionAttribute]
public static ITypeReference ToTypeReference(Type type);
    public static string SplitTypeParameterCountFromReflectionName(string reflectionName);
    public static string SplitTypeParameterCountFromReflectionName(string reflectionName, Int32& typeParameterCount);
    [ExtensionAttribute]
public static IType FindType(ICompilation compilation, TypeCode typeCode);
    [ExtensionAttribute]
public static ITypeReference ToTypeReference(TypeCode typeCode);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(IType type);
    public static ITypeReference ParseReflectionName(string reflectionTypeName);
    private static bool IsReflectionNameSpecialCharacter(char c);
    private static ITypeReference ParseReflectionName(string reflectionTypeName, Int32& pos, bool local);
    private static ITypeReference CreateGetClassTypeReference(string assemblyName, string typeName, int tpc);
    private static string SkipAheadAndReadAssemblyName(string reflectionTypeName, int pos);
    private static string ReadTypeName(string reflectionTypeName, Int32& pos, Int32& tpc);
    internal static int ReadTypeParameterCount(string reflectionTypeName, Int32& pos);
}
public class ICSharpCode.Decompiler.TypeSystem.ReflectionNameParseException : Exception {
    private int position;
    public int Position { get; }
    public ReflectionNameParseException(int position);
    public ReflectionNameParseException(int position, string message);
    public ReflectionNameParseException(int position, string message, Exception innerException);
    protected ReflectionNameParseException(SerializationInfo info, StreamingContext context);
    public int get_Position();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum ICSharpCode.Decompiler.TypeSystem.Sign : Enum {
    public byte value__;
    public static Sign None;
    public static Sign Signed;
    public static Sign Unsigned;
}
public class ICSharpCode.Decompiler.TypeSystem.SignatureComparer : object {
    private StringComparer nameComparer;
    public static SignatureComparer Ordinal;
    public SignatureComparer(StringComparer nameComparer);
    private static SignatureComparer();
    public sealed virtual bool Equals(IMember x, IMember y);
    public sealed virtual int GetHashCode(IMember obj);
}
public class ICSharpCode.Decompiler.TypeSystem.SimpleTypeResolveContext : object {
    private ICompilation compilation;
    private IModule currentModule;
    private ITypeDefinition currentTypeDefinition;
    private IMember currentMember;
    public ICompilation Compilation { get; }
    public IModule CurrentModule { get; }
    public ITypeDefinition CurrentTypeDefinition { get; }
    public IMember CurrentMember { get; }
    public SimpleTypeResolveContext(ICompilation compilation);
    public SimpleTypeResolveContext(IModule module);
    public SimpleTypeResolveContext(IEntity entity);
    private SimpleTypeResolveContext(ICompilation compilation, IModule currentModule, ITypeDefinition currentTypeDefinition, IMember currentMember);
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual IModule get_CurrentModule();
    public sealed virtual ITypeDefinition get_CurrentTypeDefinition();
    public sealed virtual IMember get_CurrentMember();
    public sealed virtual ITypeResolveContext WithCurrentTypeDefinition(ITypeDefinition typeDefinition);
    public sealed virtual ITypeResolveContext WithCurrentMember(IMember member);
}
public class ICSharpCode.Decompiler.TypeSystem.SpecialType : AbstractType {
    public static SpecialType UnknownType;
    public static SpecialType NullType;
    public static SpecialType NoType;
    public static SpecialType Dynamic;
    public static SpecialType NInt;
    public static SpecialType NUInt;
    public static SpecialType ArgList;
    public static SpecialType UnboundTypeArgument;
    private TypeKind kind;
    private string name;
    private Nullable`1<bool> isReferenceType;
    public string Name { get; }
    public TypeKind Kind { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    private SpecialType(TypeKind kind, string name, Nullable`1<bool> isReferenceType);
    private static SpecialType();
    public virtual string get_Name();
    public virtual TypeKind get_Kind();
    public virtual Nullable`1<bool> get_IsReferenceType();
    private sealed virtual override IType ICSharpCode.Decompiler.TypeSystem.ITypeReference.Resolve(ITypeResolveContext context);
    [ObsoleteAttribute("Please compare special types using the kind property instead.")]
public virtual bool Equals(IType other);
    public virtual int GetHashCode();
    public virtual IType ChangeNullability(Nullability nullability);
}
public enum ICSharpCode.Decompiler.TypeSystem.SymbolKind : Enum {
    public byte value__;
    public static SymbolKind None;
    public static SymbolKind Module;
    public static SymbolKind TypeDefinition;
    public static SymbolKind Field;
    public static SymbolKind Property;
    public static SymbolKind Indexer;
    public static SymbolKind Event;
    public static SymbolKind Method;
    public static SymbolKind Operator;
    public static SymbolKind Constructor;
    public static SymbolKind Destructor;
    public static SymbolKind Accessor;
    public static SymbolKind Namespace;
    public static SymbolKind Variable;
    public static SymbolKind Parameter;
    public static SymbolKind TypeParameter;
    public static SymbolKind Constraint;
    public static SymbolKind ReturnType;
}
public static class ICSharpCode.Decompiler.TypeSystem.TaskType : object {
    private static string ns;
    public static IType UnpackTask(ICompilation compilation, IType type);
    public static bool IsTask(IType type);
    public static bool IsCustomTask(IType type, IType& builderType);
    public static bool IsNonGenericTaskType(IType task, FullTypeName& builderTypeName);
    public static bool IsGenericTaskType(IType task, FullTypeName& builderTypeName);
    public static IType Create(ICompilation compilation, IType elementType);
}
[IsReadOnlyAttribute]
public class ICSharpCode.Decompiler.TypeSystem.TopLevelTypeName : ValueType {
    private string namespaceName;
    private string name;
    private int typeParameterCount;
    public string Namespace { get; }
    public string Name { get; }
    public int TypeParameterCount { get; }
    public string ReflectionName { get; }
    public TopLevelTypeName(string namespaceName, string name, int typeParameterCount);
    public TopLevelTypeName(string reflectionName);
    public string get_Namespace();
    public string get_Name();
    public int get_TypeParameterCount();
    public string get_ReflectionName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TopLevelTypeName other);
    public virtual int GetHashCode();
    public static bool op_Equality(TopLevelTypeName lhs, TopLevelTypeName rhs);
    public static bool op_Inequality(TopLevelTypeName lhs, TopLevelTypeName rhs);
}
public class ICSharpCode.Decompiler.TypeSystem.TopLevelTypeNameComparer : object {
    public static TopLevelTypeNameComparer Ordinal;
    public static TopLevelTypeNameComparer OrdinalIgnoreCase;
    public StringComparer NameComparer;
    public TopLevelTypeNameComparer(StringComparer nameComparer);
    private static TopLevelTypeNameComparer();
    public sealed virtual bool Equals(TopLevelTypeName x, TopLevelTypeName y);
    public sealed virtual int GetHashCode(TopLevelTypeName obj);
}
public class ICSharpCode.Decompiler.TypeSystem.TupleType : AbstractType {
    public static int RestPosition;
    private static int RestIndex;
    [CompilerGeneratedAttribute]
private ICompilation <Compilation>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterizedType <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IType> <ElementTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ElementNames>k__BackingField;
    public ICompilation Compilation { get; }
    public ParameterizedType UnderlyingType { get; }
    public ImmutableArray`1<IType> ElementTypes { get; }
    public int Cardinality { get; }
    public ImmutableArray`1<string> ElementNames { get; }
    public TypeKind Kind { get; }
    public Nullable`1<bool> IsReferenceType { get; }
    public int TypeParameterCount { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public IEnumerable`1<IType> DirectBaseTypes { get; }
    public string FullName { get; }
    public string Name { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    public TupleType(ICompilation compilation, ImmutableArray`1<IType> elementTypes, ImmutableArray`1<string> elementNames, IModule valueTupleAssembly);
    [CompilerGeneratedAttribute]
public sealed virtual ICompilation get_Compilation();
    [CompilerGeneratedAttribute]
public ParameterizedType get_UnderlyingType();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IType> get_ElementTypes();
    public int get_Cardinality();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ElementNames();
    private static ParameterizedType CreateUnderlyingType(ICompilation compilation, ImmutableArray`1<IType> elementTypes, IModule valueTupleAssembly);
    private static IType FindValueTupleType(ICompilation compilation, IModule valueTupleAssembly, int tpc);
    public static bool IsTupleCompatible(IType type, Int32& tupleCardinality);
    public static TupleType FromUnderlyingType(ICompilation compilation, IType type);
    public static ImmutableArray`1<IType> GetTupleElementTypes(IType tupleType);
    public virtual TypeKind get_Kind();
    public virtual Nullable`1<bool> get_IsReferenceType();
    public virtual int get_TypeParameterCount();
    public virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public virtual IReadOnlyList`1<IType> get_TypeArguments();
    public virtual IEnumerable`1<IType> get_DirectBaseTypes();
    public virtual string get_FullName();
    public virtual string get_Name();
    public virtual string get_ReflectionName();
    public virtual string get_Namespace();
    public virtual bool Equals(IType other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual IType AcceptVisitor(TypeVisitor visitor);
    public virtual IType VisitChildren(TypeVisitor visitor);
    public virtual IEnumerable`1<IMethod> GetAccessors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetConstructors(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual ITypeDefinition GetDefinition();
    public virtual ITypeDefinitionOrUnknown GetDefinitionOrUnknown();
    public virtual IEnumerable`1<IEvent> GetEvents(Predicate`1<IEvent> filter, GetMemberOptions options);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.TupleType/<GetFields>d__52")]
public virtual IEnumerable`1<IField> GetFields(Predicate`1<IField> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IMethod> GetMethods(IReadOnlyList`1<IType> typeArguments, Predicate`1<IMethod> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IType> GetNestedTypes(Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IType> GetNestedTypes(IReadOnlyList`1<IType> typeArguments, Predicate`1<ITypeDefinition> filter, GetMemberOptions options);
    public virtual IEnumerable`1<IProperty> GetProperties(Predicate`1<IProperty> filter, GetMemberOptions options);
    [CompilerGeneratedAttribute]
internal static bool <GetTupleElementTypes>g__Collect|21_0(IType type, <>c__DisplayClass21_0& );
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.TypeSystem.TupleTypeExtensions : object {
    [ExtensionAttribute]
public static IType TupleUnderlyingTypeOrSelf(IType type);
}
public class ICSharpCode.Decompiler.TypeSystem.TupleTypeReference : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeReference> <ElementTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ElementNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IModuleReference <ValueTupleAssembly>k__BackingField;
    public ImmutableArray`1<ITypeReference> ElementTypes { get; }
    public ImmutableArray`1<string> ElementNames { get; }
    public IModuleReference ValueTupleAssembly { get; }
    public TupleTypeReference(ImmutableArray`1<ITypeReference> elementTypes);
    public TupleTypeReference(ImmutableArray`1<ITypeReference> elementTypes, ImmutableArray`1<string> elementNames, IModuleReference valueTupleAssembly);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ITypeReference> get_ElementTypes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ElementNames();
    [CompilerGeneratedAttribute]
public IModuleReference get_ValueTupleAssembly();
    public sealed virtual IType Resolve(ITypeResolveContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ICSharpCode.Decompiler.TypeSystem.TypeConstraint : ValueType {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IAttribute> <Attributes>k__BackingField;
    public SymbolKind SymbolKind { get; }
    public IType Type { get; }
    public IReadOnlyList`1<IAttribute> Attributes { get; }
    public TypeConstraint(IType type, IReadOnlyList`1<IAttribute> attributes);
    public SymbolKind get_SymbolKind();
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IAttribute> get_Attributes();
}
public enum ICSharpCode.Decompiler.TypeSystem.TypeKind : Enum {
    public byte value__;
    public static TypeKind Other;
    public static TypeKind Class;
    public static TypeKind Interface;
    public static TypeKind Struct;
    public static TypeKind Delegate;
    public static TypeKind Enum;
    public static TypeKind Void;
    public static TypeKind Unknown;
    public static TypeKind Null;
    public static TypeKind None;
    public static TypeKind Dynamic;
    public static TypeKind UnboundTypeArgument;
    public static TypeKind TypeParameter;
    public static TypeKind Array;
    public static TypeKind Pointer;
    public static TypeKind ByReference;
    public static TypeKind Intersection;
    public static TypeKind ArgList;
    public static TypeKind Tuple;
    public static TypeKind ModOpt;
    public static TypeKind ModReq;
    public static TypeKind NInt;
    public static TypeKind NUInt;
    public static TypeKind FunctionPointer;
}
public class ICSharpCode.Decompiler.TypeSystem.TypeParameterSubstitution : TypeVisitor {
    public static TypeParameterSubstitution Identity;
    private IReadOnlyList`1<IType> classTypeArguments;
    private IReadOnlyList`1<IType> methodTypeArguments;
    public IReadOnlyList`1<IType> ClassTypeArguments { get; }
    public IReadOnlyList`1<IType> MethodTypeArguments { get; }
    public TypeParameterSubstitution(IReadOnlyList`1<IType> classTypeArguments, IReadOnlyList`1<IType> methodTypeArguments);
    private static TypeParameterSubstitution();
    public IReadOnlyList`1<IType> get_ClassTypeArguments();
    public IReadOnlyList`1<IType> get_MethodTypeArguments();
    public static TypeParameterSubstitution Compose(TypeParameterSubstitution g, TypeParameterSubstitution f);
    private static IReadOnlyList`1<IType> GetComposedTypeArguments(IReadOnlyList`1<IType> input, TypeParameterSubstitution substitution);
    public bool Equals(TypeParameterSubstitution other, TypeVisitor normalization);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool TypeListEquals(IReadOnlyList`1<IType> a, IReadOnlyList`1<IType> b);
    private static bool TypeListEquals(IReadOnlyList`1<IType> a, IReadOnlyList`1<IType> b, TypeVisitor normalization);
    private static int TypeListHashCode(IReadOnlyList`1<IType> obj);
    public virtual IType VisitTypeParameter(ITypeParameter type);
    public virtual IType VisitNullabilityAnnotatedType(NullabilityAnnotatedType type);
    public virtual string ToString();
}
internal class ICSharpCode.Decompiler.TypeSystem.TypeProvider : object {
    private MetadataModule module;
    private ICompilation compilation;
    public ICompilation Compilation { get; }
    public TypeProvider(MetadataModule module);
    public TypeProvider(ICompilation compilation);
    public sealed virtual ICompilation get_Compilation();
    public sealed virtual IType GetArrayType(IType elementType, ArrayShape shape);
    public sealed virtual IType GetByReferenceType(IType elementType);
    public sealed virtual IType GetFunctionPointerType(MethodSignature`1<IType> signature);
    public sealed virtual IType GetGenericInstantiation(IType genericType, ImmutableArray`1<IType> typeArguments);
    public sealed virtual IType GetGenericMethodParameter(GenericContext genericContext, int index);
    public sealed virtual IType GetGenericTypeParameter(GenericContext genericContext, int index);
    public sealed virtual IType GetModifiedType(IType modifier, IType unmodifiedType, bool isRequired);
    public sealed virtual IType GetPinnedType(IType elementType);
    public sealed virtual IType GetPointerType(IType elementType);
    public sealed virtual IType GetPrimitiveType(PrimitiveTypeCode typeCode);
    public sealed virtual IType GetSystemType();
    public sealed virtual IType GetSZArrayType(IType elementType);
    private Nullable`1<bool> IsReferenceType(MetadataReader reader, EntityHandle handle, byte rawTypeKind);
    public sealed virtual IType GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual IType GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public sealed virtual IType GetTypeFromSerializedName(string name);
    public sealed virtual IType GetTypeFromSpecification(MetadataReader reader, GenericContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    public sealed virtual PrimitiveTypeCode GetUnderlyingEnumType(IType type);
    public sealed virtual bool IsSystemType(IType type);
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IType> GetAllBaseTypes(IType type);
    [ExtensionAttribute]
public static IEnumerable`1<IType> GetNonInterfaceBaseTypes(IType type);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeDefinition> GetAllBaseTypeDefinitions(IType type);
    [ExtensionAttribute]
public static bool IsDerivedFrom(ITypeDefinition type, ITypeDefinition baseType);
    [ExtensionAttribute]
public static bool IsDerivedFrom(ITypeDefinition type, KnownTypeCode baseType);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.TypeSystem.TypeSystemExtensions/<GetDeclaringTypeDefinitions>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeDefinition> GetDeclaringTypeDefinitions(ITypeDefinition definition);
    [ExtensionAttribute]
public static bool IsOpen(IType type);
    private static IEntity GetTypeParameterOwner(IType type);
    [ExtensionAttribute]
public static bool IsUnbound(IType type);
    [ExtensionAttribute]
public static bool IsUnmanagedType(IType type, bool allowGenerics);
    [ExtensionAttribute]
public static bool IsKnownType(IType type, KnownTypeCode knownType);
    [ExtensionAttribute]
internal static bool IsKnownType(IType type, KnownAttribute knownType);
    [ExtensionAttribute]
public static bool IsKnownType(FullTypeName typeName, KnownTypeCode knownType);
    [ExtensionAttribute]
public static bool IsKnownType(TopLevelTypeName typeName, KnownTypeCode knownType);
    [ExtensionAttribute]
internal static bool IsKnownType(FullTypeName typeName, KnownAttribute knownType);
    [ExtensionAttribute]
internal static bool IsKnownType(TopLevelTypeName typeName, KnownAttribute knownType);
    [ExtensionAttribute]
public static IMethod GetDelegateInvokeMethod(IType type);
    [ExtensionAttribute]
public static IType SkipModifiers(IType ty);
    [ExtensionAttribute]
public static IType UnwrapByRef(IType type);
    [ExtensionAttribute]
public static bool HasReadonlyModifier(IMethod accessor);
    [ExtensionAttribute]
public static bool IsAnyPointer(TypeKind typeKind);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeDefinition> GetAllTypeDefinitions(ICompilation compilation);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeDefinition> GetTopLevelTypeDefinitions(ICompilation compilation);
    [ExtensionAttribute]
public static IReadOnlyList`1<IType> Resolve(IList`1<ITypeReference> typeReferences, ITypeResolveContext context);
    [ExtensionAttribute]
public static IType FindType(ICompilation compilation, FullTypeName fullTypeName);
    [ExtensionAttribute]
public static ITypeDefinition GetTypeDefinition(IModule module, FullTypeName fullTypeName);
    private static ITypeDefinition FindNestedType(ITypeDefinition typeDef, string name, int typeParameterCount);
    [ExtensionAttribute]
public static bool HasAttribute(IEntity entity, KnownAttribute attributeType, bool inherit);
    [ExtensionAttribute]
public static IAttribute GetAttribute(IEntity entity, KnownAttribute attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<IAttribute> GetAttributes(IEntity entity, bool inherit);
    [ExtensionAttribute]
public static bool HasAttribute(IParameter parameter, KnownAttribute attributeType);
    [ExtensionAttribute]
public static IAttribute GetAttribute(IParameter parameter, KnownAttribute attributeType);
    [ExtensionAttribute]
public static ITypeDefinition GetTypeDefinition(IModule module, string namespaceName, string name, int typeParameterCount);
    [ExtensionAttribute]
public static ISymbol GetSymbol(ResolveResult rr);
    [ExtensionAttribute]
public static IType GetElementTypeFromIEnumerable(IType collectionType, ICompilation compilation, bool allowIEnumerator, Nullable`1& isGeneric);
    [ExtensionAttribute]
public static bool FullNameIs(IMember member, string type, string name);
    [ExtensionAttribute]
public static KnownAttribute IsBuiltinAttribute(ITypeDefinition type);
    [ExtensionAttribute]
public static IType WithoutNullability(IType type);
    [ExtensionAttribute]
public static bool IsDirectImportOf(ITypeDefinition type, IModule module);
    [ExtensionAttribute]
public static IModule FindModuleByReference(ICompilation compilation, IAssemblyReference assemblyName);
    [ExtensionAttribute]
public static IType AsParameterizedType(ITypeDefinition td);
    [ExtensionAttribute]
public static INamespace GetNamespaceByFullName(ICompilation compilation, string name);
    [CompilerGeneratedAttribute]
internal static bool <IsUnmanagedType>g__IsUnmanagedTypeInternal|10_0(IType type, <>c__DisplayClass10_0& );
}
[FlagsAttribute]
public enum ICSharpCode.Decompiler.TypeSystem.TypeSystemOptions : Enum {
    public int value__;
    public static TypeSystemOptions None;
    public static TypeSystemOptions Dynamic;
    public static TypeSystemOptions Tuple;
    public static TypeSystemOptions ExtensionMethods;
    public static TypeSystemOptions OnlyPublicAPI;
    public static TypeSystemOptions Uncached;
    public static TypeSystemOptions DecimalConstants;
    public static TypeSystemOptions KeepModifiers;
    public static TypeSystemOptions ReadOnlyStructsAndParameters;
    public static TypeSystemOptions RefStructs;
    public static TypeSystemOptions UnmanagedConstraints;
    public static TypeSystemOptions NullabilityAnnotations;
    public static TypeSystemOptions ReadOnlyMethods;
    public static TypeSystemOptions NativeIntegers;
    public static TypeSystemOptions FunctionPointers;
    public static TypeSystemOptions ScopedRef;
    [ObsoleteAttribute("Use ScopedRef instead")]
public static TypeSystemOptions LifetimeAnnotations;
    public static TypeSystemOptions NativeIntegersWithoutAttribute;
    public static TypeSystemOptions Default;
}
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.TypeSystem.TypeUtils : object {
    public static int NativeIntSize;
    [ExtensionAttribute]
public static int GetSize(IType type);
    [ExtensionAttribute]
public static int GetSize(StackType type);
    public static IType GetLargerType(IType type1, IType type2);
    [ExtensionAttribute]
public static bool IsSmallIntegerType(IType type);
    [ExtensionAttribute]
public static bool IsCSharpSmallIntegerType(IType type);
    [ExtensionAttribute]
public static bool IsCSharpNativeIntegerType(IType type);
    [ExtensionAttribute]
public static bool IsCSharpPrimitiveIntegerType(IType type);
    [ExtensionAttribute]
public static bool IsIntegerType(StackType type);
    [ExtensionAttribute]
public static bool IsFloatType(StackType type);
    public static bool IsCompatiblePointerTypeForMemoryAccess(IType pointerType, IType accessType);
    public static bool IsCompatibleTypeForMemoryAccess(IType memoryType, IType accessType);
    [ExtensionAttribute]
public static StackType GetStackType(IType type);
    [ExtensionAttribute]
public static IType GetEnumUnderlyingType(IType type);
    [ExtensionAttribute]
public static Sign GetSign(IType type);
    [ExtensionAttribute]
public static PrimitiveType ToPrimitiveType(KnownTypeCode knownTypeCode);
    [ExtensionAttribute]
public static PrimitiveType ToPrimitiveType(IType type);
    [ExtensionAttribute]
public static KnownTypeCode ToKnownTypeCode(PrimitiveType primitiveType);
    [ExtensionAttribute]
public static KnownTypeCode ToKnownTypeCode(StackType stackType, Sign sign);
    [ExtensionAttribute]
public static PrimitiveType ToPrimitiveType(StackType stackType, Sign sign);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ICSharpCode.Decompiler.TypeSystem.TypeVisitor : object {
    public virtual IType VisitTypeDefinition(ITypeDefinition type);
    public virtual IType VisitTypeParameter(ITypeParameter type);
    public virtual IType VisitParameterizedType(ParameterizedType type);
    public virtual IType VisitArrayType(ArrayType type);
    public virtual IType VisitPointerType(PointerType type);
    public virtual IType VisitByReferenceType(ByReferenceType type);
    public virtual IType VisitTupleType(TupleType type);
    public virtual IType VisitOtherType(IType type);
    public virtual IType VisitModReq(ModifiedType type);
    public virtual IType VisitModOpt(ModifiedType type);
    public virtual IType VisitNullabilityAnnotatedType(NullabilityAnnotatedType type);
    public virtual IType VisitFunctionPointerType(FunctionPointerType type);
}
public class ICSharpCode.Decompiler.TypeSystem.VarArgInstanceMethod : object {
    private IMethod baseMethod;
    private IParameter[] parameters;
    public IMethod BaseMethod { get; }
    public int RegularParameterCount { get; }
    public IReadOnlyList`1<IParameter> Parameters { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ReturnTypeIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.ThisIsRefReadOnly { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsInitOnly { get; }
    public IReadOnlyList`1<ITypeParameter> TypeParameters { get; }
    public IReadOnlyList`1<IType> TypeArguments { get; }
    public EntityHandle MetadataToken { get; }
    public bool IsExtensionMethod { get; }
    private bool ICSharpCode.Decompiler.TypeSystem.IMethod.IsLocalFunction { get; }
    public bool IsConstructor { get; }
    public bool IsDestructor { get; }
    public bool IsOperator { get; }
    public bool HasBody { get; }
    public bool IsAccessor { get; }
    public IMember AccessorOwner { get; }
    public MethodSemanticsAttributes AccessorKind { get; }
    public IMethod ReducedFrom { get; }
    public IMember MemberDefinition { get; }
    public IType ReturnType { get; }
    public IEnumerable`1<IMember> ExplicitlyImplementedInterfaceMembers { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsOverridable { get; }
    public TypeParameterSubstitution Substitution { get; }
    public SymbolKind SymbolKind { get; }
    public string Name { get; }
    public ITypeDefinition DeclaringTypeDefinition { get; }
    public IType DeclaringType { get; }
    public IModule ParentModule { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public Accessibility Accessibility { get; }
    public string FullName { get; }
    public string ReflectionName { get; }
    public string Namespace { get; }
    public ICompilation Compilation { get; }
    public VarArgInstanceMethod(IMethod baseMethod, IEnumerable`1<IType> varArgTypes);
    public IMethod get_BaseMethod();
    public int get_RegularParameterCount();
    public sealed virtual IReadOnlyList`1<IParameter> get_Parameters();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(IMember obj, TypeVisitor typeNormalization);
    public virtual string ToString();
    public sealed virtual IMethod Specialize(TypeParameterSubstitution substitution);
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IEntity.HasAttribute(KnownAttribute attribute);
    private sealed virtual override IAttribute ICSharpCode.Decompiler.TypeSystem.IEntity.GetAttribute(KnownAttribute attribute);
    private sealed virtual override IEnumerable`1<IAttribute> ICSharpCode.Decompiler.TypeSystem.IMethod.GetReturnTypeAttributes();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ReturnTypeIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_ThisIsRefReadOnly();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsInitOnly();
    public sealed virtual IReadOnlyList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual IReadOnlyList`1<IType> get_TypeArguments();
    public sealed virtual EntityHandle get_MetadataToken();
    public sealed virtual bool get_IsExtensionMethod();
    private sealed virtual override bool ICSharpCode.Decompiler.TypeSystem.IMethod.get_IsLocalFunction();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsDestructor();
    public sealed virtual bool get_IsOperator();
    public sealed virtual bool get_HasBody();
    public sealed virtual bool get_IsAccessor();
    public sealed virtual IMember get_AccessorOwner();
    public sealed virtual MethodSemanticsAttributes get_AccessorKind();
    public sealed virtual IMethod get_ReducedFrom();
    private sealed virtual override IMember ICSharpCode.Decompiler.TypeSystem.IMember.Specialize(TypeParameterSubstitution substitution);
    public sealed virtual IMember get_MemberDefinition();
    public sealed virtual IType get_ReturnType();
    public sealed virtual IEnumerable`1<IMember> get_ExplicitlyImplementedInterfaceMembers();
    public sealed virtual bool get_IsExplicitInterfaceImplementation();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual TypeParameterSubstitution get_Substitution();
    public sealed virtual SymbolKind get_SymbolKind();
    public sealed virtual string get_Name();
    public sealed virtual ITypeDefinition get_DeclaringTypeDefinition();
    public sealed virtual IType get_DeclaringType();
    public sealed virtual IModule get_ParentModule();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual Accessibility get_Accessibility();
    public sealed virtual string get_FullName();
    public sealed virtual string get_ReflectionName();
    public sealed virtual string get_Namespace();
    public sealed virtual ICompilation get_Compilation();
}
public enum ICSharpCode.Decompiler.TypeSystem.VarianceModifier : Enum {
    public byte value__;
    public static VarianceModifier Invariant;
    public static VarianceModifier Covariant;
    public static VarianceModifier Contravariant;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class ICSharpCode.Decompiler.Util.BitSet : object {
    private static int BitsPerWord;
    private static int Log2BitsPerWord;
    private static ulong Mask;
    private UInt64[] words;
    public bool Item { get; public set; }
    public BitSet(int capacity);
    private BitSet(UInt64[] bits);
    private static int WordIndex(int bitIndex);
    public BitSet Clone();
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Any();
    public bool All(int startIndex, int endIndex);
    public bool SetEquals(BitSet other);
    public bool IsSubsetOf(BitSet other);
    public bool IsSupersetOf(BitSet other);
    public bool IsProperSubsetOf(BitSet other);
    public bool IsProperSupersetOf(BitSet other);
    public bool Overlaps(BitSet other);
    public void UnionWith(BitSet other);
    public void IntersectWith(BitSet other);
    public void Set(int index);
    public void Set(int startIndex, int endIndex);
    public void Clear(int index);
    public void Clear(int startIndex, int endIndex);
    public void ClearAll();
    public void ReplaceWith(BitSet incoming);
    public virtual string ToString();
}
public static class ICSharpCode.Decompiler.Util.BusyManager : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static List`1<object> _activeObjects;
    [NullableContextAttribute("2")]
public static BusyLock Enter(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.CacheManager : object {
    private ConcurrentDictionary`2<object, object> sharedDict;
    public object GetShared(object key);
    public object GetOrAddShared(object key, Func`2<object, object> valueFactory);
    public object GetOrAddShared(object key, object value);
    public void SetShared(object key, object value);
}
public class ICSharpCode.Decompiler.Util.CallbackOnDispose : object {
    [NullableAttribute("2")]
private Action action;
    [NullableContextAttribute("1")]
public CallbackOnDispose(Action action);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class ICSharpCode.Decompiler.Util.CollectionExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<K, V> pair, K& key, V& value);
    [ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<A, B>> Zip(IEnumerable`1<A> input1, IEnumerable`1<B> input2);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.CollectionExtensions/<ZipLongest>d__2`2")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<A, B>> ZipLongest(IEnumerable`1<A> input1, IEnumerable`1<B> input2);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.CollectionExtensions/<Slice>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Slice(IReadOnlyList`1<T> input, int offset, int length);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.CollectionExtensions/<Slice>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Slice(IReadOnlyList`1<T> input, int offset);
    [ExtensionAttribute]
public static HashSet`1<T> ToHashSet(IEnumerable`1<T> input);
    [ExtensionAttribute]
public static IEnumerable`1<T> SkipLast(IReadOnlyCollection`1<T> input, int count);
    [ExtensionAttribute]
public static IEnumerable`1<T> TakeLast(IReadOnlyCollection`1<T> input, int count);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T PopOrDefault(Stack`1<T> stack);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T PeekOrDefault(Stack`1<T> stack);
    [ExtensionAttribute]
public static int MaxOrDefault(IEnumerable`1<T> input, Func`2<T, int> selector, int defaultValue);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> collection, T value);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> input);
    [ExtensionAttribute]
public static U[] SelectArray(ICollection`1<T> collection, Func`2<T, U> func);
    [ExtensionAttribute]
public static ImmutableArray`1<U> SelectImmutableArray(IReadOnlyCollection`1<T> collection, Func`2<T, U> func);
    [ExtensionAttribute]
public static U[] SelectReadOnlyArray(IReadOnlyCollection`1<T> collection, Func`2<T, U> func);
    [ExtensionAttribute]
public static U[] SelectArray(List`1<T> collection, Func`2<T, U> func);
    [ExtensionAttribute]
public static U[] SelectArray(T[] collection, Func`2<T, U> func);
    [ExtensionAttribute]
public static List`1<U> SelectList(ICollection`1<T> collection, Func`2<T, U> func);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.CollectionExtensions/<SelectWithIndex>d__19`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> SelectWithIndex(IEnumerable`1<T> source, Func`3<int, T, U> func);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.CollectionExtensions/<WithIndex>d__20`1")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<int, T>> WithIndex(ICollection`1<T> source);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.CollectionExtensions/<Merge>d__21`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Merge(IEnumerable`1<T> input1, IEnumerable`1<T> input2, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static T MinBy(IEnumerable`1<T> source, Func`2<T, K> keySelector);
    [ExtensionAttribute]
public static T MinBy(IEnumerable`1<T> source, Func`2<T, K> keySelector, IComparer`1<K> keyComparer);
    [ExtensionAttribute]
public static T MaxBy(IEnumerable`1<T> source, Func`2<T, K> keySelector);
    [ExtensionAttribute]
public static T MaxBy(IEnumerable`1<T> source, Func`2<T, K> keySelector, IComparer`1<K> keyComparer);
    [ExtensionAttribute]
public static void RemoveLast(IList`1<T> list);
    [ExtensionAttribute]
public static T OnlyOrDefault(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T OnlyOrDefault(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int EnsureCapacity(List`1<T> list, int capacity);
    [ExtensionAttribute]
public static bool Any(ICollection`1<T> list);
    [ExtensionAttribute]
public static bool Any(T[] array, Predicate`1<T> match);
    [ExtensionAttribute]
public static bool Any(List`1<T> list, Predicate`1<T> match);
    [ExtensionAttribute]
public static bool All(T[] array, Predicate`1<T> match);
    [ExtensionAttribute]
public static bool All(List`1<T> list, Predicate`1<T> match);
    [ExtensionAttribute]
public static T FirstOrDefault(T[] array, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static T FirstOrDefault(List`1<T> list, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static T Last(IList`1<T> list);
}
public static class ICSharpCode.Decompiler.Util.CSharpPrimitiveCast : object {
    public static object Cast(TypeCode targetType, object input, bool checkForOverflow);
    private static object CSharpPrimitiveCastChecked(TypeCode targetType, object input);
    private static object CSharpPrimitiveCastUnchecked(TypeCode targetType, object input);
}
public static class ICSharpCode.Decompiler.Util.Empty`1 : object {
    [NullableAttribute("1")]
public static T[] Array;
    private static Empty`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class ICSharpCode.Decompiler.Util.EmptyList`1 : object {
    public static EmptyList`1<T> Instance;
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private static EmptyList`1();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[ExtensionAttribute]
internal static class ICSharpCode.Decompiler.Util.ExtensionMethods : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Predicate`1<T> And(Predicate`1<T> filter1, Predicate`1<T> filter2);
    [NullableContextAttribute("1")]
public static void Swap(T& a, T& b);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class ICSharpCode.Decompiler.Util.FileUtility : object {
    [NullableAttribute("1")]
private static Char[] separators;
    private static FileUtility();
    public static string NormalizePath(string fileName);
    [NullableContextAttribute("1")]
private static bool IsUNCPath(string fileName);
    public static bool IsEqualFileName(string fileName1, string fileName2);
    public static bool IsBaseDirectory(string baseDirectory, string testDirectory);
    private static string AddTrailingSeparator(string input);
    [NullableContextAttribute("1")]
private static char GetSeparatorForPath(string input);
    [NullableContextAttribute("1")]
public static string GetRelativePath(string baseDirectoryPath, string absPath);
    public static string TrimPath(string path, int max_chars);
}
internal class ICSharpCode.Decompiler.Util.IMAGE_RESOURCE_DATA_ENTRY : ValueType {
    public UInt32 OffsetToData;
    public UInt32 Size;
    public UInt32 CodePage;
    public UInt32 Reserved;
}
internal class ICSharpCode.Decompiler.Util.IMAGE_RESOURCE_DIRECTORY : ValueType {
    public UInt32 Characteristics;
    public UInt32 TimeDateStamp;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public ushort NumberOfNamedEntries;
    public ushort NumberOfIdEntries;
}
internal class ICSharpCode.Decompiler.Util.IMAGE_RESOURCE_DIRECTORY_ENTRY : ValueType {
    public UInt32 Name;
    public UInt32 OffsetToData;
}
internal class ICSharpCode.Decompiler.Util.IMAGE_RESOURCE_DIRECTORY_STRING : ValueType {
    public ushort Length;
    [FixedBufferAttribute("System.Char", "1")]
public <NameString>e__FixedBuffer NameString;
}
public class ICSharpCode.Decompiler.Util.Interval : ValueType {
    public int Start;
    public int End;
    public int InclusiveEnd { get; }
    public bool IsEmpty { get; }
    public Interval(int start, int end);
    public int get_InclusiveEnd();
    public bool get_IsEmpty();
    public bool Contains(int val);
    public Interval Intersect(Interval other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Interval other);
    public virtual int GetHashCode();
    public static bool op_Equality(Interval lhs, Interval rhs);
    public static bool op_Inequality(Interval lhs, Interval rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Util.KeyComparer : object {
    public static KeyComparer`2<TElement, TKey> Create(Func`2<TElement, TKey> keySelector);
    public static KeyComparer`2<TElement, TKey> Create(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer, IEqualityComparer`1<TKey> equalityComparer);
    public static IComparer`1<TElement> Create(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> comparer);
    public static IEqualityComparer`1<TElement> Create(Func`2<TElement, TKey> keySelector, IEqualityComparer`1<TKey> equalityComparer);
    [ExtensionAttribute]
public static void SortBy(List`1<TElement> list, Func`2<TElement, TKey> keySelector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.KeyComparer`2 : object {
    private Func`2<TElement, TKey> keySelector;
    private IComparer`1<TKey> keyComparer;
    private IEqualityComparer`1<TKey> keyEqualityComparer;
    public KeyComparer`2(Func`2<TElement, TKey> keySelector, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TKey> keyEqualityComparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(TElement x, TElement y);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TElement x, TElement y);
    public sealed virtual int GetHashCode(TElement obj);
}
public static class ICSharpCode.Decompiler.Util.LazyInit : object {
    [NullableContextAttribute("1")]
public static T VolatileRead(T& location);
    [NullableContextAttribute("2")]
public static T GetOrSet(T& target, T newValue);
}
internal static class ICSharpCode.Decompiler.Util.LongDict : object {
    internal static KeyComparer`2<LongInterval, long> StartComparer;
    private static LongDict();
    public static LongDict`1<T> Create(IEnumerable`1<ValueTuple`2<LongSet, T>> entries);
}
internal class ICSharpCode.Decompiler.Util.LongDict`1 : ValueType {
    private LongInterval[] keys;
    private T[] values;
    public LongDict`1(IEnumerable`1<ValueTuple`2<LongSet, T>> entries);
    public bool TryGetValue(long key, T& value);
    public T GetOrDefault(long key);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.LongDict`1/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<KeyValuePair`2<LongInterval, T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class ICSharpCode.Decompiler.Util.LongInterval : ValueType {
    public long Start;
    public long End;
    public long InclusiveEnd { get; }
    public bool IsEmpty { get; }
    public LongInterval(long start, long end);
    public static LongInterval Inclusive(long start, long inclusiveEnd);
    public long get_InclusiveEnd();
    public bool get_IsEmpty();
    public bool Contains(long val);
    public LongInterval Intersect(LongInterval other);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.LongInterval/<Range>d__10")]
public IEnumerable`1<long> Range();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LongInterval other);
    public virtual int GetHashCode();
    public static bool op_Equality(LongInterval lhs, LongInterval rhs);
    public static bool op_Inequality(LongInterval lhs, LongInterval rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.LongSet : ValueType {
    [NullableAttribute("0")]
public ImmutableArray`1<LongInterval> Intervals;
    public static LongSet Empty;
    public static LongSet Universe;
    public bool IsEmpty { get; }
    public IEnumerable`1<long> Values { get; }
    [NullableContextAttribute("0")]
private LongSet(ImmutableArray`1<LongInterval> intervals);
    public LongSet(long value);
    public LongSet(LongInterval interval);
    public LongSet(IEnumerable`1<LongInterval> intervals);
    private static LongSet();
    public bool get_IsEmpty();
    public ulong Count();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.LongSet/<DoIntersectWith>d__10")]
private IEnumerable`1<LongInterval> DoIntersectWith(LongSet other);
    public bool Overlaps(LongSet other);
    public LongSet IntersectWith(LongSet other);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.LongSet/<MergeOverlapping>d__13")]
private static IEnumerable`1<LongInterval> MergeOverlapping(IEnumerable`1<LongInterval> input);
    public LongSet UnionWith(LongSet other);
    public LongSet AddOffset(long val);
    public LongSet ExceptWith(LongSet other);
    public LongSet Invert();
    public bool IsSubsetOf(LongSet other);
    public bool IsSupersetOf(LongSet other);
    public bool IsProperSubsetOf(LongSet other);
    public bool IsProperSupersetOf(LongSet other);
    public bool Contains(long val);
    internal int upper_bound(long val);
    public IEnumerable`1<long> get_Values();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [ObsoleteAttribute("Explicitly call SetEquals() instead.")]
public sealed virtual bool Equals(LongSet other);
    public bool SetEquals(LongSet other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class ICSharpCode.Decompiler.Util.MultiDictionary`2 : object {
    private Dictionary`2<TKey, List`1<TValue>> dict;
    public IReadOnlyList`1<TValue> Item { get; }
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Linq.ILookup<TKey,TValue>.Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<TKey> comparer);
    public void Add(TKey key, TValue value);
    public bool Remove(TKey key, TValue value);
    public bool RemoveAll(TKey key);
    public void Clear();
    public IReadOnlyList`1<TValue> get_Item(TKey key);
    public sealed virtual int get_Count();
    public ICollection`1<TKey> get_Keys();
    public IEnumerable`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Linq.ILookup<TKey,TValue>.get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.MultiDictionary`2/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<IGrouping`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class ICSharpCode.Decompiler.Util.NewLine : object {
    public static char CR;
    public static char LF;
    public static char NEL;
    public static char VT;
    public static char FF;
    public static char LS;
    public static char PS;
    public static int GetDelimiterLength(char curChar, Func`1<char> nextChar);
    public static int GetDelimiterLength(char curChar, char nextChar);
    public static bool TryGetDelimiterLengthAndType(char curChar, Int32& length, UnicodeNewline& type, Func`1<char> nextChar);
    public static bool TryGetDelimiterLengthAndType(char curChar, Int32& length, UnicodeNewline& type, char nextChar);
    public static UnicodeNewline GetDelimiterType(char curChar, Func`1<char> nextChar);
    public static UnicodeNewline GetDelimiterType(char curChar, char nextChar);
    public static bool IsNewLine(char ch);
    [NullableContextAttribute("1")]
public static string GetString(UnicodeNewline newLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class ICSharpCode.Decompiler.Util.Platform : object {
    public static StringComparer FileNameComparer { get; }
    public static StringComparer get_FileNameComparer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class ICSharpCode.Decompiler.Util.ProjectedList`2 : object {
    private IList`1<TInput> input;
    private Func`2<TInput, TOutput> projection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TOutput[] items;
    public TOutput Item { get; }
    public int Count { get; }
    public ProjectedList`2(IList`1<TInput> input, Func`2<TInput, TOutput> projection);
    public sealed virtual TOutput get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.ProjectedList`2/<GetEnumerator>d__8")]
public sealed virtual IEnumerator`1<TOutput> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class ICSharpCode.Decompiler.Util.ProjectedList`3 : object {
    private IList`1<TInput> input;
    private TContext context;
    private Func`3<TContext, TInput, TOutput> projection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TOutput[] items;
    public TOutput Item { get; }
    public int Count { get; }
    public ProjectedList`3(TContext context, IList`1<TInput> input, Func`3<TContext, TInput, TOutput> projection);
    public sealed virtual TOutput get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.ProjectedList`3/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<TOutput> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.ReferenceComparer : object {
    [NullableAttribute("1")]
public static ReferenceComparer Instance;
    private static ReferenceComparer();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.ResourceSerializedObject : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    private ResourcesFile file;
    private long position;
    [NullableAttribute("2")]
public string TypeName { get; }
    internal ResourceSerializedObject(string typeName, ResourcesFile file, long position);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_TypeName();
    public Stream GetStream();
    public Byte[] GetBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.ResourcesFile : object {
    public static int MagicNumber;
    private static int ResourceSetVersion;
    private MyBinaryReader reader;
    private int version;
    private int numResources;
    private String[] typeTable;
    private Int32[] namePositions;
    private long fileStartPosition;
    private long nameSectionPosition;
    private long dataSectionPosition;
    [NullableAttribute("2")]
private Int64[] startPositions;
    public int ResourceCount { get; }
    public ResourcesFile(Stream stream, bool leaveOpen);
    public sealed virtual void Dispose();
    public int get_ResourceCount();
    public string GetResourceName(int index);
    private int GetResourceDataOffset(int index);
    private string GetResourceName(int index, Int32& dataOffset);
    internal bool AllEntriesAreStreams();
    [NullableContextAttribute("2")]
private object LoadObject(int dataOffset);
    private string FindType(int typeIndex);
    [NullableContextAttribute("2")]
private object LoadObjectV1(int dataOffset);
    [NullableContextAttribute("2")]
private object LoadObjectV2(int dataOffset);
    [NullableContextAttribute("2")]
public object GetResourceValue(int index);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.ResourcesFile/<GetEnumerator>d__26")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private Int64[] GetStartPositions();
    internal Byte[] GetBytesForSerializedObject(long pos);
}
public class ICSharpCode.Decompiler.Util.ResXResourceWriter : object {
    private string filename;
    private Stream stream;
    private TextWriter textwriter;
    private XmlTextWriter writer;
    private bool written;
    private string base_path;
    public static string BinSerializedObjectMimeType;
    public static string ByteArraySerializedObjectMimeType;
    public static string DefaultSerializedObjectMimeType;
    public static string ResMimeType;
    public static string SoapSerializedObjectMimeType;
    public static string Version;
    private static string WinFormsAssemblyName;
    private static string MSCorLibAssemblyName;
    private static string ResXNullRefTypeName;
    private static string schema;
    public string BasePath { get; public set; }
    public ResXResourceWriter(Stream stream);
    public ResXResourceWriter(TextWriter textWriter);
    public ResXResourceWriter(string fileName);
    private static ResXResourceWriter();
    protected virtual override void Finalize();
    private void InitWriter();
    private void WriteHeader(string name, string value);
    private void WriteNiceBase64(Byte[] value, int offset, int length);
    private void WriteBytes(string name, string type, Byte[] value, int offset, int length, string comment);
    private void WriteString(string name, string value, string type, string comment);
    public void AddResource(string name, Byte[] value);
    public void AddResource(string name, object value);
    private void AddResource(string name, object value, string comment);
    public void AddResource(string name, string value);
    public void Close();
    public virtual void Dispose();
    public void Generate();
    protected virtual void Dispose(bool disposing);
    public string get_BasePath();
    public void set_BasePath(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class ICSharpCode.Decompiler.Util.TreeTraversal : object {
    public static IEnumerable`1<T> PreOrder(T root, Func`2<T, IEnumerable`1<T>> recursion);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.TreeTraversal/<PreOrder>d__1`1")]
public static IEnumerable`1<T> PreOrder(IEnumerable`1<T> input, Func`2<T, IEnumerable`1<T>> recursion);
    public static IEnumerable`1<T> PostOrder(T root, Func`2<T, IEnumerable`1<T>> recursion);
    [IteratorStateMachineAttribute("ICSharpCode.Decompiler.Util.TreeTraversal/<PostOrder>d__3`1")]
public static IEnumerable`1<T> PostOrder(IEnumerable`1<T> input, Func`2<T, IEnumerable`1<T>> recursion);
}
public enum ICSharpCode.Decompiler.Util.UnicodeNewline : Enum {
    public int value__;
    public static UnicodeNewline Unknown;
    public static UnicodeNewline LF;
    public static UnicodeNewline CRLF;
    public static UnicodeNewline CR;
    public static UnicodeNewline NEL;
    public static UnicodeNewline VT;
    public static UnicodeNewline FF;
    public static UnicodeNewline LS;
    public static UnicodeNewline PS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.UnionFind`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<T, Node<T>> mapping;
    private Node<T> GetNode(T element);
    public T Find(T element);
    private Node<T> FindRoot(Node<T> node);
    public void Merge(T a, T b);
}
public class ICSharpCode.Decompiler.Util.Unit : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Data: {Name}")]
public class ICSharpCode.Decompiler.Util.Win32ResourceData : object {
    [CompilerGeneratedAttribute]
private UInt32 <OffsetToData>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Reserved>k__BackingField;
    [NullableAttribute("0")]
private Void* _pointer;
    [CompilerGeneratedAttribute]
private Win32ResourceName <Name>k__BackingField;
    public UInt32 OffsetToData { get; }
    public UInt32 Size { get; }
    public UInt32 CodePage { get; }
    public UInt32 Reserved { get; }
    public Win32ResourceName Name { get; }
    public Byte[] Data { get; }
    internal Win32ResourceData(PEReader pe, Byte* pRoot, int offset, Win32ResourceName name);
    [CompilerGeneratedAttribute]
public UInt32 get_OffsetToData();
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    [CompilerGeneratedAttribute]
public UInt32 get_CodePage();
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved();
    [CompilerGeneratedAttribute]
public Win32ResourceName get_Name();
    public Byte[] get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Directory: {Name}")]
public class ICSharpCode.Decompiler.Util.Win32ResourceDirectory : object {
    [CompilerGeneratedAttribute]
private UInt32 <Characteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeDateStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfNamedEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfIdEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private Win32ResourceName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Win32ResourceDirectory> <Directories>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Win32ResourceData> <Datas>k__BackingField;
    public UInt32 Characteristics { get; }
    public UInt32 TimeDateStamp { get; }
    public ushort MajorVersion { get; }
    public ushort MinorVersion { get; }
    public ushort NumberOfNamedEntries { get; }
    public ushort NumberOfIdEntries { get; }
    public Win32ResourceName Name { get; }
    public IList`1<Win32ResourceDirectory> Directories { get; }
    public IList`1<Win32ResourceData> Datas { get; }
    internal Win32ResourceDirectory(PEReader pe, Byte* pRoot, int offset, Win32ResourceName name);
    [CompilerGeneratedAttribute]
public UInt32 get_Characteristics();
    [CompilerGeneratedAttribute]
public UInt32 get_TimeDateStamp();
    [CompilerGeneratedAttribute]
public ushort get_MajorVersion();
    [CompilerGeneratedAttribute]
public ushort get_MinorVersion();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfNamedEntries();
    [CompilerGeneratedAttribute]
public ushort get_NumberOfIdEntries();
    [CompilerGeneratedAttribute]
public Win32ResourceName get_Name();
    [CompilerGeneratedAttribute]
public IList`1<Win32ResourceDirectory> get_Directories();
    [CompilerGeneratedAttribute]
public IList`1<Win32ResourceData> get_Datas();
    [NullableContextAttribute("0")]
private static string ReadString(Byte* pRoot, int offset);
    public Win32ResourceDirectory FindDirectory(Win32ResourceName name);
    public Win32ResourceData FindData(Win32ResourceName name);
    [NullableContextAttribute("2")]
public Win32ResourceDirectory FirstDirectory();
    [NullableContextAttribute("2")]
public Win32ResourceData FirstData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ICSharpCode.Decompiler.Util.Win32ResourceName : object {
    private object _name;
    public bool HasName { get; }
    public bool HasId { get; }
    public string Name { get; }
    public ushort Id { get; }
    public Win32ResourceName(string name);
    public Win32ResourceName(int id);
    public Win32ResourceName(ushort id);
    [NullableContextAttribute("0")]
internal Win32ResourceName(Byte* pRoot, IMAGE_RESOURCE_DIRECTORY_ENTRY* pEntry);
    public bool get_HasName();
    public bool get_HasId();
    public string get_Name();
    public ushort get_Id();
    public static bool op_Equality(Win32ResourceName x, Win32ResourceName y);
    public static bool op_Inequality(Win32ResourceName x, Win32ResourceName y);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static string <.ctor>g__ReadString|12_0(Byte* pRoot, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ICSharpCode.Decompiler.Util.Win32Resources : object {
    [ExtensionAttribute]
public static Win32ResourceDirectory ReadWin32Resources(PEReader pe);
    [ExtensionAttribute]
public static Win32ResourceDirectory Find(Win32ResourceDirectory root, Win32ResourceName type);
    [ExtensionAttribute]
public static Win32ResourceDirectory Find(Win32ResourceDirectory root, Win32ResourceName type, Win32ResourceName name);
    [ExtensionAttribute]
public static Win32ResourceData Find(Win32ResourceDirectory root, Win32ResourceName type, Win32ResourceName name, Win32ResourceName langId);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("LightJson.JsonArray/JsonArrayDebugView")]
internal class LightJson.JsonArray : object {
    private IList`1<JsonValue> items;
    public int Count { get; }
    public JsonValue Item { get; public set; }
    public JsonArray(JsonValue[] values);
    public int get_Count();
    public JsonValue get_Item(int index);
    public void set_Item(int index, JsonValue value);
    public JsonArray Add(JsonValue value);
    public JsonArray Insert(int index, JsonValue value);
    public JsonArray Remove(int index);
    public JsonArray Clear();
    public bool Contains(JsonValue item);
    public int IndexOf(JsonValue item);
    public sealed virtual IEnumerator`1<JsonValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("LightJson.JsonObject/JsonObjectDebugView")]
internal class LightJson.JsonObject : object {
    private IDictionary`2<string, JsonValue> properties;
    public int Count { get; }
    public JsonValue Item { get; public set; }
    public int get_Count();
    public JsonValue get_Item(string key);
    public void set_Item(string key, JsonValue value);
    public JsonObject Add(string key);
    public JsonObject Add(string key, JsonValue value);
    public bool Remove(string key);
    public JsonObject Clear();
    public JsonObject Rename(string oldKey, string newKey);
    public bool ContainsKey(string key);
    public bool Contains(JsonValue value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JsonValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<JsonValue> System.Collections.Generic.IEnumerable<LightJson.JsonValue>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{ToString(),nq}")]
[DebuggerTypeProxyAttribute("LightJson.JsonValue/JsonValueDebugView")]
internal class LightJson.JsonValue : ValueType {
    public static JsonValue Null;
    private JsonValueType type;
    private object reference;
    private double value;
    public JsonValueType Type { get; }
    public bool IsNull { get; }
    public bool IsBoolean { get; }
    public bool IsInteger { get; }
    public bool IsNumber { get; }
    public bool IsString { get; }
    public bool IsJsonObject { get; }
    public bool IsJsonArray { get; }
    public bool IsDateTime { get; }
    public bool AsBoolean { get; }
    public int AsInteger { get; }
    public double AsNumber { get; }
    public string AsString { get; }
    public JsonObject AsJsonObject { get; }
    public JsonArray AsJsonArray { get; }
    public Nullable`1<DateTime> AsDateTime { get; }
    public object AsObject { get; }
    public JsonValue Item { get; public set; }
    public JsonValue Item { get; public set; }
    public JsonValue(Nullable`1<bool> value);
    public JsonValue(Nullable`1<double> value);
    public JsonValue(string value);
    public JsonValue(JsonObject value);
    public JsonValue(JsonArray value);
    private JsonValue(JsonValueType type, double value, object reference);
    private static JsonValue();
    public JsonValueType get_Type();
    public bool get_IsNull();
    public bool get_IsBoolean();
    public bool get_IsInteger();
    public bool get_IsNumber();
    public bool get_IsString();
    public bool get_IsJsonObject();
    public bool get_IsJsonArray();
    public bool get_IsDateTime();
    public bool get_AsBoolean();
    public int get_AsInteger();
    public double get_AsNumber();
    public string get_AsString();
    public JsonObject get_AsJsonObject();
    public JsonArray get_AsJsonArray();
    public Nullable`1<DateTime> get_AsDateTime();
    public object get_AsObject();
    public JsonValue get_Item(string key);
    public void set_Item(string key, JsonValue value);
    public JsonValue get_Item(int index);
    public void set_Item(int index, JsonValue value);
    public static JsonValue op_Implicit(Nullable`1<bool> value);
    public static JsonValue op_Implicit(Nullable`1<double> value);
    public static JsonValue op_Implicit(string value);
    public static JsonValue op_Implicit(JsonObject value);
    public static JsonValue op_Implicit(JsonArray value);
    public static JsonValue op_Implicit(Nullable`1<DateTime> value);
    public static int op_Explicit(JsonValue jsonValue);
    public static Nullable`1<int> op_Explicit(JsonValue jsonValue);
    public static bool op_Explicit(JsonValue jsonValue);
    public static Nullable`1<bool> op_Explicit(JsonValue jsonValue);
    public static double op_Explicit(JsonValue jsonValue);
    public static Nullable`1<double> op_Explicit(JsonValue jsonValue);
    public static string op_Explicit(JsonValue jsonValue);
    public static JsonObject op_Explicit(JsonValue jsonValue);
    public static JsonArray op_Explicit(JsonValue jsonValue);
    public static DateTime op_Explicit(JsonValue jsonValue);
    public static Nullable`1<DateTime> op_Explicit(JsonValue jsonValue);
    public static bool op_Equality(JsonValue a, JsonValue b);
    public static bool op_Inequality(JsonValue a, JsonValue b);
    public static JsonValue Parse(string text);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum LightJson.JsonValueType : Enum {
    public byte value__;
    public static JsonValueType Null;
    public static JsonValueType Boolean;
    public static JsonValueType Number;
    public static JsonValueType String;
    public static JsonValueType Object;
    public static JsonValueType Array;
}
internal class LightJson.Serialization.JsonParseException : Exception {
    [CompilerGeneratedAttribute]
private TextPosition <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorType <Type>k__BackingField;
    public TextPosition Position { get; private set; }
    public ErrorType Type { get; private set; }
    public JsonParseException(ErrorType type, TextPosition position);
    public JsonParseException(string message, ErrorType type, TextPosition position);
    [CompilerGeneratedAttribute]
public TextPosition get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(TextPosition value);
    [CompilerGeneratedAttribute]
public ErrorType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ErrorType value);
    private static string GetDefaultMessage(ErrorType type);
}
internal class LightJson.Serialization.JsonReader : object {
    private TextScanner scanner;
    private JsonReader(TextReader reader);
    public static JsonValue Parse(TextReader reader);
    public static JsonValue Parse(string source);
    private string ReadJsonKey();
    private JsonValue ReadJsonValue();
    private JsonValue ReadNull();
    private JsonValue ReadBoolean();
    private void ReadDigits(StringBuilder builder);
    private JsonValue ReadNumber();
    private string ReadString();
    private int ReadHexDigit();
    private char ReadUnicodeLiteral();
    private JsonObject ReadObject();
    private JsonObject ReadObject(JsonObject jsonObject);
    private JsonArray ReadArray();
    private JsonArray ReadArray(JsonArray jsonArray);
    private JsonValue Parse();
}
internal class LightJson.Serialization.TextPosition : ValueType {
    public long Column;
    public long Line;
}
internal class LightJson.Serialization.TextScanner : object {
    private TextReader reader;
    private TextPosition position;
    public TextPosition Position { get; }
    public TextScanner(TextReader reader);
    public TextPosition get_Position();
    public char Peek();
    public int Peek(bool throwAtEndOfFile);
    public char Read();
    public void SkipWhitespace();
    public void Assert(char next);
    public void Assert(string next);
    private void SkipComment();
    private void SkipLineComment();
    private void SkipBlockComment();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
