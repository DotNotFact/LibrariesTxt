[IsReadOnlyAttribute]
public class Microsoft.ML.OnnxRuntime.BFloat16 : ValueType {
    internal static ushort SignMask;
    internal static int SignShift;
    internal static byte ShiftedSignMask;
    internal static ushort BiasedExponentMask;
    internal static int BiasedExponentShift;
    internal static byte ShiftedBiasedExponentMask;
    internal static ushort TrailingSignificandMask;
    internal static byte MinSign;
    internal static byte MaxSign;
    internal static byte MinBiasedExponent;
    internal static byte MaxBiasedExponent;
    internal static byte ExponentBias;
    internal static sbyte MinExponent;
    internal static sbyte MaxExponent;
    private static ushort PositiveZeroBits;
    private static ushort NegativeZeroBits;
    private static ushort OneBits;
    private static ushort PositiveInfinityBits;
    private static ushort NegativeInfinityBits;
    private static ushort PositiveQNaNBits;
    private static ushort NegativeQNaNBits;
    private static ushort MinValueBits;
    private static ushort MaxValueBits;
    private static ushort EpsilonBits;
    private static ushort PiBits;
    private static UInt32 RoundingBase;
    public ushort value;
    public static BFloat16 Epsilon { get; }
    public static BFloat16 Pi { get; }
    public static BFloat16 PositiveInfinity { get; }
    public static BFloat16 NegativeInfinity { get; }
    public static BFloat16 NaN { get; }
    public static BFloat16 Zero { get; }
    public static BFloat16 One { get; }
    public static BFloat16 NegativeZero { get; }
    public static BFloat16 MinValue { get; }
    public static BFloat16 MaxValue { get; }
    internal byte BiasedExponent { get; }
    internal ushort TrailingSignificand { get; }
    public BFloat16(ushort v);
    public static BFloat16 get_Epsilon();
    public static BFloat16 get_Pi();
    public static BFloat16 get_PositiveInfinity();
    public static BFloat16 get_NegativeInfinity();
    public static BFloat16 get_NaN();
    public static BFloat16 get_Zero();
    public static BFloat16 get_One();
    public static BFloat16 get_NegativeZero();
    public static BFloat16 get_MinValue();
    public static BFloat16 get_MaxValue();
    internal byte get_BiasedExponent();
    internal ushort get_TrailingSignificand();
    internal static byte ExtractBiasedExponentFromBits(ushort bits);
    internal static ushort ExtractTrailingSignificandFromBits(ushort bits);
    public static bool op_LessThan(BFloat16 left, BFloat16 right);
    public static bool op_GreaterThan(BFloat16 left, BFloat16 right);
    public static bool op_LessThanOrEqual(BFloat16 left, BFloat16 right);
    public static bool op_GreaterThanOrEqual(BFloat16 left, BFloat16 right);
    public static bool op_Equality(BFloat16 left, BFloat16 right);
    public static bool op_Inequality(BFloat16 left, BFloat16 right);
    public static bool IsFinite(BFloat16 value);
    public static bool IsInfinity(BFloat16 value);
    public static bool IsNaN(BFloat16 value);
    public static bool IsNegative(BFloat16 value);
    public static bool IsNegativeInfinity(BFloat16 value);
    public static bool IsNormal(BFloat16 value);
    public static bool IsPositiveInfinity(BFloat16 value);
    public static bool IsSubnormal(BFloat16 value);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(BFloat16 other);
    public sealed virtual bool Equals(BFloat16 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public float ToFloat();
    public static BFloat16 op_Explicit(float value);
    public static float op_Explicit(BFloat16 value);
    public static BFloat16 Negate(BFloat16 value);
    public static bool IsNaNOrZero(BFloat16 value);
    private static bool AreZero(BFloat16 left, BFloat16 right);
    private static UInt32 StripSign(BFloat16 value);
}
internal class Microsoft.ML.OnnxRuntime.BitOpsUtils : object {
    internal static UInt32 SingleBiasedExponentMask;
    internal static int SingleBiasedExponentShift;
    internal static UInt32 SingleSignMask;
    internal static int SingleSignShift;
    internal static UInt32 SingleMostSignificantSigBit;
    internal static UInt32 SingleTrailingSignificandMask;
    internal static int LeadingZeroCount(UInt32 num);
    internal static UInt32 SingleToUInt32Bits(float single);
    internal static float UInt32BitsToSingle(UInt32 singleBits);
    internal static ushort SingleBitsToBFloat16Bits(UInt32 singleBits);
    internal static UInt32 BFloat16BitsToSingleBits(ushort bfloatBits);
    internal static float CreateSingleNaN(bool sign, ulong significand);
    internal static float CreateSingle(bool sign, byte exponent, UInt32 significand);
}
public class Microsoft.ML.OnnxRuntime.CheckpointState : SafeHandle {
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    private CheckpointState(IntPtr checkpointHandle);
    internal IntPtr get_Handle();
    private void AddPropertyImpl(string propertyName, PropertyType propertyType, T propertyValue);
    public virtual bool get_IsInvalid();
    public static CheckpointState LoadCheckpoint(string checkpointPath);
    public static void SaveCheckpoint(CheckpointState state, string checkpointPath, bool includeOptimizerState);
    public void AddProperty(string propertyName, long propertyValue);
    public void AddProperty(string propertyName, float propertyValue);
    public void AddProperty(string propertyName, string propertyValue);
    public object GetProperty(string propertyName);
    public void UpdateParameter(string parameterName, OrtValue parameter);
    public OrtValue GetParameter(string parameterName);
    protected virtual bool ReleaseHandle();
}
[FlagsAttribute]
public enum Microsoft.ML.OnnxRuntime.CoreMLFlags : Enum {
    public UInt32 value__;
    public static CoreMLFlags COREML_FLAG_USE_NONE;
    public static CoreMLFlags COREML_FLAG_USE_CPU_ONLY;
    public static CoreMLFlags COREML_FLAG_ENABLE_ON_SUBGRAPH;
    public static CoreMLFlags COREML_FLAG_ONLY_ENABLE_DEVICE_WITH_ANE;
    public static CoreMLFlags COREML_FLAG_LAST;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Microsoft.ML.OnnxRuntime.DisposableArray`1 : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Span`1<T> <Span>k__BackingField;
    internal Span`1<T> Span { get; private set; }
    internal DisposableArray`1(Span`1<T> disposables);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Span`1<T> get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(Span`1<T> value);
    public void Dispose();
}
internal class Microsoft.ML.OnnxRuntime.DisposableList`1 : List`1<T> {
    private bool _disposed;
    public DisposableList`1(int count);
    public DisposableList`1(IEnumerable`1<T> collection);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Microsoft.ML.OnnxRuntime.DisposableNamedOnnxValue : NamedOnnxValue {
    private IOrtValueOwner _ortValueHolder;
    private bool _disposed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <ElementType>k__BackingField;
    public TensorElementType ElementType { get; }
    private DisposableNamedOnnxValue(string name, object value, TensorElementType elementType, IOrtValueOwner ortValueHolder);
    private DisposableNamedOnnxValue(string name, object value, OnnxValueType onnxValueType, IOrtValueOwner ortValueHolder);
    private DisposableNamedOnnxValue(string name, object value, MapHelper mapHelper, IOrtValueOwner ortValueHolder);
    [CompilerGeneratedAttribute]
public TensorElementType get_ElementType();
    internal virtual IntPtr InputToOrtValueHandle(NodeMetadata metadata, IDisposable& memoryHolder);
    internal virtual IntPtr OutputToOrtValueHandle(NodeMetadata metadata, IDisposable& memoryOwner);
    internal static DisposableNamedOnnxValue CreateFromOrtValue(string name, OrtValue& ortValue);
    internal static DisposableNamedOnnxValue CreateFromOrtValue(string name, OrtValue& ortValue, OrtAllocator allocator);
    private static DisposableNamedOnnxValue FromNativeTensor(string name, OrtValue& ortValue);
    private static DisposableNamedOnnxValue FromNativeStringTensor(string name, Int32[] shape, OrtValue& ortValue);
    private static DisposableNamedOnnxValue FromNativeTensor(string name, OrtValue& ortValue);
    private static DisposableNamedOnnxValue FromNativeSequence(string name, OrtValue& ortValueSequence, OrtAllocator allocator);
    private static DisposableNamedOnnxValue FromNativeMap(string name, OrtValue& ortValueMap, OrtAllocator allocator);
    private static DisposableNamedOnnxValue FromNativeMapElements(string name, OrtValue& ortValueMap, Int32[] keysShape, OrtValue& ortValueTensorKeys, Int32[] valsShape, OrtValue& ortValueTensorValues);
    private static DisposableNamedOnnxValue FromMapDenseTensors(string name, OrtValue& ortValueMap, DenseTensor`1<K> keys, DenseTensor`1<V> values, IDisposable disposables);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Microsoft.ML.OnnxRuntime.DisposableOrtValueHandleArray : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Span`1<IntPtr> <Span>k__BackingField;
    internal Span`1<IntPtr> Span { get; private set; }
    internal DisposableOrtValueHandleArray(Span`1<IntPtr> handles);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Span`1<IntPtr> get_Span();
    [CompilerGeneratedAttribute]
private void set_Span(Span`1<IntPtr> value);
    public void Dispose();
}
public class Microsoft.ML.OnnxRuntime.DOrtLoggingFunction : MulticastDelegate {
    public DOrtLoggingFunction(object object, IntPtr method);
    public virtual void Invoke(IntPtr param, OrtLoggingLevel severity, string category, string logId, string codeLocation, string message);
    public virtual IAsyncResult BeginInvoke(IntPtr param, OrtLoggingLevel severity, string category, string logId, string codeLocation, string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ML.OnnxRuntime.EnvironmentCreationOptions : ValueType {
    public string logId;
    public Nullable`1<OrtLoggingLevel> logLevel;
    public OrtThreadingOptions threadOptions;
    public Nullable`1<IntPtr> loggingParam;
    public DOrtLoggingFunction loggingFunction;
}
internal enum Microsoft.ML.OnnxRuntime.ErrorCode : Enum {
    public int value__;
    public static ErrorCode Ok;
    public static ErrorCode Fail;
    public static ErrorCode InvalidArgument;
    public static ErrorCode NoSuchFile;
    public static ErrorCode NoModel;
    public static ErrorCode EngineError;
    public static ErrorCode RuntimeException;
    public static ErrorCode InvalidProtobuf;
    public static ErrorCode ModelLoaded;
    public static ErrorCode NotImplemented;
    public static ErrorCode InvalidGraph;
    public static ErrorCode ShapeInferenceNotRegistered;
    public static ErrorCode RequirementNotRegistered;
}
public enum Microsoft.ML.OnnxRuntime.ExecutionMode : Enum {
    public int value__;
    public static ExecutionMode ORT_SEQUENTIAL;
    public static ExecutionMode ORT_PARALLEL;
}
public class Microsoft.ML.OnnxRuntime.FixedBufferOnnxValue : object {
    private bool _disposed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OrtValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OnnxValueType <OnnxValueType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <ElementType>k__BackingField;
    internal OrtValue Value { get; private set; }
    internal OnnxValueType OnnxValueType { get; private set; }
    internal TensorElementType ElementType { get; private set; }
    private FixedBufferOnnxValue(OrtValue& ortValue, OnnxValueType onnxValueType, TensorElementType elementType);
    [CompilerGeneratedAttribute]
internal OrtValue get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(OrtValue value);
    [CompilerGeneratedAttribute]
internal OnnxValueType get_OnnxValueType();
    [CompilerGeneratedAttribute]
private void set_OnnxValueType(OnnxValueType value);
    [CompilerGeneratedAttribute]
internal TensorElementType get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(TensorElementType value);
    public static FixedBufferOnnxValue CreateFromTensor(Tensor`1<T> value);
    public static FixedBufferOnnxValue CreateFromMemory(OrtMemoryInfo memoryInfo, Memory`1<T> memory, TensorElementType elementType, Int64[] shape, long bytesSize);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
public class Microsoft.ML.OnnxRuntime.Float16 : ValueType {
    internal static ushort SignMask;
    internal static int SignShift;
    internal static byte ShiftedSignMask;
    internal static ushort BiasedExponentMask;
    internal static int BiasedExponentShift;
    internal static byte ShiftedBiasedExponentMask;
    internal static ushort TrailingSignificandMask;
    internal static byte MinSign;
    internal static byte MaxSign;
    internal static byte MinBiasedExponent;
    internal static byte MaxBiasedExponent;
    internal static byte ExponentBias;
    internal static sbyte MinExponent;
    internal static sbyte MaxExponent;
    private static ushort PositiveZeroBits;
    private static ushort NegativeZeroBits;
    private static ushort OneBits;
    private static ushort EpsilonBits;
    private static ushort PositiveInfinityBits;
    private static ushort NegativeInfinityBits;
    private static ushort PositiveQNaNBits;
    private static ushort NegativeQNaNBits;
    private static ushort MinValueBits;
    private static ushort MaxValueBits;
    private static ushort PositiveOneBits;
    private static ushort NegativeOneBits;
    private static ushort EBits;
    private static ushort PiBits;
    private static ushort TauBits;
    public ushort value;
    public static Float16 Epsilon { get; }
    public static Float16 Pi { get; }
    public static Float16 PositiveInfinity { get; }
    public static Float16 NegativeInfinity { get; }
    public static Float16 NaN { get; }
    public static Float16 Zero { get; }
    public static Float16 One { get; }
    public static Float16 NegativeZero { get; }
    public static Float16 MinValue { get; }
    public static Float16 MaxValue { get; }
    internal byte BiasedExponent { get; }
    internal sbyte Exponent { get; }
    internal ushort Significand { get; }
    internal ushort TrailingSignificand { get; }
    public Float16(ushort v);
    private Float16(bool sign, ushort exp, ushort sig);
    public static Float16 get_Epsilon();
    public static Float16 get_Pi();
    public static Float16 get_PositiveInfinity();
    public static Float16 get_NegativeInfinity();
    public static Float16 get_NaN();
    public static Float16 get_Zero();
    public static Float16 get_One();
    public static Float16 get_NegativeZero();
    public static Float16 get_MinValue();
    public static Float16 get_MaxValue();
    internal byte get_BiasedExponent();
    internal sbyte get_Exponent();
    internal ushort get_Significand();
    internal ushort get_TrailingSignificand();
    internal static byte ExtractBiasedExponentFromBits(ushort bits);
    internal static ushort ExtractTrailingSignificandFromBits(ushort bits);
    public static bool op_LessThan(Float16 left, Float16 right);
    public static bool op_GreaterThan(Float16 left, Float16 right);
    public static bool op_LessThanOrEqual(Float16 left, Float16 right);
    public static bool op_GreaterThanOrEqual(Float16 left, Float16 right);
    public static bool op_Equality(Float16 left, Float16 right);
    public static bool op_Inequality(Float16 left, Float16 right);
    public static bool IsFinite(Float16 value);
    public static bool IsInfinity(Float16 value);
    public static bool IsNaN(Float16 value);
    public static bool IsNegative(Float16 value);
    public static bool IsNegativeInfinity(Float16 value);
    public static bool IsNormal(Float16 value);
    public static bool IsPositiveInfinity(Float16 value);
    public static bool IsSubnormal(Float16 value);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Float16 other);
    public sealed virtual bool Equals(Float16 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public float ToFloat();
    public static Float16 op_Explicit(float value);
    public static float op_Explicit(Float16 value);
    public static Float16 Negate(Float16 value);
    private static bool AreZero(Float16 left, Float16 right);
    public static bool IsNaNOrZero(Float16 value);
    private static UInt32 StripSign(Float16 value);
    private static ValueTuple`2<int, UInt32> NormSubnormalF16Sig(UInt32 sig);
    private static Float16 CreateFloat16NaN(bool sign, ulong significand);
    private static ushort RoundPackToFloat16(bool sign, short exp, ushort sig);
    private static UInt32 ShiftRightJam(UInt32 i, int dist);
    private static ulong ShiftRightJam(ulong l, int dist);
}
public enum Microsoft.ML.OnnxRuntime.GraphOptimizationLevel : Enum {
    public int value__;
    public static GraphOptimizationLevel ORT_DISABLE_ALL;
    public static GraphOptimizationLevel ORT_ENABLE_BASIC;
    public static GraphOptimizationLevel ORT_ENABLE_EXTENDED;
    public static GraphOptimizationLevel ORT_ENABLE_ALL;
}
public interface Microsoft.ML.OnnxRuntime.IDisposableReadOnlyCollection`1 {
}
public class Microsoft.ML.OnnxRuntime.InferenceSession : object {
    private IntPtr _nativeHandle;
    private Dictionary`2<string, NodeMetadata> _inputMetadata;
    private List`1<string> _inputNames;
    private Dictionary`2<string, NodeMetadata> _outputMetadata;
    private List`1<string> _outputNames;
    private Dictionary`2<string, NodeMetadata> _overridableInitializerMetadata;
    private List`1<IntPtr> _namesMemoryPtrs;
    private SessionOptions _builtInSessionOptions;
    private RunOptions _builtInRunOptions;
    private ModelMetadata _modelMetadata;
    private bool _disposed;
    private ulong _profilingStartTimeNs;
    private static OrtCallbackDelegate ortCallback;
    public IReadOnlyDictionary`2<string, NodeMetadata> InputMetadata { get; }
    public IReadOnlyList`1<string> InputNames { get; }
    public IReadOnlyDictionary`2<string, NodeMetadata> OutputMetadata { get; }
    public IReadOnlyList`1<string> OutputNames { get; }
    public IReadOnlyDictionary`2<string, NodeMetadata> OverridableInitializerMetadata { get; }
    public ModelMetadata ModelMetadata { get; }
    public ulong ProfilingStartTimeNs { get; }
    internal IntPtr Handle { get; }
    public InferenceSession(string modelPath);
    public InferenceSession(string modelPath, PrePackedWeightsContainer prepackedWeightsContainer);
    public InferenceSession(string modelPath, SessionOptions options);
    public InferenceSession(string modelPath, SessionOptions options, PrePackedWeightsContainer prepackedWeightsContainer);
    public InferenceSession(Byte[] model);
    public InferenceSession(Byte[] model, PrePackedWeightsContainer prepackedWeightsContainer);
    public InferenceSession(Byte[] model, SessionOptions options);
    public InferenceSession(Byte[] model, SessionOptions options, PrePackedWeightsContainer prepackedWeightsContainer);
    private static InferenceSession();
    public IReadOnlyDictionary`2<string, NodeMetadata> get_InputMetadata();
    public IReadOnlyList`1<string> get_InputNames();
    public IReadOnlyDictionary`2<string, NodeMetadata> get_OutputMetadata();
    public IReadOnlyList`1<string> get_OutputNames();
    public IReadOnlyDictionary`2<string, NodeMetadata> get_OverridableInitializerMetadata();
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> Run(IReadOnlyCollection`1<NamedOnnxValue> inputs);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> Run(IReadOnlyCollection`1<NamedOnnxValue> inputs, IReadOnlyCollection`1<string> outputNames);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> Run(IReadOnlyCollection`1<NamedOnnxValue> inputs, IReadOnlyCollection`1<string> outputNames, RunOptions options);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> Run(IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> Run(IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<string> outputNames);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> Run(IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<string> outputNames, RunOptions options);
    public void Run(IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<string> outputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues);
    public void Run(IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<string> outputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues, RunOptions options);
    public void Run(IReadOnlyCollection`1<NamedOnnxValue> inputs, IReadOnlyCollection`1<NamedOnnxValue> outputs);
    public void Run(IReadOnlyCollection`1<NamedOnnxValue> inputs, IReadOnlyCollection`1<NamedOnnxValue> outputs, RunOptions options);
    public void Run(IReadOnlyCollection`1<NamedOnnxValue> inputs, IReadOnlyCollection`1<string> outputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues);
    public void Run(IReadOnlyCollection`1<NamedOnnxValue> inputs, IReadOnlyCollection`1<string> outputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues, RunOptions options);
    public void Run(IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<NamedOnnxValue> outputs);
    public void Run(IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<NamedOnnxValue> outputs, RunOptions options);
    public IDisposableReadOnlyCollection`1<OrtValue> Run(RunOptions runOptions, IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<OrtValue> inputValues, IReadOnlyCollection`1<string> outputNames);
    public IDisposableReadOnlyCollection`1<OrtValue> Run(RunOptions runOptions, IReadOnlyDictionary`2<string, OrtValue> inputs, IReadOnlyCollection`1<string> outputNames);
    private static IDisposableReadOnlyCollection`1<OrtValue> CreateDisposableResult(DisposableOrtValueHandleArray disposableHandles);
    public void Run(RunOptions runOptions, IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<OrtValue> inputValues, IReadOnlyCollection`1<string> outputNames, IReadOnlyCollection`1<OrtValue> outputValues);
    public OrtIoBinding CreateIoBinding();
    public void RunWithBinding(RunOptions runOptions, OrtIoBinding ioBinding);
    public IDisposableReadOnlyCollection`1<OrtValue> RunWithBoundResults(RunOptions runOptions, OrtIoBinding ioBinding);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> RunWithBindingAndNames(RunOptions runOptions, OrtIoBinding ioBinding, String[] names);
    public string EndProfiling();
    private NodeMetadata LookupInputMetadata(string nodeName);
    private NodeMetadata LookupOutputMetadata(string nodeName);
    private static IntPtr ExtractOrtValueHandleForInput(NamedOnnxValue input, NodeMetadata metadata, IDisposable& memOwner);
    private static IntPtr ExtractOrtValueHandleForOutput(NamedOnnxValue output, NodeMetadata metadata, IDisposable& memOwner);
    private static IntPtr[] LookupUtf8Names(IReadOnlyCollection`1<T> values, NameExtractor`1<T> nameExtractor, MetadataLookup metaLookup);
    private static IntPtr[] GetOrtValuesHandles(IReadOnlyCollection`1<NamedOnnxValue> values, MetadataLookup metaLookup, OrtValueHandleExtractor ortValueExtractor, DisposableArray`1& disposer);
    private static IntPtr[] GetOrtValuesHandles(IReadOnlyCollection`1<FixedBufferOnnxValue> values, bool input);
    private DisposableOrtValueHandleArray RunImpl(RunOptions options, IntPtr[] inputNames, IntPtr[] inputValues, IntPtr[] outputNames);
    private static IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> CreateDisposableResult(Span`1<IntPtr> valueHandles, IReadOnlyCollection`1<string> outputNames);
    public ModelMetadata get_ModelMetadata();
    public ulong get_ProfilingStartTimeNs();
    private static void OrtCallback(IntPtr userData, IntPtr[] ouputs, UInt32 numOutputs, IntPtr status);
    private void RunAsyncInternal(RunOptions options, IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<OrtValue> inputValues, IReadOnlyCollection`1<string> outputNames, IReadOnlyCollection`1<OrtValue> outputValues, UserCallbackDelegate callback);
    [AsyncStateMachineAttribute("Microsoft.ML.OnnxRuntime.InferenceSession/<RunAsync>d__75")]
[DebuggerStepThroughAttribute]
public Task`1<IReadOnlyCollection`1<OrtValue>> RunAsync(RunOptions options, IReadOnlyCollection`1<string> inputNames, IReadOnlyCollection`1<OrtValue> inputValues, IReadOnlyCollection`1<string> outputNames, IReadOnlyCollection`1<OrtValue> outputValues);
    private void Init(string modelPath, SessionOptions options, PrePackedWeightsContainer prepackedWeightsContainer);
    private void Init(Byte[] modelData, SessionOptions options, PrePackedWeightsContainer prepackedWeightsContainer);
    private void InitWithSessionHandle(IntPtr session);
    private string GetOutputName(ulong index, IntPtr& utf8);
    private string GetInputName(ulong index, IntPtr& utf8);
    private string GetOverridableInitializerName(ulong index, IntPtr& utf8);
    private NodeMetadata GetInputMetadata(ulong index);
    private NodeMetadata GetOutputMetadata(ulong index);
    private NodeMetadata GetOverridableInitializerMetadata(ulong index);
    internal static NodeMetadata GetMetadataFromTypeInfo(IntPtr typeInfo);
    internal static NodeMetadata GetSequenceMetadataFromTypeInfo(IntPtr typeInfo);
    internal static NodeMetadata GetMapMetadataFromTypeInfo(IntPtr typeInfo);
    internal static NodeMetadata GetOptionalMetadataFromTypeInfo(IntPtr typeInfo);
    internal static NodeMetadata GetTensorNodeMetadata(OnnxValueType valueType, IntPtr typeInfo);
    internal IntPtr get_Handle();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void DisposeImpl(bool disposing);
}
internal interface Microsoft.ML.OnnxRuntime.IOrtValueOwner {
    public OrtValue Value { get; }
    public abstract virtual OrtValue get_Value();
}
internal enum Microsoft.ML.OnnxRuntime.LRScheduler : Enum {
    public int value__;
    public static LRScheduler None;
    public static LRScheduler Constant;
    public static LRScheduler Linear;
}
internal class Microsoft.ML.OnnxRuntime.ManagedTypeProjection : object {
    internal static OrtValue CreateProjection(NamedOnnxValue namedOnnxValue, NodeMetadata metadata);
    private static OrtValue CreateSequenceProjection(NamedOnnxValue namedOnnxValue, NodeMetadata metadata);
    private static OrtValue CreateMapProjection(NamedOnnxValue node, NodeMetadata elementMeta);
    private static OrtValue CreateTensorProjection(NamedOnnxValue node, NodeMetadata elementMeta);
}
internal class Microsoft.ML.OnnxRuntime.MapHelper : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorBase <Keys>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorBase <Values>k__BackingField;
    internal TensorBase Keys { get; }
    internal TensorBase Values { get; }
    internal MapHelper(TensorBase keys, TensorBase values);
    [CompilerGeneratedAttribute]
internal TensorBase get_Keys();
    [CompilerGeneratedAttribute]
internal TensorBase get_Values();
}
public class Microsoft.ML.OnnxRuntime.MapMetadata : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <KeyDataType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NodeMetadata <ValueMetadata>k__BackingField;
    public TensorElementType KeyDataType { get; }
    public NodeMetadata ValueMetadata { get; }
    internal MapMetadata(TensorElementType keyDataType, NodeMetadata valueMetadata);
    [CompilerGeneratedAttribute]
public TensorElementType get_KeyDataType();
    [CompilerGeneratedAttribute]
public NodeMetadata get_ValueMetadata();
}
public class Microsoft.ML.OnnxRuntime.MarshaledString : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IntPtr <Value>k__BackingField;
    internal int Length { get; private set; }
    internal IntPtr Value { get; private set; }
    internal MarshaledString(string input);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal IntPtr get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(IntPtr value);
    public sealed virtual void Dispose();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class Microsoft.ML.OnnxRuntime.MarshaledStringArray : ValueType {
    private MarshaledString[] _values;
    internal ReadOnlySpan`1<MarshaledString> Values { get; }
    internal MarshaledStringArray(Tensor`1<string> inputs);
    internal MarshaledStringArray(IEnumerable`1<string> inputs);
    internal ReadOnlySpan`1<MarshaledString> get_Values();
    internal void Fill(IntPtr[] pDestination);
    public void Dispose();
}
public class Microsoft.ML.OnnxRuntime.ModelMetadata : object {
    private string _producerName;
    private string _graphName;
    private string _domain;
    private string _description;
    private string _graphDescription;
    private long _version;
    private Dictionary`2<string, string> _customMetadataMap;
    public string ProducerName { get; }
    public string GraphName { get; }
    public string Domain { get; }
    public string Description { get; }
    public string GraphDescription { get; }
    public long Version { get; }
    public Dictionary`2<string, string> CustomMetadataMap { get; }
    internal ModelMetadata(InferenceSession session);
    public string get_ProducerName();
    public string get_GraphName();
    public string get_Domain();
    public string get_Description();
    public string get_GraphDescription();
    public long get_Version();
    public Dictionary`2<string, string> get_CustomMetadataMap();
}
public class Microsoft.ML.OnnxRuntime.NamedOnnxValue : object {
    private object _value;
    private string _name;
    private MapHelper _mapHelper;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OnnxValueType <ValueType>k__BackingField;
    public OnnxValueType ValueType { get; internal set; }
    public string Name { get; public set; }
    public object Value { get; public set; }
    [ObsoleteAttribute("Use constructors with valueType or static factory methods")]
protected NamedOnnxValue(string name, object value);
    internal NamedOnnxValue(string name, object value, OnnxValueType valueType);
    internal NamedOnnxValue(string name, object value, MapHelper helper);
    [CompilerGeneratedAttribute]
public OnnxValueType get_ValueType();
    [CompilerGeneratedAttribute]
internal void set_ValueType(OnnxValueType value);
    public static NamedOnnxValue CreateFromTensor(string name, Tensor`1<T> value);
    public static NamedOnnxValue CreateFromSequence(string name, IEnumerable`1<T> value);
    public static NamedOnnxValue CreateFromMap(string name, IDictionary`2<K, V> value);
    internal static NamedOnnxValue CreateFromMap(string name, ICollection`1<K> keys, ICollection`1<V> values);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Tensor`1<T> AsTensor();
    public IEnumerable`1<T> AsEnumerable();
    public IDictionary`2<K, V> AsDictionary();
    internal virtual IntPtr InputToOrtValueHandle(NodeMetadata metadata, IDisposable& memoryOwner);
    internal virtual IntPtr OutputToOrtValueHandle(NodeMetadata metadata, IDisposable& memoryOwner);
    internal TensorBase GetDictionaryKeys();
    internal TensorBase GetDictionaryValues();
}
internal class Microsoft.ML.OnnxRuntime.NativeApiStatus : object {
    private static string GetErrorMessage(IntPtr status);
    public static void VerifySuccess(IntPtr nativeStatus);
}
internal static class Microsoft.ML.OnnxRuntime.NativeMethods : object {
    private static OrtApi api_;
    public static DOrtGetVersionString OrtGetVersionString;
    public static DOrtCreateEnv OrtCreateEnv;
    public static DOrtCreateEnvWithCustomLogger OrtCreateEnvWithCustomLogger;
    public static DOrtCreateEnvWithGlobalThreadPools OrtCreateEnvWithGlobalThreadPools;
    public static DOrtCreateEnvWithCustomLoggerAndGlobalThreadPools OrtCreateEnvWithCustomLoggerAndGlobalThreadPools;
    public static DOrtReleaseEnv OrtReleaseEnv;
    public static DOrtEnableTelemetryEvents OrtEnableTelemetryEvents;
    public static DOrtDisableTelemetryEvents OrtDisableTelemetryEvents;
    public static DOrtUpdateEnvWithCustomLogLevel OrtUpdateEnvWithCustomLogLevel;
    public static DOrtCreateTensorRTProviderOptions OrtCreateTensorRTProviderOptions;
    public static DOrtUpdateTensorRTProviderOptions OrtUpdateTensorRTProviderOptions;
    public static DOrtGetTensorRTProviderOptionsAsString OrtGetTensorRTProviderOptionsAsString;
    public static DOrtReleaseTensorRTProviderOptions OrtReleaseTensorRTProviderOptions;
    public static DOrtCreateCUDAProviderOptions OrtCreateCUDAProviderOptions;
    public static DOrtUpdateCUDAProviderOptions OrtUpdateCUDAProviderOptions;
    public static DOrtGetCUDAProviderOptionsAsString OrtGetCUDAProviderOptionsAsString;
    public static DOrtReleaseCUDAProviderOptions OrtReleaseCUDAProviderOptions;
    public static DOrtCreateROCMProviderOptions OrtCreateROCMProviderOptions;
    public static DOrtUpdateROCMProviderOptions OrtUpdateROCMProviderOptions;
    public static DOrtGetROCMProviderOptionsAsString OrtGetROCMProviderOptionsAsString;
    public static DOrtReleaseROCMProviderOptions OrtReleaseROCMProviderOptions;
    public static DOrtGetErrorCode OrtGetErrorCode;
    public static DOrtGetErrorMessage OrtGetErrorMessage;
    public static DOrtReleaseStatus OrtReleaseStatus;
    public static DOrtCreateSession OrtCreateSession;
    public static DOrtCreateSessionWithPrepackedWeightsContainer OrtCreateSessionWithPrepackedWeightsContainer;
    public static DOrtCreateSessionFromArray OrtCreateSessionFromArray;
    public static DOrtCreateSessionFromArrayWithPrepackedWeightsContainer OrtCreateSessionFromArrayWithPrepackedWeightsContainer;
    public static DOrtRun OrtRun;
    public static DOrtRunWithBinding OrtRunWithBinding;
    public static DOrtSessionGetInputCount OrtSessionGetInputCount;
    public static DOrtSessionGetOutputCount OrtSessionGetOutputCount;
    public static DOrtSessionGetOverridableInitializerCount OrtSessionGetOverridableInitializerCount;
    public static DOrtSessionGetInputName OrtSessionGetInputName;
    public static DOrtSessionGetOutputName OrtSessionGetOutputName;
    public static DOrtSessionEndProfiling OrtSessionEndProfiling;
    public static DOrtSessionGetOverridableInitializerName OrtSessionGetOverridableInitializerName;
    public static DOrtSessionGetInputTypeInfo OrtSessionGetInputTypeInfo;
    public static DOrtSessionGetOutputTypeInfo OrtSessionGetOutputTypeInfo;
    public static DOrtSessionGetOverridableInitializerTypeInfo OrtSessionGetOverridableInitializerTypeInfo;
    public static DOrtReleaseTypeInfo OrtReleaseTypeInfo;
    public static DOrtReleaseSession OrtReleaseSession;
    public static DOrtSessionGetProfilingStartTimeNs OrtSessionGetProfilingStartTimeNs;
    public static DCreateAndRegisterAllocatorV2 OrtCreateAndRegisterAllocatorV2;
    public static DOrtRunAsync OrtRunAsync;
    public static DOrtCreateSessionOptions OrtCreateSessionOptions;
    public static DOrtReleaseSessionOptions OrtReleaseSessionOptions;
    public static DOrtCloneSessionOptions OrtCloneSessionOptions;
    public static DOrtSetSessionExecutionMode OrtSetSessionExecutionMode;
    public static DOrtSetOptimizedModelFilePath OrtSetOptimizedModelFilePath;
    public static DOrtEnableProfiling OrtEnableProfiling;
    public static DOrtDisableProfiling OrtDisableProfiling;
    public static DOrtEnableMemPattern OrtEnableMemPattern;
    public static DOrtDisableMemPattern OrtDisableMemPattern;
    public static DOrtEnableCpuMemArena OrtEnableCpuMemArena;
    public static DOrtDisableCpuMemArena OrtDisableCpuMemArena;
    public static DOrtDisablePerSessionThreads OrtDisablePerSessionThreads;
    public static DOrtSetSessionLogId OrtSetSessionLogId;
    public static DOrtSetSessionLogVerbosityLevel OrtSetSessionLogVerbosityLevel;
    public static DOrtSetSessionLogSeverityLevel OrtSetSessionLogSeverityLevel;
    public static DOrtSetIntraOpNumThreads OrtSetIntraOpNumThreads;
    public static DOrtSetInterOpNumThreads OrtSetInterOpNumThreads;
    public static DOrtSetSessionGraphOptimizationLevel OrtSetSessionGraphOptimizationLevel;
    public static DOrtAddSessionConfigEntry OrtAddSessionConfigEntry;
    public static DSessionOptionsAppendExecutionProvider_TensorRT SessionOptionsAppendExecutionProvider_TensorRT;
    public static DSessionOptionsAppendExecutionProvider_TensorRT_V2 SessionOptionsAppendExecutionProvider_TensorRT_V2;
    public static DSessionOptionsAppendExecutionProvider_CUDA SessionOptionsAppendExecutionProvider_CUDA;
    public static DSessionOptionsAppendExecutionProvider_CUDA_V2 SessionOptionsAppendExecutionProvider_CUDA_V2;
    public static DSessionOptionsAppendExecutionProvider_ROCM SessionOptionsAppendExecutionProvider_ROCM;
    public static DOrtAddFreeDimensionOverride OrtAddFreeDimensionOverride;
    public static DOrtAddFreeDimensionOverrideByName OrtAddFreeDimensionOverrideByName;
    public static DOrtRegisterCustomOpsLibrary OrtRegisterCustomOpsLibrary;
    public static DOrtRegisterCustomOpsLibrary_V2 OrtRegisterCustomOpsLibrary_V2;
    public static DOrtAddInitializer OrtAddInitializer;
    public static DSessionOptionsAppendExecutionProvider SessionOptionsAppendExecutionProvider;
    public static DOrtCreateRunOptions OrtCreateRunOptions;
    public static DOrtReleaseRunOptions OrtReleaseRunOptions;
    public static DOrtRunOptionsSetRunLogVerbosityLevel OrtRunOptionsSetRunLogVerbosityLevel;
    public static DOrtRunOptionsSetRunLogSeverityLevel OrtRunOptionsSetRunLogSeverityLevel;
    public static DOrtRunOptionsSetRunTag OrtRunOptionsSetRunTag;
    public static DOrtRunOptionsGetRunLogVerbosityLevel OrtRunOptionsGetRunLogVerbosityLevel;
    public static DOrtRunOptionsGetRunLogSeverityLevel OrtRunOptionsGetRunLogSeverityLevel;
    public static DOrtRunOptionsGetRunTag OrtRunOptionsGetRunTag;
    public static DOrtRunOptionsSetTerminate OrtRunOptionsSetTerminate;
    public static DOrtRunOptionsUnsetTerminate OrtRunOptionsUnsetTerminate;
    public static DOrtAddRunConfigEntry OrtAddRunConfigEntry;
    public static DOrtCreateThreadingOptions OrtCreateThreadingOptions;
    public static DOrtReleaseThreadingOptions OrtReleaseThreadingOptions;
    public static DOrtThreadingOptionsSetGlobalInterOpNumThreads OrtThreadingOptionsSetGlobalInterOpNumThreads;
    public static DOrtThreadingOptionsSetGlobalIntraOpNumThreads OrtThreadingOptionsSetGlobalIntraOpNumThreads;
    public static DOrtThreadingOptionsSetGlobalDenormalAsZero OrtThreadingOptionsSetGlobalDenormalAsZero;
    public static DOrtThreadingOptionsSetGlobalSpinControl OrtThreadingOptionsSetGlobalSpinControl;
    public static DOrtCreateMemoryInfo OrtCreateMemoryInfo;
    public static DOrtCreateCpuMemoryInfo OrtCreateCpuMemoryInfo;
    public static DOrtReleaseMemoryInfo OrtReleaseMemoryInfo;
    public static DOrtCompareMemoryInfo OrtCompareMemoryInfo;
    public static DOrtMemoryInfoGetName OrtMemoryInfoGetName;
    public static DOrtMemoryInfoGetId OrtMemoryInfoGetId;
    public static DOrtMemoryInfoGetMemType OrtMemoryInfoGetMemType;
    public static DOrtMemoryInfoGetType OrtMemoryInfoGetType;
    public static DOrtGetAllocatorWithDefaultOptions OrtGetAllocatorWithDefaultOptions;
    public static DOrtAllocatorGetInfo OrtAllocatorGetInfo;
    public static DOrtCreateArenaCfg OrtCreateArenaCfg;
    public static DOrtReleaseArenaCfg OrtReleaseArenaCfg;
    public static DOrtCreateAllocator OrtCreateAllocator;
    public static DOrtReleaseAllocator OrtReleaseAllocator;
    public static DOrtAllocatorAlloc OrtAllocatorAlloc;
    public static DOrtAllocatorFree OrtAllocatorFree;
    public static DOrtCreateIoBinding OrtCreateIoBinding;
    public static DOrtReleaseIoBinding OrtReleaseIoBinding;
    public static DOrtBindInput OrtBindInput;
    public static DOrtSynchronizeBoundInputs OrtSynchronizeBoundInputs;
    public static DOrtBindOutput OrtBindOutput;
    public static DOrtBindOutputToDevice OrtBindOutputToDevice;
    public static DOrtSynchronizeBoundOutputs OrtSynchronizeBoundOutputs;
    public static DOrtGetBoundOutputNames OrtGetBoundOutputNames;
    public static DOrtGetBoundOutputValues OrtGetBoundOutputValues;
    public static DOrtClearBoundInputs OrtClearBoundInputs;
    public static DOrtClearBoundOutputs OrtClearBoundOutputs;
    public static DOrtTensorAt OrtTensorAt;
    public static DOrtCreateAndRegisterAllocator OrtCreateAndRegisterAllocator;
    public static DOrtSetLanguageProjection OrtSetLanguageProjection;
    public static DOrtSessionGetModelMetadata OrtSessionGetModelMetadata;
    public static DOrtModelMetadataGetProducerName OrtModelMetadataGetProducerName;
    public static DOrtModelMetadataGetGraphName OrtModelMetadataGetGraphName;
    public static DOrtModelMetadataGetDomain OrtModelMetadataGetDomain;
    public static DOrtModelMetadataGetDescription OrtModelMetadataGetDescription;
    public static DOrtModelMetadataGetGraphDescription OrtModelMetadataGetGraphDescription;
    public static DOrtModelMetadataGetVersion OrtModelMetadataGetVersion;
    public static DOrtModelMetadataGetCustomMetadataMapKeys OrtModelMetadataGetCustomMetadataMapKeys;
    public static DOrtModelMetadataLookupCustomMetadataMap OrtModelMetadataLookupCustomMetadataMap;
    public static DOrtReleaseModelMetadata OrtReleaseModelMetadata;
    public static DOrtHasValue OrtHasValue;
    public static DOrtGetValue OrtGetValue;
    public static DOrtGetValueType OrtGetValueType;
    public static DOrtGetOnnxTypeFromTypeInfo OrtGetOnnxTypeFromTypeInfo;
    public static DOrtGetValueCount OrtGetValueCount;
    public static DOrtCreateValue OrtCreateValue;
    public static DOrtGetTypeInfo OrtGetTypeInfo;
    public static DOrtCreateTensorAsOrtValue OrtCreateTensorAsOrtValue;
    public static DOrtCreateTensorWithDataAsOrtValue OrtCreateTensorWithDataAsOrtValue;
    public static DOrtValueIsTensor OrtValueIsTensor;
    public static DOrtValueIsSparseTensor OrtValueIsSparseTensor;
    public static DOrtGetTensorMutableData OrtGetTensorMutableData;
    public static DOrtFillStringTensor OrtFillStringTensor;
    public static DOrtGetResizedStringTensorElementBuffer OrtGetResizedStringTensorElementBuffer;
    public static DOrtGetStringTensorContent OrtGetStringTensorContent;
    public static DOrtGetStringTensorDataLength OrtGetStringTensorDataLength;
    public static DOrtGetStringTensorElementLength OrtGetStringTensorElementLength;
    public static DOrtGetStringTensorElement OrtGetStringTensorElement;
    public static DOrtCastTypeInfoToTensorInfo OrtCastTypeInfoToTensorInfo;
    public static DOrtGetTensorTypeAndShape OrtGetTensorTypeAndShape;
    public static DOrtReleaseTensorTypeAndShapeInfo OrtReleaseTensorTypeAndShapeInfo;
    public static DOrtGetTensorElementType OrtGetTensorElementType;
    public static DOrtGetDimensionsCount OrtGetDimensionsCount;
    public static DOrtGetDimensions OrtGetDimensions;
    public static DOrtGetSymbolicDimensions OrtGetSymbolicDimensions;
    public static DOrtGetTensorShapeElementCount OrtGetTensorShapeElementCount;
    public static DOrtGetTensorMemoryInfo OrtGetTensorMemoryInfo;
    public static DCastTypeInfoToMapTypeInfo OrtCastTypeInfoToMapTypeInfo;
    public static DGetMapKeyType OrtGetMapKeyType;
    public static DGetMapValueType OrtGetMapValueType;
    public static DCastTypeInfoToSequenceTypeInfo OrtCastTypeInfoToSequenceTypeInfo;
    public static DGetSequenceElementType OrtGetSequenceElementType;
    public static DOrtCastTypeInfoToOptionalTypeInfo OrtCastTypeInfoToOptionalTypeInfo;
    public static DGetOptionalContainedTypeInfo OrtGetOptionalContainedTypeInfo;
    public static DOrtReleaseValue OrtReleaseValue;
    public static DOrtGetAvailableProviders OrtGetAvailableProviders;
    public static DOrtReleaseAvailableProviders OrtReleaseAvailableProviders;
    public static DOrtCreatePrepackedWeightsContainer OrtCreatePrepackedWeightsContainer;
    public static DOrtReleasePrepackedWeightsContainer OrtReleasePrepackedWeightsContainer;
    private static NativeMethods();
    public static OrtApiBase& OrtGetApiBase();
    public static IntPtr OrtSessionOptionsAppendExecutionProvider_CPU(IntPtr options, int use_arena);
    public static IntPtr OrtSessionOptionsAppendExecutionProvider_Nnapi(IntPtr options, UInt32 nnapi_flags);
}
internal static class Microsoft.ML.OnnxRuntime.NativeOnnxValueHelper : object {
    internal static Byte[] StringToZeroTerminatedUtf8(string s);
    internal static void StringToUtf8NativeMemory(Char* strPtr, int strLength, IntPtr ptr, int nativeBufferSize);
    internal static string StringFromNativeUtf8(IntPtr nativeUtf8, OrtAllocator allocator);
    internal static void StringAndUtf8FromNative(OrtAllocator allocator, IntPtr nativeUtf8, String& str, IntPtr& utf8);
    internal static Byte[] GetPlatformSerializedString(string str);
}
internal class Microsoft.ML.OnnxRuntime.NativeOrtValueCollectionOwner : object {
    private OrtValue _ortValue;
    private IDisposable _disposables;
    private bool _disposed;
    public OrtValue Value { get; }
    internal NativeOrtValueCollectionOwner(OrtValue& ortValue, IDisposable disposables);
    public sealed virtual OrtValue get_Value();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal static class Microsoft.ML.OnnxRuntime.NativeTrainingMethods : object {
    private static OrtApi api_;
    private static OrtTrainingApi trainingApi_;
    private static IntPtr trainingApiPtr;
    public static DOrtGetTrainingApi OrtGetTrainingApi;
    public static DOrtLoadCheckpoint OrtLoadCheckpoint;
    public static DOrtSaveCheckpoint OrtSaveCheckpoint;
    public static DOrtCreateTrainingSession OrtCreateTrainingSession;
    public static DOrtGetTrainingModelOutputCount OrtGetTrainingModelOutputCount;
    public static DOrtGetEvalModelOutputCount OrtGetEvalModelOutputCount;
    public static DOrtGetTrainingModelOutputName OrtGetTrainingModelOutputName;
    public static DOrtGetEvalModelOutputName OrtGetEvalModelOutputName;
    public static DOrtLazyResetGrad OrtLazyResetGrad;
    public static DOrtTrainStep OrtTrainStep;
    public static DOrtEvalStep OrtEvalStep;
    public static DOrtOptimizerStep OrtOptimizerStep;
    public static DOrtSetLearningRate OrtSetLearningRate;
    public static DOrtGetLearningRate OrtGetLearningRate;
    public static DOrtRegisterLinearLRScheduler OrtRegisterLinearLRScheduler;
    public static DOrtSchedulerStep OrtSchedulerStep;
    public static DOrtGetParametersSize OrtGetParametersSize;
    public static DOrtCopyParametersToBuffer OrtCopyParametersToBuffer;
    public static DOrtCopyBufferToParameters OrtCopyBufferToParameters;
    public static DOrtReleaseTrainingSession OrtReleaseTrainingSession;
    public static DOrtReleaseCheckpointState OrtReleaseCheckpointState;
    public static DOrtExportModelForInferencing OrtExportModelForInferencing;
    public static DOrtSetSeed OrtSetSeed;
    public static DOrtGetTrainingModelInputCount OrtGetTrainingModelInputCount;
    public static DOrtGetEvalModelInputCount OrtGetEvalModelInputCount;
    public static DOrtGetTrainingModelInputName OrtGetTrainingModelInputName;
    public static DOrtGetEvalModelInputName OrtGetEvalModelInputName;
    public static DOrtAddProperty OrtAddProperty;
    public static DOrtGetProperty OrtGetProperty;
    public static DOrtGetParameterTypeAndShape OrtGetParameterTypeAndShape;
    public static DOrtUpdateParameter OrtUpdateParameter;
    public static DOrtGetParameter OrtGetParameter;
    private static NativeTrainingMethods();
    public static bool TrainingEnabled();
}
[FlagsAttribute]
public enum Microsoft.ML.OnnxRuntime.NnapiFlags : Enum {
    public int value__;
    public static NnapiFlags NNAPI_FLAG_USE_NONE;
    public static NnapiFlags NNAPI_FLAG_USE_FP16;
    public static NnapiFlags NNAPI_FLAG_USE_NCHW;
    public static NnapiFlags NNAPI_FLAG_CPU_DISABLED;
    public static NnapiFlags NNAPI_FLAG_CPU_ONLY;
    public static NnapiFlags NNAPI_FLAG_LAST;
}
public class Microsoft.ML.OnnxRuntime.NodeMetadata : object {
    private object _metadata;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OnnxValueType <OnnxValueType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IntPtr <ZeroTerminatedName>k__BackingField;
    public OnnxValueType OnnxValueType { get; }
    internal IntPtr ZeroTerminatedName { get; internal set; }
    public Int32[] Dimensions { get; }
    public String[] SymbolicDimensions { get; }
    public Type ElementType { get; }
    public TensorElementType ElementDataType { get; }
    public bool IsString { get; }
    public bool IsTensor { get; }
    internal NodeMetadata(OnnxValueType onnxValueType, TensorTypeAndShape typeAndShape);
    internal NodeMetadata(MapMetadata mapMetadata);
    internal NodeMetadata(SequenceMetadata sequenceMetadata);
    internal NodeMetadata(OptionalMetadata optMetadata);
    private void CheckTensor();
    public MapMetadata AsMapMetadata();
    public SequenceMetadata AsSequenceMetadata();
    public OptionalMetadata AsOptionalMetadata();
    [CompilerGeneratedAttribute]
public OnnxValueType get_OnnxValueType();
    [CompilerGeneratedAttribute]
internal IntPtr get_ZeroTerminatedName();
    [CompilerGeneratedAttribute]
internal void set_ZeroTerminatedName(IntPtr value);
    public Int32[] get_Dimensions();
    public String[] get_SymbolicDimensions();
    public Type get_ElementType();
    public TensorElementType get_ElementDataType();
    public bool get_IsString();
    public bool get_IsTensor();
}
public class Microsoft.ML.OnnxRuntime.OnnxRuntimeException : Exception {
    private static Dictionary`2<ErrorCode, string> errorCodeToString;
    internal OnnxRuntimeException(ErrorCode errorCode, string message);
    private static OnnxRuntimeException();
}
public enum Microsoft.ML.OnnxRuntime.OnnxValueType : Enum {
    public int value__;
    public static OnnxValueType ONNX_TYPE_UNKNOWN;
    public static OnnxValueType ONNX_TYPE_TENSOR;
    public static OnnxValueType ONNX_TYPE_SEQUENCE;
    public static OnnxValueType ONNX_TYPE_MAP;
    public static OnnxValueType ONNX_TYPE_OPAQUE;
    public static OnnxValueType ONNX_TYPE_SPARSETENSOR;
    public static OnnxValueType ONNX_TYPE_OPTIONAL;
}
public class Microsoft.ML.OnnxRuntime.OptionalMetadata : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NodeMetadata <ElementMeta>k__BackingField;
    public NodeMetadata ElementMeta { get; }
    internal OptionalMetadata(NodeMetadata elementData);
    [CompilerGeneratedAttribute]
public NodeMetadata get_ElementMeta();
}
public class Microsoft.ML.OnnxRuntime.OrtAllocator : SafeHandle {
    private static Lazy`1<OrtAllocator> _defaultInstance;
    private bool _owned;
    public static OrtAllocator DefaultInstance { get; }
    internal IntPtr Pointer { get; }
    public bool IsInvalid { get; }
    public OrtMemoryInfo Info { get; }
    internal OrtAllocator(IntPtr allocator, bool owned);
    public OrtAllocator(InferenceSession session, OrtMemoryInfo memInfo);
    private static OrtAllocator();
    private static OrtAllocator GetDefaultCpuAllocator();
    public static OrtAllocator get_DefaultInstance();
    internal IntPtr get_Pointer();
    public virtual bool get_IsInvalid();
    public OrtMemoryInfo get_Info();
    public OrtMemoryAllocation Allocate(UInt32 size);
    internal void FreeMemory(IntPtr allocation);
    protected virtual bool ReleaseHandle();
}
public enum Microsoft.ML.OnnxRuntime.OrtAllocatorType : Enum {
    public int value__;
    public static OrtAllocatorType DeviceAllocator;
    public static OrtAllocatorType ArenaAllocator;
}
public class Microsoft.ML.OnnxRuntime.OrtApi : ValueType {
    public IntPtr CreateStatus;
    public IntPtr GetErrorCode;
    public IntPtr GetErrorMessage;
    public IntPtr CreateEnv;
    public IntPtr CreateEnvWithCustomLogger;
    public IntPtr EnableTelemetryEvents;
    public IntPtr DisableTelemetryEvents;
    public IntPtr CreateSession;
    public IntPtr CreateSessionFromArray;
    public IntPtr Run;
    public IntPtr CreateSessionOptions;
    public IntPtr SetOptimizedModelFilePath;
    public IntPtr CloneSessionOptions;
    public IntPtr SetSessionExecutionMode;
    public IntPtr EnableProfiling;
    public IntPtr DisableProfiling;
    public IntPtr EnableMemPattern;
    public IntPtr DisableMemPattern;
    public IntPtr EnableCpuMemArena;
    public IntPtr DisableCpuMemArena;
    public IntPtr SetSessionLogId;
    public IntPtr SetSessionLogVerbosityLevel;
    public IntPtr SetSessionLogSeverityLevel;
    public IntPtr SetSessionGraphOptimizationLevel;
    public IntPtr SetIntraOpNumThreads;
    public IntPtr SetInterOpNumThreads;
    public IntPtr CreateCustomOpDomain;
    public IntPtr CustomOpDomain_Add;
    public IntPtr AddCustomOpDomain;
    public IntPtr RegisterCustomOpsLibrary;
    public IntPtr SessionGetInputCount;
    public IntPtr SessionGetOutputCount;
    public IntPtr SessionGetOverridableInitializerCount;
    public IntPtr SessionGetInputTypeInfo;
    public IntPtr SessionGetOutputTypeInfo;
    public IntPtr SessionGetOverridableInitializerTypeInfo;
    public IntPtr SessionGetInputName;
    public IntPtr SessionGetOutputName;
    public IntPtr SessionGetOverridableInitializerName;
    public IntPtr CreateRunOptions;
    public IntPtr RunOptionsSetRunLogVerbosityLevel;
    public IntPtr RunOptionsSetRunLogSeverityLevel;
    public IntPtr RunOptionsSetRunTag;
    public IntPtr RunOptionsGetRunLogVerbosityLevel;
    public IntPtr RunOptionsGetRunLogSeverityLevel;
    public IntPtr RunOptionsGetRunTag;
    public IntPtr RunOptionsSetTerminate;
    public IntPtr RunOptionsUnsetTerminate;
    public IntPtr CreateTensorAsOrtValue;
    public IntPtr CreateTensorWithDataAsOrtValue;
    public IntPtr IsTensor;
    public IntPtr GetTensorMutableData;
    public IntPtr FillStringTensor;
    public IntPtr GetStringTensorDataLength;
    public IntPtr GetStringTensorContent;
    public IntPtr CastTypeInfoToTensorInfo;
    public IntPtr GetOnnxTypeFromTypeInfo;
    public IntPtr CreateTensorTypeAndShapeInfo;
    public IntPtr SetTensorElementType;
    public IntPtr SetDimensions;
    public IntPtr GetTensorElementType;
    public IntPtr GetDimensionsCount;
    public IntPtr GetDimensions;
    public IntPtr GetSymbolicDimensions;
    public IntPtr GetTensorShapeElementCount;
    public IntPtr GetTensorTypeAndShape;
    public IntPtr GetTypeInfo;
    public IntPtr GetValueType;
    public IntPtr CreateMemoryInfo;
    public IntPtr CreateCpuMemoryInfo;
    public IntPtr CompareMemoryInfo;
    public IntPtr MemoryInfoGetName;
    public IntPtr MemoryInfoGetId;
    public IntPtr MemoryInfoGetMemType;
    public IntPtr MemoryInfoGetType;
    public IntPtr AllocatorAlloc;
    public IntPtr AllocatorFree;
    public IntPtr AllocatorGetInfo;
    public IntPtr GetAllocatorWithDefaultOptions;
    public IntPtr AddFreeDimensionOverride;
    public IntPtr GetValue;
    public IntPtr GetValueCount;
    public IntPtr CreateValue;
    public IntPtr CreateOpaqueValue;
    public IntPtr GetOpaqueValue;
    public IntPtr KernelInfoGetAttribute_float;
    public IntPtr KernelInfoGetAttribute_int64;
    public IntPtr KernelInfoGetAttribute_string;
    public IntPtr KernelContext_GetInputCount;
    public IntPtr KernelContext_GetOutputCount;
    public IntPtr KernelContext_GetInput;
    public IntPtr KernelContext_GetOutput;
    public IntPtr ReleaseEnv;
    public IntPtr ReleaseStatus;
    public IntPtr ReleaseMemoryInfo;
    public IntPtr ReleaseSession;
    public IntPtr ReleaseValue;
    public IntPtr ReleaseRunOptions;
    public IntPtr ReleaseTypeInfo;
    public IntPtr ReleaseTensorTypeAndShapeInfo;
    public IntPtr ReleaseSessionOptions;
    public IntPtr ReleaseCustomOpDomain;
    public IntPtr GetDenotationFromTypeInfo;
    public IntPtr CastTypeInfoToMapTypeInfo;
    public IntPtr CastTypeInfoToSequenceTypeInfo;
    public IntPtr GetMapKeyType;
    public IntPtr GetMapValueType;
    public IntPtr GetSequenceElementType;
    public IntPtr ReleaseMapTypeInfo;
    public IntPtr ReleaseSequenceTypeInfo;
    public IntPtr SessionEndProfiling;
    public IntPtr SessionGetModelMetadata;
    public IntPtr ModelMetadataGetProducerName;
    public IntPtr ModelMetadataGetGraphName;
    public IntPtr ModelMetadataGetDomain;
    public IntPtr ModelMetadataGetDescription;
    public IntPtr ModelMetadataLookupCustomMetadataMap;
    public IntPtr ModelMetadataGetVersion;
    public IntPtr ReleaseModelMetadata;
    public IntPtr CreateEnvWithGlobalThreadPools;
    public IntPtr DisablePerSessionThreads;
    public IntPtr CreateThreadingOptions;
    public IntPtr ReleaseThreadingOptions;
    public IntPtr ModelMetadataGetCustomMetadataMapKeys;
    public IntPtr AddFreeDimensionOverrideByName;
    public IntPtr GetAvailableProviders;
    public IntPtr ReleaseAvailableProviders;
    public IntPtr GetStringTensorElementLength;
    public IntPtr GetStringTensorElement;
    public IntPtr FillStringTensorElement;
    public IntPtr AddSessionConfigEntry;
    public IntPtr CreateAllocator;
    public IntPtr ReleaseAllocator;
    public IntPtr RunWithBinding;
    public IntPtr CreateIoBinding;
    public IntPtr ReleaseIoBinding;
    public IntPtr BindInput;
    public IntPtr BindOutput;
    public IntPtr BindOutputToDevice;
    public IntPtr GetBoundOutputNames;
    public IntPtr GetBoundOutputValues;
    public IntPtr ClearBoundInputs;
    public IntPtr ClearBoundOutputs;
    public IntPtr TensorAt;
    public IntPtr CreateAndRegisterAllocator;
    public IntPtr SetLanguageProjection;
    public IntPtr SessionGetProfilingStartTimeNs;
    public IntPtr SetGlobalIntraOpNumThreads;
    public IntPtr SetGlobalInterOpNumThreads;
    public IntPtr SetGlobalSpinControl;
    public IntPtr AddInitializer;
    public IntPtr CreateEnvWithCustomLoggerAndGlobalThreadPools;
    public IntPtr SessionOptionsAppendExecutionProvider_CUDA;
    public IntPtr SessionOptionsAppendExecutionProvider_ROCM;
    public IntPtr SessionOptionsAppendExecutionProvider_OpenVINO;
    public IntPtr SetGlobalDenormalAsZero;
    public IntPtr CreateArenaCfg;
    public IntPtr ReleaseArenaCfg;
    public IntPtr ModelMetadataGetGraphDescription;
    public IntPtr SessionOptionsAppendExecutionProvider_TensorRT;
    public IntPtr SetCurrentGpuDeviceId;
    public IntPtr GetCurrentGpuDeviceId;
    public IntPtr KernelInfoGetAttributeArray_float;
    public IntPtr KernelInfoGetAttributeArray_int64;
    public IntPtr CreateArenaCfgV2;
    public IntPtr AddRunConfigEntry;
    public IntPtr CreatePrepackedWeightsContainer;
    public IntPtr ReleasePrepackedWeightsContainer;
    public IntPtr CreateSessionWithPrepackedWeightsContainer;
    public IntPtr CreateSessionFromArrayWithPrepackedWeightsContainer;
    public IntPtr SessionOptionsAppendExecutionProvider_TensorRT_V2;
    public IntPtr CreateTensorRTProviderOptions;
    public IntPtr UpdateTensorRTProviderOptions;
    public IntPtr GetTensorRTProviderOptionsAsString;
    public IntPtr ReleaseTensorRTProviderOptions;
    public IntPtr EnableOrtCustomOps;
    public IntPtr RegisterAllocator;
    public IntPtr UnregisterAllocator;
    public IntPtr IsSparseTensor;
    public IntPtr CreateSparseTensorAsOrtValue;
    public IntPtr FillSparseTensorCoo;
    public IntPtr FillSparseTensorCsr;
    public IntPtr FillSparseTensorBlockSparse;
    public IntPtr CreateSparseTensorWithValuesAsOrtValue;
    public IntPtr UseCooIndices;
    public IntPtr UseCsrIndices;
    public IntPtr UseBlockSparseIndices;
    public IntPtr GetSparseTensorFormat;
    public IntPtr GetSparseTensorValuesTypeAndShape;
    public IntPtr GetSparseTensorValues;
    public IntPtr GetSparseTensorIndicesTypeShape;
    public IntPtr GetSparseTensorIndices;
    public IntPtr HasValue;
    public IntPtr KernelContext_GetGPUComputeStream;
    public IntPtr GetTensorMemoryInfo;
    public IntPtr GetExecutionProviderApi;
    public IntPtr SessionOptionsSetCustomCreateThreadFn;
    public IntPtr SessionOptionsSetCustomThreadCreationOptions;
    public IntPtr SessionOptionsSetCustomJoinThreadFn;
    public IntPtr SetGlobalCustomCreateThreadFn;
    public IntPtr SetGlobalCustomThreadCreationOptions;
    public IntPtr SetGlobalCustomJoinThreadFn;
    public IntPtr SynchronizeBoundInputs;
    public IntPtr SynchronizeBoundOutputs;
    public IntPtr SessionOptionsAppendExecutionProvider_CUDA_V2;
    public IntPtr CreateCUDAProviderOptions;
    public IntPtr UpdateCUDAProviderOptions;
    public IntPtr GetCUDAProviderOptionsAsString;
    public IntPtr ReleaseCUDAProviderOptions;
    public IntPtr SessionOptionsAppendExecutionProvider_MIGraphX;
    public IntPtr AddExternalInitializers;
    public IntPtr CreateOpAttr;
    public IntPtr ReleaseOpAttr;
    public IntPtr CreateOp;
    public IntPtr InvokeOp;
    public IntPtr ReleaseOp;
    public IntPtr SessionOptionsAppendExecutionProvider;
    public IntPtr CopyKernelInfo;
    public IntPtr ReleaseKernelInfo;
    public IntPtr GetTrainingApi;
    public IntPtr SessionOptionsAppendExecutionProvider_CANN;
    public IntPtr CreateCANNProviderOptions;
    public IntPtr UpdateCANNProviderOptions;
    public IntPtr GetCANNProviderOptionsAsString;
    public IntPtr ReleaseCANNProviderOptions;
    public IntPtr MemoryInfoGetDeviceType;
    public IntPtr UpdateEnvWithCustomLogLevel;
    public IntPtr SetGlobalIntraOpThreadAffinity;
    public IntPtr RegisterCustomOpsLibrary_V2;
    public IntPtr RegisterCustomOpsUsingFunction;
    public IntPtr KernelInfo_GetInputCount;
    public IntPtr KernelInfo_GetOutputCount;
    public IntPtr KernelInfo_GetInputName;
    public IntPtr KernelInfo_GetOutputName;
    public IntPtr KernelInfo_GetInputTypeInfo;
    public IntPtr KernelInfo_GetOutputTypeInfo;
    public IntPtr KernelInfoGetAttribute_tensor;
    public IntPtr HasSessionConfigEntry;
    public IntPtr GetSessionConfigEntry;
    public IntPtr SessionOptionsAppendExecutionProvider_Dnnl;
    public IntPtr CreateDnnlProviderOptions;
    public IntPtr UpdateDnnlProviderOptions;
    public IntPtr GetDnnlProviderOptionsAsString;
    public IntPtr ReleaseDnnlProviderOptions;
    public IntPtr KernelInfo_GetNodeName;
    public IntPtr KernelInfo_GetLogger;
    public IntPtr KernelContext_GetLogger;
    public IntPtr Logger_LogMessage;
    public IntPtr Logger_GetLoggingSeverityLevel;
    public IntPtr KernelInfoGetConstantInput_tensor;
    public IntPtr CastTypeInfoToOptionalTypeInfo;
    public IntPtr GetOptionalContainedTypeInfo;
    public IntPtr GetResizedStringTensorElementBuffer;
    public IntPtr KernelContext_GetAllocator;
    public IntPtr GetBuildInfoString;
    public IntPtr CreateROCMProviderOptions;
    public IntPtr UpdateROCMProviderOptions;
    public IntPtr GetROCMProviderOptionsAsString;
    public IntPtr ReleaseROCMProviderOptions;
    public IntPtr CreateAndRegisterAllocatorV2;
    public IntPtr RunAsync;
}
public class Microsoft.ML.OnnxRuntime.OrtApiBase : ValueType {
    public IntPtr GetApi;
    public IntPtr GetVersionString;
}
public class Microsoft.ML.OnnxRuntime.OrtArenaCfg : SafeHandle {
    internal IntPtr Pointer { get; }
    public bool IsInvalid { get; }
    public OrtArenaCfg(UInt32 maxMemory, int arenaExtendStrategy, int initialChunkSizeBytes, int maxDeadBytesPerChunk);
    internal IntPtr get_Pointer();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.ML.OnnxRuntime.OrtCUDAProviderOptions : SafeHandle {
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    internal IntPtr get_Handle();
    public string GetOptions();
    private static IntPtr UpdateCUDAProviderOptions(IntPtr handle, IntPtr[] keys, IntPtr[] values, UIntPtr count);
    public void UpdateOptions(Dictionary`2<string, string> providerOptions);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.ML.OnnxRuntime.OrtEnv : SafeHandle {
    private static int ORT_PROJECTION_CSHARP;
    private static Byte[] _defaultLogId;
    private static Nullable`1<EnvironmentCreationOptions> _createOptions;
    private static Lazy`1<OrtEnv> _instance;
    private static DOrtLoggingFunctionInternal _loggingFunctionInternal;
    private static DOrtLoggingFunction _userLoggingFunction;
    private OrtLoggingLevel _envLogLevel;
    public static bool IsCreated { get; }
    public OrtLoggingLevel EnvLogLevel { get; public set; }
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    private OrtEnv(IntPtr handle, OrtLoggingLevel logLevel);
    private static OrtEnv();
    private static void LoggingFunctionThunk(IntPtr param, IntPtr severity, IntPtr category, IntPtr logid, IntPtr codeLocation, IntPtr message);
    private static OrtEnv CreateInstance();
    private static OrtEnv CreateDefaultEnv(OrtLoggingLevel logLevel, Byte[] logIdUtf8);
    private static OrtEnv CreateWithCustomLogger(OrtLoggingLevel logLevel, Byte[] logIdUtf8, IntPtr loggerParam, DOrtLoggingFunction loggingFunction);
    private static OrtEnv CreateWithThreadingOptions(OrtLoggingLevel logLevel, Byte[] logIdUtf8, OrtThreadingOptions threadingOptions);
    private static OrtEnv CreateEnvWithCustomLoggerAndGlobalThreadPools(OrtLoggingLevel logLevel, Byte[] logIdUtf8, IntPtr logParam, OrtThreadingOptions threadingOptions, DOrtLoggingFunction loggingFunction);
    private static void SetLanguageProjection(OrtEnv env);
    public static OrtEnv Instance();
    public static OrtEnv CreateInstanceWithOptions(EnvironmentCreationOptions& options);
    public static bool get_IsCreated();
    public void EnableTelemetryEvents();
    public void DisableTelemetryEvents();
    public void CreateAndRegisterAllocator(OrtMemoryInfo memInfo, OrtArenaCfg arenaCfg);
    public string GetVersionString();
    public String[] GetAvailableProviders();
    public OrtLoggingLevel get_EnvLogLevel();
    public void set_EnvLogLevel(OrtLoggingLevel value);
    internal IntPtr get_Handle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal static class Microsoft.ML.OnnxRuntime.OrtExtensionsNativeMethods : object {
    internal static string ExtensionsDllName;
    public static IntPtr RegisterCustomOps(IntPtr sessionOptions, OrtApiBase& ortApiBase);
}
[ObsoleteAttribute("Create OrtValue over an arbitrary piece of memory and use it where appropriate.")]
public class Microsoft.ML.OnnxRuntime.OrtExternalAllocation : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OrtMemoryInfo <Info>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Int64[] <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IntPtr <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private long <Size>k__BackingField;
    public OrtMemoryInfo Info { get; private set; }
    public Int64[] Shape { get; private set; }
    public TensorElementType ElementType { get; private set; }
    public IntPtr Pointer { get; private set; }
    public long Size { get; private set; }
    public OrtExternalAllocation(OrtMemoryInfo memInfo, Int64[] shape, TensorElementType elementType, IntPtr pointer, long sizeInBytes);
    [CompilerGeneratedAttribute]
public OrtMemoryInfo get_Info();
    [CompilerGeneratedAttribute]
private void set_Info(OrtMemoryInfo value);
    [CompilerGeneratedAttribute]
public Int64[] get_Shape();
    [CompilerGeneratedAttribute]
private void set_Shape(Int64[] value);
    [CompilerGeneratedAttribute]
public TensorElementType get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(TensorElementType value);
    [CompilerGeneratedAttribute]
public IntPtr get_Pointer();
    [CompilerGeneratedAttribute]
private void set_Pointer(IntPtr value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(long value);
}
public class Microsoft.ML.OnnxRuntime.OrtIoBinding : SafeHandle {
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    internal OrtIoBinding(InferenceSession session);
    internal IntPtr get_Handle();
    public virtual bool get_IsInvalid();
    public void BindInput(string name, OrtValue ortValue);
    public void BindInput(string name, TensorElementType elementType, Int64[] shape, OrtMemoryAllocation allocation);
    [ObsoleteAttribute("This BindInput overload is deprecated. Create OrtValue over an arbitrary piece of memory.")]
public void BindInput(string name, OrtExternalAllocation allocation);
    [ObsoleteAttribute("This BindInput overload is deprecated. Use of OrtValue based overload is recommended.")]
public void BindInput(string name, FixedBufferOnnxValue fixedValue);
    public void SynchronizeBoundInputs();
    public void BindOutput(string name, OrtValue ortValue);
    public void BindOutput(string name, TensorElementType elementType, Int64[] shape, OrtMemoryAllocation allocation);
    [ObsoleteAttribute("This BindOutput overload is deprecated. Create OrtValue over an arbitrary piece of memory.")]
public void BindOutput(string name, OrtExternalAllocation allocation);
    [ObsoleteAttribute("This BindOutput overload is deprecated. Use of OrtValue based overload is recommended.")]
public void BindOutput(string name, FixedBufferOnnxValue fixedValue);
    public void BindOutputToDevice(string name, OrtMemoryInfo memInfo);
    public void SynchronizeBoundOutputs();
    private void BindOrtAllocation(string name, TensorElementType elementType, Int64[] shape, OrtMemoryAllocation allocation, bool isInput);
    private void BindExternalAllocation(string name, OrtExternalAllocation allocation, bool isInput);
    private void BindInputOrOutput(string name, IntPtr ortValue, bool isInput);
    public String[] GetOutputNames();
    public IDisposableReadOnlyCollection`1<OrtValue> GetOutputValues();
    internal OrtValue[] GetOutputOrtValues();
    public void ClearBoundInputs();
    public void ClearBoundOutputs();
    protected virtual bool ReleaseHandle();
}
public enum Microsoft.ML.OnnxRuntime.OrtLoggingLevel : Enum {
    public int value__;
    public static OrtLoggingLevel ORT_LOGGING_LEVEL_VERBOSE;
    public static OrtLoggingLevel ORT_LOGGING_LEVEL_INFO;
    public static OrtLoggingLevel ORT_LOGGING_LEVEL_WARNING;
    public static OrtLoggingLevel ORT_LOGGING_LEVEL_ERROR;
    public static OrtLoggingLevel ORT_LOGGING_LEVEL_FATAL;
}
public class Microsoft.ML.OnnxRuntime.OrtMapTypeInfo : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OrtTypeInfo <ValueType>k__BackingField;
    public TensorElementType KeyType { get; private set; }
    public OrtTypeInfo ValueType { get; private set; }
    internal OrtMapTypeInfo(IntPtr handle);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TensorElementType get_KeyType();
    [CompilerGeneratedAttribute]
private void set_KeyType(TensorElementType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public OrtTypeInfo get_ValueType();
    [CompilerGeneratedAttribute]
private void set_ValueType(OrtTypeInfo value);
}
public class Microsoft.ML.OnnxRuntime.OrtMemoryAllocation : SafeHandle {
    private OrtAllocator _allocator;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private UInt32 <Size>k__BackingField;
    internal IntPtr Pointer { get; }
    public bool IsInvalid { get; }
    public UInt32 Size { get; private set; }
    public OrtMemoryInfo Info { get; }
    internal OrtMemoryAllocation(OrtAllocator allocator, IntPtr pointer, UInt32 size);
    internal IntPtr get_Pointer();
    public virtual bool get_IsInvalid();
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(UInt32 value);
    public OrtMemoryInfo get_Info();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.ML.OnnxRuntime.OrtMemoryInfo : SafeHandle {
    private static Lazy`1<OrtMemoryInfo> _defaultCpuAllocInfo;
    private bool _owned;
    public static Byte[] allocatorCPU;
    public static Byte[] allocatorCUDA;
    public static Byte[] allocatorCUDA_PINNED;
    public static Byte[] allocatorHIP;
    public static Byte[] allocatorHIP_PINNED;
    public static OrtMemoryInfo DefaultInstance { get; }
    internal IntPtr Pointer { get; }
    public bool IsInvalid { get; }
    public string Name { get; }
    public int Id { get; }
    internal OrtMemoryInfo(IntPtr allocInfo, bool owned);
    public OrtMemoryInfo(Byte[] utf8AllocatorName, OrtAllocatorType allocatorType, int deviceId, OrtMemType memoryType);
    public OrtMemoryInfo(string allocatorName, OrtAllocatorType allocatorType, int deviceId, OrtMemType memoryType);
    private static OrtMemoryInfo();
    private static OrtMemoryInfo CreateCpuMemoryInfo();
    public static OrtMemoryInfo get_DefaultInstance();
    internal IntPtr get_Pointer();
    public virtual bool get_IsInvalid();
    public string get_Name();
    public int get_Id();
    public OrtMemType GetMemoryType();
    public OrtAllocatorType GetAllocatorType();
    public virtual bool Equals(object obj);
    public bool Equals(OrtMemoryInfo other);
    public virtual int GetHashCode();
    protected virtual bool ReleaseHandle();
}
public enum Microsoft.ML.OnnxRuntime.OrtMemType : Enum {
    public int value__;
    public static OrtMemType CpuInput;
    public static OrtMemType CpuOutput;
    public static OrtMemType Cpu;
    public static OrtMemType Default;
}
public class Microsoft.ML.OnnxRuntime.OrtROCMProviderOptions : SafeHandle {
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    internal IntPtr get_Handle();
    public string GetOptions();
    private static IntPtr UpdateROCMProviderOptions(IntPtr handle, IntPtr[] keys, IntPtr[] values, UIntPtr count);
    public void UpdateOptions(Dictionary`2<string, string> providerOptions);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.ML.OnnxRuntime.OrtSequenceOrOptionalTypeInfo : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OrtTypeInfo <ElementType>k__BackingField;
    public OrtTypeInfo ElementType { get; private set; }
    internal OrtSequenceOrOptionalTypeInfo(IntPtr handle);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public OrtTypeInfo get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(OrtTypeInfo value);
}
public class Microsoft.ML.OnnxRuntime.OrtTensorRTProviderOptions : SafeHandle {
    private int _deviceId;
    private string _deviceIdStr;
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    internal IntPtr get_Handle();
    public string GetOptions();
    private static IntPtr UpdateTRTOptions(IntPtr handle, IntPtr[] keys, IntPtr[] values, UIntPtr count);
    public void UpdateOptions(Dictionary`2<string, string> providerOptions);
    public int GetDeviceId();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.ML.OnnxRuntime.OrtTensorTypeAndShapeInfo : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <ElementDataType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private long <ElementCount>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Int64[] <Shape>k__BackingField;
    public TensorElementType ElementDataType { get; private set; }
    public bool IsString { get; }
    public long ElementCount { get; private set; }
    public int DimensionsCount { get; }
    public Int64[] Shape { get; private set; }
    internal OrtTensorTypeAndShapeInfo(IntPtr handle);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TensorElementType get_ElementDataType();
    [CompilerGeneratedAttribute]
private void set_ElementDataType(TensorElementType value);
    public bool get_IsString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_ElementCount();
    [CompilerGeneratedAttribute]
private void set_ElementCount(long value);
    public int get_DimensionsCount();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Int64[] get_Shape();
    [CompilerGeneratedAttribute]
private void set_Shape(Int64[] value);
}
public class Microsoft.ML.OnnxRuntime.OrtThreadingOptions : SafeHandle {
    internal IntPtr Handle { get; }
    unknown int GlobalInterOpNumThreads {public set; }
    unknown int GlobalIntraOpNumThreads {public set; }
    unknown bool GlobalSpinControl {public set; }
    public bool IsInvalid { get; }
    internal IntPtr get_Handle();
    public void set_GlobalInterOpNumThreads(int value);
    public void set_GlobalIntraOpNumThreads(int value);
    public void set_GlobalSpinControl(bool value);
    public void SetGlobalDenormalAsZero();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
public class Microsoft.ML.OnnxRuntime.OrtTrainingApi : ValueType {
    public IntPtr LoadCheckpoint;
    public IntPtr SaveCheckpoint;
    public IntPtr CreateTrainingSession;
    public IntPtr CreateTrainingSessionFromBuffer;
    public IntPtr TrainingSessionGetTrainingModelOutputCount;
    public IntPtr TrainingSessionGetEvalModelOutputCount;
    public IntPtr TrainingSessionGetTrainingModelOutputName;
    public IntPtr TrainingSessionGetEvalModelOutputName;
    public IntPtr LazyResetGrad;
    public IntPtr TrainStep;
    public IntPtr EvalStep;
    public IntPtr SetLearningRate;
    public IntPtr GetLearningRate;
    public IntPtr OptimizerStep;
    public IntPtr RegisterLinearLRScheduler;
    public IntPtr SchedulerStep;
    public IntPtr GetParametersSize;
    public IntPtr CopyParametersToBuffer;
    public IntPtr CopyBufferToParameters;
    public IntPtr ReleaseTrainingSession;
    public IntPtr ReleaseCheckpointState;
    public IntPtr ExportModelForInferencing;
    public IntPtr SetSeed;
    public IntPtr TrainingSessionGetTrainingModelInputCount;
    public IntPtr TrainingSessionGetEvalModelInputCount;
    public IntPtr TrainingSessionGetTrainingModelInputName;
    public IntPtr TrainingSessionGetEvalModelInputName;
    public IntPtr AddProperty;
    public IntPtr GetProperty;
    public IntPtr LoadCheckpointFromBuffer;
    public IntPtr GetParameterTypeAndShape;
    public IntPtr UpdateParameter;
    public IntPtr GetParameter;
}
public class Microsoft.ML.OnnxRuntime.OrtTypeInfo : object {
    private Nullable`1<OrtTensorTypeAndShapeInfo> _tensorTypeAndShape;
    private Nullable`1<OrtSequenceOrOptionalTypeInfo> _sequenceOrOptional;
    private Nullable`1<OrtMapTypeInfo> _mapTypeInfo;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OnnxValueType <OnnxType>k__BackingField;
    public OnnxValueType OnnxType { get; private set; }
    public OrtTensorTypeAndShapeInfo TensorTypeAndShapeInfo { get; }
    public OrtSequenceOrOptionalTypeInfo SequenceTypeInfo { get; }
    public OrtMapTypeInfo MapTypeInfo { get; }
    public OrtSequenceOrOptionalTypeInfo OptionalTypeInfo { get; }
    internal OrtTypeInfo(IntPtr handle);
    [CompilerGeneratedAttribute]
public OnnxValueType get_OnnxType();
    [CompilerGeneratedAttribute]
private void set_OnnxType(OnnxValueType value);
    public OrtTensorTypeAndShapeInfo get_TensorTypeAndShapeInfo();
    public OrtSequenceOrOptionalTypeInfo get_SequenceTypeInfo();
    public OrtMapTypeInfo get_MapTypeInfo();
    public OrtSequenceOrOptionalTypeInfo get_OptionalTypeInfo();
}
public class Microsoft.ML.OnnxRuntime.OrtValue : object {
    private DisposableList`1<OrtValue> _compositeMembers;
    private IntPtr _handle;
    private Nullable`1<MemoryHandle> _memHandle;
    private bool _disposed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OnnxValueType <OnnxType>k__BackingField;
    internal IntPtr Handle { get; }
    public OrtValue Value { get; }
    public OnnxValueType OnnxType { get; private set; }
    public bool IsTensor { get; }
    public bool IsSparseTensor { get; }
    internal OrtValue(IntPtr handle);
    internal OrtValue(IntPtr handle, OnnxValueType onnxValueType);
    internal OrtValue(IntPtr handle, OnnxValueType onnxValueType, DisposableList`1& compositeMembers);
    private OrtValue(IntPtr handle, MemoryHandle memHandle);
    internal IntPtr get_Handle();
    public sealed virtual OrtValue get_Value();
    [CompilerGeneratedAttribute]
public OnnxValueType get_OnnxType();
    [CompilerGeneratedAttribute]
private void set_OnnxType(OnnxValueType value);
    private void InitOnnxType();
    public bool get_IsTensor();
    public bool get_IsSparseTensor();
    public int GetValueCount();
    public OrtValue GetValue(int index, OrtAllocator allocator);
    public ReadOnlySpan`1<T> GetTensorDataAsSpan();
    public Span`1<T> GetTensorMutableDataAsSpan();
    public Span`1<byte> GetTensorMutableRawData();
    public ReadOnlyMemory`1<char> GetStringElementAsMemory(int index);
    public string GetStringElement(int index);
    public ReadOnlySpan`1<byte> GetStringElementAsSpan(int index);
    public String[] GetStringTensorAsArray();
    public OrtTypeInfo GetTypeInfo();
    public OrtTensorTypeAndShapeInfo GetTensorTypeAndShape();
    public OrtMemoryInfo GetTensorMemoryInfo();
    private void GetTensorElementTypeAndCount(Int64& count, TensorElementType& elementType);
    private Char[] GetStringTensorElementChars(int index);
    private void GetStringTensorElementBuffer(UIntPtr index, UInt32& bytesLen, IntPtr& bufferPtr);
    private Span`1<byte> GetTensorBufferRawData(Type requestedType);
    public static OrtValue CreateTensorValueWithData(OrtMemoryInfo memInfo, TensorElementType elementType, Int64[] shape, IntPtr dataBufferPtr, long bufferLengthInBytes);
    public static OrtValue CreateTensorValueFromMemory(OrtMemoryInfo memoryInfo, Memory`1<T> memory, Int64[] shape);
    public static OrtValue CreateTensorValueFromMemory(T[] data, Int64[] shape);
    public static OrtValue CreateAllocatedTensorValue(OrtAllocator allocator, TensorElementType elementType, Int64[] shape);
    internal static OrtValue CreateFromTensorObject(TensorBase value, TensorElementType& elementType);
    public static OrtValue CreateTensorWithEmptyStrings(OrtAllocator allocator, Int64[] shape);
    public void StringTensorSetElementAt(ReadOnlySpan`1<char> str, int index);
    public void StringTensorSetElementAt(ReadOnlyMemory`1<char> rom, int index);
    public void StringTensorSetElementAt(ReadOnlySpan`1<byte> utf8Bytes, int index);
    public static OrtValue CreateFromStringTensor(Tensor`1<string> tensor);
    public static OrtValue CreateSequence(ICollection`1<OrtValue> ortValues);
    internal static OrtValue CreateSequence(DisposableList`1& compositeMembers);
    public void ProcessSequence(SequenceElementVisitor visitor, OrtAllocator allocator);
    public static OrtValue CreateMap(OrtValue& keys, OrtValue& values);
    public static OrtValue CreateMap(K[] keys, V[] values);
    public static OrtValue CreateMapWithStringKeys(IReadOnlyCollection`1<string> keys, V[] values);
    public static OrtValue CreateMapWithStringValues(K[] keys, IReadOnlyCollection`1<string> values);
    public void ProcessMap(MapVisitor visitor, OrtAllocator allocator);
    private void FillStringTensorElement(Char* strPtr, int strLength, int index);
    private static void PinAsTensor(Tensor`1<T> tensor, int elementSize, MemoryHandle& pinnedHandle, Int32& dataBufferLength, Int64[]& shape, Int32& rank);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.ML.OnnxRuntime.OrtValueTensor`1 : MemoryManager`1<T> {
    private OrtValue _ortValue;
    private IntPtr _dataBufferPointer;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Int32[] <Dimensions>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <ElementWidth>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <ElementType>k__BackingField;
    public OrtValue Value { get; }
    public bool IsDisposed { get; private set; }
    public Int32[] Dimensions { get; }
    public int Rank { get; }
    public int Count { get; }
    public int ElementWidth { get; }
    public TensorElementType ElementType { get; }
    public OrtValueTensor`1(OrtValue& ortValue);
    public sealed virtual OrtValue get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public Int32[] get_Dimensions();
    public int get_Rank();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public int get_ElementWidth();
    [CompilerGeneratedAttribute]
public TensorElementType get_ElementType();
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.ML.OnnxRuntime.PrePackedWeightsContainer : SafeHandle {
    internal IntPtr Pointer { get; }
    public bool IsInvalid { get; }
    internal IntPtr get_Pointer();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.ML.OnnxRuntime.ProviderOptionsUpdater : object {
    internal static void Update(Dictionary`2<string, string> providerOptions, IntPtr handle, Func`5<IntPtr, IntPtr[], IntPtr[], UIntPtr, IntPtr> updateFunc);
}
public class Microsoft.ML.OnnxRuntime.ProviderOptionsValueHelper : object {
    public static void StringToDict(string s, Dictionary`2<string, string> dict);
}
public class Microsoft.ML.OnnxRuntime.Resource : Resource {
}
public class Microsoft.ML.OnnxRuntime.RunOptions : SafeHandle {
    private OrtLoggingLevel _logSeverityLevel;
    private int _logVerbosityLevel;
    private string _logId;
    private bool _terminate;
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    public OrtLoggingLevel LogSeverityLevel { get; public set; }
    public int LogVerbosityLevel { get; public set; }
    public string LogId { get; public set; }
    public bool Terminate { get; public set; }
    internal IntPtr get_Handle();
    public virtual bool get_IsInvalid();
    public OrtLoggingLevel get_LogSeverityLevel();
    public void set_LogSeverityLevel(OrtLoggingLevel value);
    public int get_LogVerbosityLevel();
    public void set_LogVerbosityLevel(int value);
    public string get_LogId();
    public void set_LogId(string value);
    public bool get_Terminate();
    public void set_Terminate(bool value);
    public void AddRunConfigEntry(string configKey, string configValue);
    protected virtual bool ReleaseHandle();
}
public class Microsoft.ML.OnnxRuntime.SequenceMetadata : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NodeMetadata <ElementMeta>k__BackingField;
    public NodeMetadata ElementMeta { get; }
    internal SequenceMetadata(NodeMetadata elementData);
    [CompilerGeneratedAttribute]
public NodeMetadata get_ElementMeta();
}
public class Microsoft.ML.OnnxRuntime.SessionOptions : SafeHandle {
    private static String[] cudaDelayLoadedLibs;
    private static String[] trtDelayLoadedLibs;
    private bool _enableMemoryPattern;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <ProfileOutputPathPrefix>k__BackingField;
    private bool _enableProfiling;
    private string _optimizedModelFilePath;
    private bool _enableCpuMemArena;
    private string _logId;
    private OrtLoggingLevel _logSeverityLevel;
    private int _logVerbosityLevel;
    private int _intraOpNumThreads;
    private int _interOpNumThreads;
    private GraphOptimizationLevel _graphOptimizationLevel;
    private ExecutionMode _executionMode;
    internal IntPtr Handle { get; }
    public bool IsInvalid { get; }
    public bool EnableMemoryPattern { get; public set; }
    public string ProfileOutputPathPrefix { get; public set; }
    public bool EnableProfiling { get; public set; }
    public string OptimizedModelFilePath { get; public set; }
    public bool EnableCpuMemArena { get; public set; }
    public string LogId { get; public set; }
    public OrtLoggingLevel LogSeverityLevel { get; public set; }
    public int LogVerbosityLevel { get; public set; }
    public int IntraOpNumThreads { get; public set; }
    public int InterOpNumThreads { get; public set; }
    public GraphOptimizationLevel GraphOptimizationLevel { get; public set; }
    public ExecutionMode ExecutionMode { get; public set; }
    private static SessionOptions();
    public static SessionOptions MakeSessionOptionWithCudaProvider(int deviceId);
    public static SessionOptions MakeSessionOptionWithCudaProvider(OrtCUDAProviderOptions cudaProviderOptions);
    public static SessionOptions MakeSessionOptionWithTensorrtProvider(int deviceId);
    public static SessionOptions MakeSessionOptionWithTensorrtProvider(OrtTensorRTProviderOptions trtProviderOptions);
    public static SessionOptions MakeSessionOptionWithTvmProvider(string settings);
    public static SessionOptions MakeSessionOptionWithRocmProvider(int deviceId);
    public static SessionOptions MakeSessionOptionWithRocmProvider(OrtROCMProviderOptions rocmProviderOptions);
    public void AppendExecutionProvider_CPU(int useArena);
    public void AppendExecutionProvider_Dnnl(int useArena);
    public void AppendExecutionProvider_CUDA(int deviceId);
    public void AppendExecutionProvider_CUDA(OrtCUDAProviderOptions cudaProviderOptions);
    public void AppendExecutionProvider_DML(int deviceId);
    public void AppendExecutionProvider_OpenVINO(string deviceId);
    public void AppendExecutionProvider_Tensorrt(int deviceId);
    public void AppendExecutionProvider_Tensorrt(OrtTensorRTProviderOptions trtProviderOptions);
    public void AppendExecutionProvider_ROCm(int deviceId);
    public void AppendExecutionProvider_ROCm(OrtROCMProviderOptions rocmProviderOptions);
    public void AppendExecutionProvider_MIGraphX(int deviceId);
    public void AppendExecutionProvider_Nnapi(NnapiFlags nnapiFlags);
    public void AppendExecutionProvider_CoreML(CoreMLFlags coremlFlags);
    public void AppendExecutionProvider_Tvm(string settings);
    public void AppendExecutionProvider(string providerName, Dictionary`2<string, string> providerOptions);
    public void RegisterCustomOpLibrary(string libraryPath);
    public void RegisterCustomOpLibraryV2(string libraryPath, IntPtr& libraryHandle);
    public void RegisterOrtExtensions();
    public void AddInitializer(string name, OrtValue ortValue);
    public void AddSessionConfigEntry(string configKey, string configValue);
    public void AddFreeDimensionOverride(string dimDenotation, long dimValue);
    public void AddFreeDimensionOverrideByName(string dimName, long dimValue);
    internal IntPtr get_Handle();
    public virtual bool get_IsInvalid();
    public bool get_EnableMemoryPattern();
    public void set_EnableMemoryPattern(bool value);
    [CompilerGeneratedAttribute]
public string get_ProfileOutputPathPrefix();
    [CompilerGeneratedAttribute]
public void set_ProfileOutputPathPrefix(string value);
    public bool get_EnableProfiling();
    public void set_EnableProfiling(bool value);
    public string get_OptimizedModelFilePath();
    public void set_OptimizedModelFilePath(string value);
    public bool get_EnableCpuMemArena();
    public void set_EnableCpuMemArena(bool value);
    public void DisablePerSessionThreads();
    public string get_LogId();
    public void set_LogId(string value);
    public OrtLoggingLevel get_LogSeverityLevel();
    public void set_LogSeverityLevel(OrtLoggingLevel value);
    public int get_LogVerbosityLevel();
    public void set_LogVerbosityLevel(int value);
    public int get_IntraOpNumThreads();
    public void set_IntraOpNumThreads(int value);
    public int get_InterOpNumThreads();
    public void set_InterOpNumThreads(int value);
    public GraphOptimizationLevel get_GraphOptimizationLevel();
    public void set_GraphOptimizationLevel(GraphOptimizationLevel value);
    public ExecutionMode get_ExecutionMode();
    public void set_ExecutionMode(ExecutionMode value);
    private static IntPtr LoadLibrary(string dllToLoad);
    private static UInt32 GetSystemDirectory(StringBuilder lpBuffer, UInt32 uSize);
    private static bool CheckCudaExecutionProviderDLLs();
    private static bool CheckTensorrtExecutionProviderDLLs();
    private static bool CheckRocmExecutionProviderDLLs();
    protected virtual bool ReleaseHandle();
}
[ExtensionAttribute]
public static class Microsoft.ML.OnnxRuntime.SessionOptionsContainer : object {
    private static Lazy`1<Action`1<SessionOptions>> _defaultHandler;
    private static Dictionary`2<string, Lazy`1<Action`1<SessionOptions>>> _configurationHandlers;
    private static Lazy`1<Action`1<SessionOptions>> DefaultHandler { get; }
    private static SessionOptionsContainer();
    private static Lazy`1<Action`1<SessionOptions>> get_DefaultHandler();
    public static void Register(Action`1<SessionOptions> defaultHandler);
    public static void Register(string configuration, Action`1<SessionOptions> handler);
    public static SessionOptions Create(string configuration, bool useDefaultAsFallback);
    public static void Reset();
    [ExtensionAttribute]
public static SessionOptions ApplyConfiguration(SessionOptions options, string configuration, bool useDefaultAsFallback);
    private static Action`1<SessionOptions> Resolve(string configuration, bool useDefaultAsFallback);
}
[ExtensionAttribute]
public static class Microsoft.ML.OnnxRuntime.Tensors.ArrayTensorExtensions : object {
    [ExtensionAttribute]
public static DenseTensor`1<T> ToTensor(T[] array);
    [ExtensionAttribute]
public static DenseTensor`1<T> ToTensor(T[0...,0...] array, bool reverseStride);
    [ExtensionAttribute]
public static DenseTensor`1<T> ToTensor(T[0...,0...,0...] array, bool reverseStride);
    [ExtensionAttribute]
public static DenseTensor`1<T> ToTensor(T[0...,0...,0...,0...] array, bool reverseStride);
    [ExtensionAttribute]
public static DenseTensor`1<T> ToTensor(Array array, bool reverseStride);
}
internal static class Microsoft.ML.OnnxRuntime.Tensors.ArrayUtilities : object {
    public static int StackallocMax;
    public static long GetProduct(ReadOnlySpan`1<int> dimensions, int startIndex);
    public static bool IsAscending(ReadOnlySpan`1<int> values);
    public static bool IsDescending(ReadOnlySpan`1<int> values);
    public static Int32[] GetStrides(ReadOnlySpan`1<int> dimensions, bool reverseStride);
    public static void SplitStrides(Int32[] strides, Int32[] splitAxes, Int32[] newStrides, int stridesOffset, Int32[] splitStrides, int splitStridesOffset);
    public static int GetIndex(Int32[] strides, ReadOnlySpan`1<int> indices, int startFromDimension);
    public static void GetIndices(ReadOnlySpan`1<int> strides, bool reverseStride, int index, Int32[] indices, int startFromDimension);
    public static void GetIndices(ReadOnlySpan`1<int> strides, bool reverseStride, int index, Span`1<int> indices, int startFromDimension);
    public static int TransformIndexByStrides(int index, Int32[] sourceStrides, bool sourceReverseStride, Int32[] transformStrides);
    public static T[] GetEmpty();
}
public class Microsoft.ML.OnnxRuntime.Tensors.DenseTensor`1 : Tensor`1<T> {
    private Memory`1<T> memory;
    public Memory`1<T> Buffer { get; }
    internal DenseTensor`1(Array fromArray, bool reverseStride);
    public DenseTensor`1(int length);
    public DenseTensor`1(ReadOnlySpan`1<int> dimensions, bool reverseStride);
    public DenseTensor`1(Memory`1<T> memory, ReadOnlySpan`1<int> dimensions, bool reverseStride);
    public Memory`1<T> get_Buffer();
    public virtual T GetValue(int index);
    public virtual void SetValue(int index, T value);
    protected virtual void CopyTo(T[] array, int arrayIndex);
    protected virtual int IndexOf(T item);
    public virtual Tensor`1<T> Clone();
    public virtual Tensor`1<TResult> CloneEmpty(ReadOnlySpan`1<int> dimensions);
    public virtual Tensor`1<T> Reshape(ReadOnlySpan`1<int> dimensions);
}
public static class Microsoft.ML.OnnxRuntime.Tensors.ShapeUtils : object {
    public static long GetSizeForShape(ReadOnlySpan`1<long> shape);
    public static Int64[] GetStrides(ReadOnlySpan`1<long> dimensions);
    public static long GetIndex(ReadOnlySpan`1<long> strides, ReadOnlySpan`1<long> indices, int startFromDimension);
}
public static class Microsoft.ML.OnnxRuntime.Tensors.Tensor : object {
    public static Tensor`1<T> CreateIdentity(int size);
    public static Tensor`1<T> CreateIdentity(int size, bool columMajor);
    public static Tensor`1<T> CreateIdentity(int size, bool columMajor, T oneValue);
    public static Tensor`1<T> CreateFromDiagonal(Tensor`1<T> diagonal);
    public static Tensor`1<T> CreateFromDiagonal(Tensor`1<T> diagonal, int offset);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{GetArrayString(false)}")]
public abstract class Microsoft.ML.OnnxRuntime.Tensors.Tensor`1 : TensorBase {
    internal Int32[] dimensions;
    internal Int32[] strides;
    private bool isReversedStride;
    private long length;
    internal static T Zero { get; }
    internal static T One { get; }
    public long Length { get; }
    public int Rank { get; }
    public bool IsReversedStride { get; }
    public ReadOnlySpan`1<int> Dimensions { get; }
    public ReadOnlySpan`1<int> Strides { get; }
    public T Item { get; public set; }
    public T Item { get; public set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    protected Tensor`1(int length);
    protected Tensor`1(ReadOnlySpan`1<int> dimensions, bool reverseStride);
    protected Tensor`1(Array fromArray, bool reverseStride);
    internal static T get_Zero();
    internal static T get_One();
    public long get_Length();
    public int get_Rank();
    public bool get_IsReversedStride();
    public ReadOnlySpan`1<int> get_Dimensions();
    public ReadOnlySpan`1<int> get_Strides();
    public virtual void Fill(T value);
    public abstract virtual Tensor`1<T> Clone();
    public virtual Tensor`1<T> CloneEmpty();
    public virtual Tensor`1<T> CloneEmpty(ReadOnlySpan`1<int> dimensions);
    public virtual Tensor`1<TResult> CloneEmpty();
    public abstract virtual Tensor`1<TResult> CloneEmpty(ReadOnlySpan`1<int> dimensions);
    public Tensor`1<T> GetDiagonal();
    public Tensor`1<T> GetDiagonal(int offset);
    public Tensor`1<T> GetTriangle();
    public Tensor`1<T> GetTriangle(int offset);
    public Tensor`1<T> GetUpperTriangle();
    public Tensor`1<T> GetUpperTriangle(int offset);
    public Tensor`1<T> GetTriangle(int offset, bool upper);
    public abstract virtual Tensor`1<T> Reshape(ReadOnlySpan`1<int> dimensions);
    public virtual T get_Item(Int32[] indices);
    public virtual void set_Item(Int32[] indices, T value);
    public virtual T get_Item(ReadOnlySpan`1<int> indices);
    public virtual void set_Item(ReadOnlySpan`1<int> indices, T value);
    public abstract virtual T GetValue(int index);
    public abstract virtual void SetValue(int index, T value);
    public static int Compare(Tensor`1<T> left, Tensor`1<T> right);
    public static bool Equals(Tensor`1<T> left, Tensor`1<T> right);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [IteratorStateMachineAttribute("Microsoft.ML.OnnxRuntime.Tensors.Tensor`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__67")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    protected virtual bool Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    protected virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    protected virtual int IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(Tensor`1<T> other, IComparer comparer);
    private int CompareTo(Array other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(Tensor`1<T> other, IEqualityComparer comparer);
    private bool Equals(Array other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual DenseTensor`1<T> ToDenseTensor();
    public string GetArrayString(bool includeWhitespace);
    private static void Indent(StringBuilder builder, int tabs, int spacesPerTab);
    private static bool IsCompatibleObject(object value);
}
public class Microsoft.ML.OnnxRuntime.Tensors.TensorBase : object {
    private static Dictionary`2<Type, TensorTypeInfo> typeInfoMap;
    private static Dictionary`2<TensorElementType, TensorElementTypeInfo> tensorElementTypeInfoMap;
    private Type _primitiveType;
    private static TensorBase();
    protected TensorBase(Type primitiveType);
    public static TensorTypeInfo GetTypeInfo(Type type);
    public static TensorElementTypeInfo GetElementTypeInfo(TensorElementType elementType);
    public TensorTypeInfo GetTypeInfo();
}
public enum Microsoft.ML.OnnxRuntime.Tensors.TensorElementType : Enum {
    public int value__;
    public static TensorElementType Float;
    public static TensorElementType UInt8;
    public static TensorElementType Int8;
    public static TensorElementType UInt16;
    public static TensorElementType Int16;
    public static TensorElementType Int32;
    public static TensorElementType Int64;
    public static TensorElementType String;
    public static TensorElementType Bool;
    public static TensorElementType Float16;
    public static TensorElementType Double;
    public static TensorElementType UInt32;
    public static TensorElementType UInt64;
    public static TensorElementType Complex64;
    public static TensorElementType Complex128;
    public static TensorElementType BFloat16;
    public static TensorElementType DataTypeMax;
}
public class Microsoft.ML.OnnxRuntime.Tensors.TensorElementTypeInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <TensorType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <TypeSize>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsString>k__BackingField;
    public Type TensorType { get; private set; }
    public int TypeSize { get; private set; }
    public bool IsString { get; private set; }
    public TensorElementTypeInfo(Type type, int typeSize);
    [CompilerGeneratedAttribute]
public Type get_TensorType();
    [CompilerGeneratedAttribute]
private void set_TensorType(Type value);
    [CompilerGeneratedAttribute]
public int get_TypeSize();
    [CompilerGeneratedAttribute]
private void set_TypeSize(int value);
    [CompilerGeneratedAttribute]
public bool get_IsString();
    [CompilerGeneratedAttribute]
private void set_IsString(bool value);
}
public class Microsoft.ML.OnnxRuntime.Tensors.TensorTypeInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <TypeSize>k__BackingField;
    public TensorElementType ElementType { get; private set; }
    public int TypeSize { get; private set; }
    public bool IsString { get; }
    public TensorTypeInfo(TensorElementType elementType, int typeSize);
    [CompilerGeneratedAttribute]
public TensorElementType get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(TensorElementType value);
    [CompilerGeneratedAttribute]
public int get_TypeSize();
    [CompilerGeneratedAttribute]
private void set_TypeSize(int value);
    public bool get_IsString();
}
public class Microsoft.ML.OnnxRuntime.TensorTypeAndShape : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementType <ElementDataType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Int32[] <Dimensions>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private String[] <SymbolicDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TensorElementTypeInfo <ElementTypeInfo>k__BackingField;
    public TensorElementType ElementDataType { get; }
    public Int32[] Dimensions { get; }
    public String[] SymbolicDimensions { get; }
    public TensorElementTypeInfo ElementTypeInfo { get; }
    internal TensorTypeAndShape(TensorElementType elementType, Int32[] dimensions, String[] symbolicDimensions);
    [CompilerGeneratedAttribute]
public TensorElementType get_ElementDataType();
    [CompilerGeneratedAttribute]
public Int32[] get_Dimensions();
    [CompilerGeneratedAttribute]
public String[] get_SymbolicDimensions();
    [CompilerGeneratedAttribute]
public TensorElementTypeInfo get_ElementTypeInfo();
}
public class Microsoft.ML.OnnxRuntime.TrainingSession : object {
    private IntPtr _nativeHandle;
    private ulong _trainOutputCount;
    private ulong _evalOutputCount;
    private List`1<string> _trainOutputNames;
    private List`1<string> _evalOutputNames;
    private List`1<string> _trainInputNames;
    private List`1<string> _evalInputNames;
    private SessionOptions _builtInSessionOptions;
    private RunOptions _builtInRunOptions;
    private LRScheduler _scheduler;
    private bool _disposed;
    internal IntPtr Handle { get; }
    public TrainingSession(CheckpointState state, string trainModelPath, string evalModelPath, string optimizerModelPath);
    public TrainingSession(CheckpointState state, string trainModelPath, string optimizerModelPath);
    public TrainingSession(SessionOptions options, CheckpointState state, string trainModelPath, string evalModelPath, string optimizerModelPath);
    public void TrainStep(IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues);
    public void TrainStep(RunOptions options, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> TrainStep(IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues);
    public IDisposableReadOnlyCollection`1<DisposableNamedOnnxValue> TrainStep(RunOptions options, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues);
    public IDisposableReadOnlyCollection`1<OrtValue> TrainStep(IReadOnlyCollection`1<OrtValue> inputValues);
    private DisposableArray`1<OrtValue> ConvertNativeHandlesToOrtValues(IntPtr[] nativeHandles);
    public void LazyResetGrad();
    public void EvalStep(IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues);
    public void EvalStep(RunOptions options, IReadOnlyCollection`1<FixedBufferOnnxValue> inputValues, IReadOnlyCollection`1<FixedBufferOnnxValue> outputValues);
    public IDisposableReadOnlyCollection`1<OrtValue> EvalStep(IReadOnlyCollection`1<OrtValue> inputValues);
    public void SetLearningRate(float learningRate);
    public float GetLearningRate();
    public void RegisterLinearLRScheduler(long warmupStepCount, long totalStepCount, float initialLearningRate);
    public void SchedulerStep();
    public void OptimizerStep();
    public void OptimizerStep(RunOptions options);
    public void ExportModelForInferencing(string inferenceModelPath, IReadOnlyCollection`1<string> graphOutputNames);
    public OrtValue ToBuffer(bool onlyTrainable);
    public void FromBuffer(OrtValue ortValue, bool onlyTrainable);
    public List`1<string> OutputNames(bool training);
    public List`1<string> InputNames(bool training);
    private void Init(SessionOptions sessOptions, CheckpointState state, Byte[] trainModelPath, Byte[] evalModelPath, Byte[] optimizerModelPath);
    private string GetOutputName(ulong index, bool training);
    private string GetInputName(ulong index, bool training);
    private IntPtr[] GetOrtValuesHandles(IReadOnlyCollection`1<FixedBufferOnnxValue> values, bool input);
    private IntPtr[] GetOrtValuesHandles(IReadOnlyCollection`1<OrtValue> inputValues);
    private static IDisposableReadOnlyCollection`1<OrtValue> CreateDisposableResult(DisposableOrtValueHandleArray disposableHandles);
    private IntPtr[] ConvertNamesToUtf8(IReadOnlyCollection`1<string> names, DisposableList`1<IDisposable> cleanupList);
    internal IntPtr get_Handle();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void CleanupHelper(bool disposing);
}
public class Microsoft.ML.OnnxRuntime.TrainingUtils : object {
    public static void SetSeed(long seed);
}
