[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class EnumerableExtensions : object {
    private static Func`2<object, bool> notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static void Add(Dictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddRange(HashSet`1<T> hashSet, IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.139.59561")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertCollectionContainsShouldNotUseBoolCheck : AssertUsageAnalyzerBase {
    private static HashSet`1<string> linqContainsMethods;
    private static String[] targetMethods;
    private static AssertCollectionContainsShouldNotUseBoolCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static bool IsLinqContainsMethod(IMethodSymbol methodSymbol);
    private static bool IsICollectionContainsMethod(OperationAnalysisContext context, IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEmptyCollectionCheckShouldNotBeUsed : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertEmptyCollectionCheckShouldNotBeUsed();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEmptyShouldNotBeUsedForCollectionDoesNotContainCheck : AssertUsageAnalyzerBase {
    private static string linqWhereMethod;
    private static String[] targetMethods;
    private static AssertEmptyShouldNotBeUsedForCollectionDoesNotContainCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEnumerableAnyCheckShouldNotBeUsedForCollectionContainsCheck : AssertUsageAnalyzerBase {
    private static string enumerableAnyExtensionMethod;
    private static String[] targetMethods;
    private static AssertEnumerableAnyCheckShouldNotBeUsedForCollectionContainsCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEqualGenericShouldNotBeUsedForStringValue : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertEqualGenericShouldNotBeUsedForStringValue();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEqualLiteralValueShouldBeFirst : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertEqualLiteralValueShouldBeFirst();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static bool IsLiteralOrConstant(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEqualPrecisionShouldBeInRange : AssertUsageAnalyzerBase {
    private static Dictionary`2<SpecialType, int> precisionMaxLimits;
    private static String[] targetMethods;
    private static Dictionary`2<SpecialType, string> typeNames;
    private static AssertEqualPrecisionShouldBeInRange();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static Nullable`1<SpecialType> GetMethodNumericType(IMethodSymbol method);
    private static Nullable`1<ValueTuple`2<IArgumentOperation, int>> GetNumericLiteralValue(IInvocationOperation invocation);
    private static void EnsurePrecisionInRange(OperationAnalysisContext context, Location location, SpecialType numericType, int numericValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEqualShouldNotBeUsedForBoolLiteralCheck : AssertUsageAnalyzerBase {
    private static HashSet`1<string> equalMethods;
    private static HashSet`1<string> notEqualMethods;
    private static String[] targetMethods;
    private static AssertEqualShouldNotBeUsedForBoolLiteralCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static string GetReplacementMethodName(string methodName, bool isTrue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEqualShouldNotBeUsedForCollectionSizeCheck : AssertUsageAnalyzerBase {
    private static HashSet`1<string> allowedCollections;
    private static HashSet`1<string> sizeMethods;
    private static String[] targetMethods;
    private static AssertEqualShouldNotBeUsedForCollectionSizeCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static string GetReplacementMethodName(string methodName, int size);
    private static bool IsAllowedCollection(ISymbol symbol);
    private static bool IsWellKnownSizeMethod(ISymbol symbol);
    private static bool IsICollectionCountProperty(OperationAnalysisContext context, ISymbol symbol);
    private static bool IsICollectionOfTCountProperty(OperationAnalysisContext context, ISymbol symbol);
    private static bool IsIReadOnlyCollectionOfTCountProperty(OperationAnalysisContext context, ISymbol symbol);
    private static bool IsCountPropertyOf(INamedTypeSymbol collectionType, ISymbol symbol);
    private static bool IsCountPropertyOfGenericType(INamedTypeSymbol openCollectionType, ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEqualShouldNotBeUsedForNullCheck : AssertUsageAnalyzerBase {
    private static HashSet`1<string> equalMethods;
    private static HashSet`1<string> notEqualMethods;
    private static String[] targetMethods;
    private static AssertEqualShouldNotBeUsedForNullCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static string GetReplacementMethod(string methodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertEqualsShouldNotBeUsed : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertEqualsShouldNotBeUsed();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertIsTypeShouldNotBeUsedForAbstractType : AssertUsageAnalyzerBase {
    public static Dictionary`2<string, string> ReplacementMethods;
    private static string abstractClass;
    private static string interface;
    private static AssertIsTypeShouldNotBeUsedForAbstractType();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertIsTypeShouldUseGenericOverloadType : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertIsTypeShouldUseGenericOverloadType();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertNullShouldNotBeCalledOnValueTypes : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertNullShouldNotBeCalledOnValueTypes();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static bool IsArgumentTypeRecognizedAsReferenceType(ITypeSymbol argumentType);
    private static string GetDisplayString(ISymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertRegexMatchShouldNotUseBoolLiteralCheck : AssertUsageAnalyzerBase {
    private static HashSet`1<string> regexIsMatchSymbols;
    private static String[] targetMethods;
    private static AssertRegexMatchShouldNotUseBoolLiteralCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertSameShouldNotBeCalledOnValueTypes : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertSameShouldNotBeCalledOnValueTypes();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertSingleShouldBeUsedForSingleParameter : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertSingleShouldBeUsedForSingleParameter();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertStringEqualityCheckShouldNotUseBoolCheck : AssertUsageAnalyzerBase {
    private static HashSet`1<string> stringEqualsMethods;
    private static HashSet`1<StringComparison> supportedStringComparisons;
    private static String[] targetMethods;
    private static AssertStringEqualityCheckShouldNotUseBoolCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertSubstringCheckShouldNotUseBoolCheck : AssertUsageAnalyzerBase {
    private static HashSet`1<string> substringMethods;
    private static String[] targetMethods;
    private static AssertSubstringCheckShouldNotUseBoolCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static string GetReplacementMethodName(string assertMethodName, string substringMethodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertThrowsShouldNotBeUsedForAsyncThrowsCheck : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertThrowsShouldNotBeUsedForAsyncThrowsCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    private static ISymbol GetThrowExpressionSymbol(IInvocationOperation invocationOperation);
    [NullableContextAttribute("2")]
private static bool ThrowExpressionReturnsTask(ISymbol symbol, OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AssertThrowsShouldUseGenericOverloadCheck : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AssertThrowsShouldUseGenericOverloadCheck();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Xunit.Analyzers.AssertUsageAnalyzerBase : XunitDiagnosticAnalyzer {
    private HashSet`1<string> targetMethods;
    protected AssertUsageAnalyzerBase(DiagnosticDescriptor descriptor, IEnumerable`1<string> methods);
    protected AssertUsageAnalyzerBase(DiagnosticDescriptor[] descriptors, IEnumerable`1<string> methods);
    public sealed virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    protected abstract virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.AsyncAssertsShouldBeAwaited : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static AsyncAssertsShouldBeAwaited();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.BooleanAssertsShouldNotBeNegated : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static BooleanAssertsShouldNotBeNegated();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.BooleanAssertsShouldNotBeUsedForSimpleEqualityCheck : AssertUsageAnalyzerBase {
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    public static Nullable`1<SyntaxKind> LiteralReferenceKind(ExpressionSyntax expression, SemanticModel semanticModel);
    private static void ReportShouldReplaceBooleanOperationWithEquality(OperationAnalysisContext context, IInvocationOperation invocationOperation, ImmutableDictionary`2<string, string> properties, string currentMethodName, string replacement);
    private static void ReportShouldSimplifyBooleanOperation(OperationAnalysisContext context, IInvocationOperation invocationOperation, ImmutableDictionary`2<string, string> properties, string currentMethodName);
}
public enum Xunit.Analyzers.Category : Enum {
    public int value__;
    public static Category Usage;
    public static Category Assertions;
    public static Category Extensibility;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.ClassDataAttributeMustPointAtValidClass : XunitDiagnosticAnalyzer {
    private static string typesV2;
    private static string typesV3;
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    [NullableContextAttribute("2")]
private static bool IsGenericTheoryDataRowType(ITypeSymbol rowType, Dictionary`2<int, INamedTypeSymbol> theoryDataRowTypes, INamedTypeSymbol& theoryReturnType);
    private static void ReportClassReturnsUnsafeTypeValue(SyntaxNodeAnalysisContext context, AttributeSyntax attribute);
    private static void ReportExtraTypeArguments(SyntaxNodeAnalysisContext context, AttributeSyntax attribute, INamedTypeSymbol theoryDataType);
    private static void ReportIncompatibleType(SyntaxNodeAnalysisContext context, TypeSyntax parameterType, ITypeSymbol theoryDataTypeParameter, INamedTypeSymbol namedClassType, IParameterSymbol parameter);
    private static void ReportIncorrectImplementationType(SyntaxNodeAnalysisContext context, string validSymbols, AttributeSyntax attribute, ITypeSymbol classType);
    private static void ReportNullabilityMismatch(SyntaxNodeAnalysisContext context, TypeSyntax parameterType, ITypeSymbol theoryDataTypeParameter, INamedTypeSymbol namedClassType, IParameterSymbol parameter);
    private static void ReportTooFewTypeArguments(SyntaxNodeAnalysisContext context, AttributeSyntax attribute, INamedTypeSymbol theoryDataType);
    private static bool VerifyDataSourceDeclaration(SyntaxNodeAnalysisContext context, Compilation compilation, XunitContext xunitContext, INamedTypeSymbol classType, AttributeSyntax attribute);
    private static void VerifyGenericArgumentTypes(SemanticModel semanticModel, SyntaxNodeAnalysisContext context, MethodDeclarationSyntax testMethod, INamedTypeSymbol theoryDataType, INamedTypeSymbol theoryReturnType, ITypeSymbol classType, AttributeSyntax attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Xunit.Analyzers.CodeAnalysisExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol FindNamedType(IAssemblySymbol assembly, Func`2<INamedTypeSymbol, bool> selector);
    [ExtensionAttribute]
public static ImmutableArray`1<AttributeData> GetAttributesWithInheritance(IMethodSymbol method, ITypeSymbol attributeUsageType);
    [ExtensionAttribute]
public static bool IsInTestMethod(IOperation operation, XunitContext xunitContext);
    [ExtensionAttribute]
public static bool IsTestClass(ITypeSymbol type, XunitContext xunitContext, bool strict);
    private static bool IsTestClassNonStrict(ITypeSymbol type, XunitContext xunitContext);
    private static bool IsTestClassStrict(ITypeSymbol type, XunitContext xunitContext);
    [ExtensionAttribute]
public static bool IsTestMethod(IMethodSymbol method, XunitContext xunitContext, ITypeSymbol attributeUsageType, bool strict);
    [ExtensionAttribute]
public static IOperation WalkDownImplicitConversions(IOperation operation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.CollectionDefinitionClassesMustBePublic : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Xunit.Analyzers.Constants : object {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.ConstructorsOnFactAttributeSubclassShouldBePublic : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Xunit.Analyzers.ConversionChecker : object {
    public static bool IsConvertible(Compilation compilation, ITypeSymbol source, ITypeSymbol destination, XunitContext xunitContext);
    private static bool IsConvertibleTypeParameter(ITypeSymbol source, ITypeParameterSymbol destination);
    private static bool IsConvertibleNumeric(ITypeSymbol source, ITypeSymbol destination);
    private static bool IsDateTimeOffsetOrGuid(ITypeSymbol destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.CrossAppDomainClassesMustBeLongLivedMarshalByRefObject : XunitV2DiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.DataAttributeShouldBeUsedOnATheory : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Xunit.Analyzers.Descriptors : object {
    private static ConcurrentDictionary`2<Category, string> categoryMapping;
    [CompilerGeneratedAttribute]
private static SuppressionDescriptor <CA1515_Suppression>k__BackingField;
    [CompilerGeneratedAttribute]
private static SuppressionDescriptor <CA2007_Suppression>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1000_TestClassMustBePublic>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1001_FactMethodMustNotHaveParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1002_TestMethodMustNotHaveMultipleFactAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1003_TheoryMethodMustHaveTestData>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1004_TestMethodShouldNotBeSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1005_FactMethodShouldNotHaveTestData>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1006_TheoryMethodShouldHaveParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1007_ClassDataAttributeMustPointAtValidClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1008_DataAttributeShouldBeUsedOnATheory>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1009_InlineDataMustMatchTheoryParameters_TooFewValues>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1010_InlineDataMustMatchTheoryParameters_IncompatibleValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1011_InlineDataMustMatchTheoryParameters_ExtraValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1012_InlineDataMustMatchTheoryParameters_NullShouldNotBeUsedForIncompatibleParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1013_PublicMethodShouldBeMarkedAsTest>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1014_MemberDataShouldUseNameOfOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1015_MemberDataMustReferenceExistingMember>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1016_MemberDataMustReferencePublicMember>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1017_MemberDataMustReferenceStaticMember>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1018_MemberDataMustReferenceValidMemberKind>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1019_MemberDataMustReferenceMemberOfValidType>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1020_MemberDataPropertyMustHaveGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1021_MemberDataNonMethodShouldNotHaveParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1022_TheoryMethodCannotHaveParameterArray>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1023_TheoryMethodCannotHaveDefaultParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1024_TestMethodCannotHaveOverloads>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1025_InlineDataShouldBeUniqueWithinTheory>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1026_TheoryMethodShouldUseAllParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1027_CollectionDefinitionClassMustBePublic>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1028_TestMethodHasInvalidReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1029_LocalFunctionsCannotBeTestFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1030_DoNotUseConfigureAwait>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1031_DoNotUseBlockingTaskOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1032_TestClassCannotBeNestedInGenericClass>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1033_TestClassShouldHaveTFixtureArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1034_MemberDataArgumentsMustMatchMethodParameters_NullShouldNotBeUsedForIncompatibleParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1035_MemberDataArgumentsMustMatchMethodParameters_IncompatibleValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1036_MemberDataArgumentsMustMatchMethodParameters_ExtraValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1037_TheoryDataTypeArgumentsMustMatchTestMethodParameters_TooFewTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1038_TheoryDataTypeArgumentsMustMatchTestMethodParameters_ExtraTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1039_TheoryDataTypeArgumentsMustMatchTestMethodParameters_IncompatibleTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1040_TheoryDataTypeArgumentsMustMatchTestMethodParameters_IncompatibleNullability>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1041_EnsureFixturesHaveASource>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1042_MemberDataTheoryDataIsRecommendedForStronglyTypedAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1043_ConstructorOnFactAttributeSubclassShouldBePublic>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1044_AvoidUsingTheoryDataTypeArgumentsThatAreNotSerializable>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1045_AvoidUsingTheoryDataTypeArgumentsThatMightNotBeSerializable>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1046_AvoidUsingTheoryDataRowArgumentsThatAreNotSerializable>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1047_AvoidUsingTheoryDataRowArgumentsThatMightNotBeSerializable>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1048_DoNotUseAsyncVoidForTestMethods_V2>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1049_DoNotUseAsyncVoidForTestMethods_V3>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X1050_ClassDataTheoryDataRowIsRecommendedForStronglyTypedAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2000_AssertEqualLiteralValueShouldBeFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2001_AssertEqualsShouldNotBeUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2002_AssertNullShouldNotBeCalledOnValueTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2003_AssertEqualShouldNotUsedForNullCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2004_AssertEqualShouldNotUsedForBoolLiteralCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2005_AssertSameShouldNotBeCalledOnValueTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2006_AssertEqualGenericShouldNotBeUsedForStringValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2007_AssertIsTypeShouldUseGenericOverload>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2008_AssertRegexMatchShouldNotUseBoolLiteralCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2009_AssertSubstringCheckShouldNotUseBoolCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2010_AssertStringEqualityCheckShouldNotUseBoolCheckFixer>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2011_AssertEmptyCollectionCheckShouldNotBeUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2012_AssertEnumerableAnyCheckShouldNotBeUsedForCollectionContainsCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2013_AssertEqualShouldNotBeUsedForCollectionSizeCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2014_AssertThrowsShouldNotBeUsedForAsyncThrowsCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2015_AssertThrowsShouldUseGenericOverload>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2016_AssertEqualPrecisionShouldBeInRange>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2017_AssertCollectionContainsShouldNotUseBoolCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2018_AssertIsTypeShouldNotBeUsedForAbstractType>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2020_UseAssertFailInsteadOfBooleanAssert>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2021_AsyncAssertionsShouldBeAwaited>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2022_BooleanAssertionsShouldNotBeNegated>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2023_AssertSingleShouldBeUsedForSingleParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2024_BooleanAssertionsShouldNotBeUsedForSimpleEqualityCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2025_BooleanAssertionCanBeSimplified>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2026_SetsMustBeComparedWithEqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2027_SetsShouldNotBeComparedToLinearContainers>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2028_DoNotUseAssertEmptyWithProblematicTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X2029_AssertEmptyShouldNotBeUsedForCollectionDoesNotContainCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X3000_CrossAppDomainClassesMustBeLongLivedMarshalByRefObject>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <X3001_SerializableClassMustHaveParameterlessConstructor>k__BackingField;
    public static SuppressionDescriptor CA1515_Suppression { get; }
    public static SuppressionDescriptor CA2007_Suppression { get; }
    public static DiagnosticDescriptor X1000_TestClassMustBePublic { get; }
    public static DiagnosticDescriptor X1001_FactMethodMustNotHaveParameters { get; }
    public static DiagnosticDescriptor X1002_TestMethodMustNotHaveMultipleFactAttributes { get; }
    public static DiagnosticDescriptor X1003_TheoryMethodMustHaveTestData { get; }
    public static DiagnosticDescriptor X1004_TestMethodShouldNotBeSkipped { get; }
    public static DiagnosticDescriptor X1005_FactMethodShouldNotHaveTestData { get; }
    public static DiagnosticDescriptor X1006_TheoryMethodShouldHaveParameters { get; }
    public static DiagnosticDescriptor X1007_ClassDataAttributeMustPointAtValidClass { get; }
    public static DiagnosticDescriptor X1008_DataAttributeShouldBeUsedOnATheory { get; }
    public static DiagnosticDescriptor X1009_InlineDataMustMatchTheoryParameters_TooFewValues { get; }
    public static DiagnosticDescriptor X1010_InlineDataMustMatchTheoryParameters_IncompatibleValueType { get; }
    public static DiagnosticDescriptor X1011_InlineDataMustMatchTheoryParameters_ExtraValue { get; }
    public static DiagnosticDescriptor X1012_InlineDataMustMatchTheoryParameters_NullShouldNotBeUsedForIncompatibleParameter { get; }
    public static DiagnosticDescriptor X1013_PublicMethodShouldBeMarkedAsTest { get; }
    public static DiagnosticDescriptor X1014_MemberDataShouldUseNameOfOperator { get; }
    public static DiagnosticDescriptor X1015_MemberDataMustReferenceExistingMember { get; }
    public static DiagnosticDescriptor X1016_MemberDataMustReferencePublicMember { get; }
    public static DiagnosticDescriptor X1017_MemberDataMustReferenceStaticMember { get; }
    public static DiagnosticDescriptor X1018_MemberDataMustReferenceValidMemberKind { get; }
    public static DiagnosticDescriptor X1019_MemberDataMustReferenceMemberOfValidType { get; }
    public static DiagnosticDescriptor X1020_MemberDataPropertyMustHaveGetter { get; }
    public static DiagnosticDescriptor X1021_MemberDataNonMethodShouldNotHaveParameters { get; }
    public static DiagnosticDescriptor X1022_TheoryMethodCannotHaveParameterArray { get; }
    public static DiagnosticDescriptor X1023_TheoryMethodCannotHaveDefaultParameter { get; }
    public static DiagnosticDescriptor X1024_TestMethodCannotHaveOverloads { get; }
    public static DiagnosticDescriptor X1025_InlineDataShouldBeUniqueWithinTheory { get; }
    public static DiagnosticDescriptor X1026_TheoryMethodShouldUseAllParameters { get; }
    public static DiagnosticDescriptor X1027_CollectionDefinitionClassMustBePublic { get; }
    public static DiagnosticDescriptor X1028_TestMethodHasInvalidReturnType { get; }
    public static DiagnosticDescriptor X1029_LocalFunctionsCannotBeTestFunctions { get; }
    public static DiagnosticDescriptor X1030_DoNotUseConfigureAwait { get; }
    public static DiagnosticDescriptor X1031_DoNotUseBlockingTaskOperations { get; }
    public static DiagnosticDescriptor X1032_TestClassCannotBeNestedInGenericClass { get; }
    public static DiagnosticDescriptor X1033_TestClassShouldHaveTFixtureArgument { get; }
    public static DiagnosticDescriptor X1034_MemberDataArgumentsMustMatchMethodParameters_NullShouldNotBeUsedForIncompatibleParameter { get; }
    public static DiagnosticDescriptor X1035_MemberDataArgumentsMustMatchMethodParameters_IncompatibleValueType { get; }
    public static DiagnosticDescriptor X1036_MemberDataArgumentsMustMatchMethodParameters_ExtraValue { get; }
    public static DiagnosticDescriptor X1037_TheoryDataTypeArgumentsMustMatchTestMethodParameters_TooFewTypeParameters { get; }
    public static DiagnosticDescriptor X1038_TheoryDataTypeArgumentsMustMatchTestMethodParameters_ExtraTypeParameters { get; }
    public static DiagnosticDescriptor X1039_TheoryDataTypeArgumentsMustMatchTestMethodParameters_IncompatibleTypes { get; }
    public static DiagnosticDescriptor X1040_TheoryDataTypeArgumentsMustMatchTestMethodParameters_IncompatibleNullability { get; }
    public static DiagnosticDescriptor X1041_EnsureFixturesHaveASource { get; }
    public static DiagnosticDescriptor X1042_MemberDataTheoryDataIsRecommendedForStronglyTypedAnalysis { get; }
    public static DiagnosticDescriptor X1043_ConstructorOnFactAttributeSubclassShouldBePublic { get; }
    public static DiagnosticDescriptor X1044_AvoidUsingTheoryDataTypeArgumentsThatAreNotSerializable { get; }
    public static DiagnosticDescriptor X1045_AvoidUsingTheoryDataTypeArgumentsThatMightNotBeSerializable { get; }
    public static DiagnosticDescriptor X1046_AvoidUsingTheoryDataRowArgumentsThatAreNotSerializable { get; }
    public static DiagnosticDescriptor X1047_AvoidUsingTheoryDataRowArgumentsThatMightNotBeSerializable { get; }
    public static DiagnosticDescriptor X1048_DoNotUseAsyncVoidForTestMethods_V2 { get; }
    public static DiagnosticDescriptor X1049_DoNotUseAsyncVoidForTestMethods_V3 { get; }
    public static DiagnosticDescriptor X1050_ClassDataTheoryDataRowIsRecommendedForStronglyTypedAnalysis { get; }
    public static DiagnosticDescriptor X2000_AssertEqualLiteralValueShouldBeFirst { get; }
    public static DiagnosticDescriptor X2001_AssertEqualsShouldNotBeUsed { get; }
    public static DiagnosticDescriptor X2002_AssertNullShouldNotBeCalledOnValueTypes { get; }
    public static DiagnosticDescriptor X2003_AssertEqualShouldNotUsedForNullCheck { get; }
    public static DiagnosticDescriptor X2004_AssertEqualShouldNotUsedForBoolLiteralCheck { get; }
    public static DiagnosticDescriptor X2005_AssertSameShouldNotBeCalledOnValueTypes { get; }
    public static DiagnosticDescriptor X2006_AssertEqualGenericShouldNotBeUsedForStringValue { get; }
    public static DiagnosticDescriptor X2007_AssertIsTypeShouldUseGenericOverload { get; }
    public static DiagnosticDescriptor X2008_AssertRegexMatchShouldNotUseBoolLiteralCheck { get; }
    public static DiagnosticDescriptor X2009_AssertSubstringCheckShouldNotUseBoolCheck { get; }
    public static DiagnosticDescriptor X2010_AssertStringEqualityCheckShouldNotUseBoolCheckFixer { get; }
    public static DiagnosticDescriptor X2011_AssertEmptyCollectionCheckShouldNotBeUsed { get; }
    public static DiagnosticDescriptor X2012_AssertEnumerableAnyCheckShouldNotBeUsedForCollectionContainsCheck { get; }
    public static DiagnosticDescriptor X2013_AssertEqualShouldNotBeUsedForCollectionSizeCheck { get; }
    public static DiagnosticDescriptor X2014_AssertThrowsShouldNotBeUsedForAsyncThrowsCheck { get; }
    public static DiagnosticDescriptor X2015_AssertThrowsShouldUseGenericOverload { get; }
    public static DiagnosticDescriptor X2016_AssertEqualPrecisionShouldBeInRange { get; }
    public static DiagnosticDescriptor X2017_AssertCollectionContainsShouldNotUseBoolCheck { get; }
    public static DiagnosticDescriptor X2018_AssertIsTypeShouldNotBeUsedForAbstractType { get; }
    public static DiagnosticDescriptor X2020_UseAssertFailInsteadOfBooleanAssert { get; }
    public static DiagnosticDescriptor X2021_AsyncAssertionsShouldBeAwaited { get; }
    public static DiagnosticDescriptor X2022_BooleanAssertionsShouldNotBeNegated { get; }
    public static DiagnosticDescriptor X2023_AssertSingleShouldBeUsedForSingleParameter { get; }
    public static DiagnosticDescriptor X2024_BooleanAssertionsShouldNotBeUsedForSimpleEqualityCheck { get; }
    public static DiagnosticDescriptor X2025_BooleanAssertionCanBeSimplified { get; }
    public static DiagnosticDescriptor X2026_SetsMustBeComparedWithEqualityComparer { get; }
    public static DiagnosticDescriptor X2027_SetsShouldNotBeComparedToLinearContainers { get; }
    public static DiagnosticDescriptor X2028_DoNotUseAssertEmptyWithProblematicTypes { get; }
    public static DiagnosticDescriptor X2029_AssertEmptyShouldNotBeUsedForCollectionDoesNotContainCheck { get; }
    public static DiagnosticDescriptor X3000_CrossAppDomainClassesMustBeLongLivedMarshalByRefObject { get; }
    public static DiagnosticDescriptor X3001_SerializableClassMustHaveParameterlessConstructor { get; }
    private static Descriptors();
    private static DiagnosticDescriptor Diagnostic(string id, string title, Category category, DiagnosticSeverity defaultSeverity, string messageFormat);
    private static SuppressionDescriptor Suppression(string suppressedDiagnosticId, string justification);
    [CompilerGeneratedAttribute]
public static SuppressionDescriptor get_CA1515_Suppression();
    [CompilerGeneratedAttribute]
public static SuppressionDescriptor get_CA2007_Suppression();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1000_TestClassMustBePublic();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1001_FactMethodMustNotHaveParameters();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1002_TestMethodMustNotHaveMultipleFactAttributes();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1003_TheoryMethodMustHaveTestData();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1004_TestMethodShouldNotBeSkipped();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1005_FactMethodShouldNotHaveTestData();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1006_TheoryMethodShouldHaveParameters();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1007_ClassDataAttributeMustPointAtValidClass();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1008_DataAttributeShouldBeUsedOnATheory();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1009_InlineDataMustMatchTheoryParameters_TooFewValues();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1010_InlineDataMustMatchTheoryParameters_IncompatibleValueType();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1011_InlineDataMustMatchTheoryParameters_ExtraValue();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1012_InlineDataMustMatchTheoryParameters_NullShouldNotBeUsedForIncompatibleParameter();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1013_PublicMethodShouldBeMarkedAsTest();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1014_MemberDataShouldUseNameOfOperator();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1015_MemberDataMustReferenceExistingMember();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1016_MemberDataMustReferencePublicMember();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1017_MemberDataMustReferenceStaticMember();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1018_MemberDataMustReferenceValidMemberKind();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1019_MemberDataMustReferenceMemberOfValidType();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1020_MemberDataPropertyMustHaveGetter();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1021_MemberDataNonMethodShouldNotHaveParameters();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1022_TheoryMethodCannotHaveParameterArray();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1023_TheoryMethodCannotHaveDefaultParameter();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1024_TestMethodCannotHaveOverloads();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1025_InlineDataShouldBeUniqueWithinTheory();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1026_TheoryMethodShouldUseAllParameters();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1027_CollectionDefinitionClassMustBePublic();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1028_TestMethodHasInvalidReturnType();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1029_LocalFunctionsCannotBeTestFunctions();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1030_DoNotUseConfigureAwait();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1031_DoNotUseBlockingTaskOperations();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1032_TestClassCannotBeNestedInGenericClass();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1033_TestClassShouldHaveTFixtureArgument();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1034_MemberDataArgumentsMustMatchMethodParameters_NullShouldNotBeUsedForIncompatibleParameter();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1035_MemberDataArgumentsMustMatchMethodParameters_IncompatibleValueType();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1036_MemberDataArgumentsMustMatchMethodParameters_ExtraValue();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1037_TheoryDataTypeArgumentsMustMatchTestMethodParameters_TooFewTypeParameters();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1038_TheoryDataTypeArgumentsMustMatchTestMethodParameters_ExtraTypeParameters();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1039_TheoryDataTypeArgumentsMustMatchTestMethodParameters_IncompatibleTypes();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1040_TheoryDataTypeArgumentsMustMatchTestMethodParameters_IncompatibleNullability();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1041_EnsureFixturesHaveASource();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1042_MemberDataTheoryDataIsRecommendedForStronglyTypedAnalysis();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1043_ConstructorOnFactAttributeSubclassShouldBePublic();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1044_AvoidUsingTheoryDataTypeArgumentsThatAreNotSerializable();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1045_AvoidUsingTheoryDataTypeArgumentsThatMightNotBeSerializable();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1046_AvoidUsingTheoryDataRowArgumentsThatAreNotSerializable();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1047_AvoidUsingTheoryDataRowArgumentsThatMightNotBeSerializable();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1048_DoNotUseAsyncVoidForTestMethods_V2();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1049_DoNotUseAsyncVoidForTestMethods_V3();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X1050_ClassDataTheoryDataRowIsRecommendedForStronglyTypedAnalysis();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2000_AssertEqualLiteralValueShouldBeFirst();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2001_AssertEqualsShouldNotBeUsed();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2002_AssertNullShouldNotBeCalledOnValueTypes();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2003_AssertEqualShouldNotUsedForNullCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2004_AssertEqualShouldNotUsedForBoolLiteralCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2005_AssertSameShouldNotBeCalledOnValueTypes();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2006_AssertEqualGenericShouldNotBeUsedForStringValue();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2007_AssertIsTypeShouldUseGenericOverload();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2008_AssertRegexMatchShouldNotUseBoolLiteralCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2009_AssertSubstringCheckShouldNotUseBoolCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2010_AssertStringEqualityCheckShouldNotUseBoolCheckFixer();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2011_AssertEmptyCollectionCheckShouldNotBeUsed();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2012_AssertEnumerableAnyCheckShouldNotBeUsedForCollectionContainsCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2013_AssertEqualShouldNotBeUsedForCollectionSizeCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2014_AssertThrowsShouldNotBeUsedForAsyncThrowsCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2015_AssertThrowsShouldUseGenericOverload();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2016_AssertEqualPrecisionShouldBeInRange();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2017_AssertCollectionContainsShouldNotUseBoolCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2018_AssertIsTypeShouldNotBeUsedForAbstractType();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2020_UseAssertFailInsteadOfBooleanAssert();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2021_AsyncAssertionsShouldBeAwaited();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2022_BooleanAssertionsShouldNotBeNegated();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2023_AssertSingleShouldBeUsedForSingleParameter();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2024_BooleanAssertionsShouldNotBeUsedForSimpleEqualityCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2025_BooleanAssertionCanBeSimplified();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2026_SetsMustBeComparedWithEqualityComparer();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2027_SetsShouldNotBeComparedToLinearContainers();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2028_DoNotUseAssertEmptyWithProblematicTypes();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X2029_AssertEmptyShouldNotBeUsedForCollectionDoesNotContainCheck();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X3000_CrossAppDomainClassesMustBeLongLivedMarshalByRefObject();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_X3001_SerializableClassMustHaveParameterlessConstructor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.DoNotUseAssertEmptyWithProblematicTypes : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static DoNotUseAssertEmptyWithProblematicTypes();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.DoNotUseAsyncVoidForTestMethods : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.DoNotUseBlockingTaskOperations : XunitDiagnosticAnalyzer {
    private static String[] blockingAwaiterMethods;
    private static String[] blockingTaskMethods;
    private static String[] blockingTaskProperties;
    private static String[] whenAll;
    private static String[] whenAny;
    private static DoNotUseBlockingTaskOperations();
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static bool FindSymbol(ISymbol symbol, IOperation operation, INamedTypeSymbol targetType, String[] targetNames, XunitContext xunitContext, String& foundSymbolName);
    private static bool TaskIsKnownToBeCompleted(IOperation operation, IEnumerable`1<ILocalSymbol> symbols, INamedTypeSymbol taskType, XunitContext xunitContext);
    private static void ValidateTaskFromWhenAny(IVariableDeclaratorOperation operation, HashSet`1<ILocalSymbol> unfoundSymbols, INamedTypeSymbol taskType, XunitContext xunitContext);
    private static void ValidateTasksInWhenAll(IInvocationOperation operation, HashSet`1<ILocalSymbol> unfoundSymbols, INamedTypeSymbol taskType, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.DoNotUseConfigureAwait : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static bool ContainsContinueOnCapturedContext(ExpressionSyntax expression, SemanticModel semanticModel, INamedTypeSymbol configureAwaitOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.EmptyAbstractionsContext : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static EmptyAbstractionsContext <Instance>k__BackingField;
    [NullableAttribute("1")]
public static EmptyAbstractionsContext Instance { get; }
    public INamedTypeSymbol IMessageSinkType { get; }
    public INamedTypeSymbol ISourceInformationProviderType { get; }
    public INamedTypeSymbol ITestAssemblyType { get; }
    public INamedTypeSymbol ITestCaseType { get; }
    public INamedTypeSymbol ITestClassType { get; }
    public INamedTypeSymbol ITestCollectionType { get; }
    public INamedTypeSymbol ITestFrameworkDiscovererType { get; }
    public INamedTypeSymbol ITestFrameworkExecutorType { get; }
    public INamedTypeSymbol ITestFrameworkType { get; }
    public INamedTypeSymbol ITestMethodType { get; }
    public INamedTypeSymbol ITestType { get; }
    public INamedTypeSymbol IXunitSerializableType { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    private static EmptyAbstractionsContext();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static EmptyAbstractionsContext get_Instance();
    public sealed virtual INamedTypeSymbol get_IMessageSinkType();
    public sealed virtual INamedTypeSymbol get_ISourceInformationProviderType();
    public sealed virtual INamedTypeSymbol get_ITestAssemblyType();
    public sealed virtual INamedTypeSymbol get_ITestCaseType();
    public sealed virtual INamedTypeSymbol get_ITestClassType();
    public sealed virtual INamedTypeSymbol get_ITestCollectionType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkDiscovererType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkExecutorType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkType();
    public sealed virtual INamedTypeSymbol get_ITestMethodType();
    public sealed virtual INamedTypeSymbol get_ITestType();
    public sealed virtual INamedTypeSymbol get_IXunitSerializableType();
    [NullableContextAttribute("1")]
public sealed virtual Version get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.EmptyAssertContext : object {
    [CompilerGeneratedAttribute]
private static EmptyAssertContext <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public static EmptyAssertContext Instance { get; }
    public bool SupportsAssertFail { get; }
    public Version Version { get; }
    private static EmptyAssertContext();
    [CompilerGeneratedAttribute]
public static EmptyAssertContext get_Instance();
    public sealed virtual bool get_SupportsAssertFail();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.EmptyCoreContext : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static EmptyCoreContext <Instance>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public INamedTypeSymbol ClassDataAttributeType { get; }
    public INamedTypeSymbol CollectionAttributeType { get; }
    public INamedTypeSymbol CollectionDefinitionAttributeType { get; }
    public INamedTypeSymbol DataAttributeType { get; }
    public INamedTypeSymbol FactAttributeType { get; }
    public INamedTypeSymbol IClassFixtureType { get; }
    public INamedTypeSymbol ICollectionFixtureType { get; }
    public INamedTypeSymbol InlineDataAttributeType { get; }
    public INamedTypeSymbol ITestOutputHelperType { get; }
    [NullableAttribute("1")]
public static EmptyCoreContext Instance { get; }
    public INamedTypeSymbol MemberDataAttributeType { get; }
    public INamedTypeSymbol TheoryAttributeType { get; }
    public bool TheorySupportsConversionFromStringToDateTimeOffsetAndGuid { get; }
    public bool TheorySupportsDefaultParameterValues { get; }
    public bool TheorySupportsParameterArrays { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    private static EmptyCoreContext();
    public sealed virtual INamedTypeSymbol get_ClassDataAttributeType();
    public sealed virtual INamedTypeSymbol get_CollectionAttributeType();
    public sealed virtual INamedTypeSymbol get_CollectionDefinitionAttributeType();
    public sealed virtual INamedTypeSymbol get_DataAttributeType();
    public sealed virtual INamedTypeSymbol get_FactAttributeType();
    public sealed virtual INamedTypeSymbol get_IClassFixtureType();
    public sealed virtual INamedTypeSymbol get_ICollectionFixtureType();
    public sealed virtual INamedTypeSymbol get_InlineDataAttributeType();
    public sealed virtual INamedTypeSymbol get_ITestOutputHelperType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static EmptyCoreContext get_Instance();
    public sealed virtual INamedTypeSymbol get_MemberDataAttributeType();
    public sealed virtual INamedTypeSymbol get_TheoryAttributeType();
    public sealed virtual bool get_TheorySupportsConversionFromStringToDateTimeOffsetAndGuid();
    public sealed virtual bool get_TheorySupportsDefaultParameterValues();
    public sealed virtual bool get_TheorySupportsParameterArrays();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.EmptyRunnerUtilityContext : object {
    [CompilerGeneratedAttribute]
private static EmptyRunnerUtilityContext <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public static EmptyRunnerUtilityContext Instance { get; }
    [NullableAttribute("2")]
public INamedTypeSymbol LongLivedMarshalByRefObjectType { get; }
    public string Platform { get; }
    public Version Version { get; }
    private static EmptyRunnerUtilityContext();
    [CompilerGeneratedAttribute]
public static EmptyRunnerUtilityContext get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual INamedTypeSymbol get_LongLivedMarshalByRefObjectType();
    public sealed virtual string get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.EnsureFixturesHaveASource : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.FactMethodMustNotHaveParameters : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.FactMethodShouldNotHaveTestData : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("2")]
public interface Xunit.Analyzers.IAbstractionsContext {
    public INamedTypeSymbol IMessageSinkType { get; }
    public INamedTypeSymbol ISourceInformationProviderType { get; }
    public INamedTypeSymbol ITestAssemblyType { get; }
    public INamedTypeSymbol ITestCaseType { get; }
    public INamedTypeSymbol ITestClassType { get; }
    public INamedTypeSymbol ITestCollectionType { get; }
    public INamedTypeSymbol ITestFrameworkDiscovererType { get; }
    public INamedTypeSymbol ITestFrameworkExecutorType { get; }
    public INamedTypeSymbol ITestFrameworkType { get; }
    public INamedTypeSymbol ITestMethodType { get; }
    public INamedTypeSymbol ITestType { get; }
    public INamedTypeSymbol IXunitSerializableType { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    public abstract virtual INamedTypeSymbol get_IMessageSinkType();
    public abstract virtual INamedTypeSymbol get_ISourceInformationProviderType();
    public abstract virtual INamedTypeSymbol get_ITestAssemblyType();
    public abstract virtual INamedTypeSymbol get_ITestCaseType();
    public abstract virtual INamedTypeSymbol get_ITestClassType();
    public abstract virtual INamedTypeSymbol get_ITestCollectionType();
    public abstract virtual INamedTypeSymbol get_ITestFrameworkDiscovererType();
    public abstract virtual INamedTypeSymbol get_ITestFrameworkExecutorType();
    public abstract virtual INamedTypeSymbol get_ITestFrameworkType();
    public abstract virtual INamedTypeSymbol get_ITestMethodType();
    public abstract virtual INamedTypeSymbol get_ITestType();
    public abstract virtual INamedTypeSymbol get_IXunitSerializableType();
    [NullableContextAttribute("1")]
public abstract virtual Version get_Version();
}
[NullableContextAttribute("1")]
public interface Xunit.Analyzers.IAssertContext {
    public bool SupportsAssertFail { get; }
    public Version Version { get; }
    public abstract virtual bool get_SupportsAssertFail();
    public abstract virtual Version get_Version();
}
[NullableContextAttribute("2")]
public interface Xunit.Analyzers.ICoreContext {
    public INamedTypeSymbol ClassDataAttributeType { get; }
    public INamedTypeSymbol CollectionAttributeType { get; }
    public INamedTypeSymbol CollectionDefinitionAttributeType { get; }
    public INamedTypeSymbol DataAttributeType { get; }
    public INamedTypeSymbol FactAttributeType { get; }
    public INamedTypeSymbol IClassFixtureType { get; }
    public INamedTypeSymbol ICollectionFixtureType { get; }
    public INamedTypeSymbol InlineDataAttributeType { get; }
    public INamedTypeSymbol ITestOutputHelperType { get; }
    public INamedTypeSymbol MemberDataAttributeType { get; }
    public INamedTypeSymbol TheoryAttributeType { get; }
    public bool TheorySupportsConversionFromStringToDateTimeOffsetAndGuid { get; }
    public bool TheorySupportsDefaultParameterValues { get; }
    public bool TheorySupportsParameterArrays { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    public abstract virtual INamedTypeSymbol get_ClassDataAttributeType();
    public abstract virtual INamedTypeSymbol get_CollectionAttributeType();
    public abstract virtual INamedTypeSymbol get_CollectionDefinitionAttributeType();
    public abstract virtual INamedTypeSymbol get_DataAttributeType();
    public abstract virtual INamedTypeSymbol get_FactAttributeType();
    public abstract virtual INamedTypeSymbol get_IClassFixtureType();
    public abstract virtual INamedTypeSymbol get_ICollectionFixtureType();
    public abstract virtual INamedTypeSymbol get_InlineDataAttributeType();
    public abstract virtual INamedTypeSymbol get_ITestOutputHelperType();
    public abstract virtual INamedTypeSymbol get_MemberDataAttributeType();
    public abstract virtual INamedTypeSymbol get_TheoryAttributeType();
    public abstract virtual bool get_TheorySupportsConversionFromStringToDateTimeOffsetAndGuid();
    public abstract virtual bool get_TheorySupportsDefaultParameterValues();
    public abstract virtual bool get_TheorySupportsParameterArrays();
    [NullableContextAttribute("1")]
public abstract virtual Version get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.InlineDataMustMatchTheoryParameters : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static bool RequiresMatchingValue(IParameterSymbol parameter, bool supportsParamsArray, bool supportsDefaultValue, INamedTypeSymbol optionalAttribute);
    private static IList`1<ExpressionSyntax> GetParameterExpressionsFromArrayArgument(AttributeSyntax attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.InlineDataShouldBeUniqueWithinTheory : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static void AnalyzeMethod(SymbolAnalysisContext context, XunitContext xunitContext);
    private static void AnalyzeInlineDataAttributesWithinTheory(SymbolAnalysisContext context, IEnumerable`1<AttributeData> inlineDataAttributes);
    private static AttributeSyntax GetAttributeSyntax(SymbolAnalysisContext context, AttributeData attribute);
    private static void ReportDuplicate(SymbolAnalysisContext context, AttributeData duplicateAttribute);
    private static bool HasAttributeDeclarationNoCompilationErrors(AttributeData attribute, IArrayTypeSymbol objectArrayType);
}
[NullableContextAttribute("1")]
public interface Xunit.Analyzers.IRunnerUtilityContext {
    [NullableAttribute("2")]
public INamedTypeSymbol LongLivedMarshalByRefObjectType { get; }
    public string Platform { get; }
    public Version Version { get; }
    [NullableContextAttribute("2")]
public abstract virtual INamedTypeSymbol get_LongLivedMarshalByRefObjectType();
    public abstract virtual string get_Platform();
    public abstract virtual Version get_Version();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.LocalFunctionsCannotBeTestFunctions : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.MemberDataShouldReferenceValidMember : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    [NullableContextAttribute("2")]
private static ISymbol FindMemberSymbol(string memberName, ITypeSymbol type, int paramsCount);
    [NullableContextAttribute("2")]
public static ISymbol FindMethodSymbol(string memberName, ITypeSymbol type, int paramsCount);
    public static ValueTuple`2<INamedTypeSymbol, ITypeSymbol> GetClassTypesForAttribute(AttributeArgumentListSyntax attributeList, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IList`1<ExpressionSyntax> GetParameterExpressionsFromArrayArgument(List`1<AttributeArgumentSyntax> arguments, SemanticModel semanticModel);
    [NullableContextAttribute("2")]
private static bool IsGenericTheoryDataRowType(ITypeSymbol memberReturnType, INamedTypeSymbol iEnumerableOfTheoryDataRowType, INamedTypeSymbol iAsyncEnumerableOfTheoryDataRowType, Dictionary`2<int, INamedTypeSymbol> theoryDataRowTypes, INamedTypeSymbol& theoryReturnType);
    [NullableContextAttribute("2")]
private static bool IsTheoryDataType(ITypeSymbol memberReturnType, Dictionary`2<int, INamedTypeSymbol> theoryDataTypes, INamedTypeSymbol& theoryReturnType);
    private static void ReportIllegalNonMethodArguments(SyntaxNodeAnalysisContext context, AttributeSyntax attribute, List`1<AttributeArgumentSyntax> extraArguments);
    private static void ReportIncorrectMemberType(SyntaxNodeAnalysisContext context, AttributeSyntax attribute);
    private static void ReportIncorrectReturnType(SyntaxNodeAnalysisContext context, INamedTypeSymbol iEnumerableOfObjectArrayType, INamedTypeSymbol iAsyncEnumerableOfObjectArrayType, INamedTypeSymbol iEnumerableOfTheoryDataRowType, INamedTypeSymbol iAsyncEnumerableOfTheoryDataRowType, AttributeSyntax attribute, ImmutableDictionary`2<string, string> memberProperties, ITypeSymbol memberType);
    private static void ReportMemberMethodParametersDoNotMatchArgumentTypes(SyntaxNodeAnalysisContext context, ExpressionSyntax syntax, IParameterSymbol parameter, ITypeSymbol paramsElementType, Builder<string, string> builder);
    private static void ReportMemberMethodParameterNullability(SyntaxNodeAnalysisContext context, ExpressionSyntax syntax, IParameterSymbol parameter, ITypeSymbol paramsElementType, Builder<string, string> builder);
    private static void ReportMemberMethodTheoryDataExtraTypeArguments(SyntaxNodeAnalysisContext context, Location location, Builder<string, string> builder, INamedTypeSymbol theoryDataType);
    private static void ReportMemberMethodTheoryDataIncompatibleType(SyntaxNodeAnalysisContext context, Location location, ITypeSymbol theoryDataTypeParameter, INamedTypeSymbol memberType, string memberName, IParameterSymbol parameter);
    private static void ReportMemberMethodTheoryDataNullability(SyntaxNodeAnalysisContext context, Location location, ITypeSymbol theoryDataTypeParameter, INamedTypeSymbol memberType, string memberName, IParameterSymbol parameter);
    private static void ReportMemberMethodTheoryDataTooFewTypeArguments(SyntaxNodeAnalysisContext context, Location location, Builder<string, string> builder, INamedTypeSymbol theoryDataType);
    private static void ReportMissingMember(SyntaxNodeAnalysisContext context, AttributeSyntax attribute, string memberName, ITypeSymbol declaredMemberTypeSymbol);
    private static void ReportNonPublicAccessibility(SyntaxNodeAnalysisContext context, AttributeSyntax attribute, ImmutableDictionary`2<string, string> memberProperties);
    private static void ReportNonPublicPropertyGetter(SyntaxNodeAnalysisContext context, AttributeSyntax attribute);
    private static void ReportMemberReturnsTypeUnsafeValue(SyntaxNodeAnalysisContext context, AttributeSyntax attribute, string suggestedAlternative);
    private static void ReportNonStatic(SyntaxNodeAnalysisContext context, AttributeSyntax attribute, ImmutableDictionary`2<string, string> memberProperties);
    private static void ReportTooManyArgumentsProvided(SyntaxNodeAnalysisContext context, ExpressionSyntax syntax, object value, Builder<string, string> builder);
    private static void ReportUseNameof(SyntaxNodeAnalysisContext context, AttributeArgumentSyntax memberNameArgument, string memberName, INamedTypeSymbol testClassTypeSymbol, ISymbol memberSymbol);
    private static void VerifyDataMethodParameterUsage(SemanticModel semanticModel, SyntaxNodeAnalysisContext context, Compilation compilation, XunitContext xunitContext, ISymbol memberSymbol, string memberName, List`1<AttributeArgumentSyntax> extraArguments);
    private static bool VerifyDataSourceReturnType(SyntaxNodeAnalysisContext context, Compilation compilation, XunitContext xunitContext, ITypeSymbol memberType, ImmutableDictionary`2<string, string> memberProperties, AttributeSyntax attributeSyntax, INamedTypeSymbol iEnumerableOfTheoryDataRowType, INamedTypeSymbol iAsyncEnumerableOfTheoryDataRowType);
    private static void VerifyGenericArgumentTypes(SemanticModel semanticModel, SyntaxNodeAnalysisContext context, MethodDeclarationSyntax testMethod, INamedTypeSymbol theoryDataType, INamedTypeSymbol theoryReturnType, string memberName, ITypeSymbol memberType, AttributeSyntax attributeSyntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.PublicMethodShouldBeMarkedAsTest : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
public enum Xunit.Analyzers.Serializability : Enum {
    public int value__;
    public static Serializability NeverSerializable;
    public static Serializability PossiblySerializable;
    public static Serializability AlwaysSerializable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.SerializabilityAnalyzer : object {
    private SerializableTypeSymbols typeSymbols;
    public SerializabilityAnalyzer(SerializableTypeSymbols typeSymbols);
    public Serializability AnalayzeSerializability(ITypeSymbol type);
    private static Serializability GetSpecialTypeSerializability(SpecialType type);
    private static Serializability GetTypeKindSerializability(TypeKind kind);
    private static bool TypeKindShouldBeIgnored(TypeKind kind);
    [NullableContextAttribute("2")]
public bool TypeShouldBeIgnored(ITypeSymbol type);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.SerializableClassMustHaveParameterlessConstructor : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.SerializableTypeSymbols : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> bigInteger;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> dateOnly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> dateTimeOffset;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> iXunitSerializable;
    [NullableAttribute("1")]
private Dictionary`2<int, INamedTypeSymbol> theoryDataTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> timeOnly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> timeSpan;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> traitDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> type;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ClassDataAttribute>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <DataAttribute>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <MemberDataAttribute>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <TheoryAttribute>k__BackingField;
    public INamedTypeSymbol BigInteger { get; }
    [NullableAttribute("1")]
public INamedTypeSymbol ClassDataAttribute { get; }
    [NullableAttribute("1")]
public INamedTypeSymbol DataAttribute { get; }
    public INamedTypeSymbol DateOnly { get; }
    public INamedTypeSymbol DateTimeOffset { get; }
    public INamedTypeSymbol IXunitSerializable { get; }
    [NullableAttribute("1")]
public INamedTypeSymbol MemberDataAttribute { get; }
    [NullableAttribute("1")]
public INamedTypeSymbol TheoryAttribute { get; }
    public INamedTypeSymbol TimeOnly { get; }
    public INamedTypeSymbol TimeSpan { get; }
    public INamedTypeSymbol TraitDictionary { get; }
    public INamedTypeSymbol Type { get; }
    [NullableContextAttribute("1")]
private SerializableTypeSymbols(Compilation compilation, XunitContext xunitContext, INamedTypeSymbol classDataAttribute, INamedTypeSymbol dataAttribute, INamedTypeSymbol memberDataAttribute, INamedTypeSymbol theoryAttribute, Dictionary`2<int, INamedTypeSymbol> theoryDataTypes);
    public INamedTypeSymbol get_BigInteger();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_ClassDataAttribute();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_DataAttribute();
    public INamedTypeSymbol get_DateOnly();
    public INamedTypeSymbol get_DateTimeOffset();
    public INamedTypeSymbol get_IXunitSerializable();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_MemberDataAttribute();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_TheoryAttribute();
    public INamedTypeSymbol get_TimeOnly();
    public INamedTypeSymbol get_TimeSpan();
    public INamedTypeSymbol get_TraitDictionary();
    public INamedTypeSymbol get_Type();
    [NullableContextAttribute("1")]
public static SerializableTypeSymbols Create(Compilation compilation, XunitContext xunitContext);
    [NullableContextAttribute("1")]
private static INamedTypeSymbol GetTraitDictionary(Compilation compilation);
    public INamedTypeSymbol TheoryData(int arity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.SetEqualityAnalyzer : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static SetEqualityAnalyzer();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Xunit.Analyzers.SymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAttributeType(ImmutableArray`1<AttributeData> attributes, INamedTypeSymbol attributeType, bool exactMatch);
    [ExtensionAttribute]
public static ITypeSymbol GetAsyncEnumerableType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static ITypeSymbol GetEnumerableType(ITypeSymbol typeSymbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static INamedTypeSymbol GetGenericInterfaceImplementation(ITypeSymbol implementingType, INamedTypeSymbol openInterfaceType);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ISymbol GetMember(INamespaceOrTypeSymbol namespaceOrType, string name);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetInheritedAndOwnMembers(ITypeSymbol symbol, string name);
    [ExtensionAttribute]
public static bool IsAssignableFrom(ITypeSymbol targetType, ITypeSymbol sourceType, bool exactMatch);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsInstanceOf(AttributeData attribute, INamedTypeSymbol attributeType, bool exactMatch);
    [ExtensionAttribute]
public static ITypeSymbol UnwrapEnumerable(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static ITypeSymbol UnwrapEnumerable(ITypeSymbol type, ITypeSymbol enumerableType);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ITypeSymbol UnwrapNullable(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Xunit.Analyzers.SyntaxExtensions : object {
    [ExtensionAttribute]
public static bool ContainsAttributeType(SyntaxList`1<AttributeListSyntax> attributeLists, SemanticModel semanticModel, INamedTypeSymbol attributeType, bool exactMatch);
    [ExtensionAttribute]
public static SimpleNameSyntax GetSimpleName(InvocationExpressionSyntax invocation);
    [ExtensionAttribute]
public static bool IsEnumValueExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNameofExpression(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TestClassCannotBeNestedInGenericClass : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static bool DoesInheritenceTreeContainTests(INamedTypeSymbol classSymbol, XunitContext xunitContext, int depth);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TestClassMustBePublic : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TestClassShouldHaveTFixtureArgument : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TestMethodCannotHaveOverloads : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TestMethodMustNotHaveMultipleFactAttributes : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TestMethodShouldNotBeSkipped : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TestMethodSupportedReturnType : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    public static List`1<INamedTypeSymbol> GetValidReturnTypes(Compilation compilation, XunitContext xunitContext);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <GetValidReturnTypes>g__Add|2_0(INamedTypeSymbol symbol, <>c__DisplayClass2_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TheoryDataRowArgumentsShouldBeSerializable : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static IReadOnlyList`1<IOperation> GetConstructorArguments(IObjectCreationOperation objectCreation);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TheoryDataTypeArgumentsShouldBeSerializable : XunitDiagnosticAnalyzer {
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static bool AttributeIsTheoryOrDataAttribute(AttributeData attribute, SerializableTypeSymbols typeSymbols);
    private static bool DiscoveryEnumerationIsDisabled(IMethodSymbol method, SerializableTypeSymbols typeSymbols);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TheoryMethodCannotHaveDefaultParameter : XunitDiagnosticAnalyzer {
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TheoryMethodCannotHaveParamsArray : XunitDiagnosticAnalyzer {
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TheoryMethodMustHaveTestData : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TheoryMethodShouldHaveParameters : XunitDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.TheoryMethodShouldUseAllParameters : XunitDiagnosticAnalyzer {
    private static Regex discardRegex;
    private static TheoryMethodShouldUseAllParameters();
    public virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    private static void AnalyzeTheoryParameters(SyntaxNodeAnalysisContext context, MethodDeclarationSyntax methodSyntax, IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.TypeHierarchyComparer : object {
    [CompilerGeneratedAttribute]
private static TypeHierarchyComparer <Instance>k__BackingField;
    public static TypeHierarchyComparer Instance { get; }
    private static TypeHierarchyComparer();
    [CompilerGeneratedAttribute]
public static TypeHierarchyComparer get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(ITypeSymbol x, ITypeSymbol y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Xunit.Analyzers.TypeSymbolFactory : object {
    public static INamedTypeSymbol Action(Compilation compilation);
    public static INamedTypeSymbol Action(Compilation compilation, int arity);
    public static INamedTypeSymbol ArraySegmentOfT(Compilation compilation);
    public static INamedTypeSymbol AssemblyFixtureAttribute_V3(Compilation compilation);
    public static INamedTypeSymbol Assert(Compilation compilation);
    public static INamedTypeSymbol AttributeUsageAttribute(Compilation compilation);
    public static INamedTypeSymbol BigInteger(Compilation compilation);
    public static INamedTypeSymbol ClassDataAttribute(Compilation compilation);
    public static INamedTypeSymbol CollectionAttribute(Compilation compilation);
    public static INamedTypeSymbol CollectionDefinitionAttribute(Compilation compilation);
    public static INamedTypeSymbol ConfigureAwaitOptions(Compilation compilation);
    public static INamedTypeSymbol ConfiguredTaskAwaitable(Compilation compilation);
    public static INamedTypeSymbol DataAttribute_V2(Compilation compilation);
    public static INamedTypeSymbol DataAttribute_V3(Compilation compilation);
    public static INamedTypeSymbol DateOnly(Compilation compilation);
    public static INamedTypeSymbol DateTimeOffset(Compilation compilation);
    public static INamedTypeSymbol DictionaryofTKeyTValue(Compilation compilation);
    public static INamedTypeSymbol FactAttribute(Compilation compilation);
    public static INamedTypeSymbol Func(Compilation compilation, int arity);
    public static INamedTypeSymbol IAssemblyInfo_V2(Compilation compilation);
    public static INamedTypeSymbol IAsyncEnumerableOfITheoryDataRow(Compilation compilation);
    public static INamedTypeSymbol IAsyncEnumerableOfObjectArray(Compilation compilation);
    public static INamedTypeSymbol IAsyncEnumerableOfT(Compilation compilation);
    public static INamedTypeSymbol IAsyncLifetime(Compilation compilation);
    public static INamedTypeSymbol IAttributeInfo_V2(Compilation compilation);
    public static INamedTypeSymbol IClassFixureOfT(Compilation compilation);
    public static INamedTypeSymbol ICollection(Compilation compilation);
    public static INamedTypeSymbol ICollectionFixtureOfT(Compilation compilation);
    public static INamedTypeSymbol ICollectionOfT(Compilation compilation);
    public static INamedTypeSymbol ICriticalNotifyCompletion(Compilation compilation);
    public static INamedTypeSymbol IDisposable(Compilation compilation);
    public static INamedTypeSymbol IEnumerableOfITheoryDataRow(Compilation compilation);
    public static INamedTypeSymbol IEnumerableOfObjectArray(Compilation compilation);
    public static INamedTypeSymbol IEnumerableOfT(Compilation compilation);
    public static INamedTypeSymbol IMessageSink_V2(Compilation compilation);
    public static INamedTypeSymbol IMessageSink_V3(Compilation compilation);
    public static INamedTypeSymbol IMessageSinkMessage_V2(Compilation compilation);
    public static INamedTypeSymbol IMethodInfo_V2(Compilation compilation);
    public static INamedTypeSymbol InlineDataAttribute(Compilation compilation);
    public static INamedTypeSymbol IParameterInfo_V2(Compilation compilation);
    public static INamedTypeSymbol IValueTaskSource(Compilation compilation);
    public static INamedTypeSymbol IValueTaskSourceOfT(Compilation compilation);
    public static INamedTypeSymbol IReadOnlyCollectionOfT(Compilation compilation);
    public static INamedTypeSymbol IReadOnlySetOfT(Compilation compilation);
    public static INamedTypeSymbol ISetOfT(Compilation compilation);
    public static INamedTypeSymbol ISourceInformation_V2(Compilation compilation);
    public static INamedTypeSymbol ISourceInformationProvider_V2(Compilation compilation);
    public static INamedTypeSymbol ISourceInformationProvider_V3(Compilation compilation);
    public static INamedTypeSymbol ITest_V2(Compilation compilation);
    public static INamedTypeSymbol ITest_V3(Compilation compilation);
    public static INamedTypeSymbol ITestAssembly_V2(Compilation compilation);
    public static INamedTypeSymbol ITestAssembly_V3(Compilation compilation);
    public static INamedTypeSymbol ITestCase_V2(Compilation compilation);
    public static INamedTypeSymbol ITestCase_V3(Compilation compilation);
    public static INamedTypeSymbol ITestClass_V2(Compilation compilation);
    public static INamedTypeSymbol ITestClass_V3(Compilation compilation);
    public static INamedTypeSymbol ITestCollection_V2(Compilation compilation);
    public static INamedTypeSymbol ITestCollection_V3(Compilation compilation);
    public static INamedTypeSymbol ITestContextAccessor_V3(Compilation compilation);
    public static INamedTypeSymbol ITestFramework_V2(Compilation compilation);
    public static INamedTypeSymbol ITestFramework_V3(Compilation compilation);
    public static INamedTypeSymbol ITestFrameworkDiscoverer_V2(Compilation compilation);
    public static INamedTypeSymbol ITestFrameworkDiscoverer_V3(Compilation compilation);
    public static INamedTypeSymbol ITestFrameworkExecutor_V2(Compilation compilation);
    public static INamedTypeSymbol ITestFrameworkExecutor_V3(Compilation compilation);
    public static INamedTypeSymbol ITestMethod_V2(Compilation compilation);
    public static INamedTypeSymbol ITestMethod_V3(Compilation compilation);
    public static INamedTypeSymbol ITestOutputHelper_V2(Compilation compilation);
    public static INamedTypeSymbol ITestOutputHelper_V3(Compilation compilation);
    public static INamedTypeSymbol ITheoryDataRow_V3(Compilation compilation);
    public static INamedTypeSymbol ITypeInfo_V2(Compilation compilation);
    public static INamedTypeSymbol IXunitSerializable_V2(Compilation compilation);
    public static INamedTypeSymbol IXunitSerializable_V3(Compilation compilation);
    public static INamedTypeSymbol ListOfT(Compilation compilation);
    public static INamedTypeSymbol LongLivedMarshalByRefObject_ExecutionV2(Compilation compilation);
    public static INamedTypeSymbol LongLivedMarshalByRefObject_RunnerUtility(Compilation compilation);
    public static INamedTypeSymbol MemberDataAttribute(Compilation compilation);
    public static INamedTypeSymbol NullableOfT(Compilation compilation);
    public static IArrayTypeSymbol ObjectArray(Compilation compilation);
    public static INamedTypeSymbol ObsoleteAttribute(Compilation compilation);
    public static INamedTypeSymbol OptionalAttribute(Compilation compilation);
    public static INamedTypeSymbol SortedSetOfT(Compilation compilation);
    public static INamedTypeSymbol String(Compilation compilation);
    public static INamedTypeSymbol StringValues(Compilation compilation);
    public static INamedTypeSymbol Task(Compilation compilation);
    public static INamedTypeSymbol TaskOfT(Compilation compilation);
    public static INamedTypeSymbol TheoryAttribute(Compilation compilation);
    public static INamedTypeSymbol TheoryData(Compilation compilation);
    public static Dictionary`2<int, INamedTypeSymbol> TheoryData_ByGenericArgumentCount(Compilation compilation);
    public static INamedTypeSymbol TheoryDataRow_V3(Compilation compilation);
    public static Dictionary`2<int, INamedTypeSymbol> TheoryDataRow_ByGenericArgumentCount_V3(Compilation compilation);
    public static INamedTypeSymbol TimeOnly(Compilation compilation);
    public static INamedTypeSymbol TimeSpan(Compilation compilation);
    public static INamedTypeSymbol Type(Compilation compilation);
    private static int ValidateArity(int arity, int min, int max);
    public static INamedTypeSymbol ValueTask(Compilation compilation);
    public static INamedTypeSymbol ValueTaskOfT(Compilation compilation);
    public static INamedTypeSymbol Void(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Analyzers.UseAssertFailInsteadOfBooleanAssert : AssertUsageAnalyzerBase {
    private static String[] targetMethods;
    private static Dictionary`2<string, bool> targetValues;
    private static UseAssertFailInsteadOfBooleanAssert();
    protected virtual void AnalyzeInvocation(OperationAnalysisContext context, XunitContext xunitContext, IInvocationOperation invocationOperation, IMethodSymbol method);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V2AbstractionsContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIAssemblyInfoType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIAttributeInfoType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIMessageSinkMessageType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIMessageSinkType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIMethodInfoType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIParameterInfoType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyISourceInformationProviderType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyISourceInformationType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestAssemblyType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestCaseType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestClassType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestCollectionType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestFrameworkDiscovererType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestFrameworkExecutorType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestFrameworkType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestMethodType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITypeInfoType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIXunitSerializableType;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public INamedTypeSymbol IAssemblyInfoType { get; }
    public INamedTypeSymbol IAttributeInfoType { get; }
    public INamedTypeSymbol IMessageSinkMessageType { get; }
    public INamedTypeSymbol IMessageSinkType { get; }
    public INamedTypeSymbol IMethodInfoType { get; }
    public INamedTypeSymbol IParameterInfoType { get; }
    public INamedTypeSymbol ISourceInformationProviderType { get; }
    public INamedTypeSymbol ISourceInformationType { get; }
    public INamedTypeSymbol ITestAssemblyType { get; }
    public INamedTypeSymbol ITestCaseType { get; }
    public INamedTypeSymbol ITestClassType { get; }
    public INamedTypeSymbol ITestCollectionType { get; }
    public INamedTypeSymbol ITestFrameworkDiscovererType { get; }
    public INamedTypeSymbol ITestFrameworkExecutorType { get; }
    public INamedTypeSymbol ITestFrameworkType { get; }
    public INamedTypeSymbol ITestMethodType { get; }
    public INamedTypeSymbol ITestType { get; }
    public INamedTypeSymbol ITypeInfoType { get; }
    public INamedTypeSymbol IXunitSerializableType { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    [NullableContextAttribute("1")]
private V2AbstractionsContext(Compilation compilation, Version version);
    public INamedTypeSymbol get_IAssemblyInfoType();
    public INamedTypeSymbol get_IAttributeInfoType();
    public INamedTypeSymbol get_IMessageSinkMessageType();
    public sealed virtual INamedTypeSymbol get_IMessageSinkType();
    public INamedTypeSymbol get_IMethodInfoType();
    public INamedTypeSymbol get_IParameterInfoType();
    public sealed virtual INamedTypeSymbol get_ISourceInformationProviderType();
    public INamedTypeSymbol get_ISourceInformationType();
    public sealed virtual INamedTypeSymbol get_ITestAssemblyType();
    public sealed virtual INamedTypeSymbol get_ITestCaseType();
    public sealed virtual INamedTypeSymbol get_ITestClassType();
    public sealed virtual INamedTypeSymbol get_ITestCollectionType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkDiscovererType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkExecutorType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkType();
    public sealed virtual INamedTypeSymbol get_ITestMethodType();
    public sealed virtual INamedTypeSymbol get_ITestType();
    public INamedTypeSymbol get_ITypeInfoType();
    public sealed virtual INamedTypeSymbol get_IXunitSerializableType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    public static V2AbstractionsContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V2AssertContext : object {
    internal static Version Version_2_5_0;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public bool SupportsAssertFail { get; }
    public Version Version { get; }
    private V2AssertContext(Version version);
    private static V2AssertContext();
    public sealed virtual bool get_SupportsAssertFail();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [NullableContextAttribute("2")]
public static V2AssertContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V2CoreContext : object {
    [NullableAttribute("1")]
internal static Version Version_2_2_0;
    [NullableAttribute("1")]
internal static Version Version_2_4_0;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyClassDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyCollectionAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyCollectionDefinitionAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyFactAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIClassFixtureType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyICollectionFixtureType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyInlineDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestOutputHelperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyMemberDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyTheoryAttributeType;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public INamedTypeSymbol ClassDataAttributeType { get; }
    public INamedTypeSymbol CollectionAttributeType { get; }
    public INamedTypeSymbol CollectionDefinitionAttributeType { get; }
    public INamedTypeSymbol DataAttributeType { get; }
    public INamedTypeSymbol FactAttributeType { get; }
    public INamedTypeSymbol IClassFixtureType { get; }
    public INamedTypeSymbol ICollectionFixtureType { get; }
    public INamedTypeSymbol InlineDataAttributeType { get; }
    public INamedTypeSymbol ITestOutputHelperType { get; }
    public INamedTypeSymbol MemberDataAttributeType { get; }
    public INamedTypeSymbol TheoryAttributeType { get; }
    public bool TheorySupportsConversionFromStringToDateTimeOffsetAndGuid { get; }
    public bool TheorySupportsDefaultParameterValues { get; }
    public bool TheorySupportsParameterArrays { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    [NullableContextAttribute("1")]
private V2CoreContext(Compilation compilation, Version version);
    private static V2CoreContext();
    public sealed virtual INamedTypeSymbol get_ClassDataAttributeType();
    public sealed virtual INamedTypeSymbol get_CollectionAttributeType();
    public sealed virtual INamedTypeSymbol get_CollectionDefinitionAttributeType();
    public sealed virtual INamedTypeSymbol get_DataAttributeType();
    public sealed virtual INamedTypeSymbol get_FactAttributeType();
    public sealed virtual INamedTypeSymbol get_IClassFixtureType();
    public sealed virtual INamedTypeSymbol get_ICollectionFixtureType();
    public sealed virtual INamedTypeSymbol get_InlineDataAttributeType();
    public sealed virtual INamedTypeSymbol get_ITestOutputHelperType();
    public sealed virtual INamedTypeSymbol get_MemberDataAttributeType();
    public sealed virtual INamedTypeSymbol get_TheoryAttributeType();
    public sealed virtual bool get_TheorySupportsConversionFromStringToDateTimeOffsetAndGuid();
    public sealed virtual bool get_TheorySupportsDefaultParameterValues();
    public sealed virtual bool get_TheorySupportsParameterArrays();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    public static V2CoreContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V2ExecutionContext : object {
    private static string assemblyPrefix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyLongLivedMarshalByRefObjectType;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [NullableAttribute("2")]
public INamedTypeSymbol LongLivedMarshalByRefObjectType { get; }
    public string Platform { get; }
    public Version Version { get; }
    private V2ExecutionContext(Compilation compilation, string platform, Version version);
    [NullableContextAttribute("2")]
public INamedTypeSymbol get_LongLivedMarshalByRefObjectType();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [NullableContextAttribute("2")]
public static V2ExecutionContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V2RunnerUtilityContext : object {
    private static string assemblyPrefix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyLongLivedMarshalByRefObjectType;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [NullableAttribute("2")]
public INamedTypeSymbol LongLivedMarshalByRefObjectType { get; }
    public string Platform { get; }
    public Version Version { get; }
    private V2RunnerUtilityContext(Compilation compilation, string platform, Version version);
    [NullableContextAttribute("2")]
public sealed virtual INamedTypeSymbol get_LongLivedMarshalByRefObjectType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [NullableContextAttribute("2")]
public static V2RunnerUtilityContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V3AbstractionsContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIMessageSinkType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyISourceInformationProviderType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestAssemblyType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestCaseType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestClassType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestCollectionType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestFrameworkDiscovererType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestFrameworkExecutorType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestFrameworkType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestMethodType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIXunitSerializableType;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public INamedTypeSymbol IMessageSinkType { get; }
    public INamedTypeSymbol ISourceInformationProviderType { get; }
    public INamedTypeSymbol ITestAssemblyType { get; }
    public INamedTypeSymbol ITestCaseType { get; }
    public INamedTypeSymbol ITestClassType { get; }
    public INamedTypeSymbol ITestCollectionType { get; }
    public INamedTypeSymbol ITestFrameworkDiscovererType { get; }
    public INamedTypeSymbol ITestFrameworkExecutorType { get; }
    public INamedTypeSymbol ITestFrameworkType { get; }
    public INamedTypeSymbol ITestMethodType { get; }
    public INamedTypeSymbol ITestType { get; }
    public INamedTypeSymbol IXunitSerializableType { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    [NullableContextAttribute("1")]
private V3AbstractionsContext(Compilation compilation, Version version);
    public sealed virtual INamedTypeSymbol get_IMessageSinkType();
    public sealed virtual INamedTypeSymbol get_ISourceInformationProviderType();
    public sealed virtual INamedTypeSymbol get_ITestAssemblyType();
    public sealed virtual INamedTypeSymbol get_ITestCaseType();
    public sealed virtual INamedTypeSymbol get_ITestClassType();
    public sealed virtual INamedTypeSymbol get_ITestCollectionType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkDiscovererType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkExecutorType();
    public sealed virtual INamedTypeSymbol get_ITestFrameworkType();
    public sealed virtual INamedTypeSymbol get_ITestMethodType();
    public sealed virtual INamedTypeSymbol get_ITestType();
    public sealed virtual INamedTypeSymbol get_IXunitSerializableType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    public static V3AbstractionsContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V3AssertContext : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public bool SupportsAssertFail { get; }
    public Version Version { get; }
    private V3AssertContext(Version version);
    public sealed virtual bool get_SupportsAssertFail();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [NullableContextAttribute("2")]
public static V3AssertContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V3CoreContext : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyAssemblyFixtureAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyClassDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyCollectionAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyCollectionDefinitionAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyFactAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyIClassFixtureType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyICollectionFixtureType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyInlineDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestContextAccessorType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyITestOutputHelperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyMemberDataAttributeType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyTheoryAttributeType;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public INamedTypeSymbol AssemblyFixtureAttributeType { get; }
    public INamedTypeSymbol ClassDataAttributeType { get; }
    public INamedTypeSymbol CollectionAttributeType { get; }
    public INamedTypeSymbol CollectionDefinitionAttributeType { get; }
    public INamedTypeSymbol DataAttributeType { get; }
    public INamedTypeSymbol FactAttributeType { get; }
    public INamedTypeSymbol IClassFixtureType { get; }
    public INamedTypeSymbol ICollectionFixtureType { get; }
    public INamedTypeSymbol InlineDataAttributeType { get; }
    public INamedTypeSymbol ITestContextAccessorType { get; }
    public INamedTypeSymbol ITestOutputHelperType { get; }
    public INamedTypeSymbol MemberDataAttributeType { get; }
    public INamedTypeSymbol TheoryAttributeType { get; }
    public bool TheorySupportsConversionFromStringToDateTimeOffsetAndGuid { get; }
    public bool TheorySupportsDefaultParameterValues { get; }
    public bool TheorySupportsParameterArrays { get; }
    [NullableAttribute("1")]
public Version Version { get; }
    [NullableContextAttribute("1")]
private V3CoreContext(Compilation compilation, Version version);
    public INamedTypeSymbol get_AssemblyFixtureAttributeType();
    public sealed virtual INamedTypeSymbol get_ClassDataAttributeType();
    public sealed virtual INamedTypeSymbol get_CollectionAttributeType();
    public sealed virtual INamedTypeSymbol get_CollectionDefinitionAttributeType();
    public sealed virtual INamedTypeSymbol get_DataAttributeType();
    public sealed virtual INamedTypeSymbol get_FactAttributeType();
    public sealed virtual INamedTypeSymbol get_IClassFixtureType();
    public sealed virtual INamedTypeSymbol get_ICollectionFixtureType();
    public sealed virtual INamedTypeSymbol get_InlineDataAttributeType();
    public INamedTypeSymbol get_ITestContextAccessorType();
    public sealed virtual INamedTypeSymbol get_ITestOutputHelperType();
    public sealed virtual INamedTypeSymbol get_MemberDataAttributeType();
    public sealed virtual INamedTypeSymbol get_TheoryAttributeType();
    public sealed virtual bool get_TheorySupportsConversionFromStringToDateTimeOffsetAndGuid();
    public sealed virtual bool get_TheorySupportsDefaultParameterValues();
    public sealed virtual bool get_TheorySupportsParameterArrays();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    public static V3CoreContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Xunit.Analyzers.V3RunnerUtilityContext : object {
    private static string assemblyPrefix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<INamedTypeSymbol> lazyLongLivedMarshalByRefObjectType;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [NullableAttribute("2")]
public INamedTypeSymbol LongLivedMarshalByRefObjectType { get; }
    public string Platform { get; }
    public Version Version { get; }
    private V3RunnerUtilityContext(Compilation compilation, string platform, Version version);
    [NullableContextAttribute("2")]
public sealed virtual INamedTypeSymbol get_LongLivedMarshalByRefObjectType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [NullableContextAttribute("2")]
public static V3RunnerUtilityContext Get(Compilation compilation, Version versionOverride);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Xunit.Analyzers.XunitContext : object {
    private IAbstractionsContext abstractions;
    private IAssertContext assert;
    private ICoreContext core;
    private IRunnerUtilityContext runnerUtility;
    [NullableAttribute("1")]
private static Version v2AbstractionsVersion;
    [CompilerGeneratedAttribute]
private V2AbstractionsContext <V2Abstractions>k__BackingField;
    [CompilerGeneratedAttribute]
private V2AssertContext <V2Assert>k__BackingField;
    [CompilerGeneratedAttribute]
private V2CoreContext <V2Core>k__BackingField;
    [CompilerGeneratedAttribute]
private V2ExecutionContext <V2Execution>k__BackingField;
    [CompilerGeneratedAttribute]
private V2RunnerUtilityContext <V2RunnerUtility>k__BackingField;
    [CompilerGeneratedAttribute]
private V3AbstractionsContext <V3Abstractions>k__BackingField;
    [CompilerGeneratedAttribute]
private V3AssertContext <V3Assert>k__BackingField;
    [CompilerGeneratedAttribute]
private V3CoreContext <V3Core>k__BackingField;
    [CompilerGeneratedAttribute]
private V3RunnerUtilityContext <V3RunnerUtility>k__BackingField;
    [NullableAttribute("1")]
public IAbstractionsContext Abstractions { get; }
    [NullableAttribute("1")]
public IAssertContext Assert { get; }
    [NullableAttribute("1")]
public ICoreContext Core { get; }
    public bool HasV2References { get; }
    public bool HasV3References { get; }
    [NullableAttribute("1")]
public IRunnerUtilityContext RunnerUtility { get; }
    public V2AbstractionsContext V2Abstractions { get; private set; }
    public V2AssertContext V2Assert { get; private set; }
    public V2CoreContext V2Core { get; private set; }
    public V2ExecutionContext V2Execution { get; private set; }
    public V2RunnerUtilityContext V2RunnerUtility { get; private set; }
    public V3AbstractionsContext V3Abstractions { get; private set; }
    public V3AssertContext V3Assert { get; private set; }
    public V3CoreContext V3Core { get; private set; }
    public V3RunnerUtilityContext V3RunnerUtility { get; private set; }
    [NullableContextAttribute("1")]
public XunitContext(Compilation compilation);
    private static XunitContext();
    [NullableContextAttribute("1")]
public IAbstractionsContext get_Abstractions();
    [NullableContextAttribute("1")]
public IAssertContext get_Assert();
    [NullableContextAttribute("1")]
public ICoreContext get_Core();
    public bool get_HasV2References();
    public bool get_HasV3References();
    [NullableContextAttribute("1")]
public IRunnerUtilityContext get_RunnerUtility();
    [CompilerGeneratedAttribute]
public V2AbstractionsContext get_V2Abstractions();
    [CompilerGeneratedAttribute]
private void set_V2Abstractions(V2AbstractionsContext value);
    [CompilerGeneratedAttribute]
public V2AssertContext get_V2Assert();
    [CompilerGeneratedAttribute]
private void set_V2Assert(V2AssertContext value);
    [CompilerGeneratedAttribute]
public V2CoreContext get_V2Core();
    [CompilerGeneratedAttribute]
private void set_V2Core(V2CoreContext value);
    [CompilerGeneratedAttribute]
public V2ExecutionContext get_V2Execution();
    [CompilerGeneratedAttribute]
private void set_V2Execution(V2ExecutionContext value);
    [CompilerGeneratedAttribute]
public V2RunnerUtilityContext get_V2RunnerUtility();
    [CompilerGeneratedAttribute]
private void set_V2RunnerUtility(V2RunnerUtilityContext value);
    [CompilerGeneratedAttribute]
public V3AbstractionsContext get_V3Abstractions();
    [CompilerGeneratedAttribute]
private void set_V3Abstractions(V3AbstractionsContext value);
    [CompilerGeneratedAttribute]
public V3AssertContext get_V3Assert();
    [CompilerGeneratedAttribute]
private void set_V3Assert(V3AssertContext value);
    [CompilerGeneratedAttribute]
public V3CoreContext get_V3Core();
    [CompilerGeneratedAttribute]
private void set_V3Core(V3CoreContext value);
    [CompilerGeneratedAttribute]
public V3RunnerUtilityContext get_V3RunnerUtility();
    [CompilerGeneratedAttribute]
private void set_V3RunnerUtility(V3RunnerUtilityContext value);
    [NullableContextAttribute("1")]
public static XunitContext ForV2Abstractions(Compilation compilation);
    [NullableContextAttribute("1")]
public static XunitContext ForV2Assert(Compilation compilation, Version v2VersionOverride);
    [NullableContextAttribute("1")]
public static XunitContext ForV2Core(Compilation compilation, Version v2VersionOverride);
    [NullableContextAttribute("1")]
public static XunitContext ForV2Execution(Compilation compilation, Version v2VersionOverride);
    [NullableContextAttribute("1")]
public static XunitContext ForV2RunnerUtility(Compilation compilation, Version v2VersionOverride);
    [NullableContextAttribute("1")]
public static XunitContext ForV3Assert(Compilation compilation, Version v3VersionOverride);
    [NullableContextAttribute("1")]
public static XunitContext ForV3Core(Compilation compilation, Version v3VersionOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Xunit.Analyzers.XunitDiagnosticAnalyzer : DiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected XunitDiagnosticAnalyzer(DiagnosticDescriptor[] descriptors);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public abstract virtual void AnalyzeCompilation(CompilationStartAnalysisContext context, XunitContext xunitContext);
    protected virtual XunitContext CreateXunitContext(Compilation compilation);
    public sealed virtual void Initialize(AnalysisContext context);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Xunit.Analyzers.XunitV2DiagnosticAnalyzer : XunitDiagnosticAnalyzer {
    protected XunitV2DiagnosticAnalyzer(DiagnosticDescriptor[] descriptors);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Xunit.Analyzers.XunitV3DiagnosticAnalyzer : XunitDiagnosticAnalyzer {
    protected XunitV3DiagnosticAnalyzer(DiagnosticDescriptor[] descriptors);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Xunit.Guard : object {
    public static T ArgumentNotNull(T argValue, string argName);
    public static T ArgumentNotNullOrEmpty(T argValue, string argName);
    public static void ArgumentValid(string message, bool test, string argName);
    public static void ArgumentValid(Func`1<string> messageFunc, bool test, string argName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Suppressors.ConsiderCallingConfigureAwaitSuppressor : XunitDiagnosticSuppressor {
    [NullableContextAttribute("1")]
protected virtual bool ShouldSuppress(Diagnostic diagnostic, SuppressionAnalysisContext context, XunitContext xunitContext);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Xunit.Suppressors.MakeTypesInternalSuppressor : XunitDiagnosticSuppressor {
    [NullableContextAttribute("1")]
protected virtual bool ShouldSuppress(Diagnostic diagnostic, SuppressionAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Xunit.Suppressors.XunitDiagnosticSuppressor : DiagnosticSuppressor {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SuppressionDescriptor> <SupportedSuppressions>k__BackingField;
    protected SuppressionDescriptor Descriptor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SuppressionDescriptor> SupportedSuppressions { get; }
    protected XunitDiagnosticSuppressor(SuppressionDescriptor descriptor);
    protected SuppressionDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SuppressionDescriptor> get_SupportedSuppressions();
    protected virtual XunitContext CreateXunitContext(Compilation compilation);
    public sealed virtual void ReportSuppressions(SuppressionAnalysisContext context);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
    protected abstract virtual bool ShouldSuppress(Diagnostic diagnostic, SuppressionAnalysisContext context, XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Xunit.Suppressors.XunitV2DiagnosticSuppressor : XunitDiagnosticSuppressor {
    protected XunitV2DiagnosticSuppressor(SuppressionDescriptor descriptor);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Xunit.Suppressors.XunitV3DiagnosticSuppressor : XunitDiagnosticSuppressor {
    protected XunitV3DiagnosticSuppressor(SuppressionDescriptor descriptor);
    protected virtual bool ShouldAnalyze(XunitContext xunitContext);
}
